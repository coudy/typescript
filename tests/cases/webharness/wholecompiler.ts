//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export module CompilerDiagnostics {
        export var debug = false;
        export interface IDiagnosticWriter {
            Alert(output: string): void;
        }

        export var diagnosticWriter: IDiagnosticWriter = null;

        export var analysisPass: number = 0;

        export function Alert(output: string) {
            if (diagnosticWriter) {
                diagnosticWriter.Alert(output);
            }
        }

        export function debugPrint(s: string) {
            if (debug) {
                Alert(s);
            }
        }

        export function assert(condition: bool, s: string) {
            if (debug) {
                if (!condition) {
                    Alert(s);
                }
            }
        }

    }

    export interface ILogger {
        information(): bool;
        debug(): bool;
        warning(): bool;
        error(): bool;
        fatal(): bool;
        log(s: string): void;
    }

    export class NullLogger implements ILogger {
        public information(): bool { return false; }
        public debug(): bool { return false; }
        public warning(): bool { return false; }
        public error(): bool { return false; }
        public fatal(): bool { return false; }
        public log(s: string): void {
        }
    }

    export class LoggerAdapter implements ILogger {
        private _information: bool;
        private _debug: bool;
        private _warning: bool;
        private _error: bool;
        private _fatal: bool;

        constructor (public logger: ILogger) { 
            this._information = this.logger.information();
            this._debug = this.logger.debug();
            this._warning = this.logger.warning();
            this._error = this.logger.error();
            this._fatal = this.logger.fatal();
        }


        public information(): bool { return this._information; }
        public debug(): bool { return this._debug; }
        public warning(): bool { return this._warning; }
        public error(): bool { return this._error; }
        public fatal(): bool { return this._fatal; }
        public log(s: string): void {
            this.logger.log(s);
        }
    }

    export class BufferedLogger implements ILogger {
        public logContents = [];

        public information(): bool { return false; }
        public debug(): bool { return false; }
        public warning(): bool { return false; }
        public error(): bool { return false; }
        public fatal(): bool { return false; }
        public log(s: string): void {
            this.logContents.push(s);
        }
    }

    export function timeFunction(logger: ILogger, funcDescription: string, func: () =>any): any {
        var start = +new Date();
        var result = func();
        var end = +new Date();
        logger.log(funcDescription + " completed in " + (end - start) + " msec");
        return result;
    }

    export function stringToLiteral(value: string, length: number): string {
        var result = "";

        var addChar = (index: number) => {
            var ch = value.charCodeAt(index);
            switch (ch) {
                case 0x09: // tab
                    result += "\\t";
                    break;
                case 0x0a: // line feed
                    result += "\\n";
                    break;
                case 0x0b: // vertical tab
                    result += "\\v";
                    break;
                case 0x0c: // form feed
                    result += "\\f";
                    break;
                case 0x0d: // carriage return
                    result += "\\r";
                    break;
                case 0x22:  // double quote
                    result += "\\\"";
                    break;
                case 0x27: // single quote
                    result += "\\\'";
                    break;
                case 0x5c: // Backslash
                    result += "\\";
                    break;
                default:
                    result += value.charAt(index);
            }
        }

        var tooLong = (value.length > length);
        if (tooLong) {
            var mid = length >> 1;
            for (var i = 0; i < mid; i++) addChar(i);
            result += "(...)";
            for (var i = value.length - mid; i < value.length; i++) addChar(i);
        }
        else {
            length = value.length;
            for (var i = 0; i < length; i++) addChar(i);
        }
        return result;
    }

    export function getDiagnosticMessage(diagnosticType: DiagnosticMessages, args: any[]): string {
        var diagnosticName: string = (<any>DiagnosticMessages)._map[diagnosticType];

        var diagnostic = <Diagnostic> typescriptDiagnosticMessages[diagnosticName];

        if (!diagnostic) {
            throw new Error("Invalid diagnostic");
        }
        else {
            var components = diagnosticName.split("_");

            if (components.length) {
                var argCount = parseInt(components[1]);

                if (argCount != args.length) {
                    throw new Error("Expected " + argCount + " arguments to diagnostic, got " + args.length + " instead");
                }
            }
        }

        var diagnosticMessage = diagnostic.message.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined'
                ? args[num]
                : match;
        });

        var message: string;

        if (diagnosticType != DiagnosticMessages.error_2 && diagnosticType != DiagnosticMessages.warning_2) {
            var errorOrWarning = diagnostic.category == DiagnosticCategory.Error ?
                                    DiagnosticMessages.error_2 :
                                    DiagnosticMessages.warning_2;

            message = getDiagnosticMessage(errorOrWarning, [diagnostic.code, diagnosticMessage]);
        }
        else {
            message = diagnosticMessage;
        }

        return message;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export function hasFlag(val: number, flag: number) {
        return (val & flag) != 0;
    }

    export enum ErrorRecoverySet {
        None = 0,
        Comma = 1, // Comma
        SColon = 1 << 1, // SColon
        Asg = 1 << 2, // Asg
        BinOp = 1 << 3, // Lsh, Rsh, Rs2, Le, Ge, INSTANCEOF, EQ, NE, Eqv, NEqv, LogAnd, LogOr, AsgMul, AsgDiv
        // AsgMod, AsgAdd, AsgSub, AsgLsh, AsgRsh, AsgRs2, AsgAnd, AsgXor, AsgOr, QMark, Mult, Div, 
        // Pct, GT, LT, And, Xor, Or
        RBrack = 1 << 4, // RBrack
        RCurly = 1 << 5, // RCurly
        RParen = 1 << 6, // RParen
        Dot = 1 << 7, // Dot
        Colon = 1 << 8, // Colon
        PrimType = 1 << 9, // number, string, bool
        AddOp = 1 << 10, // Add, Sub
        LCurly = 1 << 11, // LCurly
        PreOp = 1 << 12, // Tilde, Bang, Inc, Dec
        RegExp = 1 << 13, // RegExp
        LParen = 1 << 14, // LParen
        LBrack = 1 << 15, // LBrack
        Scope = 1 << 16, // Scope
        In = 1 << 17, // IN
        SCase = 1 << 18, // CASE, DEFAULT
        Else = 1 << 19, // ELSE
        Catch = 1 << 20, // CATCH, FINALLY
        Var = 1 << 21, // 
        Stmt = 1 << 22, // BREAK, RETURN, THROW, DEBUGGER, FOR, SWITCH, DO, IF, TRY, WITH
        While = 1 << 23, // WHILE
        ID = 1 << 24, // ID
        Prefix = 1 << 25, // VOID, DELETE, TYPEOF, AWAIT
        Literal = 1 << 26, // IntCon, FltCon, StrCon
        RLit = 1 << 27, // THIS, TRUE, FALSE, NULL
        Func = 1 << 28, // FUNCTION
        EOF = 1 << 29, // EOF

        // REVIEW: Name this something clearer.
        TypeScriptS = 1 << 30, // PROPERTY, PRIVATE, STATIC, INTERFACE, CLASS, MODULE, EXPORT, IMPORT
        ExprStart = SColon | AddOp | LCurly | PreOp | RegExp | LParen | LBrack | ID | Prefix | RLit | Func | Literal,
        StmtStart = ExprStart | SColon | Var | Stmt | While | TypeScriptS,
        Postfix = Dot | LParen | LBrack,
    }

    export enum AllowedElements {
        None = 0,
        ModuleDeclarations = 1 << 2,
        ClassDeclarations = 1 << 3,
        InterfaceDeclarations = 1 << 4,
        AmbientDeclarations = 1 << 10,
        Properties = 1 << 11,

        Global = ModuleDeclarations | ClassDeclarations | InterfaceDeclarations | AmbientDeclarations,
        QuickParse = Global | Properties,
    }

    export enum Modifiers {
        None = 0,
        Private = 1,
        Public = 1 << 1,
        Readonly = 1 << 2,
        Ambient = 1 << 3,
        Exported = 1 << 4,
        Getter = 1 << 5,
        Setter = 1 << 6,
        Static = 1 << 7,
    }

    export enum ASTFlags {
        None = 0,
        ExplicitSemicolon = 1, // statment terminated by an explicit semicolon
        AutomaticSemicolon = 1 << 1, // statment terminated by an automatic semicolon
        Writeable = 1 << 2,  // node is lhs that can be modified
        Error = 1 << 3, // node has an error
        DotLHSPartial = 1 << 4, // node is the lhs of an incomplete dot expr at cursor
        DotLHS = 1 << 5, // node is the lhs of a dot expr
        IsStatement = 1 << 6, // node is a statement
        StrictMode = 1 << 7, // node is in the strict mode environment
        PossibleOptionalParameter = 1 << 8,
        ClassBaseConstructorCall = 1 << 9,
        OptionalName = 1 << 10,
        // REVIEW: This flag is to mark lambda nodes to note that the LParen of an expression has already been matched in the lambda header.
        //         The flag is used to communicate this piece of information to the calling parseTerm, which intern will remove it.
        //         Once we have a better way to associate information with nodes, this flag should not be used.
        SkipNextRParen = 1 << 11,
        TypeReference = 1 << 12,
    }

    export enum DeclFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
    }

    export enum ModuleFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
        IsEnum = 1 << 8,
        ShouldEmitModuleDecl = 1 << 9,
        IsWholeFile = 1 << 10,
        IsDynamic = 1 << 11,
        MustCaptureThis = 1 << 12,
    }

    export enum SymbolFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
        Property = 1 << 8,
        Readonly = 1 << 9,
        ModuleMember = 1 << 10,
        InterfaceMember = 1 << 11,
        ClassMember = 1 << 12,
        BuiltIn = 1 << 13,
        TypeSetDuringScopeAssignment = 1 << 14,
        Constant = 1 << 15,
        Optional = 1 << 16,
        RecursivelyReferenced = 1 << 17,
        Bound = 1 << 18,
        CompilerGenerated = 1 << 19,
    }

    export enum VarFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
        AutoInit = 1 << 8,
        Property = 1 << 9,
        Readonly = 1 << 10,
        Class = 1 << 11,
        ClassProperty = 1 << 12,
        ClassBodyProperty = 1 << 13,
        ClassConstructorProperty = 1 << 14,
        ClassSuperMustBeFirstCallInConstructor = 1 << 15,
        Constant = 1 << 16,
        MustCaptureThis = 1 << 17,
    }

    export enum FncFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
        Signature = 1 << 9,
        Method = 1 << 10,
        HasReturnExpression = 1 << 11,
        CallMember = 1 << 12,
        ConstructMember = 1 << 13,
        HasSelfReference = 1 << 14,
        IsFatArrowFunction = 1 << 15,
        IndexerMember = 1 << 16,
        IsFunctionExpression = 1 << 17,
        ClassMethod = 1 << 18,
        ClassPropertyMethodExported = 1 << 19,
        HasSuperReferenceInFatArrowFunction = 1 << 20,
        IsPropertyBound = 1 << 21,
    }

    export enum SignatureFlags {
        None = 0,
        IsIndexer = 1,
        IsStringIndexer = 1 << 1,
        IsNumberIndexer = 1 << 2,
    }

    export function ToDeclFlags(fncFlags: FncFlags) : DeclFlags;
    export function ToDeclFlags(varFlags: VarFlags) : DeclFlags;
    export function ToDeclFlags(symFlags: SymbolFlags): DeclFlags;
    export function ToDeclFlags(moduleFlags: ModuleFlags): DeclFlags;
    export function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags: any) {
        return <DeclFlags>fncOrVarOrSymbolOrModuleFlags;
    }

    export enum TypeFlags {
        None = 0,
        HasImplementation = 1,
        HasSelfReference = 1 << 1,
        MergeResult = 1 << 2,
        IsEnum = 1 << 3,
        BuildingName = 1 << 4,
        HasBaseType = 1 << 5,
        HasBaseTypeOfObject = 1 << 6,
        IsClass = 1 << 7,
    }

    export enum TypeRelationshipFlags {
        SuccessfulComparison = 0,
        SourceIsNullTargetIsVoidOrUndefined = 1,
        RequiredPropertyIsMissing = 1 << 1,
        IncompatibleSignatures = 1 << 2,
        SourceSignatureHasTooManyParameters = 3,
        IncompatibleReturnTypes = 1 << 4,
        IncompatiblePropertyTypes = 1 << 5,
        IncompatibleParameterTypes = 1 << 6,
    }

    export enum CodeGenTarget {
        ES3 = 0,
        ES5 = 1,
    }

    export enum ModuleGenTarget {
        Synchronous = 0,
        Asynchronous = 1,
        Local = 1 << 1,
    }

    // Compiler defaults to generating ES5-compliant code for
    //  - getters and setters
    export var codeGenTarget: CodeGenTarget = CodeGenTarget.ES3;

    export var moduleGenTarget: ModuleGenTarget = ModuleGenTarget.Synchronous;

    export var optimizeModuleCodeGen = true;

    export function flagsToString(e, flags: number): string {
        var builder = "";
        for (var i = 1; i < (1 << 31) ; i = i << 1) {
            if ((flags & i) != 0) {
                for (var k in e) {
                    if (e[k] == i) {
                        if (builder.length > 0) {
                            builder += "|";
                        }
                        builder += k;
                        break;
                    }
                }
            }
        }
        return builder;
    }

}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    // Note: Any addition to the NodeType should also be supported with addition to AstWalkerDetailCallback
    export enum NodeType {
        None,
        Empty,
        EmptyExpr,
        True,
        False,
        This,
        Super,
        QString,
        Regex,
        Null,
        ArrayLit,
        ObjectLit,
        Void,
        Comma,
        Pos,
        Neg,
        Delete,
        Await,
        In,
        Dot,
        From,
        Is,
        InstOf,
        Typeof,
        NumberLit,
        Name,
        TypeParameter,
        GenericType,
        TypeRef,
        Index,
        Call,
        New,
        Asg,
        AsgAdd,
        AsgSub,
        AsgDiv,
        AsgMul,
        AsgMod,
        AsgAnd,
        AsgXor,
        AsgOr,
        AsgLsh,
        AsgRsh,
        AsgRs2,
        ConditionalExpression,
        LogOr,
        LogAnd,
        Or,
        Xor,
        And,
        Eq,
        Ne,
        Eqv,
        NEqv,
        Lt,
        Le,
        Gt,
        Ge,
        Add,
        Sub,
        Mul,
        Div,
        Mod,
        Lsh,
        Rsh,
        Rs2,
        Not,
        LogNot,
        IncPre,
        DecPre,
        IncPost,
        DecPost,
        TypeAssertion,
        FuncDecl,
        Member,
        VarDecl,
        ArgDecl,
        Return,
        Break,
        Continue,
        Throw,
        For,
        ForIn,
        If,
        While,
        DoWhile,
        Block,
        Case,
        Switch,
        Try,
        TryCatch,
        TryFinally,
        Finally,
        Catch,
        List,
        Script,
        ClassDeclaration,
        InterfaceDeclaration,
        ModuleDeclaration,
        ImportDeclaration,
        With,
        Label,
        LabeledStatement,
        EBStart,
        GotoEB,
        EndCode,
        Error,
        Comment,
        Debugger,
        GeneralNode = FuncDecl,
        LastAsg = AsgRs2,
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export class BlockIntrinsics {
        public prototype = undefined;
        public toString = undefined;
        public toLocaleString = undefined;
        public valueOf = undefined;
        public hasOwnProperty = undefined;
        public propertyIsEnumerable = undefined;
        public isPrototypeOf = undefined;

        constructor () {
            // initialize the 'constructor' field
            this["constructor"] = undefined;
        }
    }

    export interface IHashTable {
        getAllKeys(): string[];
        add(key: string, data): bool;
        addOrUpdate(key: string, data): bool;
        map(fn: (k: string, v, c) => void , context): void;
        every(fn: (k: string, v, c) => bool, context): bool;
        some(fn: (k: string, v, c) => bool, context): bool;
        count(): number;
        lookup(key: string): any;
    }

    export class StringHashTable implements IHashTable {
        public itemCount = 0;
        public table = <any>(<any> new BlockIntrinsics());

        public getAllKeys(): string[]{
            var result: string[] = [];
            for (var k in this.table) {
                if (this.table[k] != undefined) {
                    result[result.length] = k;
                }
            }
            return result;
        }

        public add(key: string, data): bool {
            if (this.table[key] != undefined) {
                return false;
            }
            this.table[key] = data;
            this.itemCount++;
            return true;
        }

        public addOrUpdate(key: string, data): bool {
            if (this.table[key] != undefined) {
                this.table[key] = data;
                return false;
            }
            this.table[key] = data;
            this.itemCount++;
            return true;
        }

        public map(fn: (k: string, v, c) => void , context) {
            for (var k in this.table) {
                var data = this.table[k];
                if (data != undefined) {
                    fn(k, this.table[k], context);
                }
            }
        }

        public every(fn: (k: string, v, c) => bool, context) {
            for (var k in this.table) {
                var data = this.table[k];
                if (data != undefined) {
                    if (!fn(k, this.table[k], context)) {
                        return false;
                    }
                }
            }
            return true;
        }

        public some(fn: (k: string, v, c) => bool, context) {
            for (var k in this.table) {
                var data = this.table[k];
                if (data != undefined) {
                    if (fn(k, this.table[k], context)) {
                        return true;
                    }
                }
            }
            return false;
        }

        public count(): number { return this.itemCount; }

        public lookup(key: string) {
            var data = this.table[key];
            if (data != undefined) {
                return data;
            }
            else {
                return (null);
            }
        }
    }

    // The resident table is expected to reference the same table object, whereas the 
    // transientTable may reference different objects over time
    // REVIEW:  WARNING:  For performance reasons, neither the primary nor secondary table may be null
    export class DualStringHashTable implements IHashTable {

        public insertPrimary = true;

        constructor (public primaryTable: IHashTable,
                                        public secondaryTable: IHashTable) { }

        public getAllKeys(): string[]{
            return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys());
        }

        public add(key: string, data): bool {
            if (this.insertPrimary) {
                return this.primaryTable.add(key, data);
            }
            else {
                return this.secondaryTable.add(key, data);
            }
        }

        public addOrUpdate(key: string, data): bool {
            if (this.insertPrimary) {
                return this.primaryTable.addOrUpdate(key, data);
            }
            else {
                return this.secondaryTable.addOrUpdate(key, data);
            }
        }

        public map(fn: (k: string, v, c) => void , context) {
            this.primaryTable.map(fn, context);
            this.secondaryTable.map(fn, context);
        }

        public every(fn: (k: string, v, c) => bool, context) {
            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context);
        }

        public some(fn: (k: string, v, c) => bool, context) {
            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context);
        }

        public count() {
            return this.primaryTable.count() + this.secondaryTable.count();
        }

        public lookup(key: string) {
            var data = this.primaryTable.lookup(key);
            if (data != undefined) {
                return data;
            }
            else {
                return this.secondaryTable.lookup(key);
            }
        }
    }

    export function numberHashFn(key: number): number {
        var c2 = 0x27d4eb2d; // a prime or an odd constant
        key = (key ^ 61) ^ (key >>> 16);
        key = key + (key << 3);
        key = key ^ (key >>> 4);
        key = key * c2;
        key = key ^ (key >>> 15);
        return key;
    }

    export function combineHashes(key1: number, key2: number) {
        return key2 ^ ((key1 >> 5) + key1);
    }

    export class HashEntry {
        public next: HashEntry;

        constructor (public key, public data) { }
    }

    export class HashTable {
        public itemCount: number = 0;
        public table = new HashEntry[];

        constructor (public size: number, public hashFn: (key) =>number,
                    public equalsFn: (key1, key2) =>bool) {
            for (var i: number = 0; i < this.size; i++) {
                this.table[i] = null;
            }
        }

        public add(key, data): bool {
            var current: HashEntry;
            var entry: HashEntry = new HashEntry(key, data);
            var val: number = this.hashFn(key);
            val = val % this.size;

            for (current = this.table[val]; current != null ; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    return false;
                }
            }
            entry.next = this.table[val];
            this.table[val] = entry;
            this.itemCount++;
            return true;
        }

        public remove(key) {
            var current: HashEntry;
            var val: number = this.hashFn(key);
            val = val % this.size;
            var result = null;
            var prevEntry: HashEntry = null;

            for (current = this.table[val]; current != null ; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    result = current.data;
                    this.itemCount--;
                    if (prevEntry) {
                        prevEntry.next = current.next;
                    }
                    else {
                        this.table[val] = current.next;
                    }
                    break;
                }
                prevEntry = current;
            }
            return result;
        }

        public count(): number { return this.itemCount; }

        public lookup(key) {
            var current: HashEntry;
            var val: number = this.hashFn(key);
            val = val % this.size;
            for (current = this.table[val]; current != null ; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    return (current.data);
                }
            }
            return (null);
        }
    }

    // Simple Hash table with list of keys and values matching each other at the given index
    export class SimpleHashTable {
        private keys = [];
        private values = [];

        public lookup(key, findValue?: bool) {
            var searchArray = this.keys;
            if (findValue) {
                searchArray = this.values;
            }

            for (var i = 0; i < searchArray.length; i++) {
                if (searchArray[i] == key) {
                    return {
                        key: this.keys[i],
                        data: this.values[i],
                    };
                }
            }
            return null;
        }

        public add(key, data): bool {
            var lookupData = this.lookup(key);
            if (lookupData) {
                return false;
            }

            this.keys[this.keys.length] = key;
            this.values[this.values.length] = data;

            return true;
        }
    }

}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class ASTSpan {
        public minChar: number = -1;  // -1 = "undefined" or "compiler generated"
        public limChar: number = -1;  // -1 = "undefined" or "compiler generated"   
    }

    export var astID = 0;

    export class AST extends ASTSpan {
        public type: Type = null;
        public flags = ASTFlags.Writeable;

        private astID = astID++;

        // REVIEW: for diagnostic purposes
        public passCreated: number = CompilerDiagnostics.analysisPass;

        public preComments: Comment[] = null;
        public postComments: Comment[] = null;
        private docComments: Comment[] = null;

        public isParenthesized = false;

        constructor (public nodeType: NodeType) {
            super();
        }

        public getLength() { return this.limChar - this.minChar; }

        public getID() { return this.astID; }

        public isExpression() { return false; }

        public isStatementOrExpression() { return false; }

        public isCompoundStatement() { return false; }

        public isLeaf() { return this.isStatementOrExpression() && (!this.isCompoundStatement()); }
        
        public isDeclaration() { return false; }

        public typeCheck(typeFlow: TypeFlow) {
            switch (this.nodeType) {
                case NodeType.Error:
                case NodeType.EmptyExpr:
                    this.type = typeFlow.anyType;
                    break;
                case NodeType.This:
                    return typeFlow.typeCheckThis(this);
                case NodeType.Null:
                    this.type = typeFlow.nullType;
                    break;
                case NodeType.False:
                case NodeType.True:
                    this.type = typeFlow.booleanType;
                    break;
                case NodeType.Super:
                    return typeFlow.typeCheckSuper(this);
                case NodeType.EndCode:
                case NodeType.Empty:
                case NodeType.Void:
                    this.type = typeFlow.voidType;
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            switch (this.nodeType) {
                case NodeType.This:
                    emitter.recordSourceMappingStart(this);
                    if (emitter.thisFnc && (hasFlag(emitter.thisFnc.fncFlags, FncFlags.IsFatArrowFunction))) {
                        emitter.writeToOutput("_this");
                    }
                    else {
                        emitter.writeToOutput("this");
                    }
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.Null:
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("null");
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.False:
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("false");
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.True:
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("true");
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.Super:
                    emitter.recordSourceMappingStart(this);
                    emitter.emitSuperReference();
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.EndCode:
                case NodeType.Error:
                case NodeType.EmptyExpr:
                    break;
                case NodeType.Empty:
                    emitter.recordSourceMappingStart(this);
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.Void:
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("void ");
                    emitter.recordSourceMappingEnd(this);
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public print(context: PrintContext) {
            context.startLine();
            var lineCol = { line: -1, col: -1 };
            var limLineCol = { line: -1, col: -1 };
            if (context.parser !== null) {
                context.parser.getSourceLineCol(lineCol, this.minChar);
                context.parser.getSourceLineCol(limLineCol, this.limChar);
                context.write("(" + lineCol.line + "," + lineCol.col + ")--" +
                              "(" + limLineCol.line + "," + limLineCol.col + "): ");
            }
            var lab = this.printLabel();
            if (hasFlag(this.flags, ASTFlags.Error)) {
                lab += " (Error)";
            }
            context.writeLine(lab);
        }

        public printLabel() {
            if (nodeTypeTable[this.nodeType] !== undefined) {
                return nodeTypeTable[this.nodeType];
            }
            else {
                return (<any>NodeType)._map[this.nodeType];
            }
        }

        public addToControlFlow(context: ControlFlowContext): void {
            // by default, AST adds itself to current basic block and does not check its children
            context.walker.options.goChildren = false;
            context.addContent(this);
        }

        public netFreeUses(container: Symbol, freeUses: StringHashTable) {
        }

        public treeViewLabel() {
            return (<any>NodeType)._map[this.nodeType];
        }

        public static getResolvedIdentifierName(name: string): string {
            if (!name) return "";

            var resolved = "";
            var start = 0;
            var i = 0;
            while(i <= name.length - 6) {
                // Look for escape sequence \uxxxx
                if (name.charAt(i) == '\\' && name.charAt(i+1) == 'u') {
                    var charCode = parseInt(name.substr(i + 2, 4), 16);
                    resolved += name.substr(start, i - start);
                    resolved += String.fromCharCode(charCode);
                    i += 6;
                    start = i;
                    continue;
                } 
                i++;
            }
            // Append remaining string
            resolved += name.substring(start);
            return resolved;
        }

        public getDocComments() : Comment[] {
            if (!this.isDeclaration() || !this.preComments || this.preComments.length == 0) {
                return [];
            }

            if (!this.docComments) {
                var preCommentsLength = this.preComments.length;
                var docComments: Comment[] = [];
                for (var i = preCommentsLength - 1; i >= 0; i--) {
                    if (this.preComments[i].isDocComment()) {
                        var prevDocComment = docComments.length > 0 ? docComments[docComments.length - 1] : null;
                        if (prevDocComment == null || // If the help comments were not yet set then this is the comment
                             (this.preComments[i].limLine == prevDocComment.minLine ||
                              this.preComments[i].limLine + 1 == prevDocComment.minLine)) { // On same line or next line
                            docComments.push(this.preComments[i]);
                            continue;
                        }
                    }
                    break;
                }

                this.docComments = docComments.reverse();
            }

            return this.docComments;
        }
    }

    export class IncompleteAST extends AST {
        constructor (min: number, lim: number) {
            super(NodeType.Error);

            this.minChar = min;
            this.limChar = lim;
        }
    }

    export class ASTList extends AST {
        public enclosingScope: SymbolScope = null;
        public members: AST[] = new AST[];

        constructor () {
            super(NodeType.List);
        }

        public addToControlFlow(context: ControlFlowContext) {
            var len = this.members.length;
            for (var i = 0; i < len; i++) {
                if (context.noContinuation) {
                    context.addUnreachable(this.members[i]);
                    break;
                }
                else {
                    this.members[i] = context.walk(this.members[i], this);
                }
            }
            context.walker.options.goChildren = false;
        }

        public append(ast: AST) {
            this.members[this.members.length] = ast;
            return this;
        }

        public appendAll(ast: AST) {
            if (ast.nodeType == NodeType.List) {
                var list = <ASTList>ast;
                for (var i = 0, len = list.members.length; i < len; i++) {
                    this.append(list.members[i]);
                }
            }
            else {
                this.append(ast);
            }
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascriptList(this, null, TokenID.Semicolon, startLine, false, false);
            emitter.recordSourceMappingEnd(this);
        }

        public typeCheck(typeFlow: TypeFlow) {
            var len = this.members.length;
            typeFlow.nestingLevel++;
            for (var i = 0; i < len; i++) {
                if (this.members[i]) {
                    this.members[i] = this.members[i].typeCheck(typeFlow);
                }
            }
            typeFlow.nestingLevel--;
            return this;
        }
    }

    export class Identifier extends AST {
        public sym: Symbol = null;
        public cloId = -1;
        public text: string;

        // 'actualText' is the text that the user has entered for the identifier. the text might 
        // include any Unicode escape sequences (e.g.: \u0041 for 'A'). 'text', however, contains 
        // the resolved value of any escape sequences in the actual text; so in the previous 
        // example, actualText = '\u0041', text = 'A'.
        //
        // For purposes of finding a symbol, use text, as this will allow you to match all 
        // variations of the variable text. For full-fidelity translation of the user input, such
        // as emitting, use the actualText field.
        // 
        // Note: 
        //    To change text, and to avoid running into a situation where 'actualText' does not 
        //    match 'text', always use setText.
        constructor (public actualText: string, public hasEscapeSequence?: bool) {
            super(NodeType.Name);
            this.setText(actualText, hasEscapeSequence);
        }

        public setText(actualText: string, hasEscapeSequence?: bool) {
            this.actualText = actualText;
            if (hasEscapeSequence) {
                this.text = AST.getResolvedIdentifierName(actualText);
            }
            else {
                this.text = actualText;
            }
        }

        public isMissing() { return false; }
        public isLeaf() { return true; }

        public treeViewLabel() {
            return "id: " + this.actualText;
        }

        public printLabel() {
            if (this.actualText) {
                return "id: " + this.actualText;
            }
            else {
                return "name node";
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckName(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitJavascriptName(this, true);
        }

        public static fromToken(token: Token): Identifier {
            return new Identifier(token.getText(), (<IdentifierToken>token).hasEscapeSequence);
        }
    }

    export class MissingIdentifier extends Identifier {
        constructor () {
            super("__missing");
        }

        public isMissing() {
            return true;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            // Emit nothing for a missing ID
        }
    }

    export class Label extends AST {
        constructor (public id: Identifier) {
            super(NodeType.Label);
        }

        public printLabel() { return this.id.actualText + ":"; }

        public typeCheck(typeFlow: TypeFlow) {
            this.type = typeFlow.voidType;
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.recordSourceMappingStart(this.id);
            emitter.writeToOutput(this.id.actualText);
            emitter.recordSourceMappingEnd(this.id);
            emitter.writeLineToOutput(":");
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class Expression extends AST {
        constructor (nodeType: NodeType) {
            super(nodeType);
        }

        public isExpression() { return true; }

        public isStatementOrExpression() { return true; }
    }

    export class UnaryExpression extends Expression {
        public targetType: Type = null; // Target type for an object literal (null if no target type)
        public castTerm: AST = null;

        constructor (nodeType: NodeType, public operand: AST) {
            super(nodeType);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            super.addToControlFlow(context);
            // TODO: add successor as catch block/finally block if present
            if (this.nodeType == NodeType.Throw) {
                context.returnStmt();
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
            switch (this.nodeType) {
                case NodeType.Not:
                    return typeFlow.typeCheckBitNot(this);

                case NodeType.LogNot:
                    return typeFlow.typeCheckLogNot(this);

                case NodeType.Pos:
                case NodeType.Neg:
                    return typeFlow.typeCheckUnaryNumberOperator(this);

                case NodeType.IncPost:
                case NodeType.IncPre:
                case NodeType.DecPost:
                case NodeType.DecPre:
                    return typeFlow.typeCheckIncOrDec(this);

                case NodeType.ArrayLit:
                    typeFlow.typeCheckArrayLit(this);
                    return this;

                case NodeType.ObjectLit:
                    typeFlow.typeCheckObjectLit(this);
                    return this;

                case NodeType.Throw:
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.voidType;
                    return this;

                case NodeType.Typeof:
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.stringType;
                    return this;

                case NodeType.Delete:
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.booleanType;
                    break;

                case NodeType.TypeAssertion:
                    this.castTerm = typeFlow.typeCheck(this.castTerm);
                    var applyTargetType = !this.operand.isParenthesized;

                    var targetType = applyTargetType ? this.castTerm.type : null;

                    typeFlow.checker.typeCheckWithContextualType(targetType, typeFlow.checker.inProvisionalTypecheckMode(), true, this.operand);
                    typeFlow.castWithCoercion(this.operand, this.castTerm.type, false, true);
                    this.type = this.castTerm.type;
                    return this;

                case NodeType.Void:
                    // REVIEW - Although this is good to do for completeness's sake,
                    // this shouldn't be strictly necessary from the void operator's
                    // point of view
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.checker.undefinedType;
                    break;

                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            switch (this.nodeType) {
                case NodeType.IncPost:
                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);
                    emitter.writeToOutput("++");
                    break;
                case NodeType.LogNot:
                    emitter.writeToOutput("!");
                    emitter.emitJavascript(this.operand, TokenID.Exclamation, false);
                    break;
                case NodeType.DecPost:
                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);
                    emitter.writeToOutput("--");
                    break;
                case NodeType.ObjectLit:
                    emitter.emitObjectLiteral(<ASTList>this.operand);
                    break;
                case NodeType.ArrayLit:
                    emitter.emitArrayLiteral(<ASTList>this.operand);
                    break;
                case NodeType.Not:
                    emitter.writeToOutput("~");
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    break;
                case NodeType.Neg:
                    emitter.writeToOutput("-");
                    if (this.operand.nodeType == NodeType.Neg) {
                        this.operand.isParenthesized = true;
                    }
                    emitter.emitJavascript(this.operand, TokenID.Minus, false);
                    break;
                case NodeType.Pos:
                    emitter.writeToOutput("+");
                    if (this.operand.nodeType == NodeType.Pos) {
                        this.operand.isParenthesized = true;
                    }
                    emitter.emitJavascript(this.operand, TokenID.Plus, false);
                    break;
                case NodeType.IncPre:
                    emitter.writeToOutput("++");
                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);
                    break;
                case NodeType.DecPre:
                    emitter.writeToOutput("--");
                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);
                    break;
                case NodeType.Throw:
                    emitter.writeToOutput("throw ");
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    emitter.writeToOutput(";");
                    break;
                case NodeType.Typeof:
                    emitter.writeToOutput("typeof ");
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    break;
                case NodeType.Delete:
                    emitter.writeToOutput("delete ");
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    break;
                case NodeType.Void:
                    emitter.writeToOutput("void ");
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    break;
                case NodeType.TypeAssertion:
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class CallExpression extends Expression {
        constructor (nodeType: NodeType,
                     public target: AST,
                     public typeArguments: ASTList,
                     public arguments: ASTList) {
            super(nodeType);
            this.minChar = this.target.minChar;
        }

        public signature: Signature = null;

        public typeCheck(typeFlow: TypeFlow) {
            if (this.nodeType == NodeType.New) {
                return typeFlow.typeCheckNew(this);
            }
            else {
                return typeFlow.typeCheckCall(this);
            }
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);

            if (this.nodeType == NodeType.New) {
                emitter.emitNew(this.target, this.arguments);
            }
            else {
                emitter.emitCall(this, this.target, this.arguments);
            }

            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class BinaryExpression extends Expression {
        constructor (nodeType: NodeType, public operand1: AST, public operand2: AST) {
            super(nodeType);
        }

        public typeCheck(typeFlow: TypeFlow) {
            switch (this.nodeType) {
                case NodeType.Dot:
                    return typeFlow.typeCheckDotOperator(this);
                case NodeType.Asg:
                    return typeFlow.typeCheckAsgOperator(this);
                case NodeType.Add:
                case NodeType.Sub:
                case NodeType.Mul:
                case NodeType.Div:
                case NodeType.Mod:
                case NodeType.Or:
                case NodeType.And:
                    return typeFlow.typeCheckArithmeticOperator(this, false);
                case NodeType.Xor:
                    return typeFlow.typeCheckBitwiseOperator(this, false);
                case NodeType.Ne:
                case NodeType.Eq:
                    var text: string;
                    if (typeFlow.checker.styleSettings.eqeqeq) {
                        text = nodeTypeTable[this.nodeType];
                        typeFlow.checker.errorReporter.styleError(this, "use of " + text);
                    }
                    else if (typeFlow.checker.styleSettings.eqnull) {
                        text = nodeTypeTable[this.nodeType];
                        if ((this.operand2 !== null) && (this.operand2.nodeType == NodeType.Null)) {
                            typeFlow.checker.errorReporter.styleError(this, "use of " + text + " to compare with null");
                        }
                    }
                case NodeType.Eqv:
                case NodeType.NEqv:
                case NodeType.Lt:
                case NodeType.Le:
                case NodeType.Ge:
                case NodeType.Gt:
                    return typeFlow.typeCheckBooleanOperator(this);
                case NodeType.Index:
                    return typeFlow.typeCheckIndex(this);
                case NodeType.Member:
                    this.type = typeFlow.voidType;
                    return this;
                case NodeType.LogOr:
                    return typeFlow.typeCheckLogOr(this);
                case NodeType.LogAnd:
                    return typeFlow.typeCheckLogAnd(this);
                case NodeType.AsgAdd:
                case NodeType.AsgSub:
                case NodeType.AsgMul:
                case NodeType.AsgDiv:
                case NodeType.AsgMod:
                case NodeType.AsgOr:
                case NodeType.AsgAnd:
                    return typeFlow.typeCheckArithmeticOperator(this, true);
                case NodeType.AsgXor:
                    return typeFlow.typeCheckBitwiseOperator(this, true);
                case NodeType.Lsh:
                case NodeType.Rsh:
                case NodeType.Rs2:
                    return typeFlow.typeCheckShift(this, false);
                case NodeType.AsgLsh:
                case NodeType.AsgRsh:
                case NodeType.AsgRs2:
                    return typeFlow.typeCheckShift(this, true);
                case NodeType.Comma:
                    return typeFlow.typeCheckCommaOperator(this);
                case NodeType.InstOf:
                    return typeFlow.typeCheckInstOf(this);
                case NodeType.In:
                    return typeFlow.typeCheckInOperator(this);
                case NodeType.From:
                    typeFlow.checker.errorReporter.simpleError(this, "Illegal use of 'from' keyword in binary expression");
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            var binTokenId = nodeTypeToTokTable[this.nodeType];

            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (binTokenId != undefined) {

                emitter.emitJavascript(this.operand1, binTokenId, false);

                if (tokenTable[binTokenId].text == "instanceof") {
                    emitter.writeToOutput(" instanceof ");
                }
                else if (tokenTable[binTokenId].text == "in") {
                    emitter.writeToOutput(" in ");
                }
                else {
                    emitter.writeToOutputTrimmable(" " + tokenTable[binTokenId].text + " ");
                }

                emitter.emitJavascript(this.operand2, binTokenId, false);
            }
            else {
                switch (this.nodeType) {
                    case NodeType.Dot:
                        if (!emitter.tryEmitConstant(this)) {
                            emitter.emitJavascript(this.operand1, TokenID.Dot, false);
                            emitter.writeToOutput(".");
                            emitter.emitJavascriptName(<Identifier>this.operand2, false);
                        }
                        break;
                    case NodeType.Index:
                        emitter.emitIndex(this.operand1, this.operand2);
                        break;

                    case NodeType.Member:
                        if (this.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>this.operand2).isAccessor()) {
                            var funcDecl = <FuncDecl>this.operand2;
                            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                                emitter.writeToOutput("get ");
                            }
                            else {
                                emitter.writeToOutput("set ");
                            }
                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);
                        }
                        else {
                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);
                            emitter.writeToOutputTrimmable(": ");
                        }
                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);
                        break;
                    case NodeType.Comma:
                        emitter.emitJavascript(this.operand1, TokenID.Comma, false);
                        if (emitter.emitState.inObjectLiteral) {
                            emitter.writeLineToOutput(", ");
                        }
                        else {
                            emitter.writeToOutput(",");
                        }
                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);
                        break;
                    case NodeType.Is:
                        throw new Error("should be de-sugared during type check");
                    default:
                        throw new Error("please implement in derived class");
                }
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class ConditionalExpression extends Expression {
        constructor (public operand1: AST,
                     public operand2: AST,
                     public operand3: AST) {
            super(NodeType.ConditionalExpression);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckQMark(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascript(this.operand1, TokenID.Question, false);
            emitter.writeToOutput(" ? ");
            emitter.emitJavascript(this.operand2, TokenID.Question, false);
            emitter.writeToOutput(" : ");
            emitter.emitJavascript(this.operand3, TokenID.Question, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class NumberLiteral extends Expression {
        constructor (public value: number, public text: string) {
            super(NodeType.NumberLit);
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.type = typeFlow.doubleType;
            return this;
        }

        public treeViewLabel() {
            return "num: " + this.printLabel();
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public printLabel(): string {
            return this.text;
        }
    }

    export class RegexLiteral extends Expression {
        constructor (public text: string) {
            super(NodeType.Regex);
        }
        
        public typeCheck(typeFlow: TypeFlow) {
            this.type = typeFlow.regexType;
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class StringLiteral extends Expression {
        constructor (public text: string) {
            super(NodeType.QString);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitStringLiteral(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.type = typeFlow.stringType;
            return this;
        }

        public treeViewLabel() {
            return "st: " + this.text;
        }

        public printLabel() {
            return this.text;
        }
    }

    export class ModuleElement extends AST {
        constructor (nodeType: NodeType) {
            super(nodeType);
        }
    }

    export class ImportDeclaration extends ModuleElement {
        public isStatementOrExpression() { return true; }
        public varFlags = VarFlags.None;
        public isDynamicImport = false;
        public isDeclaration() { return true; }

        constructor (public id: Identifier, public alias: AST) {
            super(NodeType.ImportDeclaration);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            var mod = <ModuleType>this.alias.type;
            // REVIEW: Only modules may be aliased for now, though there's no real
            // restriction on what the type symbol may be
            if (!this.isDynamicImport || (this.id.sym && !(<TypeSymbol>this.id.sym).onlyReferencedAsTypeRef)) {
                var prevModAliasId = emitter.modAliasId;
                var prevFirstModAlias = emitter.firstModAlias;

                emitter.recordSourceMappingStart(this);
                emitter.emitParensAndCommentsInPlace(this, true);
                emitter.writeToOutput("var " + this.id.actualText + " = ");
                emitter.modAliasId = this.id.actualText;
                emitter.firstModAlias = this.firstAliasedModToString();
                emitter.emitJavascript(this.alias, TokenID.Tilde, false);
                // the dynamic import case will insert the semi-colon automatically
                if (!this.isDynamicImport) {
                    emitter.writeToOutput(";");
                }
                emitter.emitParensAndCommentsInPlace(this, false);
                emitter.recordSourceMappingEnd(this);

                emitter.modAliasId = prevModAliasId;
                emitter.firstModAlias = prevFirstModAlias;
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckImportDecl(this);
        }

        public getAliasName(aliasAST?: AST = this.alias) : string {
            if (aliasAST.nodeType == NodeType.Name) {
                return (<Identifier>aliasAST).actualText;
            } else {
                var dotExpr = <BinaryExpression>aliasAST;
                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);
            }
        }

        public firstAliasedModToString() {
            if (this.alias.nodeType == NodeType.Name) {
                return (<Identifier>this.alias).actualText;
            }
            else {
                var dotExpr = <BinaryExpression>this.alias;
                var firstMod = <Identifier>dotExpr.operand1;
                return firstMod.actualText;
            }
        }
    }

    export class BoundDecl extends AST {
        public init: AST = null;
        public typeExpr: AST = null;
        public varFlags = VarFlags.None;
        public sym: Symbol = null;
        public isDeclaration() { return true; }

        constructor (public id: Identifier, nodeType: NodeType, public nestingLevel: number) {
            super(nodeType);
        }

        public isStatementOrExpression() { return true; }

        public isPrivate() { return hasFlag(this.varFlags, VarFlags.Private); }
        public isPublic() { return hasFlag(this.varFlags, VarFlags.Public); }
        public isProperty() { return hasFlag(this.varFlags, VarFlags.Property); }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckBoundDecl(this);
        }

        public printLabel() {
            return this.treeViewLabel();
        }
    }

    export class VarDecl extends BoundDecl {
        constructor (id: Identifier, nest: number) {
            super(id, NodeType.VarDecl, nest);
        }

        public isAmbient() { return hasFlag(this.varFlags, VarFlags.Ambient); }
        public isExported() { return hasFlag(this.varFlags, VarFlags.Exported); }
        public isStatic() { return hasFlag(this.varFlags, VarFlags.Static); }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitJavascriptVarDecl(this, tokenId);
        }

        public treeViewLabel() {
            return "var " + this.id.actualText;
        }
    }

    export class ArgDecl extends BoundDecl {
        constructor (id: Identifier) {
            super(id, NodeType.ArgDecl, 0);
        }

        public isOptional = false;

        public isOptionalArg() { return this.isOptional || this.init; }

        public treeViewLabel() {
            return "arg: " + this.id.actualText;
        }

        public parameterPropertySym: FieldSymbol = null;

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.id.actualText);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    var internalId = 0;

    export class FuncDecl extends AST {
        public hint: string = null;
        public fncFlags = FncFlags.None;
        public returnTypeAnnotation: AST = null;
        public symbols: IHashTable;
        public variableArgList = false;
        public signature: Signature;
        public envids: Identifier[];
        public jumpRefs: Identifier[] = null;
        public internalNameCache: string = null;
        public tmp1Declared = false;
        public enclosingFnc: FuncDecl = null;
        public freeVariables: Symbol[] = [];
        public unitIndex = -1;
        public classDecl: NamedDeclaration = null;
        public boundToProperty: VarDecl = null;
        public isOverload = false;
        public innerStaticFuncs: FuncDecl[] = [];
        public isTargetTypedAsMethod = false;
        public isInlineCallLiteral = false;
        public accessorSymbol: Symbol = null;
        public leftCurlyCount = 0;
        public rightCurlyCount = 0;
        public returnStatementsWithExpressions: ReturnStatement[] = [];
        public scopeType: Type = null; // Type of the FuncDecl, before target typing
        public endingToken: ASTSpan = null;
        public isDeclaration() { return true; }
        public constructorSpan: ASTSpan = null;

        constructor(public name: Identifier,
                    public bod: ASTList,
                    public isConstructor: bool,
                    public typeArguments: ASTList,
                    public arguments: ASTList,
                    public vars: ASTList,
                    public scopes: ASTList,
                    public statics: ASTList,
                    nodeType: number) {

            super(nodeType);
        }

        public internalName(): string {
            if (this.internalNameCache == null) {
                var extName = this.getNameText();
                if (extName) {
                    this.internalNameCache = "_internal_" + extName;
                }
                else {
                    this.internalNameCache = "_internal_" + internalId++;
                }
            }
            return this.internalNameCache;
        }

        public hasSelfReference() { return hasFlag(this.fncFlags, FncFlags.HasSelfReference); }
        public setHasSelfReference() { this.fncFlags |= FncFlags.HasSelfReference; }

        public hasSuperReferenceInFatArrowFunction() { return hasFlag(this.fncFlags, FncFlags.HasSuperReferenceInFatArrowFunction); }
        public setHasSuperReferenceInFatArrowFunction() { this.fncFlags |= FncFlags.HasSuperReferenceInFatArrowFunction; }

        public addCloRef(id: Identifier, sym: Symbol): number {
            if (this.envids == null) {
                this.envids = new Identifier[];
            }
            this.envids[this.envids.length] = id;
            var outerFnc = this.enclosingFnc;
            if (sym) {
                while (outerFnc && (outerFnc.type.symbol != sym.container)) {
                    outerFnc.addJumpRef(sym);
                    outerFnc = outerFnc.enclosingFnc;
                }
            }
            return this.envids.length - 1;
        }

        public addJumpRef(sym: Symbol): void {
            if (this.jumpRefs == null) {
                this.jumpRefs = new Identifier[];
            }
            var id = new Identifier(sym.name);
            this.jumpRefs[this.jumpRefs.length] = id;
            id.sym = sym;
            id.cloId = this.addCloRef(id, null);
        }

        public buildControlFlow(): ControlFlowContext {
            var entry = new BasicBlock();
            var exit = new BasicBlock();

            var context = new ControlFlowContext(entry, exit);

            var controlFlowPrefix = (ast: AST, parent: AST, walker: IAstWalker) => {
                ast.addToControlFlow(walker.state);
                return ast;
            }

            var walker = getAstWalkerFactory().getWalker(controlFlowPrefix, null, null, context);
            context.walker = walker;
            walker.walk(this.bod, this);

            return context;
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckFunction(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitJavascriptFunction(this);
        }

        public getNameText() {
            if (this.name) {
                return this.name.actualText;
            }
            else {
                return this.hint;
            }
        }

        public isMethod() {
            return (this.fncFlags & FncFlags.Method) != FncFlags.None;
        }

        public isCallMember() { return hasFlag(this.fncFlags, FncFlags.CallMember); }
        public isConstructMember() { return hasFlag(this.fncFlags, FncFlags.ConstructMember); }
        public isIndexerMember() { return hasFlag(this.fncFlags, FncFlags.IndexerMember); }
        public isSpecialFn() { return this.isCallMember() || this.isIndexerMember() || this.isConstructMember(); }
        public isAnonymousFn() { return this.name === null; }
        public isAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor) || hasFlag(this.fncFlags, FncFlags.SetAccessor); }
        public isGetAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor); }
        public isSetAccessor() { return hasFlag(this.fncFlags, FncFlags.SetAccessor); }
        public isAmbient() { return hasFlag(this.fncFlags, FncFlags.Ambient); }
        public isExported() { return hasFlag(this.fncFlags, FncFlags.Exported); }
        public isPrivate() { return hasFlag(this.fncFlags, FncFlags.Private); }
        public isPublic() { return hasFlag(this.fncFlags, FncFlags.Public); }
        public isStatic() { return hasFlag(this.fncFlags, FncFlags.Static); }

        public treeViewLabel() {
            if (this.name == null) {
                return "funcExpr";
            }
            else {
                return "func: " + this.name.actualText
            }
        }

        public ClearFlags(): void {
            this.fncFlags = FncFlags.None;
        }

        public isSignature() { return (this.fncFlags & FncFlags.Signature) != FncFlags.None; }
    }

    export class LocationInfo {
        constructor(public filename: string,
                    public lineMap: number[],
                    public unitIndex) { }
    }

    export var unknownLocationInfo = new LocationInfo("unknown", null, -1);

    export class Script extends FuncDecl {
        public locationInfo: LocationInfo = null;
        public referencedFiles: IFileReference[] = [];
        public requiresGlobal = false;
        public requiresExtendsBlock = false;
        public isResident = false;
        public isDeclareFile = false;
        public hasBeenTypeChecked = false;
        public topLevelMod: ModuleDeclaration = null;
        public leftCurlyCount = 0;
        public rightCurlyCount = 0;
        public vars: ASTList;
        // Remember if the script contains Unicode chars, that is needed when generating code for this script object to decide the output file correct encoding.
        public containsUnicodeChar = false;
        public containsUnicodeCharInComment = false;
        public cachedEmitRequired: bool;

        private setCachedEmitRequired(value: bool) {
            this.cachedEmitRequired = value;
            return this.cachedEmitRequired;
        }

        constructor (vars: ASTList, scopes: ASTList) {
            super(new Identifier("script"), null, false, null, null, vars, scopes, null, NodeType.Script);
            this.vars = vars;
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckScript(this);
        }

        public treeViewLabel() {
            return "Script";
        }

        public emitRequired(emitOptions: EmitOptions) {
            if (this.cachedEmitRequired != undefined) {
                return this.cachedEmitRequired;
            }

            if (!this.isDeclareFile && !this.isResident && this.bod) {
                if (this.bod.members.length == 0) {
                    // allow empty files that are not declare files 
                    return this.setCachedEmitRequired(true);
                }

                for (var i = 0, len = this.bod.members.length; i < len; i++) {
                    var stmt = this.bod.members[i];
                    if (stmt.nodeType == NodeType.ModuleDeclaration) {
                        if (!hasFlag((<ModuleDeclaration>stmt).modFlags, ModuleFlags.ShouldEmitModuleDecl | ModuleFlags.Ambient)) {
                            return this.setCachedEmitRequired(true);
                        }
                    }
                    else if (stmt.nodeType == NodeType.ClassDeclaration) {
                        if (!hasFlag((<ClassDeclaration>stmt).varFlags, VarFlags.Ambient)) {
                            return this.setCachedEmitRequired(true);
                        }
                    }
                    else if (stmt.nodeType == NodeType.VarDecl) {
                        if (!hasFlag((<VarDecl>stmt).varFlags, VarFlags.Ambient)) {
                            return this.setCachedEmitRequired(true);
                        }
                    }
                    else if (stmt.nodeType == NodeType.FuncDecl) {
                        if (!(<FuncDecl>stmt).isSignature()) {
                            return this.setCachedEmitRequired(true);
                        }
                    }
                    else if (stmt.nodeType != NodeType.InterfaceDeclaration && stmt.nodeType != NodeType.Empty) {
                        return this.setCachedEmitRequired(true);
                    }
                }

                if ( emitOptions.emitComments &&
                    ((this.bod.preComments && this.bod.preComments.length > 0) || (this.bod.postComments && this.bod.postComments.length > 0))) {
                    return this.setCachedEmitRequired(true);
                }
            }
            return this.setCachedEmitRequired(false);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            if (this.emitRequired(emitter.emitOptions)) {
                emitter.emitJavascriptList(this.bod, null, TokenID.Semicolon, true, false, false, true, this.requiresExtendsBlock);
            }
        }

        public externallyVisibleImportedSymbols: Symbol[] = [];

        public AddExternallyVisibleImportedSymbol(symbol: Symbol, checker: TypeChecker) {
            if (this.isExternallyVisibleSymbol(symbol)) {
                return;
            }

            // Before adding check if the external symbol is also marked for visibility
            if (!symbol.getType().symbol.isExternallyVisible(checker)) {
                // Report error
                var quotes = "";
                var moduleName = symbol.getType().symbol.prettyName;
                if (!isQuoted(moduleName)) {
                    quotes = "'";
                }
                checker.errorReporter.simpleError(symbol.declAST, "Externally visible import statement uses non exported module " + quotes + moduleName + quotes);
            }
            this.externallyVisibleImportedSymbols.push(symbol);
        }

        public isExternallyVisibleSymbol(symbol: Symbol) {
            for (var i = 0 ; i < this.externallyVisibleImportedSymbols.length; i++) {
                if (this.externallyVisibleImportedSymbols[i] == symbol) {
                    return true;
                }
            }
            return false;
        }
    }

    export class NamedDeclaration extends ModuleElement {
        public leftCurlyCount = 0;
        public rightCurlyCount = 0;
        public isDeclaration() { return true; }

        constructor (nodeType: NodeType,
                     public name: Identifier,
                     public members: ASTList) {
            super(nodeType);
        }
    }

    export class ModuleDeclaration extends NamedDeclaration {
        public modFlags = ModuleFlags.ShouldEmitModuleDecl;
        public mod: ModuleType;
        public prettyName: string;
        public amdDependencies: string[] = [];
        public vars: ASTList;
        // Remember if the module contains Unicode chars, that is needed for dynamic module as we will generate a file for each.
        public containsUnicodeChar = false;
        public containsUnicodeCharInComment = false;

        constructor (name: Identifier, members: ASTList, vars: ASTList, public endingToken: ASTSpan) {
            super(NodeType.ModuleDeclaration, name, members);

            this.vars = vars;
            this.prettyName = this.name.actualText;
        }

        public isExported() { return hasFlag(this.modFlags, ModuleFlags.Exported); }
        public isAmbient() { return hasFlag(this.modFlags, ModuleFlags.Ambient); }
        public isEnum() { return hasFlag(this.modFlags, ModuleFlags.IsEnum); }
        public isWholeFile() { return hasFlag(this.modFlags, ModuleFlags.IsWholeFile); }

        public recordNonInterface() {
            this.modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckModule(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            if (!hasFlag(this.modFlags, ModuleFlags.ShouldEmitModuleDecl)) {
                emitter.emitParensAndCommentsInPlace(this, true);
                emitter.emitJavascriptModule(this);
                emitter.emitParensAndCommentsInPlace(this, false);
            }
        }
    }

    export class TypeDeclaration extends NamedDeclaration {
        public varFlags = VarFlags.None;

        constructor(nodeType: NodeType,
                    name: Identifier,
                    public typeParameters: ASTList,
                    public extendsList: ASTList,
                    public implementsList: ASTList,
                    members: ASTList) {
            super(nodeType, name, members);
        }

        public isExported() { 
            return hasFlag(this.varFlags, VarFlags.Exported);
        }

        public isAmbient() {
            return hasFlag(this.varFlags, VarFlags.Ambient);
        }
    }

    export class ClassDeclaration extends TypeDeclaration {
        public knownMemberNames: any = {};
        public constructorDecl: FuncDecl = null;
        public constructorNestingLevel = 0;
        public endingToken: ASTSpan = null;

        constructor(name: Identifier,
                    typeParameters: ASTList,
                    members: ASTList,
                    extendsList: ASTList,
                    implementsList: ASTList) {
            super(NodeType.ClassDeclaration, name, typeParameters, extendsList, implementsList, members);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckClass(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitJavascriptClass(this);
        }
    }

    export class InterfaceDeclaration extends TypeDeclaration {
        constructor(name: Identifier,
                    typeParameters: ASTList,
                    members: ASTList,
                    extendsList: ASTList,
                    implementsList: ASTList) {
            super(NodeType.InterfaceDeclaration, name, typeParameters, extendsList, implementsList, members);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckInterface(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
        }
    }

    export class Statement extends ModuleElement {
        constructor (nodeType: NodeType) {
            super(nodeType);
            this.flags |= ASTFlags.IsStatement;
        }

        public isLoop() { return false; }

        public isStatementOrExpression() { return true; }

        public isCompoundStatement() { return this.isLoop(); }

        public typeCheck(typeFlow: TypeFlow) {
            this.type = typeFlow.voidType;
            return this;
        }
    }

    export class LabeledStatement extends Statement {
        constructor (public labels: ASTList, public stmt: AST) {
            super(NodeType.LabeledStatement);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.labels) {
                var labelsLen = this.labels.members.length;
                for (var i = 0; i < labelsLen; i++) {
                    this.labels.members[i].emit(emitter, tokenId, startLine);
                }
            }
            this.stmt.emit(emitter, tokenId, true);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            typeFlow.typeCheck(this.labels);
            this.stmt = this.stmt.typeCheck(typeFlow);
            return this;
        }

        public addToControlFlow(context: ControlFlowContext): void {
            var beforeBB = context.current;
            var bb = new BasicBlock();
            context.current = bb;
            beforeBB.addSuccessor(bb);
        }
    }

    export class Block extends Statement {
        constructor (public statements: ASTList,
                     public isStatementBlock: bool) {
            super(NodeType.Block);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.isStatementBlock) {
                emitter.writeLineToOutput(" {");
                emitter.indenter.increaseIndent();
            } else {
                emitter.setInVarBlock(this.statements.members.length);
            }
            var temp = emitter.setInObjectLiteral(false);
            if (this.statements) {
                emitter.emitJavascriptList(this.statements, null, TokenID.Semicolon, true, false, false);
            }
            if (this.isStatementBlock) {
                emitter.indenter.decreaseIndent();
                emitter.emitIndent();
                emitter.writeToOutput("}");
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public addToControlFlow(context: ControlFlowContext) {
            var afterIfNeeded = new BasicBlock();
            context.pushStatement(this, context.current, afterIfNeeded);
            if (this.statements) {
                context.walk(this.statements, this);
            }
            context.walker.options.goChildren = false;
            context.popStatement();
            if (afterIfNeeded.predecessors.length > 0) {
                context.current.addSuccessor(afterIfNeeded);
                context.current = afterIfNeeded;
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
            if (!typeFlow.checker.styleSettings.emptyBlocks) {
                if ((this.statements === null) || (this.statements.members.length == 0)) {
                    typeFlow.checker.errorReporter.styleError(this, "empty block");
                }
            }

            typeFlow.typeCheck(this.statements);
            return this;
        }
    }

    export class Jump extends Statement {
        public target: string = null;
        public hasExplicitTarget() { return (this.target); }
        public resolvedTarget: Statement = null;

        constructor (nodeType: NodeType) {
            super(nodeType);
        }

        public setResolvedTarget(parser: Parser, stmt: Statement): bool {
            if (stmt.isLoop()) {
                this.resolvedTarget = stmt;
                return true;
            }
            if (this.nodeType === NodeType.Continue) {
                parser.reportParseError("continue statement applies only to loops");
                return false;
            }
            else {
                if ((stmt.nodeType == NodeType.Switch) || this.hasExplicitTarget()) {
                    this.resolvedTarget = stmt;
                    return true;
                }
                else {
                    parser.reportParseError("break statement with no label can apply only to a loop or switch statement");
                    return false;
                }
            }
        }

        public addToControlFlow(context: ControlFlowContext): void {
            super.addToControlFlow(context);
            context.unconditionalBranch(this.resolvedTarget, (this.nodeType == NodeType.Continue));
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.nodeType == NodeType.Break) {
                emitter.writeToOutput("break");
            }
            else {
                emitter.writeToOutput("continue");
            }
            if (this.hasExplicitTarget()) {
                emitter.writeToOutput(" " + this.target);
            }
            emitter.recordSourceMappingEnd(this);
            emitter.writeToOutput(";");
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class WhileStatement extends Statement {
        public body: AST = null;

        constructor (public cond: AST) {
            super(NodeType.While);
        }

        public isLoop() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("while(");
            emitter.emitJavascript(this.cond, TokenID.While, false);
            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, false);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckWhile(this);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            var loopHeader = context.current;
            var loopStart = new BasicBlock();
            var afterLoop = new BasicBlock();

            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            context.addContent(this.cond);
            var condBlock = context.current;
            var targetInfo: ITargetInfo = null;
            if (this.body) {
                context.current = new BasicBlock();
                condBlock.addSuccessor(context.current);
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
            }
            context.current = afterLoop;
            condBlock.addSuccessor(afterLoop);
            // TODO: check for while (true) and then only continue if afterLoop has predecessors
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        }
    }

    export class DoWhileStatement extends Statement {
        public body: AST = null;
        public whileAST: AST = null;
        public cond: AST = null;
        public isLoop() { return true; }

        constructor () {
            super(NodeType.DoWhile);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("do");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.recordSourceMappingStart(this.whileAST);
            emitter.writeToOutput("while");
            emitter.recordSourceMappingEnd(this.whileAST);
            emitter.writeToOutput('(');
            emitter.emitJavascript(this.cond, TokenID.CloseParen, false);
            emitter.writeToOutput(")");
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.writeToOutput(";");
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckDoWhile(this);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            var loopHeader = context.current;
            var loopStart = new BasicBlock();
            var afterLoop = new BasicBlock();
            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            var targetInfo: ITargetInfo = null;
            if (this.body) {
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
                context.addContent(this.cond);
                // TODO: check for while (true) 
                context.current = afterLoop;
                loopEnd.addSuccessor(afterLoop);
            }
            else {
                context.addUnreachable(this.cond);
            }
            context.walker.options.goChildren = false;
        }
    }

    export class IfStatement extends Statement {
        public thenBod: AST;
        public elseBod: AST = null;
        public statement: ASTSpan = new ASTSpan();

        constructor (public cond: AST) {
            super(NodeType.If);
        }

        public isCompoundStatement() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("if(");
            emitter.emitJavascript(this.cond, TokenID.If, false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascriptStatements(this.thenBod, true);
            if (this.elseBod) {
                if (this.elseBod.nodeType === NodeType.If) {
                    emitter.writeToOutput(" else ");
                    this.elseBod.emit(emitter, tokenId, /*startLine:*/ false);
                }
                else {
                    emitter.writeToOutput(" else");
                    emitter.emitJavascriptStatements(this.elseBod, true);
                }
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckIf(this);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            this.cond.addToControlFlow(context);
            var afterIf = new BasicBlock();
            var beforeIf = context.current;
            context.pushStatement(this, beforeIf, afterIf);
            var hasContinuation = false;
            context.current = new BasicBlock();
            beforeIf.addSuccessor(context.current);
            context.walk(this.thenBod, this);
            if (!context.noContinuation) {
                hasContinuation = true;
                context.current.addSuccessor(afterIf);
            }
            if (this.elseBod) {
                // current block will be thenBod
                context.current = new BasicBlock();
                context.noContinuation = false;
                beforeIf.addSuccessor(context.current);
                context.walk(this.elseBod, this);
                if (!context.noContinuation) {
                    hasContinuation = true;
                    context.current.addSuccessor(afterIf);
                }
                else {
                    // thenBod created continuation for if statement
                    if (hasContinuation) {
                        context.noContinuation = false;
                    }
                }
            }
            else {
                beforeIf.addSuccessor(afterIf);
                context.noContinuation = false;
                hasContinuation = true;
            }
            var targetInfo = context.popStatement();
            if (afterIf.predecessors.length > 0) {
                context.noContinuation = false;
                hasContinuation = true;
            }
            if (hasContinuation) {
                context.current = afterIf;
            }
            context.walker.options.goChildren = false;
        }
    }

    export class ReturnStatement extends Statement {
        public returnExpression: AST = null;

        constructor () {
            super(NodeType.Return);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            if (this.returnExpression) {
                emitter.writeToOutput("return ");
                emitter.emitJavascript(this.returnExpression, TokenID.Semicolon, false);

                if (this.returnExpression.nodeType === NodeType.FuncDecl) {
                    emitter.writeToOutput(";");
                }
            }
            else {
                emitter.writeToOutput("return;");
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            super.addToControlFlow(context);
            context.returnStmt();
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckReturn(this);
        }
    }

    export class EndCode extends AST {
        constructor () {
            super(NodeType.EndCode);
        }
    }

    export class ForInStatement extends Statement {
        constructor (public lval: AST, public obj: AST) {
            super(NodeType.ForIn);
            if (this.lval && (this.lval.nodeType == NodeType.VarDecl)) {
                (<BoundDecl>this.lval).varFlags |= VarFlags.AutoInit;
            }
        }
        public statement: ASTSpan = new ASTSpan();
        public body: AST;

        public isLoop() { return true; }

        public isFiltered() {
            if (this.body) {
                var singleItem: AST = null;
                if (this.body.nodeType == NodeType.List) {
                    var stmts = <ASTList>this.body;
                    if (stmts.members.length == 1) {
                        singleItem = stmts.members[0];
                    }
                }
                else {
                    singleItem = this.body;
                }
                // match template for filtering 'own' properties from obj
                if (singleItem !== null) {
                    if (singleItem.nodeType == NodeType.Block) {
                        var block = <Block>singleItem;
                        if ((block.statements !== null) && (block.statements.members.length == 1)) {
                            singleItem = block.statements.members[0];
                        }
                    }
                    if (singleItem.nodeType == NodeType.If) {
                        var cond = (<IfStatement>singleItem).cond;
                        if (cond.nodeType == NodeType.Call) {
                            var target = (<CallExpression>cond).target;
                            if (target.nodeType == NodeType.Dot) {
                                var binex = <BinaryExpression>target;
                                if ((binex.operand1.nodeType == NodeType.Name) &&
                                    (this.obj.nodeType == NodeType.Name) &&
                                    ((<Identifier>binex.operand1).actualText == (<Identifier>this.obj).actualText)) {
                                    var prop = <Identifier>binex.operand2;
                                    if (prop.actualText == "hasOwnProperty") {
                                        var args = (<CallExpression>cond).arguments;
                                        if ((args !== null) && (args.members.length == 1)) {
                                            var arg = args.members[0];
                                            if ((arg.nodeType == NodeType.Name) &&
                                                 (this.lval.nodeType == NodeType.Name)) {
                                                if (((<Identifier>this.lval).actualText) == (<Identifier>arg).actualText) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("for(");
            emitter.emitJavascript(this.lval, TokenID.For, false);
            emitter.writeToOutput(" in ");
            emitter.emitJavascript(this.obj, TokenID.For, false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascriptStatements(this.body, true);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            if (typeFlow.checker.styleSettings.forin) {
                if (!this.isFiltered()) {
                    typeFlow.checker.errorReporter.styleError(this, "no hasOwnProperty filter");
                }
            }
            return typeFlow.typeCheckForIn(this);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            if (this.lval) {
                context.addContent(this.lval);
            }
            if (this.obj) {
                context.addContent(this.obj);
            }

            var loopHeader = context.current;
            var loopStart = new BasicBlock();
            var afterLoop = new BasicBlock();

            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            if (this.body) {
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
            }
            context.current = afterLoop;
            context.noContinuation = false;
            loopHeader.addSuccessor(afterLoop);
            context.walker.options.goChildren = false;
        }
    }

    export class ForStatement extends Statement {
        public cond: AST;
        public body: AST;
        public incr: AST;

        constructor (public init: AST) {
            super(NodeType.For);
        }

        public isLoop() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("for(");
            if (this.init) {
                if (this.init.nodeType != NodeType.List) {
                    emitter.emitJavascript(this.init, TokenID.For, false);
                }
                else {
                    emitter.setInVarBlock((<ASTList>this.init).members.length); 
                    emitter.emitJavascriptList(this.init, null, TokenID.For, false, false, false);
                }
            }
            emitter.writeToOutput("; ");
            emitter.emitJavascript(this.cond, TokenID.For, false);
            emitter.writeToOutput("; ");
            emitter.emitJavascript(this.incr, TokenID.For, false);
            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckFor(this);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            if (this.init) {
                context.addContent(this.init);
            }
            var loopHeader = context.current;
            var loopStart = new BasicBlock();
            var afterLoop = new BasicBlock();

            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            var condBlock: BasicBlock = null;
            var continueTarget = loopStart;
            var incrBB: BasicBlock = null;
            if (this.incr) {
                incrBB = new BasicBlock();
                continueTarget = incrBB;
            }
            if (this.cond) {
                condBlock = context.current;
                context.addContent(this.cond);
                context.current = new BasicBlock();
                condBlock.addSuccessor(context.current);
            }
            var targetInfo: ITargetInfo = null;
            if (this.body) {
                context.pushStatement(this, continueTarget, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (this.incr) {
                if (context.noContinuation) {
                    if (incrBB.predecessors.length == 0) {
                        context.addUnreachable(this.incr);
                    }
                }
                else {
                    context.current.addSuccessor(incrBB);
                    context.current = incrBB;
                    context.addContent(this.incr);
                }
            }
            var loopEnd = context.current;
            if (!(context.noContinuation)) {
                loopEnd.addSuccessor(loopStart);

            }
            if (condBlock) {
                condBlock.addSuccessor(afterLoop);
                context.noContinuation = false;
            }
            if (afterLoop.predecessors.length > 0) {
                context.noContinuation = false;
                context.current = afterLoop;
            }
            context.walker.options.goChildren = false;
        }
    }

    export class WithStatement extends Statement {
        public body: AST;

        public isCompoundStatement() { return true; }

        public withSym: WithSymbol = null;

        constructor (public expr: AST) {
            super(NodeType.With);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("with (");
            if (this.expr) {
                emitter.emitJavascript(this.expr, TokenID.With, false);
            }

            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckWith(this);
        }
    }

    export class SwitchStatement extends Statement {
        public caseList: ASTList;
        public defaultCase: CaseStatement = null;
        public statement: ASTSpan = new ASTSpan();

        constructor (public val: AST) {
            super(NodeType.Switch);
        }

        public isCompoundStatement() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("switch(");
            emitter.emitJavascript(this.val, TokenID.Identifier, false);
            emitter.writeToOutput(")"); 
            emitter.recordSourceMappingEnd(this.statement);
            emitter.writeLineToOutput(" {");
            emitter.indenter.increaseIndent();
            var casesLen = this.caseList.members.length;
            for (var i = 0; i < casesLen; i++) {
                var caseExpr = this.caseList.members[i];
                emitter.emitJavascript(caseExpr, TokenID.Case, true);
            }
            emitter.indenter.decreaseIndent();
            emitter.emitIndent();
            emitter.writeToOutput("}");
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            var len = this.caseList.members.length;
            this.val = typeFlow.typeCheck(this.val);
            for (var i = 0; i < len; i++) {
                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]);
            }
            this.defaultCase = <CaseStatement>typeFlow.typeCheck(this.defaultCase);
            this.type = typeFlow.voidType;
            return this;
        }

        // if there are break statements that match this switch, then just link cond block with block after switch
        public addToControlFlow(context: ControlFlowContext) {
            var condBlock = context.current;
            context.addContent(this.val);
            var execBlock = new BasicBlock();
            var afterSwitch = new BasicBlock();

            condBlock.addSuccessor(execBlock);
            context.pushSwitch(execBlock);
            context.current = execBlock;
            context.pushStatement(this, execBlock, afterSwitch);
            context.walk(this.caseList, this);
            context.popSwitch();
            var targetInfo = context.popStatement();
            var hasCondContinuation = (this.defaultCase == null);
            if (this.defaultCase == null) {
                condBlock.addSuccessor(afterSwitch);
            }
            if (afterSwitch.predecessors.length > 0) {
                context.noContinuation = false;
                context.current = afterSwitch;
            }
            else {
                context.noContinuation = true;
            }
            context.walker.options.goChildren = false;
        }
    }

    export class CaseStatement extends Statement {
        public expr: AST = null;
        public body: ASTList;

        constructor () {
            super(NodeType.Case);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.expr) {
                emitter.writeToOutput("case ");
                emitter.emitJavascript(this.expr, TokenID.Identifier, false);
            }
            else {
                emitter.writeToOutput("default");
            }
            emitter.writeToOutput(":");
            if (this.body.members.length == 1 && this.body.members[0].nodeType == NodeType.Block) {
                // The case statement was written with curly braces, so emit it with the appropriate formatting
                emitter.emitJavascriptStatements(this.body, false);
            }
            else {
                // No curly braces. Format in the expected way
                emitter.writeLineToOutput("");
                emitter.indenter.increaseIndent();
                emitter.emitBareJavascriptStatements(this.body);
                emitter.indenter.decreaseIndent();
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.expr = typeFlow.typeCheck(this.expr);
            typeFlow.typeCheck(this.body);
            this.type = typeFlow.voidType;
            return this;
        }

        // TODO: more reasoning about unreachable cases (such as duplicate literals as case expressions)
        // for now, assume all cases are reachable, regardless of whether some cases fall through
        public addToControlFlow(context: ControlFlowContext) {
            var execBlock = new BasicBlock();
            var sw = context.currentSwitch[context.currentSwitch.length - 1];
            // TODO: fall-through from previous (+ to end of switch)
            if (this.expr) {
                var exprBlock = new BasicBlock();
                context.current = exprBlock;
                sw.addSuccessor(exprBlock);
                context.addContent(this.expr);
                exprBlock.addSuccessor(execBlock);
            }
            else {
                sw.addSuccessor(execBlock);
            }
            context.current = execBlock;
            if (this.body) {
                context.walk(this.body, this);
            }
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        }
    }

    export class TypeParameter extends AST {
        constructor(public name: Identifier, public constraint: AST) {
            super(NodeType.TypeParameter);
        }
    }

    export class GenericType extends AST {
        constructor(public name: AST, public typeArguments: ASTList) {
            super(NodeType.GenericType);
        }
    }

    export class TypeReference extends AST {
        constructor (public term: AST, public arrayCount: number) {
            super(NodeType.TypeRef);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            throw new Error("should not emit a type ref");
        }

        public typeCheck(typeFlow: TypeFlow) {
            var prevInTCTR = typeFlow.inTypeRefTypeCheck;
            typeFlow.inTypeRefTypeCheck = true;
            var typeLink = getTypeLink(this, typeFlow.checker, true);
            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false);

            if (this.term) {
                typeFlow.typeCheck(this.term);
            }

            typeFlow.checkForVoidConstructor(typeLink.type, this);

            this.type = typeLink.type;

            // in error recovery cases, there may not be a term
            if (this.term) {
                this.term.type = this.type;
            }

            typeFlow.inTypeRefTypeCheck = prevInTCTR;
            return this;
        }
    }

    export class TryFinally extends Statement {
        constructor (public tryNode: AST, public finallyNode: Finally) {
            super(NodeType.TryFinally);
        }

        public isCompoundStatement() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascript(this.tryNode, TokenID.Try, false);
            emitter.emitJavascript(this.finallyNode, TokenID.Finally, false);
            emitter.recordSourceMappingEnd(this);
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.tryNode = typeFlow.typeCheck(this.tryNode);
            this.finallyNode = <Finally>typeFlow.typeCheck(this.finallyNode);
            this.type = typeFlow.voidType;
            return this;
        }

        public addToControlFlow(context: ControlFlowContext) {
            var afterFinally = new BasicBlock();
            context.walk(this.tryNode, this);
            var finBlock = new BasicBlock();
            if (context.current) {
                context.current.addSuccessor(finBlock);
            }
            context.current = finBlock;
            context.pushStatement(this, null, afterFinally);
            context.walk(this.finallyNode, this);
            if (!context.noContinuation && context.current) {
                context.current.addSuccessor(afterFinally);
            }
            if (afterFinally.predecessors.length > 0) {
                context.current = afterFinally;
            }
            else {
                context.noContinuation = true;
            }
            context.popStatement();
            context.walker.options.goChildren = false;
        }
    }

    export class TryCatch extends Statement {
        constructor (public tryNode: Try, public catchNode: Catch) {
            super(NodeType.TryCatch);
        }

        public isCompoundStatement() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascript(this.tryNode, TokenID.Try, false);
            emitter.emitJavascript(this.catchNode, TokenID.Catch, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public addToControlFlow(context: ControlFlowContext) {
            var beforeTry = context.current;
            var tryBlock = new BasicBlock();
            beforeTry.addSuccessor(tryBlock);
            context.current = tryBlock;
            var afterTryCatch = new BasicBlock();
            context.pushStatement(this, null, afterTryCatch);
            context.walk(this.tryNode, this);
            if (!context.noContinuation) {
                if (context.current) {
                    context.current.addSuccessor(afterTryCatch);
                }
            }
            context.current = new BasicBlock();
            beforeTry.addSuccessor(context.current);
            context.walk(this.catchNode, this);
            context.popStatement();
            if (!context.noContinuation) {
                if (context.current) {
                    context.current.addSuccessor(afterTryCatch);
                }
            }
            context.current = afterTryCatch;
            context.walker.options.goChildren = false;
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.tryNode = <Try>typeFlow.typeCheck(this.tryNode);
            this.catchNode = <Catch>typeFlow.typeCheck(this.catchNode);
            this.type = typeFlow.voidType;
            return this;
        }
    }

    export class Try extends Statement {
        constructor (public body: AST) {
            super(NodeType.Try);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("try ");
            emitter.emitJavascript(this.body, TokenID.Try, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.body = typeFlow.typeCheck(this.body);
            return this;
        }

        public addToControlFlow(context: ControlFlowContext) {
            if (this.body) {
                context.walk(this.body, this);
            }
            context.walker.options.goChildren = false;
            context.noContinuation = false;
        }
    }

    export class Catch extends Statement {
        constructor (public param: VarDecl, public body: AST) {
            super(NodeType.Catch);
            if (this.param) {
                this.param.varFlags |= VarFlags.AutoInit;
            }
        }
        public statement: ASTSpan = new ASTSpan();
        public containedScope: SymbolScope = null;

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(" ");
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("catch (");
            emitter.emitJavascript(this.param, TokenID.OpenParen, false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascript(this.body, TokenID.Catch, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public addToControlFlow(context: ControlFlowContext) {
            if (this.param) {
                context.addContent(this.param);
                var bodBlock = new BasicBlock();
                context.current.addSuccessor(bodBlock);
                context.current = bodBlock;
            }
            if (this.body) {
                context.walk(this.body, this);
            }
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        }

        public typeCheck(typeFlow: TypeFlow) {
            var prevScope = typeFlow.scope;
            typeFlow.scope = this.containedScope;
            this.param = <VarDecl>typeFlow.typeCheck(this.param);
            var exceptVar = new ValueLocation();
            var varSym = new VariableSymbol((<VarDecl>this.param).id.text,
                                          this.param.minChar,
                                          typeFlow.checker.locationInfo.unitIndex,
                                          exceptVar);
            exceptVar.symbol = varSym;
            exceptVar.typeLink = new TypeLink();
            // var type for now (add syntax for type annotation)
            exceptVar.typeLink.type = typeFlow.anyType;
            var thisFnc = typeFlow.thisFnc;
            if (thisFnc && thisFnc.type) {
                exceptVar.symbol.container = thisFnc.type.symbol;
            }
            else {
                exceptVar.symbol.container = null;
            }
            this.param.sym = exceptVar.symbol;
            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol,
                                 typeFlow.checker.errorReporter, false, false, false);
            this.body = typeFlow.typeCheck(this.body);

            // if we're in provisional typecheck mode, clean up the symbol entry
            // REVIEW: This is obviously bad form, since we're counting on the internal
            // layout of the symbol table, but this is also the only place where we insert
            // symbols during typecheck
            if (typeFlow.checker.inProvisionalTypecheckMode()) {
                var table = typeFlow.scope.getTable();
                (<any>table).secondaryTable.table[exceptVar.symbol.name] = undefined;
            }
            this.type = typeFlow.voidType;
            typeFlow.scope = prevScope;
            return this;
        }
    }

    export class Finally extends Statement {
        constructor (public body: AST) {
            super(NodeType.Finally);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("finally");
            emitter.emitJavascript(this.body, TokenID.Finally, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public addToControlFlow(context: ControlFlowContext) {
            if (this.body) {
                context.walk(this.body, this);
            }
            context.walker.options.goChildren = false;
            context.noContinuation = false;
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.body = typeFlow.typeCheck(this.body);
            return this;
        }
    }

    export class Comment extends AST {

        public text: string[] = null;
        public minLine: number;
        public limLine: number;
        private docCommentText: string = null;

        constructor (public content: string, public isBlockComment: bool, public endsLine) {
            super(NodeType.Comment);
        }

        public getText(): string[] {
            if (this.text == null) {
                if (this.isBlockComment) {
                    this.text = this.content.split("\n");
                    for (var i = 0; i < this.text.length; i++) {
                        this.text[i] = this.text[i].replace(/^\s+|\s+$/g, '');
                    }
                }
                else {
                    this.text = [(this.content.replace(/^\s+|\s+$/g, ''))];
                }
            }

            return this.text;
        }

        public isDocComment() {
            if (this.isBlockComment) {
                return this.content.charAt(2) == "*" && this.content.charAt(3) != "/";
            }

            return false;
        }

        public getDocCommentText() {
            if (this.docCommentText == null) {
                this.docCommentText = Comment.cleanJSDocComment(this.content);
            }

            return this.docCommentText;
        }

        static consumeLeadingSpace(line: string, startIndex: number, maxSpacesToRemove?: number) {
            var endIndex = line.length;
            if (maxSpacesToRemove != undefined) {
                endIndex = min(startIndex + maxSpacesToRemove, endIndex);
            }

            for (; startIndex < endIndex; startIndex++) {
                var charCode = line.charCodeAt(startIndex);
                if (charCode != LexCodeSpace && charCode != LexCodeTAB) {
                    return startIndex;
                }
            }
            
            if (endIndex != line.length) {
                return endIndex;
            }

            return -1;
        }

        static isSpaceChar(line: string, index: number) {
            var length = line.length;
            if (index < length) {
                var charCode = line.charCodeAt(index);
                // If the character is space
                return charCode == LexCodeSpace || charCode == LexCodeTAB;
            }

            // If the index is end of the line it is space
            return index == length;
        }

        static cleanDocCommentLine(line: string, jsDocStyleComment: bool, jsDocLineSpaceToRemove?: number) {
            var nonSpaceIndex = Comment.consumeLeadingSpace(line, 0);
            if (nonSpaceIndex != -1) {
                var jsDocSpacesRemoved = nonSpaceIndex;
                if (jsDocStyleComment && line.charAt(nonSpaceIndex) == '*') { // remove leading * in case of jsDocComment
                    var startIndex = nonSpaceIndex + 1;
                    nonSpaceIndex = Comment.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);

                    if (nonSpaceIndex != -1) {
                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;
                    } else {
                        return null;
                    }
                }

                return {
                    minChar: nonSpaceIndex,
                    limChar: line.charAt(line.length - 1) == "\r" ? line.length - 1 : line.length,
                    jsDocSpacesRemoved: jsDocSpacesRemoved
                };
            }

            return null;
        }

        static cleanJSDocComment(content: string, spacesToRemove?: number) {

            var docCommentLines: string[] = [];
            content = content.replace("/**", ""); // remove /**
            if (content.length >= 2 && content.charAt(content.length - 1) == "/" && content.charAt(content.length - 2) == "*") {
                content = content.substring(0, content.length - 2); // remove last */
            }
            var lines = content.split("\n");
            var inParamTag = false;
            for (var l = 0; l < lines.length; l++) {
                var line = lines[l];
                var cleanLinePos = Comment.cleanDocCommentLine(line, true, spacesToRemove);
                if (!cleanLinePos) {
                    // Whole line empty, read next line
                    continue;
                }

                var docCommentText = "";
                var prevPos = cleanLinePos.minChar;
                for (var i = line.indexOf("@", cleanLinePos.minChar); 0 <= i && i < cleanLinePos.limChar; i = line.indexOf("@", i + 1)) {
                    // We have encoutered @. 
                    // If we were omitting param comment, we dont have to do anything
                    // other wise the content of the text till @ tag goes as doc comment
                    var wasInParamtag = inParamTag;

                    // Parse contents next to @
                    if (line.indexOf("param", i + 1) == i + 1 && Comment.isSpaceChar(line, i + 6)) {
                        // It is param tag. 

                        // If we were not in param tag earlier, push the contents from prev pos of the tag this tag start as docComment
                        if (!wasInParamtag) {
                            docCommentText += line.substring(prevPos, i);
                        }

                        // New start of contents 
                        prevPos = i;
                        inParamTag = true;
                    } else if (wasInParamtag) {
                        // Non param tag start
                        prevPos = i;
                        inParamTag = false;
                    }
                }

                if (!inParamTag) {
                    docCommentText += line.substring(prevPos, cleanLinePos.limChar);
                }

                // Add line to comment text if it is not only white space line
                var newCleanPos = Comment.cleanDocCommentLine(docCommentText, false);
                if (newCleanPos) {
                    if (spacesToRemove == undefined) {
                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;
                    }
                    docCommentLines.push(docCommentText);
                }
            }
            
            return docCommentLines.join("\n");
        }

        static getDocCommentText(comments: Comment[]) {
            var docCommentText: string[] = [];
            for (var c = 0 ; c < comments.length; c++) {
                var commentText = comments[c].getDocCommentText();
                if (commentText != "") {
                    docCommentText.push(commentText);
                }
            }
            return docCommentText.join("\n");
        }

        static getParameterDocCommentText(param: string, fncDocComments: Comment[]) {
            if (fncDocComments.length == 0 || !fncDocComments[0].isBlockComment) {
                // there were no fnc doc comments and the comment is not block comment then it cannot have 
                // @param comment that can be parsed
                return "";
            }
            
            for (var i = 0; i < fncDocComments.length; i++) {
                var commentContents = fncDocComments[i].content;
                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {
                    j += 6;
                    if (!Comment.isSpaceChar(commentContents, j)) {
                        // This is not param tag but a tag line @paramxxxxx
                        continue;
                    }

                    // This is param tag. Check if it is what we are looking for
                    j = Comment.consumeLeadingSpace(commentContents, j);
                    if (j == -1) {
                        break;
                    }
                    
                    // Ignore the type expression
                    if (commentContents.charCodeAt(j) == LexCodeLC) {
                        j++;
                        // Consume the type
                        var charCode = 0;
                        for (var curlies = 1; j < commentContents.length; j++) {
                            charCode = commentContents.charCodeAt(j);
                            // { character means we need to find another } to match the found one
                            if (charCode == LexCodeLC) {
                                curlies++;
                                continue;
                            }

                            // } char
                            if (charCode == LexCodeRC) {
                                curlies--;
                                if (curlies == 0) {
                                    // We do not have any more } to match the type expression is ignored completely
                                    break;
                                } else {
                                    // there are more { to be matched with }
                                    continue;
                                }
                            }

                            // Found start of another tag
                            if (charCode == LexCodeAtSign) {
                                break;
                            }
                        }

                        // End of the comment
                        if (j == commentContents.length) {
                            break;
                        }

                        // End of the tag, go onto looking for next tag
                        if (charCode == LexCodeAtSign) {
                            continue;
                        }

                        j = Comment.consumeLeadingSpace(commentContents, j + 1);
                        if (j == -1) {
                            break;
                        }
                    }

                    // Parameter name
                    if (param != commentContents.substr(j, param.length) || !Comment.isSpaceChar(commentContents, j + param.length)) {
                        // this is not the parameter we are looking for
                        continue;
                    }

                    // Found the parameter we were looking for
                    j = Comment.consumeLeadingSpace(commentContents, j + param.length);
                    if (j == -1) {
                        return "";
                    }
                    
                    var endOfParam = commentContents.indexOf("@", j);
                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);

                    // Find alignement spaces to remove
                    var paramSpacesToRemove: number = undefined;
                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\n") + 1;
                    if (paramLineIndex != 0) {
                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) == "\r") {
                            paramLineIndex++;
                        }
                    }
                    var startSpaceRemovalIndex = Comment.consumeLeadingSpace(commentContents, paramLineIndex);
                    if (startSpaceRemovalIndex != j && commentContents.charAt(startSpaceRemovalIndex) == "*") {
                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;
                    }

                    // Clean jsDocComment and return
                    return Comment.cleanJSDocComment(paramHelpString, paramSpacesToRemove);
                }
            }

            return "";
        }

        static getDocCommentFirstOverloadSignature(signatureGroup: SignatureGroup) {
            for (var i = 0; i < signatureGroup.signatures.length; i++) {
                var signature = signatureGroup.signatures[i];
                if (signature == signatureGroup.definitionSignature) {
                    continue;
                }

                return TypeScript.Comment.getDocCommentText(signature.declAST.getDocComments());
            }

            return "";
        }
    }

    export class DebuggerStatement extends Statement {
        constructor () {
            super(NodeType.Debugger);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeLineToOutput("debugger;");
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export interface IAstWalker {
        walk(ast: AST, parent: AST): AST;
        options: AstWalkOptions;
        state: any; // user state object
    }

    export class AstWalkOptions {
        public goChildren = true;
        public goNextSibling = true;
        public reverseSiblings = false; // visit siblings in reverse execution order

        public stopWalk(stop:bool = true) {
            this.goChildren = !stop;
            this.goNextSibling = !stop;
        }
    }

    export interface IAstWalkCallback {
        (ast: AST, parent: AST, walker: IAstWalker): AST;
    }

    export interface IAstWalkChildren {
        (preAst: AST, parent: AST, walker: IAstWalker): void;
    }

    class AstWalker implements IAstWalker {
        constructor (
            private childrenWalkers: IAstWalkChildren[],
            private pre: IAstWalkCallback,
            private post: IAstWalkCallback,
            public options: AstWalkOptions,
            public state: any) {
        }

        public walk(ast: AST, parent: AST): AST {
            var preAst = this.pre(ast, parent, this);
            if (preAst === undefined) {
                preAst = ast;
            }
            if (this.options.goChildren) {
                var svGoSib = this.options.goNextSibling;
                this.options.goNextSibling = true;
                // Call the "walkChildren" function corresponding to "nodeType".
                this.childrenWalkers[ast.nodeType](ast, parent, this);
                this.options.goNextSibling = svGoSib;
            }
            else {
                // no go only applies to children of node issuing it
                this.options.goChildren = true;
            }
            if (this.post) {
                var postAst = this.post(preAst, parent, this);
                if (postAst === undefined) {
                    postAst = preAst;
                }
                return postAst;
            }
            else {
                return preAst;
            }
        }
    }

    export class AstWalkerFactory {
        private childrenWalkers: IAstWalkChildren[] = [];

        constructor () {
            this.initChildrenWalkers();
        }

        public walk(ast: AST, pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): AST {
            return this.getWalker(pre, post, options, state).walk(ast, null)
        }

        public getWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {
            return this.getSlowWalker(pre, post, options, state);
        }

        private getSlowWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {
            if (!options) {
                options = new AstWalkOptions();
            }

            return new AstWalker(this.childrenWalkers, pre, post, options, state);
        }

        private initChildrenWalkers(): void {
            this.childrenWalkers[NodeType.None] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Empty] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.EmptyExpr] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.True] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.False] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.This] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Super] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.QString] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Regex] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Null] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.ArrayLit] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.ObjectLit] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.Void] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.Comma] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Pos] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.Neg] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.Delete] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.Await] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.In] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Dot] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.From] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Is] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.InstOf] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Typeof] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.NumberLit] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Name] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.TypeParameter] = ChildrenWalkers.walkTypeParameterChildren;
            this.childrenWalkers[NodeType.GenericType] = ChildrenWalkers.walkGenericTypeChildren;
            this.childrenWalkers[NodeType.TypeRef] = ChildrenWalkers.walkTypeReferenceChildren;
            this.childrenWalkers[NodeType.Index] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Call] = ChildrenWalkers.walkCallExpressionChildren;
            this.childrenWalkers[NodeType.New] = ChildrenWalkers.walkCallExpressionChildren;
            this.childrenWalkers[NodeType.Asg] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgAdd] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgSub] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgDiv] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgMul] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgMod] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgAnd] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgXor] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgOr] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgLsh] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgRsh] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgRs2] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.ConditionalExpression] = ChildrenWalkers.walkTrinaryExpressionChildren;
            this.childrenWalkers[NodeType.LogOr] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.LogAnd] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Or] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Xor] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.And] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Eq] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Ne] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Eqv] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.NEqv] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Lt] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Le] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Gt] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Ge] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Add] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Sub] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Mul] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Div] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Mod] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Lsh] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Rsh] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Rs2] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Not] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.LogNot] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.IncPre] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.DecPre] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.IncPost] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.DecPost] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.TypeAssertion] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.FuncDecl] = ChildrenWalkers.walkFuncDeclChildren;
            this.childrenWalkers[NodeType.Member] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.VarDecl] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[NodeType.ArgDecl] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[NodeType.Return] = ChildrenWalkers.walkReturnStatementChildren;
            this.childrenWalkers[NodeType.Break] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Continue] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Throw] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.For] = ChildrenWalkers.walkForStatementChildren;
            this.childrenWalkers[NodeType.ForIn] = ChildrenWalkers.walkForInStatementChildren;
            this.childrenWalkers[NodeType.If] = ChildrenWalkers.walkIfStatementChildren;
            this.childrenWalkers[NodeType.While] = ChildrenWalkers.walkWhileStatementChildren;
            this.childrenWalkers[NodeType.DoWhile] = ChildrenWalkers.walkDoWhileStatementChildren;
            this.childrenWalkers[NodeType.Block] = ChildrenWalkers.walkBlockChildren;
            this.childrenWalkers[NodeType.Case] = ChildrenWalkers.walkCaseStatementChildren;
            this.childrenWalkers[NodeType.Switch] = ChildrenWalkers.walkSwitchStatementChildren;
            this.childrenWalkers[NodeType.Try] = ChildrenWalkers.walkTryChildren;
            this.childrenWalkers[NodeType.TryCatch] = ChildrenWalkers.walkTryCatchChildren;
            this.childrenWalkers[NodeType.TryFinally] = ChildrenWalkers.walkTryFinallyChildren;
            this.childrenWalkers[NodeType.Finally] = ChildrenWalkers.walkFinallyChildren;
            this.childrenWalkers[NodeType.Catch] = ChildrenWalkers.walkCatchChildren;
            this.childrenWalkers[NodeType.List] = ChildrenWalkers.walkListChildren;
            this.childrenWalkers[NodeType.Script] = ChildrenWalkers.walkScriptChildren;
            this.childrenWalkers[NodeType.ClassDeclaration] = ChildrenWalkers.walkClassDeclChildren;
            this.childrenWalkers[NodeType.InterfaceDeclaration] = ChildrenWalkers.walkTypeDeclChildren;
            this.childrenWalkers[NodeType.ModuleDeclaration] = ChildrenWalkers.walkModuleDeclChildren;
            this.childrenWalkers[NodeType.ImportDeclaration] = ChildrenWalkers.walkImportDeclChildren;
            this.childrenWalkers[NodeType.With] = ChildrenWalkers.walkWithStatementChildren;
            this.childrenWalkers[NodeType.Label] = ChildrenWalkers.walkLabelChildren;
            this.childrenWalkers[NodeType.LabeledStatement] = ChildrenWalkers.walkLabeledStatementChildren;
            this.childrenWalkers[NodeType.EBStart] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.GotoEB] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.EndCode] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Error] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Comment] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Debugger] = ChildrenWalkers.walkNone;

            // Verify the code is up to date with the enum
            for (var e in (<any>NodeType)._map) {
                if ((<any>this.childrenWalkers)[e] === undefined) {
                    throw new Error("initWalkers function is not up to date with enum content!");
                }
            }
        }
    }

    var globalAstWalkerFactory: AstWalkerFactory;

    export function getAstWalkerFactory(): AstWalkerFactory {
        if (!globalAstWalkerFactory) {
            globalAstWalkerFactory = new AstWalkerFactory();
        }
        return globalAstWalkerFactory;
    }

    module ChildrenWalkers {
        export function walkNone(preAst: ASTList, parent: AST, walker: IAstWalker): void {
            // Nothing to do
        }

        export function walkListChildren(preAst: ASTList, parent: AST, walker: IAstWalker): void {
            var len = preAst.members.length;
            if (walker.options.reverseSiblings) {
                for (var i = len - 1; i >= 0; i--) {
                    if (walker.options.goNextSibling) {
                        preAst.members[i] = walker.walk(preAst.members[i], preAst);
                    }
                }
            }
            else {
                for (var i = 0; i < len; i++) {
                    if (walker.options.goNextSibling) {
                        preAst.members[i] = walker.walk(preAst.members[i], preAst);
                    }
                }
            }
        }

        export function walkUnaryExpressionChildren(preAst: UnaryExpression, parent: AST, walker: IAstWalker): void {
            if (preAst.castTerm) {
                preAst.castTerm = walker.walk(preAst.castTerm, preAst);
            }
            if (preAst.operand) {
                preAst.operand = walker.walk(preAst.operand, preAst);
            }
        }

        export function walkBinaryExpressionChildren(preAst: BinaryExpression, parent: AST, walker: IAstWalker): void {
            if (walker.options.reverseSiblings) {
                if (preAst.operand2) {
                    preAst.operand2 = walker.walk(preAst.operand2, preAst);
                }
                if ((preAst.operand1) && (walker.options.goNextSibling)) {
                    preAst.operand1 = walker.walk(preAst.operand1, preAst);
                }
            } else {
                if (preAst.operand1) {
                    preAst.operand1 = walker.walk(preAst.operand1, preAst);
                }
                if ((preAst.operand2) && (walker.options.goNextSibling)) {
                    preAst.operand2 = walker.walk(preAst.operand2, preAst);
                }
            }
        }

        export function walkTypeParameterChildren(preAst: TypeParameter, parent: AST, walker: IAstWalker): void {
            if (preAst.name) {
                preAst.name = <Identifier>walker.walk(preAst.name, preAst);
            }

            if (preAst.constraint && (walker.options.goNextSibling)) {
                preAst.constraint = <ASTList> walker.walk(preAst.constraint, preAst);
            }
        }

        export function walkGenericTypeChildren(preAst: GenericType, parent: AST, walker: IAstWalker): void {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }

            if (preAst.typeArguments && (walker.options.goNextSibling)) {
                preAst.typeArguments = <ASTList> walker.walk(preAst.typeArguments, preAst);
            }
        }

        export function walkTypeReferenceChildren(preAst: TypeReference, parent: AST, walker: IAstWalker): void {
            if (preAst.term) {
                preAst.term = walker.walk(preAst.term, preAst);
            }
        }

        export function walkCallExpressionChildren(preAst: CallExpression, parent: AST, walker: IAstWalker): void {
            if (!walker.options.reverseSiblings) {
                preAst.target = walker.walk(preAst.target, preAst);
            }
            if (preAst.arguments && (walker.options.goNextSibling)) {
                preAst.arguments = <ASTList> walker.walk(preAst.arguments, preAst);
            }
            if ((walker.options.reverseSiblings) && (walker.options.goNextSibling)) {
                preAst.target = walker.walk(preAst.target, preAst);
            }
        }

        export function walkTrinaryExpressionChildren(preAst: ConditionalExpression, parent: AST, walker: IAstWalker): void {
            if (preAst.operand1) {
                preAst.operand1 = walker.walk(preAst.operand1, preAst);
            }
            if (preAst.operand2 && (walker.options.goNextSibling)) {
                preAst.operand2 = walker.walk(preAst.operand2, preAst);
            }
            if (preAst.operand3 && (walker.options.goNextSibling)) {
                preAst.operand3 = walker.walk(preAst.operand3, preAst);
            }
        }

        export function walkFuncDeclChildren(preAst: FuncDecl, parent: AST, walker: IAstWalker): void {
            if (preAst.name) {
                preAst.name = <Identifier>walker.walk(preAst.name, preAst);
            }
            if (preAst.typeArguments) {
                preAst.typeArguments = <ASTList>walker.walk(preAst.typeArguments, preAst);
            }
            if (preAst.arguments && (preAst.arguments.members.length > 0) && (walker.options.goNextSibling)) {
                preAst.arguments = <ASTList>walker.walk(preAst.arguments, preAst);
            }
            if (preAst.returnTypeAnnotation && (walker.options.goNextSibling)) {
                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);
            }
            if (preAst.bod && (preAst.bod.members.length > 0) && (walker.options.goNextSibling)) {
                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);
            }
        }

        export function walkBoundDeclChildren(preAst: BoundDecl, parent: AST, walker: IAstWalker): void {
            if (preAst.id) {
                preAst.id = <Identifier>walker.walk(preAst.id, preAst);
            }
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }
            if ((preAst.typeExpr) && (walker.options.goNextSibling)) {
                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);
            }
        }

        export function walkReturnStatementChildren(preAst: ReturnStatement, parent: AST, walker: IAstWalker): void {
            if (preAst.returnExpression) {
                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);
            }
        }

        export function walkForStatementChildren(preAst: ForStatement, parent: AST, walker: IAstWalker): void {
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }

            if (preAst.cond && walker.options.goNextSibling) {
                preAst.cond = walker.walk(preAst.cond, preAst);
            }

            if (preAst.incr && walker.options.goNextSibling) {
                preAst.incr = walker.walk(preAst.incr, preAst);
            }

            if (preAst.body && walker.options.goNextSibling) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkForInStatementChildren(preAst: ForInStatement, parent: AST, walker: IAstWalker): void {
            preAst.lval = walker.walk(preAst.lval, preAst);
            if (walker.options.goNextSibling) {
                preAst.obj = walker.walk(preAst.obj, preAst);
            }
            if (preAst.body && (walker.options.goNextSibling)) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkIfStatementChildren(preAst: IfStatement, parent: AST, walker: IAstWalker): void {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.thenBod && (walker.options.goNextSibling)) {
                preAst.thenBod = walker.walk(preAst.thenBod, preAst);
            }
            if (preAst.elseBod && (walker.options.goNextSibling)) {
                preAst.elseBod = walker.walk(preAst.elseBod, preAst);
            }
        }

        export function walkWhileStatementChildren(preAst: WhileStatement, parent: AST, walker: IAstWalker): void {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body && (walker.options.goNextSibling)) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkDoWhileStatementChildren(preAst: DoWhileStatement, parent: AST, walker: IAstWalker): void {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body && (walker.options.goNextSibling)) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkBlockChildren(preAst: Block, parent: AST, walker: IAstWalker): void {
            if (preAst.statements) {
                preAst.statements = <ASTList>walker.walk(preAst.statements, preAst);
            }
        }

        export function walkCaseStatementChildren(preAst: CaseStatement, parent: AST, walker: IAstWalker): void {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }

            if (preAst.body && walker.options.goNextSibling) {
                preAst.body = <ASTList>walker.walk(preAst.body, preAst);
            }
        }

        export function walkSwitchStatementChildren(preAst: SwitchStatement, parent: AST, walker: IAstWalker): void {
            if (preAst.val) {
                preAst.val = walker.walk(preAst.val, preAst);
            }

            if ((preAst.caseList) && walker.options.goNextSibling) {
                preAst.caseList = <ASTList>walker.walk(preAst.caseList, preAst);
            }
        }

        export function walkTryChildren(preAst: Try, parent: AST, walker: IAstWalker): void {
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkTryCatchChildren(preAst: TryCatch, parent: AST, walker: IAstWalker): void {
            if (preAst.tryNode) {
                preAst.tryNode = <Try>walker.walk(preAst.tryNode, preAst);
            }

            if ((preAst.catchNode) && walker.options.goNextSibling) {
                preAst.catchNode = <Catch>walker.walk(preAst.catchNode, preAst);
            }
        }

        export function walkTryFinallyChildren(preAst: TryFinally, parent: AST, walker: IAstWalker): void {
            if (preAst.tryNode) {
                preAst.tryNode = walker.walk(preAst.tryNode, preAst);
            }

            if (preAst.finallyNode && walker.options.goNextSibling) {
                preAst.finallyNode = <Finally>walker.walk(preAst.finallyNode, preAst);
            }
        }

        export function walkFinallyChildren(preAst: Finally, parent: AST, walker: IAstWalker): void {
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkCatchChildren(preAst: Catch, parent: AST, walker: IAstWalker): void {
            if (preAst.param) {
                preAst.param = <VarDecl>walker.walk(preAst.param, preAst);
            }

            if ((preAst.body) && walker.options.goNextSibling) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkRecordChildren(preAst: NamedDeclaration, parent: AST, walker: IAstWalker): void {
            preAst.name = <Identifier>walker.walk(preAst.name, preAst);
            if (walker.options.goNextSibling && preAst.members) {
                preAst.members = <ASTList>walker.walk(preAst.members, preAst);
            }

        }

        export function walkNamedTypeChildren(preAst: TypeDeclaration, parent: AST, walker: IAstWalker): void {
            walkRecordChildren(preAst, parent, walker);
        }

        export function walkClassDeclChildren(preAst: ClassDeclaration, parent: AST, walker: IAstWalker): void {
            walkNamedTypeChildren(preAst, parent, walker);

            if (walker.options.goNextSibling && preAst.typeParameters) {
                preAst.typeParameters = <ASTList>walker.walk(preAst.typeParameters, preAst);
            }

            if (walker.options.goNextSibling && preAst.extendsList) {
                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);
            }

            if (walker.options.goNextSibling && preAst.implementsList) {
                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);
            }
        }

        export function walkScriptChildren(preAst: Script, parent: AST, walker: IAstWalker): void {
            if (preAst.bod) {
                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);
            }
        }

        export function walkTypeDeclChildren(preAst: InterfaceDeclaration, parent: AST, walker: IAstWalker): void {
            walkNamedTypeChildren(preAst, parent, walker);

            if (walker.options.goNextSibling && preAst.typeParameters) {
                preAst.typeParameters = <ASTList>walker.walk(preAst.typeParameters, preAst);
            }

            // walked arguments as part of members
            if (walker.options.goNextSibling && preAst.extendsList) {
                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);
            }

            if (walker.options.goNextSibling && preAst.implementsList) {
                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);
            }
        }

        export function walkModuleDeclChildren(preAst: ModuleDeclaration, parent: AST, walker: IAstWalker): void {
            walkRecordChildren(preAst, parent, walker);
        }

        export function walkImportDeclChildren(preAst: ImportDeclaration, parent: AST, walker: IAstWalker): void {
            if (preAst.id) {
                preAst.id = <Identifier>walker.walk(preAst.id, preAst);
            }
            if (preAst.alias) {
                preAst.alias = walker.walk(preAst.alias, preAst);
            }
        }

        export function walkWithStatementChildren(preAst: WithStatement, parent: AST, walker: IAstWalker): void {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }

            if (preAst.body && walker.options.goNextSibling) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkLabelChildren(preAst: Label, parent: AST, walker: IAstWalker): void {
            //TODO: Walk "id"?
        }

        export function walkLabeledStatementChildren(preAst: LabeledStatement, parent: AST, walker: IAstWalker): void {
            preAst.labels = <ASTList>walker.walk(preAst.labels, preAst);
            if (walker.options.goNextSibling) {
                preAst.stmt = walker.walk(preAst.stmt, preAst);
            }
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript.AstWalkerWithDetailCallback {
    export interface AstWalkerDetailCallback {
        EmptyCallback? (pre, ast: AST): bool;
        EmptyExprCallback? (pre, ast: AST): bool;
        TrueCallback? (pre, ast: AST): bool;
        FalseCallback? (pre, ast: AST): bool;
        ThisCallback? (pre, ast: AST): bool;
        SuperCallback? (pre, ast: AST): bool;
        QStringCallback? (pre, ast: AST): bool;
        RegexCallback? (pre, ast: AST): bool;
        NullCallback? (pre, ast: AST): bool;
        ArrayLitCallback? (pre, ast: AST): bool;
        ObjectLitCallback? (pre, ast: AST): bool;
        VoidCallback? (pre, ast: AST): bool;
        CommaCallback? (pre, ast: AST): bool;
        PosCallback? (pre, ast: AST): bool;
        NegCallback? (pre, ast: AST): bool;
        DeleteCallback? (pre, ast: AST): bool;
        AwaitCallback? (pre, ast: AST): bool;
        InCallback? (pre, ast: AST): bool;
        DotCallback? (pre, ast: AST): bool;
        FromCallback? (pre, ast: AST): bool;
        IsCallback? (pre, ast: AST): bool;
        InstOfCallback? (pre, ast: AST): bool;
        TypeofCallback? (pre, ast: AST): bool;
        NumberLitCallback? (pre, ast: AST): bool;
        NameCallback? (pre, identifierAst: Identifier): bool;
        TypeRefCallback? (pre, ast: AST): bool;
        IndexCallback? (pre, ast: AST): bool;
        CallCallback? (pre, ast: AST): bool;
        NewCallback? (pre, ast: AST): bool;
        AsgCallback? (pre, ast: AST): bool;
        AsgAddCallback? (pre, ast: AST): bool;
        AsgSubCallback? (pre, ast: AST): bool;
        AsgDivCallback? (pre, ast: AST): bool;
        AsgMulCallback? (pre, ast: AST): bool;
        AsgModCallback? (pre, ast: AST): bool;
        AsgAndCallback? (pre, ast: AST): bool;
        AsgXorCallback? (pre, ast: AST): bool;
        AsgOrCallback? (pre, ast: AST): bool;
        AsgLshCallback? (pre, ast: AST): bool;
        AsgRshCallback? (pre, ast: AST): bool;
        AsgRs2Callback? (pre, ast: AST): bool;
        QMarkCallback? (pre, ast: AST): bool;
        LogOrCallback? (pre, ast: AST): bool;
        LogAndCallback? (pre, ast: AST): bool;
        OrCallback? (pre, ast: AST): bool;
        XorCallback? (pre, ast: AST): bool;
        AndCallback? (pre, ast: AST): bool;
        EqCallback? (pre, ast: AST): bool;
        NeCallback? (pre, ast: AST): bool;
        EqvCallback? (pre, ast: AST): bool;
        NEqvCallback? (pre, ast: AST): bool;
        LtCallback? (pre, ast: AST): bool;
        LeCallback? (pre, ast: AST): bool;
        GtCallback? (pre, ast: AST): bool;
        GeCallback? (pre, ast: AST): bool;
        AddCallback? (pre, ast: AST): bool;
        SubCallback? (pre, ast: AST): bool;
        MulCallback? (pre, ast: AST): bool;
        DivCallback? (pre, ast: AST): bool;
        ModCallback? (pre, ast: AST): bool;
        LshCallback? (pre, ast: AST): bool;
        RshCallback? (pre, ast: AST): bool;
        Rs2Callback? (pre, ast: AST): bool;
        NotCallback? (pre, ast: AST): bool;
        LogNotCallback? (pre, ast: AST): bool;
        IncPreCallback? (pre, ast: AST): bool;
        DecPreCallback? (pre, ast: AST): bool;
        IncPostCallback? (pre, ast: AST): bool;
        DecPostCallback? (pre, ast: AST): bool;
        TypeAssertionCallback? (pre, ast: AST): bool;
        FuncDeclCallback? (pre, funcDecl: FuncDecl): bool;
        MemberCallback? (pre, ast: AST): bool;
        VarDeclCallback? (pre, varDecl: VarDecl): bool;
        ArgDeclCallback? (pre, ast: AST): bool;
        ReturnCallback? (pre, ast: AST): bool;
        BreakCallback? (pre, ast: AST): bool;
        ContinueCallback? (pre, ast: AST): bool;
        ThrowCallback? (pre, ast: AST): bool;
        ForCallback? (pre, ast: AST): bool;
        ForInCallback? (pre, ast: AST): bool;
        IfCallback? (pre, ast: AST): bool;
        WhileCallback? (pre, ast: AST): bool;
        DoWhileCallback? (pre, ast: AST): bool;
        BlockCallback? (pre, block: Block): bool;
        CaseCallback? (pre, ast: AST): bool;
        SwitchCallback? (pre, ast: AST): bool;
        TryCallback? (pre, ast: AST): bool;
        TryCatchCallback? (pre, ast: AST): bool;
        TryFinallyCallback? (pre, ast: AST): bool;
        FinallyCallback? (pre, ast: AST): bool;
        CatchCallback? (pre, ast: AST): bool;
        ListCallback? (pre, astList: ASTList): bool;
        ScriptCallback? (pre, script: Script): bool;
        ClassDeclarationCallback? (pre, ast: AST): bool;
        InterfaceDeclarationCallback? (pre, interfaceDecl: InterfaceDeclaration): bool;
        ModuleDeclarationCallback? (pre, moduleDecl: ModuleDeclaration): bool;
        ImportDeclarationCallback? (pre, ast: AST): bool;
        WithCallback? (pre, ast: AST): bool;
        LabelCallback? (pre, labelAST: AST): bool;
        LabeledStatementCallback? (pre, ast: AST): bool;
        EBStartCallback? (pre, ast: AST): bool;
        GotoEBCallback? (pre, ast: AST): bool;
        EndCodeCallback? (pre, ast: AST): bool;
        ErrorCallback? (pre, ast: AST): bool;
        CommentCallback? (pre, ast: AST): bool;
        DebuggerCallback? (pre, ast: AST): bool;
        DefaultCallback? (pre, ast: AST): bool;
    }

    export function walk(script: Script, callback: AstWalkerDetailCallback): void {
        var pre = (cur: AST, parent: AST) => {
            walker.options.goChildren = AstWalkerCallback(true, cur, callback);
            return cur;
        }

        var post = (cur: AST, parent: AST) => {
            AstWalkerCallback(false, cur, callback);
            return cur;
        }

        var walker = TypeScript.getAstWalkerFactory().getWalker(pre, post);
        walker.walk(script, null);
    }

    function AstWalkerCallback(pre: bool, ast: AST, callback: AstWalkerDetailCallback): bool {
        // See if the Callback needs to be handled using specific one or default one
        var nodeType = ast.nodeType;
        var callbackString = (<any>NodeType)._map[nodeType] + "Callback";
        if (callback[callbackString]) {
            return callback[callbackString](pre, ast);
        }

        if (callback.DefaultCallback) {
            return callback.DefaultCallback(pre, ast);
        }

        return true;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export function lastOf(items: any[]): any {
        return (items === null || items.length === 0) ? null : items[items.length - 1];
    }

    export function max(a: number, b: number): number {
        return a >= b ? a : b;
    }

    export function min(a: number, b: number): number {
        return a <= b ? a : b;
    }

    //
    // Helper class representing a path from a root ast node to a (grand)child ast node.
    // This is helpful as our tree don't have parents.
    //
    export class AstPath {
        public asts: TypeScript.AST[] = [];
        public top: number = -1;

        static reverseIndexOf(items: any[], index: number): any {
            return (items === null || items.length <= index) ? null : items[items.length - index - 1];
        }

        public clone(): AstPath {
            var clone = new AstPath();
            clone.asts = this.asts.map((value) => { return value; });
            clone.top = this.top;
            return clone;
        }

        public pop(): TypeScript.AST {
            var head = this.ast();
            this.up();

            while (this.asts.length > this.count()) {
                this.asts.pop();
            }
            return head;
        }

        public push(ast: TypeScript.AST) {
            while (this.asts.length > this.count()) {
                this.asts.pop();
            }
            this.top = this.asts.length;
            this.asts.push(ast);
        }

        public up() {
            if (this.top <= -1)
                throw new Error("Invalid call to 'up'");
            this.top--;
        }

        public down() {
            if (this.top == this.ast.length - 1)
                throw new Error("Invalid call to 'down'");
            this.top++;
        }

        public nodeType(): TypeScript.NodeType {
            if (this.ast() == null)
                return TypeScript.NodeType.None;
            return this.ast().nodeType;
        }

        public ast() {
            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));
        }

        public parent() {
            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);
        }

        public count() {
            return this.top + 1;
        }

        public get(index: number): TypeScript.AST {
            return this.asts[index];
        }

        public isNameOfClass(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.ClassDeclaration) &&
                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());
        }

        public isNameOfInterface(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.InterfaceDeclaration) &&
                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());
        }

        public isNameOfArgument(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.ArgDecl) &&
                ((<TypeScript.ArgDecl>this.parent()).id === this.ast());
        }

        public isNameOfVariable(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.VarDecl) &&
                ((<TypeScript.VarDecl>this.parent()).id === this.ast());
        }

        public isNameOfModule(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.ModuleDeclaration) &&
                ((<TypeScript.ModuleDeclaration>this.parent()).name === this.ast());
        }

        public isNameOfFunction(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.FuncDecl) &&
                ((<TypeScript.FuncDecl>this.parent()).name === this.ast());
        }

        public isChildOfScript(): bool {
            var ast = lastOf(this.asts);
            return this.count() >= 3 &&
                this.asts[this.top] === ast &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Script;
        }

        public isChildOfModule(): bool {
            var ast = lastOf(this.asts);
            return this.count() >= 3 &&
                this.asts[this.top] === ast &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ModuleDeclaration;
        }

        public isChildOfClass(): bool {
            var ast = lastOf(this.asts);
            return this.count() >= 3 &&
                this.asts[this.top] === ast &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ClassDeclaration;
        }

        public isArgumentOfClassConstructor(): bool {
            var ast = lastOf(this.asts);
            return this.count() >= 5 &&
                this.asts[this.top] === ast &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&
                this.asts[this.top - 3].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 4].nodeType === TypeScript.NodeType.ClassDeclaration &&
                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).isConstructor) &&
                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1]) &&
                ((<TypeScript.ClassDeclaration>this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2]);
        }

        public isChildOfInterface(): bool {
            var ast = lastOf(this.asts);
            return this.count() >= 3 &&
                this.asts[this.top] === ast &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.InterfaceDeclaration;
        }

        public isTopLevelImplicitModule() {
            return this.count() >= 1 &&
                this.asts[this.top].nodeType === TypeScript.NodeType.ModuleDeclaration &&
                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top]).modFlags, TypeScript.ModuleFlags.IsWholeFile);
        }

        public isBodyOfTopLevelImplicitModule() {
            return this.count() >= 2 &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&
                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0] &&
                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).modFlags, TypeScript.ModuleFlags.IsWholeFile);
        }

        public isBodyOfScript(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Script &&
                 (<TypeScript.Script>this.asts[this.top - 1]).bod == this.asts[this.top - 0];
        }

        public isBodyOfSwitch(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Switch &&
                 (<TypeScript.SwitchStatement>this.asts[this.top - 1]).caseList == this.asts[this.top - 0];
        }

        public isBodyOfModule(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&
                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];
        }

        public isBodyOfClass(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ClassDeclaration &&
                 (<TypeScript.ClassDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];
        }

        public isBodyOfFunction(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&
                 (<TypeScript.FuncDecl>this.asts[this.top - 1]).bod == this.asts[this.top - 0];
        }

        public isBodyOfInterface(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.InterfaceDeclaration &&
                 (<TypeScript.InterfaceDeclaration>this.asts[this.top - 1]).members == this.asts[this.top - 0];
        }

        public isBodyOfBlock(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Block &&
                (<TypeScript.Block>this.asts[this.top - 1]).statements == this.asts[this.top - 0];
        }

        public isBodyOfFor(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.For &&
                (<TypeScript.ForStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
        }

        public isBodyOfCase(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Case &&
                (<TypeScript.CaseStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
        }

        public isBodyOfTry(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Try &&
                (<TypeScript.Try>this.asts[this.top - 1]).body == this.asts[this.top - 0];
        }

        public isBodyOfCatch(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Catch &&
                (<TypeScript.Catch>this.asts[this.top - 1]).body == this.asts[this.top - 0];
        }

        public isBodyOfDoWhile(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.DoWhile &&
                (<TypeScript.DoWhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
        }

        public isBodyOfWhile(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.While &&
                (<TypeScript.WhileStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
        }

        public isBodyOfForIn(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ForIn &&
                (<TypeScript.ForInStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
        }

        public isBodyOfWith(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.With &&
                (<TypeScript.WithStatement>this.asts[this.top - 1]).body == this.asts[this.top - 0];
        }

        public isBodyOfFinally(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Finally &&
                (<TypeScript.Finally>this.asts[this.top - 1]).body == this.asts[this.top - 0];
        }

        public isCaseOfSwitch(): bool {
            return this.count() >= 3 &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1];
        }

        public isDefaultCaseOfSwitch(): bool {
            return this.count() >= 3 &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList == this.asts[this.top - 1] &&
                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).defaultCase == this.asts[this.top - 0];
        }

        public isListOfObjectLit(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];
        }

        public isBodyOfObjectLit(): bool {
            return this.isListOfObjectLit();
        }

        public isEmptyListOfObjectLit(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0] &&
                (<TypeScript.ASTList>this.asts[this.top - 0]).members.length == 0;
        }

        public isMemberOfObjectLit(): bool {
            return this.count() >= 3 &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ObjectLit &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Member &&
                (<TypeScript.UnaryExpression>this.asts[this.top - 2]).operand == this.asts[this.top - 1];
        }

        public isNameOfMemberOfObjectLit(): bool {
            return this.count() >= 4 &&
                this.asts[this.top - 3].nodeType === TypeScript.NodeType.ObjectLit &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Name &&
                (<TypeScript.UnaryExpression>this.asts[this.top - 3]).operand == this.asts[this.top - 2];
        }

        public isListOfArrayLit(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ArrayLit &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand == this.asts[this.top - 0];
        }

        public isTargetOfMember(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&
                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand1 === this.asts[this.top - 0];
        }

        public isMemberOfMember(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&
                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];
        }

        public isItemOfList(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List;
            //(<Tools.ASTList>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];
        }

        public isThenOfIf(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&
                (<TypeScript.IfStatement>this.asts[this.top - 1]).thenBod == this.asts[this.top - 0];
        }

        public isElseOfIf(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&
                (<TypeScript.IfStatement>this.asts[this.top - 1]).elseBod == this.asts[this.top - 0];
        }

        public isBodyOfDefaultCase(): bool {
            return this.isBodyOfCase();
        }

        public isSingleStatementList(): bool {
            return this.count() >= 1 &&
                this.asts[this.top].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.ASTList>this.asts[this.top]).members.length === 1;
        }

        public isArgumentListOfFunction(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&
                (<TypeScript.FuncDecl>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        }

        public isArgumentOfFunction(): bool {
            return this.count() >= 3 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&
                (<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1];
        }

        public isArgumentListOfCall(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Call &&
                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        }

        public isArgumentListOfNew(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.New &&
                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        }

        public isSynthesizedBlock(): bool {
            return this.count() >= 1 &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Block &&
                (<TypeScript.Block>this.asts[this.top - 0]).isStatementBlock === false;
        }
    }

    export function isValidAstNode(ast: TypeScript.ASTSpan): bool {
        if (ast === null)
            return false;

        if (ast.minChar === -1 || ast.limChar === -1)
            return false;

        return true;
    }

    export class AstPathContext {
        public path = new TypeScript.AstPath();
    }

    export enum GetAstPathOptions {
        Default = 0,
        EdgeInclusive = 1,
        //We need this options dealing with an AST coming from an incomplete AST. For example:
        //     class foo { // r
        // If we ask for the AST at the position after the "r" character, we won't see we are 
        // inside a comment, because the "class" AST node has a limChar corresponding to the position of 
        // the "{" character, meaning we don't traverse the tree down to the stmt list of the class, meaning
        // we don't find the "precomment" attached to the errorneous empty stmt.
        //TODO: It would be nice to be able to get rid of this.
        DontPruneSearchBasedOnPosition = 1 << 1,
    }

    ///
    /// Return the stack of AST nodes containing "position"
    ///
    export function getAstPathToPosition(script: TypeScript.AST, pos: number, options = GetAstPathOptions.Default): TypeScript.AstPath {
        var lookInComments = (comments: TypeScript.Comment[]) => {
            if (comments && comments.length > 0) {
                for (var i = 0; i < comments.length; i++) {
                    var minChar = comments[i].minChar;
                    var limChar = comments[i].limChar;
                    if (!comments[i].isBlockComment) {
                        limChar++; // For single line comments, include 1 more character (for the newline)
                    }
                    if (pos >= minChar && pos < limChar) {
                        ctx.path.push(comments[i]);
                    }
                }
            }
        }

        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: IAstWalker) {
            if (isValidAstNode(cur)) {

                // Add "cur" to the stack if it contains our position
                // For "identifier" nodes, we need a special case: A position equal to "limChar" is
                // valid, since the position corresponds to a caret position (in between characters)
                // For example:
                //  bar
                //  0123
                // If "position == 3", the caret is at the "right" of the "r" character, which should be considered valid
                var inclusive =
                    hasFlag(options, GetAstPathOptions.EdgeInclusive) ||
                    cur.nodeType === TypeScript.NodeType.Name ||
                    pos === script.limChar; // Special "EOF" case

                var minChar = cur.minChar;
                var limChar = cur.limChar + (inclusive ? 1 : 0)
                if (pos >= minChar && pos < limChar) {

                    // TODO: Since AST is sometimes not correct wrt to position, only add "cur" if it's better
                    //       than top of the stack.
                    var previous = ctx.path.ast();
                    if (previous == null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {
                        ctx.path.push(cur);
                    }
                    else {
                        //logger.log("TODO: Ignoring node because minChar, limChar not better than previous node in stack");
                    }
                }

                // The AST walker skips comments, but we might be in one, so check the pre/post comments for this node manually
                if (pos < limChar) {
                    lookInComments(cur.preComments);
                }
                if (pos >= minChar) {
                    lookInComments(cur.postComments);
                }

                if (!hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {
                    // Don't go further down the tree if pos is outside of [minChar, limChar]
                    walker.options.goChildren = (minChar <= pos && pos <= limChar);
                }
            }
            return cur;
        }

        var ctx = new AstPathContext();
        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);
        return ctx.path;
    }

    //
    // Find a source text offset that is safe for lexing tokens at the given position.
    // This is used when "position" might be inside a comment or string, etc.
    //
    export function getTokenizationOffset(script: TypeScript.Script, position: number): number {
        var bestOffset = 0;
        var pre = (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker): TypeScript.AST => {
            if (TypeScript.isValidAstNode(cur)) {
                // Did we find a closer offset?
                if (cur.minChar <= position) {
                    bestOffset = max(bestOffset, cur.minChar);
                }

                // Stop the walk if this node is not related to "minChar"
                if (cur.minChar > position || cur.limChar < bestOffset) {
                    walker.options.goChildren = false;
                }
            }

            return cur;
        }

        TypeScript.getAstWalkerFactory().walk(script, pre);
        return bestOffset;
    }

    ///
    /// Simple function to Walk an AST using a simple callback function.
    ///
    export function walkAST(ast: TypeScript.AST, callback: (path: AstPath, walker: TypeScript.IAstWalker) => void ): void {
        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {
            var path: TypeScript.AstPath = walker.state;
            path.push(cur);
            callback(path, walker);
            return cur;
        }
        var post = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {
            var path: TypeScript.AstPath = walker.state;
            path.pop();
            return cur;
        }

        var path = new AstPath();
        TypeScript.getAstWalkerFactory().walk(ast, pre, post, null, path);
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

module TypeScript {
    export class AstLogger {

        constructor (public logger: ILogger) { }

        public logScript(script: TypeScript.Script): void {
            this.logLinemap(script.locationInfo.lineMap);

            var stack: AST[]= [];

            var pre = (cur: TypeScript.AST, parent: TypeScript.AST) => {
                stack.push(cur);
                var indent = (stack.length - 1) * 2;
                this.logComments(script, cur.preComments, indent);
                this.logNode(script, cur, indent);
                this.logComments(script, cur.postComments, indent);
                return cur;
            }

            var post = (cur: TypeScript.AST, parent: TypeScript.AST) => {
                stack.pop();
                return cur;
            }

            TypeScript.getAstWalkerFactory().walk(script, pre, post);
        }


        public logNode(script: TypeScript.Script, cur: TypeScript.AST, indent: number) {
            var msg = this.addPadding("", indent, "| ", true);

            msg = msg.concat("+ " + cur.treeViewLabel());
            msg = this.addPadding(msg, 70, " ", false);

            msg = msg + this.addLineColumn(script, cur.minChar);
            msg = this.addPadding(msg, 80, " ", false);

            msg = msg + "=> ";
            msg = msg + this.addLineColumn(script, cur.limChar);
            msg = this.addPadding(msg, 102, " ", false);

            msg = msg.concat("[" + this.addPadding(cur.minChar.toString(), 1, " ", true) + ", " + this.addPadding(cur.limChar.toString(), 1, " ", true) + "]");

            msg = this.addPadding(msg, 115, " ", false);
            msg = msg.concat("sym=" + (<any>cur).sym);

            msg = this.addPadding(msg, 135, " ", false);
            msg = msg.concat("type=" + (cur.type === null ? "null" : cur.type.getTypeName()));
            this.logger.log(msg);
        }

        private logComments(script: TypeScript.Script, comments: TypeScript.AST[], indent: number) {
            if (comments == null)
                return;

            for (var i = 0; i < comments.length; i++) {
                this.logNode(script, comments[i], indent);
            }
        }

        public logLinemap(linemap: number[]) {
            var result = "[";
            for (var i = 0; i < linemap.length; i++) {
                if (i > 0)
                    result += ",";
                result += linemap[i];
            }
            result += "]";
            this.logger.log("linemap: " + result);
        }

        private addPadding(s: string, targetLength: number, paddingString: string, leftPadding: bool): string {
            var result = (leftPadding ? "" : s);
            for (var i = s.length; i < targetLength; i++) {
                result = result + paddingString;
            }
            result = result + (leftPadding ? s : "");
            return result;
        }

        private addLineColumn(script: TypeScript.Script, position: number): string {
            // just for calling getSourceLineColFromMap
            var lineInfo = {
                line: -1,
                col: -1
            }
            TypeScript.getSourceLineColFromMap(lineInfo, position, script.locationInfo.lineMap);

            if (lineInfo.col !== -1) {
                lineInfo.col++; //TODO: function above seems to consider line as 1-based, and column as 0-based
            }

            return "(" + lineInfo.line + ", " + lineInfo.col + ")";
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class Binder {
        constructor(public checker: TypeChecker) { }
        
        public resolveBaseTypeLinks(typeLinks: TypeLink[], scope: SymbolScope) {
            var extendsList: Type[] = null;
            if (typeLinks) {
                extendsList = new Type[];
                for (var i = 0, len = typeLinks.length; i < len; i++) {
                    extendsList[i] = this.checker.resolveBaseTypeLink(typeLinks[i], scope);
                }
            }
            return extendsList;
        }

        public resolveBases(scope: SymbolScope, type: Type) {
            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope);

            var i = 0, len = type.extendsList.length;
            var derivedIsClass = type.isClassInstance();
            for (; i < len; i++) {
                var baseIsClass = type.extendsList[i].isClassInstance();
                if (type.extendsList[i] != this.checker.anyType) {
                    var baseRef = type.extendsTypeLinks[i].ast;
                    if (derivedIsClass) {
                        if (!baseIsClass) {
                            this.checker.errorReporter.simpleError(baseRef,
                                                                     "A class may only extend other classes, " + type.extendsList[i].symbol.fullName() + " is not a class.");
                        }
                    }
                    else {
                        if (baseIsClass) {
                            this.checker.errorReporter.simpleError(baseRef,
                                                                     "An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() + " is a class.");
                        }
                    }
                }
            }

            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope);

            if (type.implementsList) {
                for (i = 0, len = type.implementsList.length; i < len; i++) {
                    var iface = type.implementsList[i];
                    var baseRef = type.implementsTypeLinks[i].ast;
                    if (iface.isClassInstance()) {
                        if (derivedIsClass) {
                            this.checker.errorReporter.simpleError(baseRef,
                                                                     "A class may only implement an interface; " + iface.symbol.fullName() + " is a class.");
                        }
                    }
                }
            }
        }

        public resolveSignatureGroup(signatureGroup: SignatureGroup, scope: SymbolScope, instanceType: Type) {
            var supplyVar = !(signatureGroup.hasImplementation);
            for (var i = 0, len = signatureGroup.signatures.length; i < len; i++) {
                var signature = signatureGroup.signatures[i];
                if (instanceType) {
                    signature.returnType.type = instanceType;
                }
                else {
                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar);
                }
                var paramLen = signature.parameters.length;
                for (var j = 0; j < paramLen; j++) {
                    this.bindSymbol(scope, signature.parameters[j]);
                }
                if (signature.hasVariableArgList) {
                    // check that last parameter has an array type
                    var lastParam = <ParameterSymbol>signature.parameters[paramLen - 1];
                    lastParam.argsOffset = paramLen - 1;
                    if (!lastParam.getType().isArray()) {
                        this.checker.errorReporter.simpleErrorFromSym(lastParam,
                                                                 "... parameter must have array type");
                        lastParam.parameter.typeLink.type = this.checker.makeArrayType(lastParam.parameter.typeLink.type);
                    }
                }
            }
        }

        public bindType(scope: SymbolScope, type: Type, instanceType: Type): void {
            if (instanceType) {
                this.bindType(scope, instanceType, null);
            }
            if (type.hasMembers()) {
                var members = type.members;
                var ambientMembers = type.ambientMembers;
                var typeMembers = type.getAllEnclosedTypes(); // REVIEW: Should only be getting exported types?
                var ambientTypeMembers = type.getAllAmbientEnclosedTypes(); // REVIEW: Should only be getting exported types?
                var memberScope = new SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol);
                var agg = new SymbolAggregateScope(type.symbol);
                var prevCurrentModDecl = this.checker.currentModDecl;
                var prevBindStatus = this.checker.inBind;
                agg.addParentScope(memberScope);
                agg.addParentScope(scope);
                if (type.isModuleType()) {
                    this.checker.currentModDecl = <ModuleDeclaration>type.symbol.declAST;
                    this.checker.inBind = true;
                }
                if (members) {
                    this.bind(agg, type.members.allMembers); // REVIEW: Should only be getting exported types?
                }
                if (typeMembers) {
                    this.bind(agg, typeMembers.allMembers);
                }
                if (ambientMembers) {
                    this.bind(agg, ambientMembers.allMembers);
                }
                if (ambientTypeMembers) {
                    this.bind(agg, ambientTypeMembers.allMembers);
                }
                this.checker.currentModDecl = prevCurrentModDecl;
                this.checker.inBind = prevBindStatus;
            }
            if (type.extendsTypeLinks) {
                this.resolveBases(scope, type);
            }
            if (type.construct) {
                this.resolveSignatureGroup(type.construct, scope, instanceType);
            }
            if (type.call) {
                this.resolveSignatureGroup(type.call, scope, null);
            }
            if (type.index) {
                this.resolveSignatureGroup(type.index, scope, null);
            }
            if (type.elementType) {
                this.bindType(scope, type.elementType, null);
            }
        }

        public bindSymbol(scope: SymbolScope, symbol: Symbol) {
            if (!symbol.bound) {
                var prevLocationInfo = this.checker.locationInfo;
                if ((this.checker.units) && (symbol.unitIndex >= 0) && (symbol.unitIndex < this.checker.units.length)) {
                    this.checker.locationInfo = this.checker.units[symbol.unitIndex];
                }
                switch (symbol.kind()) {
                    case SymbolKind.Type:

                        if (symbol.flags & SymbolFlags.Bound) {
                            break;
                        }

                        var typeSymbol = <TypeSymbol>symbol;
                        typeSymbol.flags |= SymbolFlags.Bound;

                        // Since type collection happens out of order, a dynamic module referenced by an import statement
                        // may not yet be in scope when the import symbol is created.  In that case, we need to search
                        // out the module symbol now
                        // Note that we'll also want to do this in resolveTypeMembers, in case the symbol is set outside the
                        // context of a given module  (E.g., an outer import statement)
                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {
                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;
                            var modSym = this.checker.findSymbolForDynamicModule(modPath, this.checker.locationInfo.filename, (id) => scope.find(id, false, true));
                            if (modSym) {
                                typeSymbol.type = modSym.getType();
                            }
                        }

                        if (typeSymbol.type && typeSymbol.type != this.checker.gloModType) {
                            this.bindType(scope, typeSymbol.type, typeSymbol.instanceType);

                            // bind expansions on the parent type symbol
                            if (typeSymbol.type.isModuleType()) {
                                for (var i = 0; i < typeSymbol.expansions.length; i++) {
                                    this.bindType(scope, typeSymbol.expansions[i], typeSymbol.instanceType);
                                }
                            }
                        }
                        break;
                    case SymbolKind.Field:
                        this.checker.resolveTypeLink(scope, (<FieldSymbol>symbol).field.typeLink,
                                                false);
                        break;
                    case SymbolKind.Parameter:
                        this.checker.resolveTypeLink(scope,
                                                (<ParameterSymbol>symbol).parameter.typeLink,
                                                true);
                        break;
                }
                this.checker.locationInfo = prevLocationInfo;
            }
            symbol.bound = true;
        }

        public bind(scope: SymbolScope, table: IHashTable) {
            table.map(
                (key, sym, binder) => {
                    binder.bindSymbol(scope, sym);
                },
                this);
        }
    }

}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

module TypeScript {
    class Base64Format {
        static encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        static encode(inValue: number) {
            if (inValue < 64) {
                return encodedValues.charAt(inValue);
            }
            throw TypeError(inValue + ": not a 64 based value");
        }

        static decodeChar(inChar: string) {
            if (inChar.length === 1) {
                return encodedValues.indexOf(inChar);
            } else {
                throw TypeError('"' + inChar + '" must have length 1');
            }
        }
    }

    export class Base64VLQFormat {
        static encode(inValue: number) {
            // Add a new least significant bit that has the sign of the value.
            // if negative number the least significant bit that gets added to the number has value 1
            // else least significant bit value that gets added is 0
            // eg. -1 changes to binary : 01 [1] => 3
            //     +1 changes to binary : 01 [0] => 2
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            }
            else {
                inValue = inValue << 1;
            }

            // Encode 5 bits at a time starting from least significant bits
            var encodedStr = "";
            do {
                var currentDigit = inValue & 31; // 11111
                inValue = inValue >> 5;
                if (inValue > 0) {
                    // There are still more digits to decode, set the msb (6th bit)
                    currentDigit = currentDigit | 32; 
                }
                encodedStr = encodedStr + Base64Format.encode(currentDigit);
            } while (inValue > 0);

            return encodedStr;
        }

        static decode(inString: string) {
            var result = 0;
            var negative = false;

            var shift = 0;
            for (var i = 0; i < inString.length; i++) {
                var byte = Base64Format.decodeChar(inString[i]);
                if (i === 0) {
                    // Sign bit appears in the LSBit of the first value
                    if ((byte & 1) === 1) {
                        negative = true;
                    }
                    result = (byte >> 1) & 15; // 1111x
                } else {
                    result = result | ((byte & 31) << shift); // 11111
                }

                shift += (i == 0) ? 4 : 5;

                if ((byte & 32) === 32) {
                    // Continue
                } else {
                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };
                }
            }

            throw new Error('Base64 value "' + inString + '" finished with a continuation bit');
        }
    }
}
﻿/* -----------------------------------------------------------------------------
This file is based on or incorporates material from the projects listed below 
(collectively, "Third Party Code"). Microsoft is not the original author of the 
Third Party Code. The original copyright notice and the license, under which 
Microsoft received such Third Party Code, are set forth below. Such licenses 
and notices are provided for informational purposes only. Microsoft, not the 
third party, licenses the Third Party Code to you under the terms of the 
Apache License, Version 2.0. See License.txt in the project root for complete 
license information. Microsoft reserves all rights not expressly granted under 
the Apache 2.0 License, whether by implication, estoppel or otherwise. 
----------------------------------------------------------------------------- */

/*
    json2.js
    2011-10-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON2: any = { };


(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = <any>function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        var strProto: any = String.prototype;
        var numProto: any = Number.prototype;
        numProto.JSON = strProto.JSON = 
            (<any>Boolean).prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = <any>0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a: string) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder): string {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k = null,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value,[]) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON2.stringify !== 'function') {
        JSON2.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON2.parse !== 'function') {
        JSON2.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key): {} {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k = null, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = <any>0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />
///<reference path='..\harness\external\json2.ts' />

module TypeScript {
    export class SourceMapPosition {
        public sourceLine: number;
        public sourceColumn: number;
        public emittedLine: number;
        public emittedColumn: number;
    }

    export class SourceMapping {
        public start = new SourceMapPosition();
        public end = new SourceMapPosition();
        public nameIndex: number = -1;
        public childMappings: SourceMapping[] = [];
    }

    export class SourceMapper {
        static MapFileExtension = ".map";
        
        public sourceMappings: SourceMapping[] = [];
        public currentMappings: SourceMapping[][] = [];

        public names: string[] = [];
        public currentNameIndex: number[] = [];

        public jsFileName: string;
        public tsFileName: string;

        constructor(tsFileName: string, jsFileName: string, public jsFile: ITextWriter, public sourceMapOut: ITextWriter,
            public errorReporter: ErrorReporter, emitFullPathOfSourceMap: bool) {
            this.currentMappings.push(this.sourceMappings);

            jsFileName = switchToForwardSlashes(jsFileName);
            this.jsFileName = TypeScript.getPrettyName(jsFileName, false, true);
            
            var removalIndex = jsFileName.lastIndexOf(this.jsFileName);
            var fixedPath = jsFileName.substring(0, removalIndex);

            if (emitFullPathOfSourceMap) {
                if (jsFileName.indexOf("://") == -1) {
                    jsFileName = "file:///" + jsFileName;
                }
                this.jsFileName = jsFileName;
            }

            this.tsFileName = TypeScript.getRelativePathToFixedPath(fixedPath, tsFileName);
        }
        
        // Generate source mapping
        static EmitSourceMapping(allSourceMappers: SourceMapper[]) {
            // At this point we know that there is at least one source mapper present.
            // If there are multiple source mappers, all will correspond to same map file but different sources

            // Output map file name into the js file
            var sourceMapper = allSourceMappers[0];
            sourceMapper.jsFile.WriteLine("//@ sourceMappingURL=" + sourceMapper.jsFileName + SourceMapper.MapFileExtension);

            // Now output map file
            var sourceMapOut = sourceMapper.sourceMapOut;
            var mappingsString = "";
            var tsFiles: string[] = [];

            var prevEmittedColumn = 0;
            var prevEmittedLine = 0;
            var prevSourceColumn = 0;
            var prevSourceLine = 0;
            var prevSourceIndex = 0;
            var prevNameIndex = 0;
            var namesList: string[] = [];
            var namesCount = 0;
            var emitComma = false;

            var recordedPosition: SourceMapPosition = null;
            for (var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {
                sourceMapper = allSourceMappers[sourceMapperIndex];

                // If there are any mappings generated
                var currentSourceIndex = tsFiles.length;
                tsFiles.push(sourceMapper.tsFileName);

                // Join namelist
                if (sourceMapper.names.length > 0) {
                    namesList.push.apply(namesList, sourceMapper.names);
                }

                var recordSourceMapping = (mappedPosition: SourceMapPosition, nameIndex: number) => {
                    if (recordedPosition != null &&
                        recordedPosition.emittedColumn == mappedPosition.emittedColumn &&
                        recordedPosition.emittedLine == mappedPosition.emittedLine) {
                        // This position is already recorded
                        return;
                    }

                    // Record this position
                    if (prevEmittedLine !== mappedPosition.emittedLine) {
                        while (prevEmittedLine < mappedPosition.emittedLine) {
                            prevEmittedColumn = 0;
                            mappingsString = mappingsString + ";";
                            prevEmittedLine++;
                        }
                        emitComma = false;
                    }
                    else if (emitComma) {
                        mappingsString = mappingsString + ",";
                    }

                    // 1. Relative Column
                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);
                    prevEmittedColumn = mappedPosition.emittedColumn;

                    // 2. Relative sourceIndex 
                    mappingsString = mappingsString + Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);
                    prevSourceIndex = currentSourceIndex;

                    // 3. Relative sourceLine 0 based
                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);
                    prevSourceLine = mappedPosition.sourceLine - 1;

                    // 4. Relative sourceColumn 0 based 
                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);
                    prevSourceColumn = mappedPosition.sourceColumn;

                    // 5. Relative namePosition 0 based
                    if (nameIndex >= 0) {
                        mappingsString = mappingsString + Base64VLQFormat.encode(namesCount + nameIndex - prevNameIndex);
                        prevNameIndex = namesCount + nameIndex;
                    }

                    emitComma = true;
                    recordedPosition = mappedPosition;
                }

                // Record starting spans
                var recordSourceMappingSiblings = (sourceMappings: SourceMapping[]) => {
                    for (var i = 0; i < sourceMappings.length; i++) {
                        var sourceMapping = sourceMappings[i];
                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);
                        recordSourceMappingSiblings(sourceMapping.childMappings);
                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);
                    }
                }

                recordSourceMappingSiblings(sourceMapper.sourceMappings, -1);
                namesCount = namesCount + sourceMapper.names.length;
            }

            // Write the actual map file
            sourceMapOut.Write(JSON2.stringify({
                version: 3,
                file: sourceMapper.jsFileName,
                sources: tsFiles,
                names: namesList,
                mappings: mappingsString
            }));

            // Done, close the file
            try {
                // Closing files could result in exceptions, report them if they occur
                sourceMapOut.Close();
            } catch (ex) {
                sourceMapper.errorReporter.emitterError(null, ex.message);
            }
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export enum EmitContainer {
        Prog,
        Module,
        DynamicModule,
        Class,
        Constructor,
        Function,
        Args,
        Interface,
    }

    export class EmitState {
        public column: number;
        public line: number;
        public pretty: bool;
        public inObjectLiteral: bool;
        public container: EmitContainer;

        constructor () {
            this.column = 0;
            this.line = 0;
            this.pretty = false;
            this.inObjectLiteral = false;
            this.container = EmitContainer.Prog;
        }
    }

    export class EmitOptions {
        public minWhitespace: bool;
        public propagateConstants: bool;
        public emitComments: bool;
        public emitFullSourceMapPath: bool;
        public outputOption: string;
        public ioHost: EmitterIOHost = null;
        public outputMany: bool = true;
        public commonDirectoryPath = "";

        constructor(settings: CompilationSettings) {
            this.minWhitespace = settings.minWhitespace;
            this.propagateConstants = settings.propagateConstants;
            this.emitComments = settings.emitComments;
            this.outputOption = settings.outputOption;
            this.emitFullSourceMapPath = settings.emitFullSourceMapPath;
        }

        public mapOutputFileName(fileName: string, extensionChanger: (fname: string, wholeFileNameReplaced: bool) => string) {
            if (this.outputMany) {
                var updatedFileName = fileName;
                if (this.outputOption != "") {
                    // Replace the common directory path with the option specified
                    updatedFileName = fileName.replace(this.commonDirectoryPath, "");
                    updatedFileName = this.outputOption + updatedFileName;
                }
                return extensionChanger(updatedFileName, false);
            } else {
                return extensionChanger(this.outputOption, true);
            }
        }
    }

    export class Indenter {
        static indentStep : number = 4;
        static indentStepString : string = "    ";
        static indentStrings: string[] = [];
        public indentAmt: number = 0;

        public increaseIndent() {
            this.indentAmt += Indenter.indentStep;
        }

        public decreaseIndent() {
            this.indentAmt -= Indenter.indentStep;
        }

        public getIndent() {
            var indentString = Indenter.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {
                    indentString += Indenter.indentStepString;
                }
                Indenter.indentStrings[this.indentAmt] = indentString;
            }
            return indentString;
        }
    }

    export class Emitter {
        public prologueEmitted = false;
        public thisClassNode: TypeDeclaration = null;
        public thisFnc: FuncDecl = null;
        public moduleDeclList: ModuleDeclaration[] = [];
        public moduleName = "";
        public emitState = new EmitState();
        public indenter = new Indenter();
        public ambientModule = false;
        public modAliasId: string = null;
        public firstModAlias: string = null;
        public allSourceMappers: SourceMapper[] = [];
        public sourceMapper: SourceMapper = null;
        public captureThisStmtString = "var _this = this;";
        public varListCountStack: number[] = [0]; 

        constructor(public checker: TypeChecker, public emittingFileName: string, public outfile: ITextWriter, public emitOptions: EmitOptions, public errorReporter: ErrorReporter) {
        }

        public setSourceMappings(mapper: SourceMapper) {
            this.allSourceMappers.push(mapper);
            this.sourceMapper = mapper;
        }

        public writeToOutput(s: string) {
            this.outfile.Write(s);
            // TODO: check s for newline
            this.emitState.column += s.length;
        }

        public writeToOutputTrimmable(s: string) {
            if (this.emitOptions.minWhitespace) {
                s = s.replace(/[\s]*/g, '');
            }
            this.writeToOutput(s);
        }

        public writeLineToOutput(s: string) {
            if (this.emitOptions.minWhitespace) {
                this.writeToOutput(s);
                var c = s.charCodeAt(s.length - 1);
                if (!((c == LexCodeSpace) || (c == LexCodeSMC) || (c == LexCodeLBR))) {
                    this.writeToOutput(' ');
                }
            }
            else {
                this.outfile.WriteLine(s);
                this.emitState.column = 0
                this.emitState.line++;
            }
        }

        public writeCaptureThisStatement(ast: AST) {
            this.emitIndent();
            this.recordSourceMappingStart(ast);
            this.writeToOutput(this.captureThisStmtString);
            this.recordSourceMappingEnd(ast);
            this.writeLineToOutput("");
        }

        public setInVarBlock(count: number) {
            this.varListCountStack[this.varListCountStack.length - 1] = count;
        }

        public setInObjectLiteral(val: bool): bool {
            var temp = this.emitState.inObjectLiteral;
            this.emitState.inObjectLiteral = val;
            return temp;
        }

        public setContainer(c: number): number {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        }

        private getIndentString() {
            if (this.emitOptions.minWhitespace) {
                return "";
            }
            else {
                return this.indenter.getIndent();
            }
        }

        public emitIndent() {
            this.writeToOutput(this.getIndentString());
        }

        public emitCommentInPlace(comment: Comment) {
            var text = comment.getText();
            var hadNewLine = false;

            if (comment.isBlockComment) {
                if (this.emitState.column == 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);

                if (text.length > 1 || comment.endsLine) {
                    for (var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingEnd(comment);
                    this.writeLineToOutput("");
                    hadNewLine = true;
                } else {
                    this.recordSourceMappingEnd(comment);
                }
            }
            else {
                if (this.emitState.column == 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingEnd(comment);
                this.writeLineToOutput("");
                hadNewLine = true;
            }

            if (hadNewLine) {
                this.emitIndent();
            }
            else {
                this.writeToOutput(" ");
            }
        }

        public emitParensAndCommentsInPlace(ast: AST, pre: bool) {
            var comments = pre ? ast.preComments : ast.postComments;

            // comments should be printed before the LParen, but after the RParen
            if (ast.isParenthesized && !pre) {
                this.writeToOutput(")");
            }
            if (this.emitOptions.emitComments && comments && comments.length != 0) {
                for (var i = 0; i < comments.length; i++) {
                    this.emitCommentInPlace(comments[i]);
                }
            }
            if (ast.isParenthesized && pre) {
                this.writeToOutput("(");
            }
        }

        // TODO: emit accessor pattern
        public emitObjectLiteral(content: ASTList) {
            this.writeLineToOutput("{");
            this.indenter.increaseIndent();
            var inObjectLiteral = this.setInObjectLiteral(true);
            this.emitJavascriptList(content, ",", TokenID.Comma, true, false, false);
            this.setInObjectLiteral(inObjectLiteral);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutput("}");
        }

        public emitArrayLiteral(content: ASTList) {
            this.writeToOutput("[");
            if (content) {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascriptList(content, ", ", TokenID.Comma, true, false, false);
                this.indenter.decreaseIndent();
                this.emitIndent();
            }
            this.writeToOutput("]");
        }

        public emitNew(target: AST, args: ASTList) {
            this.writeToOutput("new ");
            if (target.nodeType == NodeType.TypeRef) {
                var typeRef = <TypeReference>target;
                if (typeRef.arrayCount) {
                    this.writeToOutput("Array()");
                }
                else {
                    this.emitJavascript(typeRef.term, TokenID.Tilde, false);
                    this.writeToOutput("()");
                }
            }
            else {
                this.emitJavascript(target, TokenID.Tilde, false);
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(args);
            }
        }

        private getConstantValue(init: AST): number {
            if (init) {
                if (init.nodeType === NodeType.NumberLit) {
                    var numLit = <NumberLiteral>init;
                    return numLit.value;
                }
                else if (init.nodeType === NodeType.Lsh) {
                    var binop = <BinaryExpression>init;
                    if (binop.operand1.nodeType === NodeType.NumberLit &&
                        binop.operand2.nodeType === NodeType.NumberLit) {
                        return (<NumberLiteral>binop.operand1).value << (<NumberLiteral>binop.operand2).value;
                    }
                }
                else if (init.nodeType === NodeType.Name) {
                    var ident = <Identifier>init;
                    if (ident.sym !== null && ident.sym.declAST.nodeType === NodeType.VarDecl) {
                        var varDecl = <VarDecl>ident.sym.declAST;
                        return this.getConstantValue(varDecl.init);
                    }
                }
            }

            return null;
        }

        public tryEmitConstant(dotExpr: BinaryExpression) {
            if (!this.emitOptions.propagateConstants) {
                return false;
            }
            var propertyName = <Identifier>dotExpr.operand2;
            if (propertyName && propertyName.sym && propertyName.sym.isVariable()) {
                if (hasFlag(propertyName.sym.flags, SymbolFlags.Constant)) {
                    if (propertyName.sym.declAST) {
                        var boundDecl = <BoundDecl>propertyName.sym.declAST;
                        var value = this.getConstantValue(boundDecl.init);
                        if (value !== null) {
                            this.writeToOutput(value.toString());
                            var comment = " /* ";
                            comment += propertyName.actualText;
                            comment += " */ ";
                            this.writeToOutput(comment);
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        public emitCall(callNode: CallExpression, target: AST, args: ASTList) {
            if (!this.emitSuperCall(callNode)) {
                if (!hasFlag(callNode.flags, ASTFlags.ClassBaseConstructorCall)) {
                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {
                        this.writeToOutput("(");
                    }
                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {
                        this.writeToOutput("_super.call");
                    }
                    else {
                        this.emitJavascript(target, TokenID.OpenParen, false);
                    }
                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {
                        this.writeToOutput(")");
                    }
                    this.recordSourceMappingStart(args);
                    this.writeToOutput("(");
                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {
                        this.writeToOutput("this");
                        if (args && args.members.length) {
                            this.writeToOutput(", ");
                        }
                    }
                    this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);
                    this.writeToOutput(")");
                    this.recordSourceMappingEnd(args);
                }
                else {
                    this.indenter.decreaseIndent();
                    this.indenter.decreaseIndent();
                    var constructorCall = new ASTList();
                    constructorCall.members[0] = callNode;
                    this.emitConstructorCalls(constructorCall, this.thisClassNode);
                    this.indenter.increaseIndent();
                    this.indenter.increaseIndent();
                }
            }
        }

        public emitConstructorCalls(bases: ASTList, classDecl: TypeDeclaration) {
            if (bases == null) {
                return;
            }
            var basesLen = bases.members.length;
            this.recordSourceMappingStart(classDecl);
            for (var i = 0; i < basesLen; i++) {
                var baseExpr = bases.members[i];
                var baseSymbol: Symbol = null;
                if (baseExpr.nodeType == NodeType.Call) {
                    baseSymbol = (<CallExpression>baseExpr).target.type.symbol;
                }
                else {
                    baseSymbol = baseExpr.type.symbol;
                }
                var baseName = baseSymbol.name;
                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {
                    baseName = baseSymbol.fullName();
                }
                if (baseExpr.nodeType == NodeType.Call) {
                    this.emitIndent();
                    this.writeToOutput("_super.call(this");
                    var args = (<CallExpression>baseExpr).arguments;
                    if (args && (args.members.length > 0)) {
                        this.writeToOutput(", ");
                        this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);
                    }
                    this.writeToOutput(")");
                }
                else {
                    if (baseExpr.type && (baseExpr.type.isClassInstance())) {
                        // parameterless constructor call;
                        this.emitIndent();
                        this.writeToOutput(classDecl.name.actualText + "._super.constructor");
                        //emitJavascript(baseExpr,TokenID.LParen,false);
                        this.writeToOutput(".call(this)");
                    }
                }
            }
            this.recordSourceMappingEnd(classDecl);
        }

        public emitInnerFunction(funcDecl: FuncDecl, printName: bool, isMember: bool,
            bases: ASTList, hasSelfRef: bool, classDecl: TypeDeclaration) {
            /// REVIEW: The code below causes functions to get pushed to a newline in cases where they shouldn't
            /// such as: 
            ///     Foo.prototype.bar = 
            ///         function() {
            ///         };
            /// Once we start emitting comments, we should pull this code out to place on the outer context where the function
            /// is used.
            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {
            //    this.writeLineToOutput("");
            //    this.increaseIndent();
            //    emitIndent();
            //}

            var isClassConstructor = funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod);
            var hasNonObjectBaseType = isClassConstructor && hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseType) && !hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);
            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);

            // We have no way of knowing if the current function is used as an expression or a statement, so as to enusre that the emitted
            // JavaScript is always valid, add an extra parentheses for unparenthesized function expressions
            var shouldParenthesize = hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) && !funcDecl.isParenthesized && !funcDecl.isAccessor() && (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon));

            this.emitParensAndCommentsInPlace(funcDecl, true);
            if (shouldParenthesize) {
                this.writeToOutput("(");
            }
            this.recordSourceMappingStart(funcDecl);
            if (!(funcDecl.isAccessor() && (<FieldSymbol>funcDecl.accessorSymbol).isObjectLitField)) {
                this.writeToOutput("function ");
            }
            if (printName) {
                var id = funcDecl.getNameText();
                if (id && !funcDecl.isAccessor()) {
                    if (funcDecl.name) {
                        this.recordSourceMappingStart(funcDecl.name);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.name) {
                        this.recordSourceMappingEnd(funcDecl.name);
                    }
                }
            }

            this.writeToOutput("(");
            var argsLen = 0;
            var i = 0;
            var arg: ArgDecl;
            var defaultArgs: ArgDecl[] = [];
            if (funcDecl.arguments) {
                var tempContainer = this.setContainer(EmitContainer.Args);
                argsLen = funcDecl.arguments.members.length;
                var printLen = argsLen;
                if (funcDecl.variableArgList) {
                    printLen--;
                }
                for (i = 0; i < printLen; i++) {
                    arg = <ArgDecl>funcDecl.arguments.members[i];
                    if (arg.init) {
                        defaultArgs.push(arg);
                    }
                    this.emitJavascript(arg, TokenID.OpenParen, false);
                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                    }
                }
                this.setContainer(tempContainer);
            }
            this.writeLineToOutput(") {");

            if (funcDecl.isConstructor) {
                this.recordSourceMappingNameStart("constructor");
            } else if (funcDecl.isGetAccessor()) {
                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());
            } else if (funcDecl.isSetAccessor()) {
                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());
            } else {
                this.recordSourceMappingNameStart(funcDecl.getNameText());
            }
            this.indenter.increaseIndent();

            // set default args first
            for (i = 0; i < defaultArgs.length; i++) {
                var arg = defaultArgs[i];
                this.emitIndent();
                this.recordSourceMappingStart(arg);
                this.writeToOutput("if (typeof " + arg.id.actualText + " === \"undefined\") { ");//
                this.recordSourceMappingStart(arg.id);
                this.writeToOutput(arg.id.actualText);
                this.recordSourceMappingEnd(arg.id);
                this.writeToOutput(" = ");
                this.emitJavascript(arg.init, TokenID.OpenParen, false);
                this.writeLineToOutput("; }")
                this.recordSourceMappingEnd(arg);
            }

            if (funcDecl.isConstructor && ((<ClassDeclaration>funcDecl.classDecl).varFlags & VarFlags.MustCaptureThis)) {
                this.writeCaptureThisStatement(funcDecl);
            }

            if (funcDecl.isConstructor && !classPropertiesMustComeAfterSuperCall) {
                if (funcDecl.arguments) {
                    argsLen = funcDecl.arguments.members.length;
                    for (i = 0; i < argsLen; i++) {
                        arg = <ArgDecl>funcDecl.arguments.members[i];
                        if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {
                            this.emitIndent();
                            this.recordSourceMappingStart(arg);
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput("this." + arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeToOutput(" = ");
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput(arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeLineToOutput(";");
                            this.recordSourceMappingEnd(arg);
                        }
                    }
                }

                // For classes, the constructor needs to be explicitly called
                if (!hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
                    this.emitConstructorCalls(bases, classDecl);
                }
            }
            if (hasSelfRef) {
                this.writeCaptureThisStatement(funcDecl);
            }
            if (funcDecl.variableArgList) {
                argsLen = funcDecl.arguments.members.length;
                var lastArg = <ArgDecl>funcDecl.arguments.members[argsLen - 1];
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.recordSourceMappingStart(lastArg.id);
                this.writeToOutput(lastArg.id.actualText);
                this.recordSourceMappingEnd(lastArg.id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (")
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var _i = 0;");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput(" ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i < (arguments.length - " + (argsLen - 1) + ")");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput("; ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i++");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();

                this.recordSourceMappingStart(lastArg);
                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (argsLen - 1) + "];");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }

            // if it's a class, emit the uninitializedMembers, first emit the non-proto class body members
            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod) && !classPropertiesMustComeAfterSuperCall) {

                var nProps = (<ASTList>this.thisClassNode.members).members.length;

                for (var i = 0; i < nProps; i++) {
                    if ((<ASTList>this.thisClassNode.members).members[i].nodeType == NodeType.VarDecl) {
                        var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[i];
                        if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {
                            this.emitIndent();
                            this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);
                            this.writeLineToOutput("");
                        }
                    }
                }
                //this.writeLineToOutput("");
            }

            this.emitBareJavascriptStatements(funcDecl.bod, classPropertiesMustComeAfterSuperCall);

            this.indenter.decreaseIndent();
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl.endingToken);
            this.writeToOutput("}");

            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl.endingToken);
            this.recordSourceMappingEnd(funcDecl);

            if (shouldParenthesize) {
                this.writeToOutput(")");
            }

            // The extra call is to make sure the caller's funcDecl end is recorded, since caller wont be able to record it
            this.recordSourceMappingEnd(funcDecl);

            this.emitParensAndCommentsInPlace(funcDecl, false);

            if (!isMember &&
                //funcDecl.name != null &&
                !hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) &&
                (!hasFlag(funcDecl.fncFlags, FncFlags.Signature) || funcDecl.isConstructor)) {
                this.writeLineToOutput("");
            } else if (hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {
                if (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon)) {
                    // If either of these two flags are set, then the function expression is a statement. Terminate it.
                    this.writeLineToOutput(";");
                }
            }
            /// TODO: See the other part of this at the beginning of function
            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {
            //    this.decreaseIndent();
            //}           
        }

        public emitJavascriptModule(moduleDecl: ModuleDeclaration) {
            var modName = moduleDecl.name.actualText;
            if (isTSFile(modName)) {
                moduleDecl.name.setText(modName.substring(0, modName.length - 3));
            }
            else if (isSTRFile(modName)) {
                moduleDecl.name.setText(modName.substring(0, modName.length - 4));
            }

            if (!hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient)) {
                var isDynamicMod = hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic);
                var prevOutFile = this.outfile;
                var prevOutFileName = this.emittingFileName;
                var prevAllSourceMappers = this.allSourceMappers;
                var prevSourceMapper = this.sourceMapper;
                var prevColumn = this.emitState.column;
                var prevLine = this.emitState.line;
                var temp = this.setContainer(EmitContainer.Module);
                var svModuleName = this.moduleName;
                var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);
                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;
                var isWholeFile = hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile);
                this.moduleName = moduleDecl.name.actualText;

                // prologue
                if (isDynamicMod) {
                    // create the new outfile for this module
                    var tsModFileName = stripQuotes(moduleDecl.name.actualText);
                    var modFilePath = trimModName(tsModFileName) + ".js";
                    modFilePath = this.emitOptions.mapOutputFileName(modFilePath, TypeScriptCompiler.mapToJSFileName);

                    if (this.emitOptions.ioHost) {
                        // Ensure that the slashes are normalized so that the comparison is fair
                        // REVIEW: Note that modFilePath is normalized to forward slashes in Parser.parse, so the 
                        // first call to switchToForwardSlashes is technically a no-op, but it will prevent us from
                        // regressing if the parser changes
                        if (switchToForwardSlashes(modFilePath) != switchToForwardSlashes(this.emittingFileName)) {
                            this.emittingFileName = modFilePath;
                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);
                            this.outfile = this.createFile(this.emittingFileName, useUTF8InOutputfile);
                            if (prevSourceMapper != null) {
                                this.allSourceMappers = [];
                                var sourceMappingFile = this.createFile(this.emittingFileName + SourceMapper.MapFileExtension, false);
                                this.setSourceMappings(new TypeScript.SourceMapper(tsModFileName, this.emittingFileName, this.outfile, sourceMappingFile, this.errorReporter, this.emitOptions.emitFullSourceMapPath));
                                this.emitState.column = 0;
                                this.emitState.line = 0;
                            }
                        } else {
                            CompilerDiagnostics.assert(this.emitOptions.outputMany, "Cannot have dynamic modules compiling into single file");
                        }
                    }

                    this.setContainer(EmitContainer.DynamicModule); // discard the previous 'Module' container

                    this.recordSourceMappingStart(moduleDecl);
                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD
                        var dependencyList = "[\"require\", \"exports\"";
                        var importList = "require, exports";
                        var importStatement: ImportDeclaration = null;

                        // all dependencies are quoted
                        for (var i = 0; i < (<ModuleType>moduleDecl.mod).importedModules.length; i++) {
                            importStatement = (<ModuleType>moduleDecl.mod).importedModules[i]

                            // if the imported module is only used in a type position, do not add it as a requirement
                            if (importStatement.id.sym &&
                                !(<TypeSymbol>importStatement.id.sym).onlyReferencedAsTypeRef) {
                                if (i <= (<ModuleType>moduleDecl.mod).importedModules.length - 1) {
                                    dependencyList += ", ";
                                    importList += ", ";
                                }

                                importList += "__" + importStatement.id.actualText + "__";
                                dependencyList += importStatement.firstAliasedModToString();
                            }
                        }

                        // emit any potential amd dependencies
                        for (var i = 0; i < moduleDecl.amdDependencies.length; i++) {
                            dependencyList += ", \"" + moduleDecl.amdDependencies[i] + "\"";
                        }

                        dependencyList += "]";

                        this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                    }
                    else { // Node

                    }
                }
                else {

                    if (!isExported) {
                        this.recordSourceMappingStart(moduleDecl);
                        this.writeToOutput("var ");
                        this.recordSourceMappingStart(moduleDecl.name);
                        this.writeToOutput(this.moduleName);
                        this.recordSourceMappingEnd(moduleDecl.name);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(moduleDecl);
                        this.emitIndent();
                    }

                    this.writeToOutput("(");
                    this.recordSourceMappingStart(moduleDecl);
                    this.writeToOutput("function (");
                    this.recordSourceMappingStart(moduleDecl.name);
                    this.writeToOutput(this.moduleName);
                    this.recordSourceMappingEnd(moduleDecl.name);
                    this.writeLineToOutput(") {");
                }

                if (!isWholeFile) {
                    this.recordSourceMappingNameStart(this.moduleName);
                }

                // body - don't indent for Node
                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {
                    this.indenter.increaseIndent();
                }

                if (moduleDecl.modFlags & ModuleFlags.MustCaptureThis) {
                    this.writeCaptureThisStatement(moduleDecl);
                }

                this.emitJavascriptList(moduleDecl.members, null, TokenID.Semicolon, true, false, false);
                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {
                    this.indenter.decreaseIndent();
                }
                this.emitIndent();

                // epilogue
                if (isDynamicMod) {
                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD
                        this.writeLineToOutput("})");
                    }
                    else { // Node
                    }
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl);

                    // close the module outfile, and restore the old one
                    if (this.outfile != prevOutFile) {
                        this.Close();
                        if (prevSourceMapper != null) {
                            this.allSourceMappers = prevAllSourceMappers;
                            this.sourceMapper = prevSourceMapper;
                            this.emitState.column = prevColumn;
                            this.emitState.line = prevLine;
                        }
                        this.outfile = prevOutFile;
                        this.emittingFileName = prevOutFileName;
                    }
                }
                else {
                    var containingMod: ModuleDeclaration = null;
                    if (moduleDecl.type && moduleDecl.type.symbol.container && moduleDecl.type.symbol.container.declAST) {
                        containingMod = <ModuleDeclaration>moduleDecl.type.symbol.container.declAST;
                    }
                    var parentIsDynamic = containingMod && hasFlag(containingMod.modFlags, ModuleFlags.IsDynamic);

                    this.recordSourceMappingStart(moduleDecl.endingToken);
                    if (temp == EmitContainer.Prog && isExported) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
                    }
                    else if (isExported || temp == EmitContainer.Prog) {
                        var dotMod = svModuleName != "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
                    }
                    else if (!isExported && temp != EmitContainer.Prog) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
                    }
                    else {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")();");
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                    this.writeLineToOutput("");
                    if (temp != EmitContainer.Prog && isExported) {
                        this.emitIndent();
                        this.recordSourceMappingStart(moduleDecl);
                        if (parentIsDynamic) {
                            this.writeLineToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                        } else {
                            this.writeLineToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                        }
                        this.recordSourceMappingEnd(moduleDecl);
                    }
                }

                this.setContainer(temp);
                this.moduleName = svModuleName;
                this.moduleDeclList.length--;
            }
        }

        public emitIndex(operand1: AST, operand2: AST) {
            var temp = this.setInObjectLiteral(false);
            this.emitJavascript(operand1, TokenID.Tilde, false);
            this.writeToOutput("[");
            this.emitJavascriptList(operand2, ", ", TokenID.Comma, false, false, false);
            this.writeToOutput("]");
            this.setInObjectLiteral(temp);
        }

        public emitStringLiteral(text: string) {
            // should preserve escape etc.
            // TODO: simplify object literal simple name
            this.writeToOutput(text);
        }

        public emitJavascriptFunction(funcDecl: FuncDecl) {
            if (hasFlag(funcDecl.fncFlags, FncFlags.Signature) || funcDecl.isOverload) {
                return;
            }
            var temp: number;
            var tempFnc = this.thisFnc;
            this.thisFnc = funcDecl;

            if (funcDecl.isConstructor) {
                temp = this.setContainer(EmitContainer.Constructor);
            }
            else {
                temp = this.setContainer(EmitContainer.Function);
            }

            var bases: ASTList = null;
            var hasSelfRef = false;
            var funcName = funcDecl.getNameText();

            if ((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) &&
                ((temp != EmitContainer.Constructor) ||
                ((funcDecl.fncFlags & FncFlags.Method) == FncFlags.None))) {
                var tempLit = this.setInObjectLiteral(false);
                if (this.thisClassNode) {
                    bases = this.thisClassNode.extendsList;
                }
                hasSelfRef = Emitter.shouldCaptureThis(funcDecl);
                this.recordSourceMappingStart(funcDecl);
                if (hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) && funcDecl.type.symbol.container == this.checker.gloMod && !funcDecl.isConstructor) {
                    this.writeToOutput("this." + funcName + " = ");
                    this.emitInnerFunction(funcDecl, false, false, bases, hasSelfRef, this.thisClassNode);
                }
                else {
                    this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()), false, bases, hasSelfRef, this.thisClassNode);
                }
                this.setInObjectLiteral(tempLit);
            }
            this.setContainer(temp);
            this.thisFnc = tempFnc;

            if (!hasFlag(funcDecl.fncFlags, FncFlags.Signature)) {
                if (hasFlag(funcDecl.fncFlags, FncFlags.Static)) {
                    if (this.thisClassNode) {
                        if (funcDecl.isAccessor()) {
                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);
                        }
                        else {
                            this.emitIndent();
                            this.recordSourceMappingStart(funcDecl);
                            this.writeLineToOutput(this.thisClassNode.name.actualText + "." + funcName +
                                          " = " + funcName + ";");
                            this.recordSourceMappingEnd(funcDecl);
                        }
                    }
                }
                else if ((this.emitState.container == EmitContainer.Module || this.emitState.container == EmitContainer.DynamicModule) && hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported)) {
                    this.emitIndent();
                    var modName = this.emitState.container == EmitContainer.Module ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeLineToOutput(modName + "." + funcName +
                                      " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        }

        public emitAmbientVarDecl(varDecl: VarDecl) {
            if (varDecl.init) {
                this.emitParensAndCommentsInPlace(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                this.writeToOutput(" = ");
                this.emitJavascript(varDecl.init, TokenID.Comma, false);
                this.recordSourceMappingEnd(varDecl);
                this.writeToOutput(";");
                this.emitParensAndCommentsInPlace(varDecl, false);
            }
        }

        public varListCount(): number {
            return this.varListCountStack[this.varListCountStack.length - 1];
        }

        // Emits "var " if it is allowed
        public emitVarDeclVar() {
            // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var
            // If it is var list of form  var a = varList count will be 0
            if (this.varListCount() >= 0) {
                this.writeToOutput("var ");
                this.setInVarBlock(-this.varListCount());
            }
            return true;
        }

        public onEmitVar() {
            if (this.varListCount() > 0) {
                this.setInVarBlock(this.varListCount() - 1);
            }
            else if (this.varListCount() < 0) {
                this.setInVarBlock(this.varListCount() + 1);
            }
        }

        public emitJavascriptVarDecl(varDecl: VarDecl, tokenId: TokenID) {
            if ((varDecl.varFlags & VarFlags.Ambient) == VarFlags.Ambient) {
                this.emitAmbientVarDecl(varDecl);
                this.onEmitVar();
            }
            else {
                var sym = varDecl.sym;
                var hasInitializer = (varDecl.init != null);
                this.emitParensAndCommentsInPlace(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                if (sym && sym.isMember() && sym.container &&
                    (sym.container.kind() == SymbolKind.Type)) {
                    var type = (<TypeSymbol>sym.container).type;
                    if (type.isClass() && (!hasFlag(sym.flags, SymbolFlags.ModuleMember))) {
                        // class
                        if (this.emitState.container != EmitContainer.Args) {
                            if (hasFlag(sym.flags, SymbolFlags.Static)) {
                                this.writeToOutput(sym.container.name + ".");
                            }
                            else {
                                this.writeToOutput("this.");
                            }
                        }
                    }
                    else if (type.hasImplementation()) {
                        // module
                        if (!hasFlag(sym.flags, SymbolFlags.Exported) && (sym.container == this.checker.gloMod || !hasFlag(sym.flags, SymbolFlags.Property))) {
                            this.emitVarDeclVar();
                        }
                        else if (hasFlag(varDecl.varFlags, VarFlags.LocalStatic)) {
                            this.writeToOutput(".");
                        }
                        else {
                            if (this.emitState.container == EmitContainer.DynamicModule) {
                                this.writeToOutput("exports.");
                            }
                            else {
                                this.writeToOutput(this.moduleName + ".");
                            }
                        }
                    }
                    else {
                        // function, constructor, method etc.
                        if (tokenId != TokenID.OpenParen) {
                            if (hasFlag(sym.flags, SymbolFlags.Exported) && sym.container == this.checker.gloMod) {
                                this.writeToOutput("this.");
                            }
                            else {
                                this.emitVarDeclVar();
                            }
                        }
                    }
                }
                else {
                    if (tokenId != TokenID.OpenParen) {
                        this.emitVarDeclVar();
                    }
                }
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                if (hasInitializer) {
                    this.writeToOutputTrimmable(" = ");

                    // Ensure we have a fresh var list count when recursing into the variable 
                    // initializer.  We don't want our current list of variables to affect how we
                    // emit nested variable lists.
                    this.varListCountStack.push(0);
                    this.emitJavascript(varDecl.init, TokenID.Comma, false);
                    this.varListCountStack.pop();
                }
                this.onEmitVar();
                if ((tokenId != TokenID.OpenParen)) {
                    if (this.varListCount() < 0) {
                        this.writeToOutput(", ");
                    } else if (tokenId != TokenID.For) {
                        this.writeToOutputTrimmable(";");
                    }
                }
                this.recordSourceMappingEnd(varDecl);
                this.emitParensAndCommentsInPlace(varDecl, false);
            }
        }

        public declEnclosed(moduleDecl: ModuleDeclaration): bool {
            if (moduleDecl == null) {
                return true;
            }
            for (var i = 0, len = this.moduleDeclList.length; i < len; i++) {
                if (this.moduleDeclList[i] == moduleDecl) {
                    return true;
                }
            }
            return false;
        }

        public emitJavascriptName(name: Identifier, addThis: bool) {
            var sym = name.sym;
            this.emitParensAndCommentsInPlace(name, true);
            this.recordSourceMappingStart(name);
            if (!name.isMissing()) {
                if (addThis && (this.emitState.container != EmitContainer.Args) && sym) {
                    // TODO: flag global module with marker other than string name
                    if (sym.container && (sym.container.name != globalId)) {
                        if (hasFlag(sym.flags, SymbolFlags.Static) && (hasFlag(sym.flags, SymbolFlags.Property))) {
                            if (sym.declModule && hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {
                                this.writeToOutput("exports.");
                            }
                            else {
                                this.writeToOutput(sym.container.name + ".");
                            }
                        }
                        else if (sym.kind() == SymbolKind.Field) {
                            var fieldSym = <FieldSymbol>sym;
                            if (hasFlag(fieldSym.flags, SymbolFlags.ModuleMember)) {
                                if ((sym.container != this.checker.gloMod) && ((hasFlag(sym.flags, SymbolFlags.Property)) || hasFlag(sym.flags, SymbolFlags.Exported))) {
                                    if (hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {
                                        this.writeToOutput("exports.");
                                    }
                                    else {
                                        this.writeToOutput(sym.container.name + ".");
                                    }
                                }
                            }
                            else {
                                if (sym.isInstanceProperty()) {
                                    this.emitThis();
                                    this.writeToOutput(".");
                                }
                            }
                        }
                        else if (sym.kind() == SymbolKind.Type) {
                            if (sym.isInstanceProperty()) {
                                var typeSym = <TypeSymbol>sym;
                                var type = typeSym.type;
                                if (type.call && !hasFlag(sym.flags, SymbolFlags.ModuleMember)) {
                                    this.emitThis();
                                    this.writeToOutput(".");
                                }
                            }
                            else if ((sym.unitIndex != this.checker.locationInfo.unitIndex) || (!this.declEnclosed(sym.declModule))) {
                                this.writeToOutput(sym.container.name + ".")
                            }
                        }
                    }
                    else if (sym.container == this.checker.gloMod &&
                                hasFlag(sym.flags, SymbolFlags.Exported) &&
                                !hasFlag(sym.flags, SymbolFlags.Ambient) &&
                                // check that it's a not a member of an ambient module...
                                !((sym.isType() || sym.isMember()) &&
                                    sym.declModule &&
                                    hasFlag(sym.declModule.modFlags, ModuleFlags.Ambient)) &&
                                this.emitState.container == EmitContainer.Prog &&
                                sym.declAST.nodeType != NodeType.FuncDecl) {
                        this.writeToOutput("this.");
                    }
                }

                // If it's a dynamic module, we need to print the "require" invocation
                if (sym &&
                    sym.declAST &&
                    sym.declAST.nodeType == NodeType.ModuleDeclaration &&
                    (hasFlag((<ModuleDeclaration>sym.declAST).modFlags, ModuleFlags.IsDynamic))) {
                    var moduleDecl: ModuleDeclaration = <ModuleDeclaration>sym.declAST;

                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) {
                        this.writeLineToOutput("__" + this.modAliasId + "__;");
                    }
                    else {
                        var modPath = name.actualText;//(<ModuleDecl>moduleDecl.mod.symbol.declAST).name.actualText;
                        var isAmbient = moduleDecl.mod.symbol.declAST && hasFlag((<ModuleDeclaration>moduleDecl.mod.symbol.declAST).modFlags, ModuleFlags.Ambient);
                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : quoteBaseName(modPath);
                        modPath = isAmbient ? modPath : (!isRelative(stripQuotes(modPath)) ? quoteStr("./" + stripQuotes(modPath)) : modPath);
                        this.writeToOutput("require(" + modPath + ")");
                    }
                }
                else {
                    this.writeToOutput(name.actualText);
                }
            }
            this.recordSourceMappingEnd(name);
            this.emitParensAndCommentsInPlace(name, false);
        }

        public emitJavascriptStatements(stmts: AST, emitEmptyBod: bool) {
            if (stmts) {
                if (stmts.nodeType != NodeType.Block) {
                    var hasContents = (stmts && (stmts.nodeType != NodeType.List || ((<ASTList>stmts).members.length > 0)));
                    if (emitEmptyBod || hasContents) {
                        var hasOnlyBlockStatement = ((stmts.nodeType == NodeType.Block) ||
                            ((stmts.nodeType == NodeType.List) && ((<ASTList>stmts).members.length == 1) && ((<ASTList>stmts).members[0].nodeType == NodeType.Block)));

                        this.recordSourceMappingStart(stmts);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput(" {");
                            this.indenter.increaseIndent();
                        }
                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, false);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput("");
                            this.indenter.decreaseIndent();
                            this.emitIndent();
                            this.writeToOutput("}");
                        }
                        this.recordSourceMappingEnd(stmts);
                    }
                }
                else {
                    this.emitJavascript(stmts, TokenID.Semicolon, true);
                }
            }
            else if (emitEmptyBod) {
                this.writeToOutput("{ }");
            }
        }

        public emitBareJavascriptStatements(stmts: AST, emitClassPropertiesAfterSuperCall: bool = false) {
            // just the statements without enclosing curly braces
            if (stmts.nodeType != NodeType.Block) {
                if (stmts.nodeType == NodeType.List) {
                    var stmtList = <ASTList>stmts;
                    if ((stmtList.members.length == 2) &&
                        (stmtList.members[0].nodeType == NodeType.Block) &&
                        (stmtList.members[1].nodeType == NodeType.EndCode)) {
                        this.emitJavascript(stmtList.members[0], TokenID.Semicolon, true);
                        this.writeLineToOutput("");
                    }
                    else {
                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, emitClassPropertiesAfterSuperCall);
                    }
                }
                else {
                    this.emitJavascript(stmts, TokenID.Semicolon, true);
                }
            }
            else {
                this.emitJavascript(stmts, TokenID.Semicolon, true);
            }
        }

        public recordSourceMappingNameStart(name: string) {
            if (this.sourceMapper) {
                var finalName = name;
                if (!name) {
                    finalName = "";
                } else if (this.sourceMapper.currentNameIndex.length > 0) {
                    finalName = this.sourceMapper.names[this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1]] + "." + name;
                }

                // We are currently not looking for duplicate but that is possible.
                this.sourceMapper.names.push(finalName);
                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);
            }
        }

        public recordSourceMappingNameEnd() {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        }

        public recordSourceMappingStart(ast: ASTSpan) {
            if (this.sourceMapper && isValidAstNode(ast)) {
                var lineCol = { line: -1, col: -1 };
                var sourceMapping = new SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;
                // REVIEW: check time consumed by this binary search (about two per leaf statement)
                getSourceLineColFromMap(lineCol, ast.minChar, this.checker.locationInfo.lineMap);
                sourceMapping.start.sourceColumn = lineCol.col;
                sourceMapping.start.sourceLine = lineCol.line;
                getSourceLineColFromMap(lineCol, ast.limChar, this.checker.locationInfo.lineMap);
                sourceMapping.end.sourceColumn = lineCol.col;
                sourceMapping.end.sourceLine = lineCol.line;
                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }
                // Set parent and child relationship
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
            }
        }

        public recordSourceMappingEnd(ast: ASTSpan) {
            if (this.sourceMapper && isValidAstNode(ast)) {
                // Pop source mapping childs
                this.sourceMapper.currentMappings.pop();

                // Get the last source mapping from sibling list = which is the one we are recording end for
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];

                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;
            }
        }

        public Close() {
            if (this.sourceMapper != null) {
                SourceMapper.EmitSourceMapping(this.allSourceMappers);
            }
            try {
                // Closing files could result in exceptions, report them if they occur
                this.outfile.Close();
            } catch (ex) {
                this.errorReporter.emitterError(null, ex.message);
            }
        }

        public emitJavascriptList(ast: AST, delimiter: string, tokenId: TokenID, startLine: bool, onlyStatics: bool, emitClassPropertiesAfterSuperCall: bool = false, emitPrologue? = false, requiresExtendsBlock?: bool) {
            if (ast == null) {
                return;
            }
            else if (ast.nodeType != NodeType.List) {
                this.emitPrologue(emitPrologue);
                this.emitJavascript(ast, tokenId, startLine);
            }
            else {
                var list = <ASTList>ast;
                this.emitParensAndCommentsInPlace(ast, true);
                if (list.members.length == 0) {
                    this.emitParensAndCommentsInPlace(ast, false);
                    return;
                }

                var len = list.members.length;
                for (var i = 0; i < len; i++) {
                    if (emitPrologue) {
                        // If the list has Strict mode flags, emit prologue after first statement
                        // otherwise emit before first statement
                        if (i == 1 || !hasFlag(list.flags, ASTFlags.StrictMode)) {
                            this.emitPrologue(requiresExtendsBlock);
                            emitPrologue = false;
                        }
                    }

                    // In some circumstances, class property initializers must be emitted immediately after the 'super' constructor
                    // call which, in these cases, must be the first statement in the constructor body
                    if (i == 1 && emitClassPropertiesAfterSuperCall) {

                        // emit any parameter properties first
                        var constructorDecl = (<ClassDeclaration>this.thisClassNode).constructorDecl;

                        if (constructorDecl && constructorDecl.arguments) {
                            var argsLen = constructorDecl.arguments.members.length;
                            for (var iArg = 0; iArg < argsLen; iArg++) {
                                var arg = <BoundDecl>constructorDecl.arguments.members[iArg];
                                if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {
                                    this.emitIndent();
                                    this.recordSourceMappingStart(arg);
                                    this.recordSourceMappingStart(arg.id);
                                    this.writeToOutput("this." + arg.id.actualText);
                                    this.recordSourceMappingEnd(arg.id);
                                    this.writeToOutput(" = ");
                                    this.recordSourceMappingStart(arg.id);
                                    this.writeToOutput(arg.id.actualText);
                                    this.recordSourceMappingEnd(arg.id);
                                    this.writeLineToOutput(";");
                                    this.recordSourceMappingEnd(arg);
                                }
                            }
                        }

                        var nProps = (<ASTList>this.thisClassNode.members).members.length;

                        for (var iMember = 0; iMember < nProps; iMember++) {
                            if ((<ASTList>this.thisClassNode.members).members[iMember].nodeType == NodeType.VarDecl) {
                                var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[iMember];
                                if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {
                                    this.emitIndent();
                                    this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);
                                    this.writeLineToOutput("");
                                }
                            }
                        }
                    }

                    var emitNode = list.members[i];

                    var isStaticDecl =
                                (emitNode.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>emitNode).fncFlags, FncFlags.Static)) ||
                                (emitNode.nodeType == NodeType.VarDecl && hasFlag((<VarDecl>emitNode).varFlags, VarFlags.Static))

                    if (onlyStatics ? !isStaticDecl : isStaticDecl) {
                        continue;
                    }
                    this.emitJavascript(emitNode, tokenId, startLine);

                    if (delimiter && (i < (len - 1))) {
                        if (startLine) {
                            this.writeLineToOutput(delimiter);
                        }
                        else {
                            this.writeToOutput(delimiter);
                        }
                    }
                    else if (startLine &&
                             (emitNode.nodeType != NodeType.ModuleDeclaration) &&
                             (emitNode.nodeType != NodeType.InterfaceDeclaration) &&
                             (!((emitNode.nodeType == NodeType.VarDecl) &&
                                ((((<VarDecl>emitNode).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&
                                (((<VarDecl>emitNode).init) == null)) && this.varListCount() >= 0) &&
                             (emitNode.nodeType != NodeType.Block || (<Block>emitNode).isStatementBlock) &&
                             (emitNode.nodeType != NodeType.EndCode) &&
                             (emitNode.nodeType != NodeType.FuncDecl)) {
                        this.writeLineToOutput("");
                    }
                }
                this.emitParensAndCommentsInPlace(ast, false);
            }
        }

        // tokenId is the id the preceding token
        public emitJavascript(ast: AST, tokenId: TokenID, startLine: bool) {
            if (ast == null) {
                return;
            }

            // REVIEW: simplify rules for indenting
            if (startLine && (this.indenter.indentAmt > 0) && (ast.nodeType != NodeType.List) &&
                (ast.nodeType != NodeType.Block)) {
                if ((ast.nodeType != NodeType.InterfaceDeclaration) &&
                    (!((ast.nodeType == NodeType.VarDecl) &&
                       ((((<VarDecl>ast).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&
                       (((<VarDecl>ast).init) == null)) && this.varListCount() >= 0) &&
                    (ast.nodeType != NodeType.EndCode) &&
                    ((ast.nodeType != NodeType.FuncDecl) ||
                     (this.emitState.container != EmitContainer.Constructor))) {
                    this.emitIndent();
                }
            }

            ast.emit(this, tokenId, startLine);

            if ((tokenId == TokenID.Semicolon) && (ast.nodeType < NodeType.GeneralNode)) {
                this.writeToOutput(";");
            }
        }

        public emitPropertyAccessor(funcDecl: FuncDecl, className: string, isProto: bool) {
            if (!(<FieldSymbol>funcDecl.accessorSymbol).hasBeenEmitted) {
                var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;
                this.emitIndent();
                this.recordSourceMappingStart(funcDecl);
                this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \"" : ", \"") + funcDecl.name.actualText + "\"" + ", {");
                this.indenter.increaseIndent();

                if (accessorSymbol.getter) {
                    var getter: FuncDecl = <FuncDecl>accessorSymbol.getter.declAST;

                    this.emitIndent();
                    this.recordSourceMappingStart(getter);
                    this.writeToOutput("get: ");
                    this.emitInnerFunction(getter, false, isProto, null, Emitter.shouldCaptureThis(getter), null);
                    this.writeLineToOutput(",");
                }

                if (accessorSymbol.setter) {
                    var setter: FuncDecl = <FuncDecl>accessorSymbol.setter.declAST;

                    this.emitIndent();
                    this.recordSourceMappingStart(setter);
                    this.writeToOutput("set: ");
                    this.emitInnerFunction(setter, false, isProto, null, Emitter.shouldCaptureThis(setter), null);
                    this.writeLineToOutput(",");
                }

                this.emitIndent();
                this.writeLineToOutput("enumerable: true,");
                this.emitIndent();
                this.writeLineToOutput("configurable: true");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("});");
                this.recordSourceMappingEnd(funcDecl);

                accessorSymbol.hasBeenEmitted = true;
            }
        }

        public emitPrototypeMember(member: AST, className: string) {
            if (member.nodeType == NodeType.FuncDecl) {
                var funcDecl = <FuncDecl>member;
                if (funcDecl.isAccessor()) {
                    this.emitPropertyAccessor(funcDecl, className, true);
                }
                else {
                    this.emitIndent();
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");
                    this.emitInnerFunction(funcDecl, false, true, null, Emitter.shouldCaptureThis(funcDecl), null);
                    this.writeLineToOutput(";");
                }
            }
            else if (member.nodeType == NodeType.VarDecl) {
                var varDecl = <VarDecl>member;

                if (varDecl.init) {
                    this.emitIndent();
                    this.recordSourceMappingStart(varDecl);
                    this.recordSourceMappingStart(varDecl.id);
                    this.writeToOutput(className + ".prototype." + varDecl.id.actualText);
                    this.recordSourceMappingEnd(varDecl.id);
                    this.writeToOutput(" = ");
                    this.emitJavascript(varDecl.init, TokenID.Equals, false);
                    this.recordSourceMappingEnd(varDecl);
                    this.writeLineToOutput(";");
                }
            }
        }

        public emitAddBaseMethods(className: string, base: Type, classDecl: TypeDeclaration): void {
            if (base.members) {
                var baseSymbol = base.symbol;
                var baseName = baseSymbol.name;
                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {
                    baseName = baseSymbol.fullName();
                }
                base.members.allMembers.map(function(key, s, c) {
                    var sym = <Symbol>s;
                    if ((sym.kind() == SymbolKind.Type) && (<TypeSymbol>sym).type.call) {
                        this.recordSourceMappingStart(sym.declAST);
                        this.writeLineToOutput(className + ".prototype." + sym.name + " = " +
                                          baseName + ".prototype." + sym.name + ";");
                        this.recordSourceMappingEnd(sym.declAST);
                    }
                }, null);
            }
            if (base.extendsList) {
                for (var i = 0, len = base.extendsList.length; i < len; i++) {
                    this.emitAddBaseMethods(className, base.extendsList[i], classDecl);
                }
            }
        }

        public emitJavascriptClass(classDecl: ClassDeclaration) {
            if (!hasFlag(classDecl.varFlags, VarFlags.Ambient)) {
                var svClassNode = this.thisClassNode;
                var i = 0;
                this.thisClassNode = classDecl;
                var className = classDecl.name.actualText;
                this.emitParensAndCommentsInPlace(classDecl, true);
                var temp = this.setContainer(EmitContainer.Class);

                this.recordSourceMappingStart(classDecl);
                if (hasFlag(classDecl.varFlags, VarFlags.Exported) && classDecl.type.symbol.container == this.checker.gloMod) {
                    this.writeToOutput("this." + className);
                }
                else {
                    this.writeToOutput("var " + className);
                }

                //if (hasFlag(classDecl.varFlags, VarFlags.Exported) && (temp == EmitContainer.Module || temp == EmitContainer.DynamicModule)) {
                //    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";
                //    this.writeToOutput(" = " + modName + "." + className);
                //}

                var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;
                var baseNameDecl: AST = null;
                var baseName: AST = null;

                if (hasBaseClass) {
                    this.writeLineToOutput(" = (function (_super) {");
                } else {
                    this.writeLineToOutput(" = (function () {");
                }

                this.recordSourceMappingNameStart(className);
                this.indenter.increaseIndent();

                if (hasBaseClass) {
                    baseNameDecl = classDecl.extendsList.members[0];
                    baseName = baseNameDecl.nodeType == NodeType.Call ? (<CallExpression>baseNameDecl).target : baseNameDecl;
                    this.emitIndent();
                    this.writeLineToOutput("__extends(" + className + ", _super);");
                }

                this.emitIndent();

                var constrDecl = classDecl.constructorDecl;

                // output constructor
                if (constrDecl) {
                    // declared constructor
                    this.emitJavascript(classDecl.constructorDecl, TokenID.OpenParen, false);

                }
                else {
                    var wroteProps = 0;

                    this.recordSourceMappingStart(classDecl);
                    // default constructor
                    this.indenter.increaseIndent();
                    this.writeToOutput("function " + classDecl.name.actualText + "() {");
                    this.recordSourceMappingNameStart("constructor");
                    if (hasBaseClass) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeLineToOutput("_super.apply(this, arguments);");
                        wroteProps++;
                    }

                    if (classDecl.varFlags & VarFlags.MustCaptureThis) {
                        this.writeCaptureThisStatement(classDecl);
                    }

                    var members = (<ASTList>this.thisClassNode.members).members

                    // output initialized properties
                    for (var i = 0; i < members.length; i++) {
                        if (members[i].nodeType == NodeType.VarDecl) {
                            var varDecl = <VarDecl>members[i];
                            if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {
                                this.writeLineToOutput("");
                                this.emitIndent();
                                this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);
                                wroteProps++;
                            }
                        }
                    }
                    if (wroteProps) {
                        this.writeLineToOutput("");
                        this.indenter.decreaseIndent();
                        this.emitIndent();
                        this.writeLineToOutput("}");
                    }
                    else {
                        this.writeLineToOutput(" }");
                        this.indenter.decreaseIndent();
                    }
                    this.recordSourceMappingNameEnd();
                    this.recordSourceMappingEnd(classDecl);
                }

                var membersLen = classDecl.members.members.length;
                for (var j = 0; j < membersLen; j++) {

                    var memberDecl: AST = classDecl.members.members[j];

                    if (memberDecl.nodeType == NodeType.FuncDecl) {
                        var fn = <FuncDecl>memberDecl;

                        if (hasFlag(fn.fncFlags, FncFlags.Method) && !fn.isSignature()) {
                            if (!hasFlag(fn.fncFlags, FncFlags.Static)) {
                                this.emitPrototypeMember(fn, className);
                            }
                            else { // static functions
                                if (fn.isAccessor()) {
                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);
                                }
                                else {
                                    this.emitIndent();
                                    this.recordSourceMappingStart(fn)
                                    this.writeToOutput(classDecl.name.actualText + "." + fn.name.actualText + " = ");
                                    this.emitInnerFunction(fn, (fn.name && !fn.name.isMissing()), true,
                                            null, Emitter.shouldCaptureThis(fn), null);
                                    this.writeLineToOutput(";");
                                }
                            }
                        }
                    }
                    else if (memberDecl.nodeType == NodeType.VarDecl) {
                        var varDecl = <VarDecl>memberDecl;
                        if (hasFlag(varDecl.varFlags, VarFlags.Static)) {

                            if (varDecl.init) {
                                // EMITREVIEW
                                this.emitIndent();
                                this.recordSourceMappingStart(varDecl);
                                this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");
                                this.emitJavascript(varDecl.init, TokenID.Equals, false);
                                // EMITREVIEW

                                this.writeLineToOutput(";");
                                this.recordSourceMappingEnd(varDecl);
                            }
                        }
                    }
                    else {
                        throw Error("We want to catch this");
                    }
                }

                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeLineToOutput("return " + className + ";");
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.recordSourceMappingStart(classDecl);
                this.writeToOutput(")(");
                if (hasBaseClass)
                    this.emitJavascript(baseName, TokenID.Tilde, false);
                this.writeToOutput(");");
                this.recordSourceMappingEnd(classDecl);

                if ((temp == EmitContainer.Module || temp == EmitContainer.DynamicModule) && hasFlag(classDecl.varFlags, VarFlags.Exported)) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";
                    this.recordSourceMappingStart(classDecl);
                    this.writeToOutput(modName + "." + className + " = " + className + ";");
                    this.recordSourceMappingEnd(classDecl);
                }

                this.emitIndent();
                this.recordSourceMappingEnd(classDecl);
                this.emitParensAndCommentsInPlace(classDecl, false);
                this.setContainer(temp);
                this.thisClassNode = svClassNode;
            }
        }

        public emitPrologue(reqInherits: bool) {
            if (!this.prologueEmitted) {
                if (reqInherits) {
                    this.prologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
                if (this.checker.mustCaptureGlobalThis) {
                    this.prologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        }

        public emitSuperReference() {
            this.writeToOutput("_super.prototype");
        }

        public emitSuperCall(callEx: CallExpression): bool {
            if (callEx.target.nodeType == NodeType.Dot) {
                var dotNode = <BinaryExpression>callEx.target;
                if (dotNode.operand1.nodeType == NodeType.Super) {
                    this.emitJavascript(dotNode, TokenID.OpenParen, false);
                    this.writeToOutput(".call(");
                    this.emitThis();
                    if (callEx.arguments && callEx.arguments.members.length > 0) {
                        this.writeToOutput(", ");
                        this.emitJavascriptList(callEx.arguments, ", ", TokenID.Comma, false, false, false);
                    }
                    this.writeToOutput(")");
                    return true;
                }
            }
            return false;
        }

        public emitThis() {
            if (this.thisFnc && !this.thisFnc.isMethod() && (!this.thisFnc.isConstructor)) {
                this.writeToOutput("_this");
            }
            else {
                this.writeToOutput("this");
            }
        }

        private static shouldCaptureThis(func: FuncDecl): bool {
            // Super calls use 'this' reference. If super call is in a lambda, 'this' value needs to be captured in the parent.
            return func.hasSelfReference() || func.hasSuperReferenceInFatArrowFunction();
        }

        public createFile(fileName: string, useUTF8: bool): ITextWriter {
            try {
                return this.emitOptions.ioHost.createFile(fileName, useUTF8);
            } catch (ex) {
                this.errorReporter.emitterError(null, ex.message);
            }
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export interface ILineCol {
        line: number;
        col: number;
    }

    export class ErrorReporter {
        public parser: Parser = null;
        public checker: TypeChecker = null;
        public lineCol = { line: 0, col: 0 };
        public emitAsComments = true;
        public hasErrors = false;
        public pushToErrorSink = false;
        public errorSink: string[] = [];

        constructor (public outfile: ITextWriter) { }

        public getCapturedErrors() { return this.errorSink; }
        public freeCapturedErrors() { this.errorSink = []; }
        public captureError(emsg: string) { this.errorSink[this.errorSink.length] = emsg; }

        public setErrOut(outerr) {
            this.outfile = outerr;
            this.emitAsComments = false;
        }

        public emitPrefix() {
            if (this.emitAsComments) {
                this.outfile.Write("// ");
            }
            this.outfile.Write(this.checker.locationInfo.filename + "(" + this.lineCol.line + "," + this.lineCol.col + "): ");
        }

        public writePrefix(ast: AST): void {
            if (ast) {
                this.setError(ast);
            }
            else {
                this.lineCol.line = 0;
                this.lineCol.col = 0;
            }
            this.emitPrefix();
        }

        public writePrefixFromSym(symbol: Symbol): void {
            if (symbol && this.checker.locationInfo.lineMap) {
                getSourceLineColFromMap(this.lineCol, symbol.location,
                                        this.checker.locationInfo.lineMap);
            }
            else {
                this.lineCol.line = -1;
                this.lineCol.col = -1;
            }
            this.emitPrefix();
        }

        public setError(ast: AST) {
            if (ast) {
                ast.flags |= ASTFlags.Error;
                if (this.checker.locationInfo.lineMap) {
                    getSourceLineColFromMap(this.lineCol, ast.minChar, this.checker.locationInfo.lineMap);
                }
            }
        }

        public reportError(ast: AST, message: string) {
            if (this.pushToErrorSink) {
                this.captureError(message);
                return;
            }

            this.hasErrors = true;
            if (ast && this.parser.errorRecovery && this.parser.errorCallback) {
                var len = (ast.limChar - ast.minChar);
                this.parser.errorCallback(ast.minChar, len, message, this.checker.locationInfo.unitIndex);
            }
            else {
                this.writePrefix(ast);
                this.outfile.WriteLine(message); // Right after the semi-colon
            }
        }

        public reportErrorFromSym(symbol: Symbol, message: string) {
            if (this.pushToErrorSink) {
                this.captureError(message);
                return;
            }

            this.hasErrors = true;
            if (this.parser.errorRecovery && this.parser.errorCallback) {
                this.parser.errorCallback(symbol.location, symbol.length, message, this.checker.locationInfo.unitIndex);
            }
            else {
                this.writePrefixFromSym(symbol);
                this.outfile.WriteLine(message);
            }
        }

        public emitterError(ast: AST, message: string) {
            this.reportError(ast, message);
            // Emitter errors are not recoverable, stop immediately
            throw Error("EmitError");
        }

        public duplicateIdentifier(ast: AST, name: string) {
            this.reportError(ast, "Duplicate identifier '" + name + "'");
        }

        public showRef(ast: AST, text: string, symbol: Symbol) {
            var defLineCol = { line: -1, col: -1 };
            // TODO: multiple def locations
            this.parser.getSourceLineCol(defLineCol, symbol.location);
            this.reportError(ast, "symbol " + text + " defined at (" + defLineCol.line + "," + defLineCol.col + ")");
        }

        public unresolvedSymbol(ast: AST, name: string) {
            this.reportError(ast, "The name '" + name + "' does not exist in the current scope");
        }

        public symbolDoesNotReferToAValue(ast: AST, name: string): void {
            this.reportError(ast, "The name '" + name + "' does not refer to a value");
        }

        public styleError(ast: AST, msg: string): void {
            var bkThrow = this.pushToErrorSink;
            this.pushToErrorSink = false;
            this.reportError(ast, "STYLE: " + msg);
            this.pushToErrorSink = bkThrow;
        }

        public simpleError(ast: AST, msg: string): void {
            this.reportError(ast, msg);
        }

        public simpleErrorFromSym(sym: Symbol, msg: string): void {
            this.reportErrorFromSym(sym, msg);
        }

        public invalidSuperReference(ast: AST) {
            this.simpleError(ast, "Keyword 'super' can only be used inside a class instance method");
        }

        public valueCannotBeModified(ast: AST) {
            this.simpleError(ast, "The left-hand side of an assignment expression must be a variable, property or indexer");
        }

        public invalidCall(ast: CallExpression, nodeType: number, scope: SymbolScope): void {
            var targetType = ast.target.type;
            var typeName = targetType.getScopedTypeName(scope);
            if (targetType.construct && (nodeType == NodeType.Call)) {
                this.reportError(ast, "Value of type '" + typeName + "' is not callable.  Did you mean to include 'new'?");
            } else {
                var catString = (nodeType == NodeType.Call) ? "callable" : "newable";

                this.reportError(ast, "Value of type '" + typeName + "' is not " + catString);
            }
        }

        public indexLHS(ast: BinaryExpression, scope: SymbolScope): void {
            var targetType = ast.operand1.type.getScopedTypeName(scope);
            var indexType = ast.operand2.type.getScopedTypeName(scope);
            this.simpleError(ast, "Value of type '" + targetType + "' is not indexable by type '" + indexType + "'");
        }

        public incompatibleTypes(ast: AST, t1: Type, t2: Type, op: string, scope: SymbolScope, comparisonInfo?:TypeComparisonInfo) {
            if (!t1) {
                t1 = this.checker.anyType;
            }
            if (!t2) {
                t2 = this.checker.anyType;
            }

            var reason = comparisonInfo ? comparisonInfo.message : "";
            if (op) {
                this.reportError(ast, "Operator '" + op + "' cannot be applied to types '" + t1.getScopedTypeName(scope) +
                                  "' and '" + t2.getScopedTypeName(scope) + "'" + (reason ? ": " + reason : ""));
            }
            else {
                this.reportError(ast, "Cannot convert '" + t1.getScopedTypeName(scope) +
                                  "' to '" + t2.getScopedTypeName(scope) + "'" + (reason ? ": " + reason : ""));
            }
        }

        public expectedClassOrInterface(ast: AST): void {
            this.simpleError(ast, "Expected var, class, interface, or module");
        }

        public unaryOperatorTypeError(ast: AST, op: string, type: Type) {
            this.reportError(ast, "Operator '" + op + "' cannot be applied to type '" + type.getTypeName() + "'");
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export enum TypeContext {
        NoTypes = 0,
        ArraySuffix = 1,
        Primitive = 2,
        Named = 4,
        AllSimpleTypes = Primitive | Named,
        AllTypes = Primitive | Named | ArraySuffix,
    }

    export interface IStatementInfo {
        stmt: Statement;
        labels: ASTList;
    }

    export interface ILambdaArgumentContext {
        preProcessedLambdaArgs: AST;
    }

    export class QuickParseResult {
        constructor(public Script: Script, public endLexState: LexState) { }
    }

    export class Parser {
        private varLists: ASTList[] = [];
        private scopeLists: ASTList[] = [];
        private staticsLists: ASTList[] = [];

        private scanner: IScanner = new Scanner();
        private currentToken: Token = null;

        private needTerminator = false;

        // TODO: consolidate these
        private inFunction = false;
        private inInterfaceDecl = false;
        public currentClassDecl: NamedDeclaration = null; // REVIEW: This should be removed in favor of currentClassDefinition

        private inFncDecl = false;  // this is only for FuncDecls - not constructors, like inFnc
        private anonId = new Identifier("_anonymous");
        public style_requireSemi = false;
        public style_funcInLoop = true;
        private incremental = false;
        public errorRecovery = false;
        public outfile: ITextWriter = undefined;
        public errorCallback: (minChar: number, charLen: number, message: string, unit: number) => void = null;
        private ambientModule = false;
        private ambientClass = false;
        private topLevel = true;
        private allowImportDeclaration = true;
        private currentUnitIndex = (-1);
        private prevIDTok: Token = null;
        private statementInfoStack: IStatementInfo[] = new IStatementInfo[];
        private hasTopLevelImportOrExport = false; // for imports, only true if it's a dynamic module
        private strictMode = false;
        private nestingLevel = 0;
        private prevExpr: AST = null;
        private currentClassDefinition: ClassDeclaration = null;
        private parsingClassConstructorDefinition = false;
        private parsingDeclareFile = false;
        private amdDependencies: string[] = [];
        public inferPropertiesFromThisAssignment = false;
        public requiresExtendsBlock = false;

        private resetStmtStack() {
            this.statementInfoStack = new IStatementInfo[];
        }

        private inLoop() {
            for (var j = this.statementInfoStack.length - 1; j >= 0; j--) {
                if (this.statementInfoStack[j].stmt.isLoop()) {
                    return true;
                }
            }
            return false;
        }

        private pushStmt(stmt: Statement, labels: ASTList) {
            // allocate here to avoid always storing this information in statements
            var info = { stmt: stmt, labels: labels };
            this.statementInfoStack.push(info);
        }

        private popStmt(): IStatementInfo {
            return this.statementInfoStack.pop();
        }

        private resolveJumpTarget(jump: Jump): void {
            var resolvedTarget = AST.getResolvedIdentifierName(jump.target);
            var len = this.statementInfoStack.length;
            for (var i = len - 1; i >= 0; i--) {
                var info = this.statementInfoStack[i];
                if (jump.target) {
                    if (info.labels && (info.labels.members.length > 0)) {
                        for (var j = 0, labLen = info.labels.members.length; j < labLen; j++) {
                            var label = <Label>info.labels.members[j];
                            if (label.id.text == resolvedTarget) {
                                jump.setResolvedTarget(this, info.stmt);
                                return;
                            }
                        }
                    }
                }
                else {
                    if (info.stmt.isLoop()) {
                        jump.setResolvedTarget(this, info.stmt);
                        return;
                    }
                    else if ((info.stmt.nodeType == NodeType.Switch) && (jump.nodeType == NodeType.Break)) {
                        jump.setResolvedTarget(this, info.stmt);
                        return;
                    }
                }
            }
            // no luck
            if (jump.target) {
                this.reportParseError("could not find enclosing statement with label " + jump.target);
            }
            else {
                if (jump.nodeType == NodeType.Break) {
                    this.reportParseError("break statement requires enclosing loop or switch");
                }
                else {
                    this.reportParseError("continue statement requires enclosing loop");
                }
            }
        }

        public setErrorRecovery(outfile: ITextWriter) {
            this.outfile = outfile;
            this.errorRecovery = true;
        }

        public getSourceLineCol(lineCol: ILineCol, minChar: number): void {
            getSourceLineColFromMap(lineCol, minChar, this.scanner.lineMap);
        }

        private createRef(text: string, hasEscapeSequence: bool, minChar: number): Identifier {
            var id = new Identifier(text, hasEscapeSequence);
            id.minChar = minChar;
            return id;
        }

        private reportParseStyleError(message: string) {
            this.reportParseError("STYLE: " + message);
        }

        public reportParseError(message: string, startPos = this.scanner.startPos, pos = this.scanner.pos) {
            var len = Math.max(1, pos - startPos);
            if (this.errorCallback) {
                this.errorCallback(startPos, len, message, this.currentUnitIndex);
            }
            else if (this.errorRecovery) {
                var lineCol = { line: -1, col: -1 };
                this.getSourceLineCol(lineCol, startPos);
                if (this.outfile) {
                    this.outfile.WriteLine("// " + this.fname + " (" + lineCol.line + "," + lineCol.col + "): " + message);
                }
            }
            else {
                throw new SyntaxError(this.fname + " (" + this.scanner.line + "," + this.scanner.col + "): " + message);
            }
        }

        private checkNextToken(tokenId: TokenID, errorRecoverySet: ErrorRecoverySet, errorText: string = null): void {
            this.currentToken = this.scanner.scan();
            this.checkCurrentToken(tokenId, errorRecoverySet, errorText);
        }

        private skip(errorRecoverySet: ErrorRecoverySet) {
            errorRecoverySet |= ErrorRecoverySet.EOF;
            var ersTok = ErrorRecoverySet.None;
            var tokenInfo = lookupToken(this.currentToken.tokenId);
            if (tokenInfo != undefined) {
                ersTok = tokenInfo.ers;
            }
            var pendingRightCurlies = 0;
            while (((ersTok & errorRecoverySet) == ErrorRecoverySet.None) ||
                   (this.currentToken.tokenId == TokenID.CloseBrace) && (pendingRightCurlies > 0)) {
                if (this.currentToken.tokenId == TokenID.OpenBrace) {
                    pendingRightCurlies++;
                }
                else if (this.currentToken.tokenId == TokenID.CloseBrace) {
                    pendingRightCurlies--;
                }
                this.currentToken = this.scanner.scan();
                ersTok = ErrorRecoverySet.None;
                tokenInfo = lookupToken(this.currentToken.tokenId);
                if (tokenInfo != undefined) {
                    ersTok = tokenInfo.ers;
                }
                // TODO: regex rescan 
            }
        }

        private checkCurrentToken(tokenId: TokenID, errorRecoverySet: ErrorRecoverySet, errorText: string = null): void {
            if (this.currentToken.tokenId != tokenId) {
                errorText = errorText == null ? ("Expected '" + tokenTable[tokenId].text + "'") : errorText;
                this.reportParseError(errorText);
                if (this.errorRecovery) {
                    this.skip(errorRecoverySet);
                }
            }
            else {
                this.currentToken = this.scanner.scan();
            }
        }

        private pushDeclLists() {
            this.staticsLists.push(new ASTList());
            this.varLists.push(new ASTList());
            this.scopeLists.push(new ASTList());
        }

        private popDeclLists() {
            this.staticsLists.pop();
            this.varLists.pop();
            this.scopeLists.pop();
        }

        private topVarList() {
            return this.varLists[this.varLists.length - 1];
        }

        private topScopeList() {
            return this.scopeLists[this.scopeLists.length - 1];
        }

        private topStaticsList() {
            return this.staticsLists[this.staticsLists.length - 1];
        }

        private parseComment(comment: CommentToken) {
            if (comment) {
                var c: Comment = new Comment(comment.value, comment.isBlock, comment.endsLine);
                c.minChar = comment.startPos;
                c.limChar = comment.startPos + comment.value.length;
                var lineCol = { line: -1, col: -1 };
                this.getSourceLineCol(lineCol, c.minChar);
                c.minLine = lineCol.line;
                this.getSourceLineCol(lineCol, c.limChar);
                c.limLine = lineCol.line;

                if (!comment.isBlock && comment.value.length > 3 && comment.value.substring(0, 3) == "///") {
                    var dependencyPath = getAdditionalDependencyPath(comment.value);

                    if (dependencyPath) {
                        this.amdDependencies.push(dependencyPath);
                    }

                    if (getImplicitImport(comment.value)) {
                        this.hasTopLevelImportOrExport = true;
                    }
                }

                return c;
            }
            else {
                return null;
            }
        }

        private parseCommentsInner(comments: CommentToken[]): Comment[] {
            if (comments) {
                var commentASTs: Comment[] = new Comment[];
                for (var i = 0; i < comments.length; i++) {
                    commentASTs.push(this.parseComment(comments[i]));
                }

                return commentASTs;
            } else {
                return null;
            }
        }

        private parseComments(): Comment[] {
            var comments = this.scanner.getComments();
            return this.parseCommentsInner(comments);
        }

        private parseCommentsForLine(line: number) {
            var comments = this.scanner.getCommentsForLine(line);

            return this.parseCommentsInner(comments);
        }

        private combineComments(comment1: Comment[], comment2: Comment[]) {
            if (comment1 == null) {
                return comment2;
            }
            else if (comment2 == null) {
                return comment1;
            }
            else {
                return comment1.concat(comment2);
            }
        }

        private parseEnumDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ModuleDeclaration {
            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;

            var name: Identifier = null;
            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                name = Identifier.fromToken(this.currentToken);
                name.minChar = this.scanner.startPos;
                name.limChar = this.scanner.pos;
                this.currentToken = this.scanner.scan();
            }
            else {
                this.reportParseError("Enum declaration requires identifier");
                if (this.errorRecovery) {
                    name = new MissingIdentifier();
                    name.minChar = this.scanner.startPos;
                    name.limChar = this.scanner.startPos;
                    name.flags |= ASTFlags.Error;
                }
            }

            var membersMinChar = this.scanner.startPos;
            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.ID);
            this.pushDeclLists();
            var members = new ASTList();
            members.minChar = membersMinChar;
            var mapDecl = new VarDecl(new Identifier("_map"), 0);
            mapDecl.varFlags |= VarFlags.Exported;
            mapDecl.varFlags |= VarFlags.Private;

            // REVIEW: Is this still necessary?
            mapDecl.varFlags |= (VarFlags.Property | VarFlags.Public);
            mapDecl.init = new UnaryExpression(NodeType.ArrayLit, null);
            members.append(mapDecl);
            var lastValue: NumberLiteral = null;
            var memberNames: Identifier[] = [];
            for (; ;) {
                var minChar = this.scanner.startPos;
                var limChar;
                var memberName: Identifier = null;
                var memberValue: AST = null;
                var preComments = null;
                var postComments = null;

                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {
                    memberName = Identifier.fromToken(this.currentToken);
                    memberName.minChar = this.scanner.startPos;
                    memberName.limChar = this.scanner.pos;
                    memberNames.push(memberName);
                }
                else if (this.currentToken.tokenId == TokenID.CloseBrace) {
                    break;
                }
                else {
                    this.reportParseError("Expected identifer of enum member");
                    if (this.errorRecovery) {
                        memberName = new MissingIdentifier();
                        memberName.minChar = this.scanner.startPos;
                        memberName.limChar = this.scanner.startPos;
                        memberName.flags |= ASTFlags.Error;
                    }
                }

                limChar = this.scanner.pos;
                preComments = this.parseComments();
                this.currentToken = this.scanner.scan();
                postComments = this.parseComments();

                if (this.currentToken.tokenId == TokenID.Equals) {
                    this.currentToken = this.scanner.scan();
                    memberValue = this.parseExpr(errorRecoverySet, OperatorPrecedence.Comma, true,
                                          TypeContext.NoTypes);
                    lastValue = <NumberLiteral>memberValue;
                    limChar = memberValue.limChar;
                }
                else {
                    if (lastValue == null) {
                        memberValue = new NumberLiteral(0, "0");
                        lastValue = <NumberLiteral>memberValue;
                    }
                    else {
                        var nextValue = lastValue.value + 1;
                        memberValue = new NumberLiteral(nextValue, nextValue.toString());
                        lastValue = <NumberLiteral>memberValue;
                    }
                    var map: BinaryExpression =
                        new BinaryExpression(NodeType.Asg,
                                             new BinaryExpression(NodeType.Index,
                                                                  new Identifier("_map"),
                                                                  memberValue),
                                             new StringLiteral('"' + memberName.actualText + '"'));
                    members.append(map);
                }
                var member = new VarDecl(memberName, this.nestingLevel);
                member.minChar = minChar;
                member.limChar = limChar;
                member.init = memberValue;
                // Note: Leave minChar, limChar as "-1" on typeExpr as this is a parsing artifact.
                member.typeExpr = new TypeReference(this.createRef(name.actualText, name.hasEscapeSequence, -1), 0);
                member.varFlags |= (VarFlags.Readonly | VarFlags.Property);

                if (memberValue.nodeType == NodeType.NumberLit) {
                    member.varFlags |= VarFlags.Constant;
                }
                else if (memberValue.nodeType === NodeType.Lsh) {
                    // If the initializer is of the form "value << value" then treat it as a constant
                    // as well.
                    var binop = <BinaryExpression>memberValue;
                    if (binop.operand1.nodeType === NodeType.NumberLit && binop.operand2.nodeType === NodeType.NumberLit) {
                        member.varFlags |= VarFlags.Constant;
                    }
                }
                else if (memberValue.nodeType === NodeType.Name) {
                    // If the initializer refers to an earlier enum value, then treat it as a constant
                    // as well.
                    var nameNode = <Identifier>memberValue;
                    for (var i = 0; i < memberNames.length; i++) {
                        var memberName = memberNames[i];
                        if (memberName.text === nameNode.text) {
                            member.varFlags |= VarFlags.Constant;
                            break;
                        }
                    }
                }

                member.preComments = preComments;
                members.append(member);
                member.postComments = postComments;
                // all enum members are exported
                member.varFlags |= VarFlags.Exported;

                if (this.currentToken.tokenId == TokenID.Comma) {
                    this.currentToken = this.scanner.scan();
                    member.postComments = this.combineComments(member.postComments, this.parseCommentsForLine(this.scanner.prevLine));
                    if ((this.currentToken.tokenId == TokenID.Identifier) || (convertTokToIDName(this.currentToken))) {
                        continue;
                    }
                }
                break;
            }
            var endingToken = new ASTSpan();
            endingToken.minChar = this.scanner.startPos;
            endingToken.limChar = this.scanner.pos;

            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);
            members.limChar = this.scanner.lastTokenLimChar();
            var modDecl = new ModuleDeclaration(name, members, this.topVarList(), endingToken);
            modDecl.modFlags |= ModuleFlags.IsEnum;
            this.popDeclLists();

            modDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            modDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            return modDecl;
        }

        private parseDottedName(enclosedList: AST[]): void {
            this.currentToken = this.scanner.scan();
            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                var id = Identifier.fromToken(this.currentToken);
                id.preComments = this.parseComments();
                enclosedList[enclosedList.length] = id;
                id.minChar = this.scanner.startPos;
                id.limChar = this.scanner.pos;
                this.currentToken = this.scanner.scan();
                if (this.currentToken.tokenId == TokenID.Dot) {
                    this.parseDottedName(enclosedList);
                }
            }
            else {
                this.reportParseError("need identifier after '.'");
            }
        }

        // REVIEW: This is much more lenient than the spec - we're basically just checking to see if the
        // path is rooted or contains an extension, not if it could potentially be a bogus file path
        private isValidImportPath(importPath: string) {
            importPath = stripQuotes(importPath);

            if (!importPath ||
                importPath.indexOf(':') != -1 ||
                importPath.indexOf('\\') != -1 ||
                //(importPath.indexOf('.') != -1 && importPath.charAt(0) != '.') ||
                importPath.charAt(0) == '/') {
                return false;
            }
            return true;
        }

        private parseImportDeclaration(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): ImportDeclaration {

            var name: Identifier = null;
            var alias: AST = null;
            var importDecl: ImportDeclaration = null;
            var minChar = this.scanner.startPos;
            var isDynamicImport = false;

            this.currentToken = this.scanner.scan();

            if (this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {
                name = Identifier.fromToken(this.currentToken);
            }
            else {
                this.reportParseError("Expected identifer after 'import'");
                name = new MissingIdentifier();
            }

            name.minChar = this.scanner.startPos;
            name.limChar = this.scanner.pos;

            this.currentToken = this.scanner.scan();

            this.checkCurrentToken(TokenID.Equals, errorRecoverySet | ErrorRecoverySet.ID);

            var aliasPreComments = this.parseComments();

            var limChar;
            if (this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {

                if (this.currentToken.tokenId == TokenID.Module) {
                    limChar = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                    if (this.currentToken.tokenId == TokenID.OpenParen) {
                        this.currentToken = this.scanner.scan();

                        if (this.currentToken.tokenId == TokenID.StringLiteral || this.currentToken.tokenId == TokenID.Identifier || convertTokToID(this.currentToken, this.strictMode)) {

                            if (this.currentToken.tokenId == TokenID.StringLiteral) {

                                if (this.topLevel) {
                                    this.hasTopLevelImportOrExport = true;
                                } else if (!this.allowImportDeclaration) {
                                    this.reportParseError("Import declaration of external module is permitted only in global or top level dynamic modules");
                                }

                                var aliasText = this.currentToken.getText();
                                alias = Identifier.fromToken(this.currentToken);
                                alias.minChar = this.scanner.startPos;
                                alias.limChar = this.scanner.pos;

                                if (!this.isValidImportPath((<Identifier>alias).text)) {
                                    this.reportParseError("Invalid import path");
                                }

                                isDynamicImport = true;
                                this.currentToken = this.scanner.scan();

                                alias.preComments = aliasPreComments;
                            }
                            else {
                                alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,
                                            OperatorPrecedence.Assignment, true,
                                            TypeContext.NoTypes);

                                alias.preComments = aliasPreComments;
                            }
                        }

                        limChar = this.scanner.pos;
                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.ID);

                        if (alias) {
                            alias.postComments = this.parseComments();
                        }
                    }
                }
                else {
                    alias = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,
                                            OperatorPrecedence.Assignment, true,
                                            TypeContext.NoTypes);
                    limChar = this.scanner.pos; // Include semicolon if needed
                }
            }
            else {
                this.reportParseError("Expected module name");
                alias = new MissingIdentifier();
                alias.minChar = this.scanner.startPos;
                if (this.currentToken.tokenId == TokenID.Semicolon) {
                    alias.limChar = this.scanner.startPos;
                } else {
                    alias.limChar = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                }
                alias.flags |= ASTFlags.Error;
                limChar = alias.limChar;
            }

            importDecl = new ImportDeclaration(name, alias);
            importDecl.isDynamicImport = isDynamicImport;

            importDecl.minChar = minChar;
            importDecl.limChar = limChar;

            return importDecl;
        }

        private parseModuleDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers, preComments: Comment[]): ModuleDeclaration {
            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;

            var svAmbient = this.ambientModule;
            var svTopLevel = this.topLevel;
            this.topLevel = false;
            if (this.parsingDeclareFile || svAmbient || hasFlag(modifiers, Modifiers.Ambient)) {
                this.ambientModule = true;
            }

            this.currentToken = this.scanner.scan();
            var name: Identifier = null;
            var enclosedList: AST[] = null;
            this.pushDeclLists();
            var minChar = this.scanner.startPos;
            var isDynamicMod = false;

            if ((this.currentToken.tokenId == TokenID.Identifier) || (this.currentToken.tokenId == TokenID.StringLiteral) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode))) {
                var nameText = this.currentToken.getText();

                if (this.currentToken.tokenId == TokenID.StringLiteral) {
                    isDynamicMod = true;
                    if (!this.ambientModule) {
                        this.reportParseError("Only ambient dynamic modules may have string literal names");
                    }

                    if (!svTopLevel) {
                        this.reportParseError("Dynamic modules may not be nested within other modules");
                    }
                }

                name = Identifier.fromToken(this.currentToken);
                name.minChar = this.scanner.startPos;
                name.limChar = this.scanner.pos;

                this.currentToken = this.scanner.scan();
            }
            else if (this.currentToken.tokenId == TokenID.OpenBrace) {
                this.reportParseError("Module name missing");
                name = new Identifier("");
                // "fake" position of where the ID would be
                name.minChar = minChar;
                name.limChar = minChar;
            }

            if (this.currentToken.tokenId == TokenID.Dot) {
                enclosedList = new AST[];
                this.parseDottedName(enclosedList);
            }

            if (name == null) {
                name = new MissingIdentifier();
            }

            var moduleBody = new ASTList();
            var bodyMinChar = this.scanner.startPos;
            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.ID);

            if (svTopLevel && isDynamicMod) {
                this.allowImportDeclaration = true;
            } else {
                this.allowImportDeclaration = false;
            }
            this.parseStatementList(
                errorRecoverySet | ErrorRecoverySet.RCurly, moduleBody,
                /*sourceElements:*/ true, /*noLeadingCase:*/ true, AllowedElements.Global, modifiers);
            moduleBody.minChar = bodyMinChar;
            moduleBody.limChar = this.scanner.pos;

            var endingToken = new ASTSpan();
            endingToken.minChar = this.scanner.startPos;
            endingToken.limChar = this.scanner.pos;
            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);

            var limChar = this.scanner.lastTokenLimChar();
            var moduleDecl: ModuleDeclaration;

            this.allowImportDeclaration = svTopLevel;

            if (enclosedList && (enclosedList.length > 0)) {
                var len = enclosedList.length;
                var innerName = <Identifier>enclosedList[len - 1];
                var innerDecl = new ModuleDeclaration(innerName, moduleBody, this.topVarList(), endingToken);
                innerDecl.preComments = preComments;

                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {
                    innerDecl.modFlags |= ModuleFlags.Ambient;
                }

                innerDecl.modFlags |= ModuleFlags.Exported;

                // REVIEW: will also possibly need to re-parent comments as well
                innerDecl.minChar = minChar;
                innerDecl.limChar = limChar;

                this.popDeclLists();
                var outerModBod: ASTList;
                for (var i = len - 2; i >= 0; i--) {
                    outerModBod = new ASTList();
                    outerModBod.append(innerDecl);
                    innerName = <Identifier>enclosedList[i];
                    innerDecl = new ModuleDeclaration(innerName, outerModBod, new ASTList(), endingToken);
                    outerModBod.minChar = innerDecl.minChar = minChar;
                    outerModBod.limChar = innerDecl.limChar = limChar;

                    if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {
                        innerDecl.modFlags |= ModuleFlags.Ambient;
                    }

                    innerDecl.modFlags |= ModuleFlags.Exported;
                }
                outerModBod = new ASTList();
                outerModBod.append(innerDecl);
                outerModBod.minChar = minChar;
                outerModBod.limChar = limChar;
                moduleDecl = new ModuleDeclaration(<Identifier>name, outerModBod, new ASTList(), endingToken);
            }
            else {
                moduleDecl = new ModuleDeclaration(<Identifier>name, moduleBody, this.topVarList(), endingToken);
                moduleDecl.preComments = preComments;
                this.popDeclLists();
            }

            if (this.parsingDeclareFile || svAmbient || hasFlag(modifiers, Modifiers.Ambient)) {
                moduleDecl.modFlags |= ModuleFlags.Ambient;
            }
            if (svAmbient || hasFlag(modifiers, Modifiers.Exported)) {
                moduleDecl.modFlags |= ModuleFlags.Exported;
            }

            if (isDynamicMod) {
                moduleDecl.modFlags |= ModuleFlags.IsDynamic;
            }

            this.ambientModule = svAmbient;

            this.topLevel = svTopLevel;
            moduleDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            moduleDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            moduleDecl.limChar = moduleBody.limChar;
            return moduleDecl;
        }

        private parseTypeReferenceTail(errorRecoverySet: ErrorRecoverySet, minChar: number, term: AST): TypeReference {
            var result = new TypeReference(term, 0);
            result.minChar = minChar;
            while (this.currentToken.tokenId == TokenID.OpenBracket) {
                this.currentToken = this.scanner.scan();
                result.arrayCount++;
                this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet | ErrorRecoverySet.LBrack);
            }
            result.limChar = this.scanner.lastTokenLimChar();
            return result;
        }

        // REVIEW: Consider renaming to parseTypeName.
        private parseNamedType(errorRecoverySet: ErrorRecoverySet, minChar: number, term: AST, tail: bool): AST {
            this.currentToken = this.scanner.scan();
            if (this.currentToken.tokenId == TokenID.Dot) {
                var curpos = this.scanner.pos;
                this.currentToken = this.scanner.scan();
                // Don't allow reserved words if immediately after a new line and error recovery is enabled
                if ((this.currentToken.tokenId == TokenID.Identifier) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && convertTokToID(this.currentToken, this.strictMode))) {
                    var op2 = Identifier.fromToken(this.currentToken);
                    op2.minChar = this.scanner.startPos;
                    op2.limChar = this.scanner.pos;
                    var dotNode = new BinaryExpression(NodeType.Dot, term, op2);
                    dotNode.minChar = term.minChar;
                    dotNode.limChar = op2.limChar;
                    return this.parseNamedType(errorRecoverySet, minChar,
                                            dotNode, tail);
                }
                else {
                    this.reportParseError("need identifier after '.'");
                    if (this.errorRecovery) {
                        term.flags |= ASTFlags.DotLHS;
                        // We set "limChar" to be slightly innacurate for completion list behavior
                        // (last AST node from "quickParse" will match DotLHS and be at end of file position)
                        // This is to match the behavior of TokenId.Dot processing in parsePostfixOperators.
                        term.limChar = this.scanner.lastTokenLimChar();
                        return term;
                    }
                    else {
                        var eop2 = new MissingIdentifier();
                        eop2.minChar = this.scanner.pos;
                        eop2.limChar = this.scanner.pos;
                        var edotNode = new BinaryExpression(NodeType.Dot, term, eop2);
                        edotNode.flags |= ASTFlags.Error;
                        edotNode.minChar = term.minChar;
                        edotNode.limChar = eop2.limChar;
                        return this.parseNamedType(errorRecoverySet, minChar,
                                                edotNode, tail);
                    }
                }
            }
            else {
                if (tail) {
                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, term);
                }
                else {
                    return term;
                }
            }
        }

        // REVIEW: Reconsider renaming this to parseType to match the grammar.
        private parseTypeReference(errorRecoverySet: ErrorRecoverySet, allowVoid: bool): AST {
            var minChar = this.scanner.startPos;
            var isConstructorMember = false;

            switch (this.currentToken.tokenId) {
                case TokenID.Void:
                    if (!allowVoid) {
                        this.reportParseError("void not a valid type in this context");
                    }
                // Intentional fall-through
                case TokenID.Any:
                case TokenID.Number:
                case TokenID.Bool:
                case TokenID.String: {
                    var text = tokenTable[this.currentToken.tokenId].text;
                    var predefinedIdentifier = new Identifier(text);
                    predefinedIdentifier.minChar = minChar;
                    predefinedIdentifier.limChar = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                    return this.parseTypeReferenceTail(errorRecoverySet, minChar, predefinedIdentifier);
                }

                case TokenID.Identifier:
                    var ident = this.createRef(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence, minChar);
                    ident.limChar = this.scanner.pos;
                    return this.parseNamedType(errorRecoverySet, minChar, ident, true);

                case TokenID.OpenBrace:
                    return this.parseObjectType(minChar, errorRecoverySet);

                case TokenID.New:
                    this.currentToken = this.scanner.scan();
                    // can't use chkCurrentTok, since we don't want to advance the token
                    if (this.currentToken.tokenId != TokenID.OpenParen) {
                        this.reportParseError("Expected '('");
                    }
                    else {
                        isConstructorMember = true;
                        // fall through...
                    }
                
                case TokenID.OpenParen: {
                    // ( formals ) => type
                    var formals = new ASTList();
                    var variableArgList =
                        this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,
                                            formals, false, true, false, false, false, false, null, true);
                    this.checkCurrentToken(TokenID.EqualsGreaterThan, errorRecoverySet);
                    var returnType = this.parseTypeReference(errorRecoverySet, true);
                    var funcDecl = new FuncDecl(null, null, false, null, formals, null, null, null,
                                                NodeType.FuncDecl);
                    funcDecl.returnTypeAnnotation = returnType;
                    funcDecl.variableArgList = variableArgList;
                    funcDecl.fncFlags |= FncFlags.Signature;

                    if (isConstructorMember) {
                        funcDecl.fncFlags |= FncFlags.ConstructMember;
                        funcDecl.hint = "_construct";
                        funcDecl.classDecl = null;
                    }
                    funcDecl.minChar = minChar;
                    funcDecl.flags |= ASTFlags.TypeReference;
                    var trt = this.parseTypeReferenceTail(errorRecoverySet, minChar, funcDecl);
                    funcDecl.limChar = trt.limChar;
                    return trt;
                }

                default:
                    this.reportParseError("Expected type name");
                    var etr = new TypeReference(null, 0);
                    etr.flags |= ASTFlags.Error;
                    etr.minChar = this.scanner.pos;
                    etr.limChar = this.scanner.pos;
                    return etr;
            }
        }

        private parseObjectType(minChar: number, errorRecoverySet: ErrorRecoverySet): TypeReference {
            this.currentToken = this.scanner.scan();

            var members = new ASTList();
            members.minChar = minChar;

            var prevInInterfaceDecl = this.inInterfaceDecl;
            this.inInterfaceDecl = true;
            this.parseTypeMemberList(errorRecoverySet | ErrorRecoverySet.RCurly, members);
            this.inInterfaceDecl = prevInInterfaceDecl;

            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);

            // REVIEW: We're parsing an ObjectType, but we give a NodeType of Interface here.
            var interfaceDecl = new InterfaceDeclaration(
                this.anonId, null, members, /*extends:*/ null, /*implements:*/ null);

            interfaceDecl.minChar = minChar;
            interfaceDecl.limChar = members.limChar;    // "}"

            var typeRef = this.parseTypeReferenceTail(errorRecoverySet, minChar, interfaceDecl);
            typeRef.flags |= ASTFlags.TypeReference;
            return typeRef;
        }

        private parseFunctionBlock(errorRecoverySet: ErrorRecoverySet,
            allowedElements: AllowedElements,
            parentModifiers: Modifiers,
            bod: ASTList,
            bodMinChar: number): void {
            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.StmtStart);
            var savedInFunction = this.inFunction;
            this.inFunction = true;
            this.parseStatementList(
                errorRecoverySet | ErrorRecoverySet.RCurly | ErrorRecoverySet.StmtStart,
                bod, /*sourceElements:*/ true, /*noLeadingCase:*/ false, allowedElements, parentModifiers);
            bod.minChar = bodMinChar;
            bod.limChar = this.scanner.pos;
            this.inFunction = savedInFunction;
            var ec = new EndCode();
            ec.minChar = bod.limChar;
            ec.limChar = ec.minChar;
            bod.append(ec);
        }

        private parseFunctionStatements(errorRecoverySet: ErrorRecoverySet,
            name: Identifier,
            isConstructor: bool,
            isMethod: bool,
            args: ASTList,
            allowedElements: AllowedElements,
            minChar: number,
            requiresSignature: bool,
            parentModifiers: Modifiers) {

            this.pushDeclLists();
            // start new statement stack
            var svStmtStack = this.statementInfoStack;
            this.resetStmtStack();

            var bod: ASTList = null;
            var wasShorthand = false;
            var isAnonLambda = false;
            var limChar: number;

            if (requiresSignature) {
                // If we require a signature, but they provided a block, then give an error, but
                // still consume the block.
                limChar = this.scanner.pos;
                if (this.currentToken.tokenId === TokenID.OpenBrace) {
                    this.reportParseError("Function declarations are not permitted within interfaces, ambient modules or classes")
                    bod = new ASTList();
                    var bodMinChar = this.scanner.startPos;

                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);
                    this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);

                    // If there's also a semicolon, then just skip over it.  We don't want to report an 
                    // additional error here.
                    if (this.currentToken.tokenId === TokenID.Semicolon) {
                        this.currentToken = this.scanner.scan();
                    }
                }
                else {
                    this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet, "Expected ';'");
                }
            }
            else {
                bod = new ASTList();
                var bodMinChar = this.scanner.startPos;
                if (this.currentToken.tokenId == TokenID.EqualsGreaterThan) {
                    if (isMethod) {
                        this.reportParseError("'=>' may not be used for class methods");
                    }
                    wasShorthand = true;
                    this.currentToken = this.scanner.scan();
                }

                if (wasShorthand && this.currentToken.tokenId != TokenID.OpenBrace) {
                    var retExpr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,
                                            OperatorPrecedence.Assignment, true,
                                            TypeContext.NoTypes);
                    var retStmt = new ReturnStatement();
                    retStmt.returnExpression = retExpr;
                    retStmt.minChar = retExpr.minChar;
                    retStmt.limChar = retExpr.limChar;
                    bod.minChar = bodMinChar;
                    bod.limChar = retExpr.limChar;
                    bod.append(retStmt);
                }
                else {
                    isAnonLambda = wasShorthand;
                    this.parseFunctionBlock(errorRecoverySet, allowedElements, parentModifiers, bod, bodMinChar);
                }

                limChar = this.scanner.pos;
            }

            var funcDecl = new FuncDecl(name, bod, isConstructor, null, args, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);
            var staticFuncDecl = false;

            if (!requiresSignature) {
                if (!wasShorthand || isAnonLambda) {
                    funcDecl.endingToken = new ASTSpan();
                    funcDecl.endingToken.minChar = this.scanner.startPos;
                    funcDecl.endingToken.limChar = this.scanner.pos;
                    this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);

                    if (isAnonLambda) {
                        funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;
                    }
                }
                else {
                    funcDecl.fncFlags |= FncFlags.IsFatArrowFunction;
                    funcDecl.endingToken = new ASTSpan();

                    funcDecl.endingToken.minChar = bod.members[0].minChar;
                    funcDecl.endingToken.limChar = bod.members[0].limChar;
                }
            }
            funcDecl.minChar = minChar;
            funcDecl.limChar = limChar;

            if (requiresSignature) {
                funcDecl.fncFlags |= FncFlags.Signature;
            }

            this.statementInfoStack = svStmtStack;
            return funcDecl;
        }

        private transformAnonymousArgsIntoFormals(formals: ASTList, argList: AST): bool {

            var translateBinExOperand = (operand: AST): bool => {
                if (operand.nodeType == NodeType.Comma) {
                    return this.transformAnonymousArgsIntoFormals(formals, operand);
                }
                else if (operand.nodeType == NodeType.Name || operand.nodeType == NodeType.Asg) {
                    var opArg = operand.nodeType == NodeType.Asg ? (<BinaryExpression>operand).operand1 : operand;
                    opArg.isParenthesized = false;

                    var arg = new ArgDecl(<Identifier>opArg);
                    arg.preComments = opArg.preComments;
                    arg.postComments = opArg.postComments;
                    arg.minChar = operand.minChar;
                    arg.limChar = operand.limChar;

                    if (hasFlag(opArg.flags, ASTFlags.PossibleOptionalParameter)) {
                        arg.isOptional = true;
                    }

                    if (operand.nodeType == NodeType.Asg) {
                        arg.init = (<BinaryExpression>operand).operand2;
                    }

                    formals.append(arg);

                    return arg.isOptional || arg.init;
                }
                else {
                    this.reportParseError("Invalid lambda argument");
                }
                return false;
            }

            if (argList) {
                if (argList.nodeType == NodeType.Comma) {
                    var commaList = <BinaryExpression> argList;
                    if (commaList.operand1.isParenthesized) {
                        this.reportParseError("Invalid lambda argument", commaList.operand1.minChar, commaList.operand1.limChar);
                    }
                    if (commaList.operand2.isParenthesized) {
                        this.reportParseError("Invalid lambda argument", commaList.operand2.minChar, commaList.operand2.limChar);
                    }
                    var isOptional = translateBinExOperand(commaList.operand1);
                    isOptional = translateBinExOperand(commaList.operand2) || isOptional;
                    return isOptional;
                }
                else {
                    return translateBinExOperand(argList);
                }
            }
        }

        private parseFormalParameterList(errorRecoverySet: ErrorRecoverySet,
            formals: ASTList,
            isClassConstr: bool,
            isSig: bool,
            isIndexer: bool,
            isGetter: bool,
            isSetter: bool,
            isLambda: bool,
            preProcessedLambdaArgs: AST,
            expectClosingRParen: bool): bool {

            formals.minChar = this.scanner.startPos; // '(' or '['
            if (isIndexer) {
                this.currentToken = this.scanner.scan();
            }
            else if (!isLambda) {
                this.checkCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.RParen);
            }
            var sawEllipsis = false;
            var firstArg = true;
            var hasOptional = false;
            var haveFirstArgID = false;

            // if preProcessedLambdaArgs is "true", we either have a typeless argument list, or we have
            // a single identifier node and the current token is the ':' before a typereference
            if (isLambda && preProcessedLambdaArgs && preProcessedLambdaArgs.nodeType != NodeType.EmptyExpr) {
                hasOptional = this.transformAnonymousArgsIntoFormals(formals, preProcessedLambdaArgs);
                formals.minChar = preProcessedLambdaArgs.minChar;
                haveFirstArgID = true;
            }

            while (true) {
                var munchedArg = false;
                var argFlags = VarFlags.None;
                var argMinChar = this.scanner.startPos;

                if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == TokenID.This) {
                    if (!isClassConstr) {
                        this.reportParseError("Instance property declarations using 'this' may only be used in class constructors");
                    }
                    this.currentToken = this.scanner.scan(); // consume the '.'

                    argFlags |= (VarFlags.Public | VarFlags.Property);
                    if (this.currentClassDefinition) {
                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;
                    }
                }
                if (this.currentToken.tokenId == TokenID.Public) {
                    argFlags |= (VarFlags.Public | VarFlags.Property);

                    if (this.currentClassDefinition) {
                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;
                    }
                }
                else if (this.currentToken.tokenId == TokenID.Private) {
                    argFlags |= (VarFlags.Private | VarFlags.Property);

                    if (this.currentClassDefinition) {
                        this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;
                    }
                }
                else if (this.currentToken.tokenId == TokenID.Static && isClassConstr) {
                    this.reportParseError("Static properties can not be declared as parameter properties");
                    this.currentToken = this.scanner.scan();
                }

                if (argFlags != VarFlags.None) {
                    if (!isClassConstr) {
                        this.reportParseError("only constructor parameters can be properties");
                    }
                    this.currentToken = this.scanner.scan();

                    if (isModifier(this.currentToken)) {
                        this.reportParseError("Multiple modifiers may not be applied to parameters");
                        this.currentToken = this.scanner.scan();
                    }

                    if (this.inferPropertiesFromThisAssignment && this.currentToken.tokenId == TokenID.This) {
                        if (!isClassConstr) {
                            this.reportParseError("Instance property declarations using 'this' may only be used in class constructors");
                        }
                        this.currentToken = this.scanner.scan(); // consume the '.'
                        this.currentToken = this.scanner.scan();
                    }
                }
                else if (this.currentToken.tokenId == TokenID.DotDotDot) {
                    sawEllipsis = true;
                    this.currentToken = this.scanner.scan();

                    if (!(this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                        this.reportParseError("'...' parameters require both a parameter name and an array type annotation to be specified");
                        sawEllipsis = false; // Do not treat this parameter as vararg
                    }
                }

                var argId: Identifier = null;

                if (!haveFirstArgID && (this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                    argId = Identifier.fromToken(this.currentToken);
                    argId.minChar = this.scanner.startPos;
                    argId.limChar = this.scanner.pos;
                }

                if (haveFirstArgID || argId) {
                    munchedArg = true;
                    var type: AST = null;
                    var arg: ArgDecl = null;

                    if (haveFirstArgID && formals.members.length) {
                        arg = <ArgDecl>formals.members[formals.members.length - 1];

                        if (arg.isOptional) {
                            hasOptional = true;
                        }
                    }
                    else {
                        arg = new ArgDecl(argId);

                        if (isGetter) {
                            this.reportParseError("Property getters may not take any arguments");
                        }

                        if (isSetter && !firstArg) {
                            this.reportParseError("Property setters may only take one argument");
                        }

                        arg.minChar = argMinChar;
                        arg.preComments = this.parseComments();
                        this.currentToken = this.scanner.scan();
                    }

                    if (this.currentToken.tokenId == TokenID.Question) {
                        arg.isOptional = true;
                        hasOptional = true;
                        this.currentToken = this.scanner.scan();
                    }

                    if (this.currentToken.tokenId == TokenID.Colon) {
                        this.currentToken = this.scanner.scan();
                        type = this.parseTypeReference(errorRecoverySet, false);
                    }

                    // check for default parameter
                    // REVIEW: In the case of a typed reference, assume that parseTypeReference or one
                    // of its children in the call graph advanced tok
                    if (this.currentToken.tokenId == TokenID.Equals) {
                        if (isSig) {
                            this.reportParseError("Arguments in signatures may not have default values");
                        }

                        hasOptional = true;
                        this.currentToken = this.scanner.scan();
                        arg.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,
                                            OperatorPrecedence.Comma, false,
                                            TypeContext.NoTypes);

                    }

                    if (hasOptional && !arg.isOptionalArg() && !sawEllipsis) {
                        this.reportParseError("Optional parameters may only be followed by other optional parameters");
                    }

                    if (sawEllipsis && arg.isOptionalArg()) {
                        this.reportParseError("Varargs may not be optional or have default parameters");
                    }

                    if (sawEllipsis && !type) {
                        // Ellipsis is missing a type definition
                        this.reportParseError("'...' parameters require both a parameter name and an array type annotation to be specified");
                    }

                    // REVIEW: Ok for lambdas?
                    arg.postComments = this.parseComments();
                    arg.typeExpr = type;
                    arg.limChar = this.scanner.lastTokenLimChar();
                    arg.varFlags |= argFlags;
                    if (!haveFirstArgID) {
                        formals.append(arg);
                    }
                    else {
                        haveFirstArgID = false;
                    }
                }

                firstArg = false;
                if (this.currentToken.tokenId == TokenID.Comma) {
                    if ((munchedArg) && (!sawEllipsis)) {
                        this.currentToken = this.scanner.scan();
                        continue;
                    }
                    else {
                        this.reportParseError("Unexpected ',' in argument list");
                        if (this.errorRecovery) {
                            this.currentToken = this.scanner.scan();
                            continue;
                        }
                    }
                }
                else {
                    break;
                }
            }

            if (isIndexer) {
                this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);
            }
            else if (expectClosingRParen) {
                this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly | ErrorRecoverySet.SColon);
            }

            formals.limChar = this.scanner.lastTokenLimChar(); // ')' or ']'
            return sawEllipsis;
        }

        private parseFncDecl(errorRecoverySet: ErrorRecoverySet,
            isDecl: bool,
            requiresSignature: bool,
            isMethod: bool,
            methodName: Identifier,
            indexer: bool,
            isStatic: bool,
            markedAsAmbient: bool,
            modifiers: Modifiers,
            lambdaArgContext: ILambdaArgumentContext,
            expectClosingRParen: bool): AST {

            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;

            var prevInConstr = this.parsingClassConstructorDefinition;
            this.parsingClassConstructorDefinition = false;

            var name: Identifier = null;
            var fnMin = this.scanner.startPos;
            var minChar = this.scanner.pos;
            var prevNestingLevel = this.nestingLevel;
            var preComments = this.parseComments();
            var isLambda = !!lambdaArgContext;
            this.nestingLevel = 0;
            if ((!this.style_funcInLoop) && this.inLoop()) {
                this.reportParseStyleError("function declaration in loop");
            }
            
            if (!isMethod && !isStatic && !indexer && !lambdaArgContext && !methodName) {
                // past function keyword
                this.currentToken = this.scanner.scan();
                if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToID(this.currentToken, this.strictMode))) {
                    if (isDecl) {
                        this.reportParseError("Function declaration must include identifier");

                        this.nestingLevel = prevNestingLevel;
                        return new IncompleteAST(fnMin, this.scanner.pos);
                    }
                }
                else {
                    name = Identifier.fromToken(this.currentToken);
                    name.minChar = this.scanner.startPos;
                    name.limChar = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                }
            }
            else {
                if (methodName) {
                    name = methodName;
                }
            }

            var args: ASTList = new ASTList();
            var variableArgList = false;
            var isOverload = false;
            var isGetter = hasFlag(modifiers, Modifiers.Getter);
            var isSetter = hasFlag(modifiers, Modifiers.Setter);
            if ((this.currentToken.tokenId == TokenID.OpenParen) || (indexer && (this.currentToken.tokenId == TokenID.OpenBracket)) || (lambdaArgContext && (lambdaArgContext.preProcessedLambdaArgs || this.currentToken.tokenId == TokenID.DotDotDot))) {
                // arg list
                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, false, requiresSignature, indexer, isGetter, isSetter, isLambda, lambdaArgContext ? lambdaArgContext.preProcessedLambdaArgs : null, expectClosingRParen);
            }
            var returnType: AST = null;
            if (this.currentToken.tokenId == TokenID.Colon) {
                this.currentToken = this.scanner.scan();
                if (hasFlag(modifiers, Modifiers.Setter)) {
                    this.reportParseError("Property setters may not declare a return type");
                }
                returnType = this.parseTypeReference(errorRecoverySet, true);
            }

            if (indexer && args.members.length == 0) {
                this.reportParseError("Index signatures require a parameter type to be specified");
            }

            if (isLambda && this.currentToken.tokenId != TokenID.EqualsGreaterThan) {
                this.reportParseError("Expected '=>'");
            }

            // REVIEW:
            // Currently, it's imperative that ambient functions *not* be marked as overloads.  At some point, we may
            // want to unify the two concepts internally
            if (isDecl && !(this.parsingDeclareFile || markedAsAmbient) && !this.ambientModule && !this.ambientClass && !this.inInterfaceDecl && this.currentToken.tokenId == TokenID.Semicolon) {
                isOverload = true;
                isDecl = false;
                requiresSignature = true;
            }
            var svInFncDecl = this.inFncDecl;
            this.inFncDecl = true;
            var funcDecl: FuncDecl =
                this.parseFunctionStatements(
                errorRecoverySet | ErrorRecoverySet.RCurly,
                name, /*isConstructor:*/ false, isMethod, args, AllowedElements.None,
                minChar, requiresSignature, Modifiers.None);

            this.inFncDecl = svInFncDecl;
            funcDecl.variableArgList = variableArgList;
            funcDecl.isOverload = isOverload;

            if (isStatic) {
                funcDecl.fncFlags |= FncFlags.Static;
            }

            if (requiresSignature) {
                funcDecl.fncFlags |= FncFlags.Signature;
            }

            if (indexer) {
                funcDecl.fncFlags |= FncFlags.IndexerMember;
            }

            funcDecl.returnTypeAnnotation = returnType;
            if (((this.inInterfaceDecl || this.currentClassDefinition) && !this.inFncDecl) && isMethod) {
                funcDecl.fncFlags |= FncFlags.Method;
                // all class property methods are currently exported
                funcDecl.fncFlags |= FncFlags.ClassPropertyMethodExported;
            }
            funcDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            funcDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;

            this.nestingLevel = prevNestingLevel;
            this.parsingClassConstructorDefinition = prevInConstr;
            funcDecl.preComments = preComments;
            return funcDecl;
        }

        private convertToTypeReference(ast: AST): TypeReference {
            var result: TypeReference;
            switch (ast.nodeType) {
                case NodeType.TypeRef:
                    return <TypeReference>ast;
                case NodeType.Name:
                    result = new TypeReference(ast, 0);
                    result.minChar = ast.minChar;
                    result.limChar = ast.limChar;
                    return result;
                case NodeType.Index: {
                    var expr = <BinaryExpression>ast;
                    result = this.convertToTypeReference(expr.operand1);
                    if (result) {
                        result.arrayCount++;
                        result.minChar = expr.minChar;
                        result.limChar = expr.limChar;
                        return result;
                    }
                    else {
                        var etr = <TypeReference>new AST(NodeType.Error);
                        return etr;
                    }
                }
            }
            return null;
        }

        private parseArgList(errorRecoverySet: ErrorRecoverySet): ASTList {
            var args: ASTList = new ASTList();
            args.minChar = this.scanner.startPos;

            // skip left paren
            this.currentToken = this.scanner.scan();

            if (this.currentToken.tokenId !== TokenID.CloseParen) {
                while (true) {
                    if (args.members.length > 0xffff) {
                        this.reportParseError("max number of args exceeded");
                        break;
                    }

                    var arg = this.parseExpr(
                        ErrorRecoverySet.Comma | errorRecoverySet,
                        OperatorPrecedence.Comma,
                        /*allowIn:*/ true,
                        TypeContext.NoTypes);

                    args.append(arg);
                    if (this.currentToken.tokenId != TokenID.Comma) {
                        break;
                    }

                    this.currentToken = this.scanner.scan();
                }
            }

            args.limChar = this.scanner.pos;
            return args;
        }

        private parseBaseList(extendsList: ASTList,
            implementsList: ASTList,
            errorRecoverySet: ErrorRecoverySet,
            isClass: bool): void {
            var keyword = true;
            var currentList = extendsList;
            for (; ;) {
                if (keyword) {
                    if (this.currentToken.tokenId === TokenID.Implements) {
                        currentList = implementsList;
                    }
                    else if (this.currentToken.tokenId == TokenID.Extends && !this.requiresExtendsBlock) {
                        this.requiresExtendsBlock = isClass;
                    }
                    this.currentToken = this.scanner.scan();
                    keyword = false;
                }
                var baseName: Identifier = null;
                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                    var minChar = this.scanner.startPos;
                    baseName = Identifier.fromToken(this.currentToken);
                    baseName.minChar = minChar;
                    baseName.limChar = this.scanner.pos;
                    baseName = <Identifier>this.parseNamedType(errorRecoverySet | ErrorRecoverySet.LCurly,
                                            minChar, baseName, false);
                }
                else {
                    this.reportParseError("Expected base name");
                    if (this.errorRecovery) {
                        baseName = new MissingIdentifier();
                        baseName.minChar = this.scanner.pos;
                        baseName.limChar = this.scanner.pos;
                        baseName.flags |= ASTFlags.Error;
                    }
                }
                if (this.currentToken.tokenId == TokenID.OpenParen) {
                    if (isClass) {
                        this.reportParseError("Base classes may only be initialized via a 'super' call within the constructor body");
                    }
                    else {
                        this.reportParseError("Interfaces may not be extended with a call expression");
                    }
                }
                else {
                    currentList.append(baseName);
                }

                if (isClass && currentList == extendsList && extendsList.members.length > 1) {
                    this.reportParseError("A class may only extend one other class");
                }

                if (this.currentToken.tokenId == TokenID.Comma) {
                    this.currentToken = this.scanner.scan();
                    continue;
                }

                else if ((this.currentToken.tokenId == TokenID.Extends) ||
                         (this.currentToken.tokenId == TokenID.Implements)) {

                    if (this.currentToken.tokenId == TokenID.Extends && !this.requiresExtendsBlock) {
                        this.requiresExtendsBlock = isClass;
                    }

                    currentList = extendsList;
                    keyword = true;
                    continue;
                }

                break;
            }
        }

        private parseClassDecl(errorRecoverySet: ErrorRecoverySet, minChar: number, modifiers: Modifiers): ClassDeclaration {
            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;

            if ((modifiers & Modifiers.Readonly) != Modifiers.None) {
                this.reportParseError("const modifier is implicit for class");
            }

            // mark the class as ambient, as necessary
            if (this.parsingDeclareFile || this.ambientModule) {
                modifiers |= Modifiers.Ambient;
                modifiers |= Modifiers.Exported;
            }

            var classIsMarkedAsAmbient = this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None;
            var svAmbientClass = this.ambientClass;
            this.ambientClass = classIsMarkedAsAmbient;

            // grab the class's name
            this.currentToken = this.scanner.scan();
            var name: Identifier = null;
            if ((this.currentToken.tokenId == TokenID.Identifier) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode))) {
                name = Identifier.fromToken(this.currentToken);
                name.minChar = this.scanner.startPos;
                name.limChar = this.scanner.pos;
                this.currentToken = this.scanner.scan();
            }
            else {
                this.reportParseError("class missing name");
                if (this.errorRecovery) {
                    name = new MissingIdentifier();
                    name.minChar = this.scanner.pos;
                    name.limChar = this.scanner.pos;
                    name.flags |= ASTFlags.Error;
                }
            }

            var extendsList: ASTList = null;
            var implementsList: ASTList = null;
            var requiresSignature = false;

            if ((this.currentToken.tokenId == TokenID.Extends) ||
                (this.currentToken.tokenId == TokenID.Implements)) {
                extendsList = new ASTList();
                implementsList = new ASTList();
                this.parseBaseList(extendsList, implementsList, errorRecoverySet, /*isClass:*/ true);
            }

            // REVIEW: Note that we don't set this as the current class decl
            var classDecl = new ClassDeclaration(name, null, new ASTList(), extendsList, implementsList);

            this.currentClassDefinition = classDecl;

            // parse the classes members
            this.parseClassElements(classDecl, errorRecoverySet, modifiers);

            if (this.ambientModule || this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Exported)) {
                classDecl.varFlags |= VarFlags.Exported;
            }

            if (this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {
                classDecl.varFlags |= VarFlags.Ambient;
            }

            classDecl.varFlags |= VarFlags.Class;

            this.ambientClass = svAmbientClass;
            classDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            classDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            return classDecl;
        }

        private parseClassElements(classDecl: ClassDeclaration, errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers) {
            var modifiers = parentModifiers;
            var resetModifiers = false;

            var membersMinChar = this.scanner.startPos;
            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet);

            this.nestingLevel++;

            var currentMemberMinChar = this.scanner.startPos;
            var wasGetOrSetId = false;

            while (!(this.currentToken.tokenId == TokenID.CloseBrace || this.currentToken.tokenId == TokenID.EndOfFile)) {
                var scanNext = true;
                var publicOrPrivateFlags = Modifiers.Public | Modifiers.Private;

                // modifiers
                if (this.currentToken.tokenId == TokenID.Get) {
                    if (modifiers & Modifiers.Getter) {
                        this.reportParseError("Duplicate 'get' declaration in class body");
                    }
                    if (modifiers & Modifiers.Setter) {
                        this.reportParseError("Getter already marked as a setter");
                    }
                    modifiers |= Modifiers.Getter;
                }
                else if (this.currentToken.tokenId == TokenID.Set) {
                    if (modifiers & Modifiers.Setter) {
                        this.reportParseError("Duplicate 'set' declaration in class body");
                    }
                    if (modifiers & Modifiers.Getter) {
                        this.reportParseError("Setter already marked as a getter");
                    }
                    modifiers |= Modifiers.Setter;

                }
                else if (this.currentToken.tokenId == TokenID.Private) {
                    if (modifiers & publicOrPrivateFlags) {
                        this.reportParseError("Multiple modifiers may not be applied to class members");
                    }
                    modifiers |= Modifiers.Private;
                }
                else if (this.currentToken.tokenId == TokenID.Public) {
                    if (modifiers & publicOrPrivateFlags) {
                        this.reportParseError("Multiple modifiers may not be applied to class members");
                    }
                    modifiers |= Modifiers.Public;
                }
                else if (this.currentToken.tokenId == TokenID.Static) {
                    if (modifiers & Modifiers.Static) { // only check for double instances of static
                        this.reportParseError("Multiple modifiers may not be applied to class members");
                    }
                    modifiers |= Modifiers.Static;
                }  // constructors
                else if (this.currentToken.tokenId == TokenID.Constructor) {

                    if (modifiers != parentModifiers) {
                        this.reportParseError("Constructors may not have modifiers");
                    }

                    this.parseClassConstructorDeclaration(currentMemberMinChar, errorRecoverySet, modifiers);
                    scanNext = false; // parsing functions advances the token for us
                    resetModifiers = true;
                }  // member declarations
                else if (wasGetOrSetId || this.currentToken.tokenId == TokenID.Identifier || convertTokToIDName(this.currentToken)) {

                    var idText = wasGetOrSetId ? ((modifiers & Modifiers.Getter) ? "get" : "set") : this.currentToken.getText();
                    var id = wasGetOrSetId ? new Identifier(idText) : Identifier.fromToken(this.currentToken);
                    id.minChar = this.scanner.startPos;
                    id.limChar = this.scanner.pos;

                    // unset the get/set bit, if we're using it for an id
                    if (wasGetOrSetId) {
                        modifiers = modifiers ^ ((modifiers & Modifiers.Getter) ? Modifiers.Getter : Modifiers.Setter);
                        wasGetOrSetId = false;
                    }
                    else {
                        this.currentToken = this.scanner.scan();
                    }

                    if (this.currentToken.tokenId == TokenID.OpenParen) {
                        this.parseClassMemberFunctionDeclaration(id, currentMemberMinChar, errorRecoverySet, modifiers);
                        scanNext = false; // parsing functions advances the token for us
                    }
                    else {
                        if (modifiers & Modifiers.Getter || modifiers & Modifiers.Setter) {
                            this.reportParseError("Property accessors must be functions");
                        }

                        var varDecl = this.parseClassMemberVariableDeclaration(id, currentMemberMinChar, false, errorRecoverySet, modifiers);

                        if (varDecl.init && varDecl.init.nodeType == NodeType.FuncDecl) {
                            if (this.currentToken.tokenId == TokenID.CloseBrace) {
                                scanNext = false;
                            }
                        }
                        else if (varDecl.init && varDecl.init.nodeType == NodeType.ObjectLit && this.currentToken.tokenId != TokenID.Semicolon) {
                            scanNext = false;
                            varDecl.init.flags |= ASTFlags.AutomaticSemicolon;
                        }
                        else if (this.currentToken.tokenId != TokenID.Semicolon) {
                            this.reportParseError("Expected ';'");
                            scanNext = false;
                        }
                    }

                    resetModifiers = true;
                } // catch errant uses of 'super'
                else if (this.currentToken.tokenId == TokenID.Super) {
                    this.reportParseError("Base class initializers must be the first statement in a class definition");
                }
                else if (!wasGetOrSetId && ((modifiers & Modifiers.Getter) || (modifiers & Modifiers.Setter)) &&
                         ((this.currentToken.tokenId == TokenID.OpenParen) || (this.currentToken.tokenId == TokenID.Equals) ||
                          (this.currentToken.tokenId == TokenID.Colon) || (this.currentToken.tokenId == TokenID.Semicolon))) {
                    // catch a 'get' or 'set' used as an identifier
                    wasGetOrSetId = true;
                    scanNext = false;

                }  // mark anything else as an error
                else if (this.currentToken.tokenId != TokenID.Semicolon) { // jettison semicolons
                    this.reportParseError("Unexpected '" + this.currentToken.getText() + "' in class definition");
                    resetModifiers = true;
                }

                if (scanNext) {
                    this.currentToken = this.scanner.scan();
                }

                if (resetModifiers) {
                    modifiers = parentModifiers;
                    currentMemberMinChar = this.scanner.startPos;
                    resetModifiers = false;
                }
            }

            var membersLimChar = this.scanner.pos;
            if (this.currentToken.tokenId == TokenID.CloseBrace) {
                classDecl.endingToken = new ASTSpan();
                classDecl.endingToken.minChar = this.scanner.startPos;
                classDecl.endingToken.limChar = this.scanner.pos;

                // for a class with an empty body, consume any 'dangling' inner comments
                if (!this.currentClassDefinition.members.members.length) {
                    this.currentClassDefinition.preComments = this.parseComments();
                }

                this.currentToken = this.scanner.scan();
            }

            this.nestingLevel--;

            this.currentClassDefinition.members.minChar = membersMinChar;
            this.currentClassDefinition.members.limChar = membersLimChar;
            this.currentClassDefinition.limChar = membersLimChar;
            this.currentClassDefinition = null;
        }

        private parseClassConstructorDeclaration(minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {
            this.parsingClassConstructorDefinition = true;

            var isAmbient = this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient);

            var args: ASTList = new ASTList();
            var variableArgList = false;
            var preComments = this.parseComments();

            var constructorSpan = new ASTSpan();
            constructorSpan.minChar = this.scanner.startPos;
            constructorSpan.limChar = this.scanner.pos;

            this.currentToken = this.scanner.scan(); // scan past the 'constructor' token

            if (this.currentToken.tokenId == TokenID.OpenParen) {
                variableArgList = this.parseFormalParameterList(errorRecoverySet, args, true, isAmbient, false, false, false, false, null, true);
                if (args.members.length > 0) {
                    var lastArg = args.members[args.members.length - 1];
                }
            }

            var requiresSignature = isAmbient || this.currentToken.tokenId == TokenID.Semicolon;


            if (requiresSignature) {
                for (var i = 0; i < args.members.length; i++) {
                    var arg = <ArgDecl> args.members[i];
                    if (hasFlag(arg.varFlags, VarFlags.Property)) {
                        this.reportParseError("Overload or ambient signatures may not specify parameter properties", arg.minChar, arg.limChar);
                    }
                }
            }

            if (!requiresSignature) {
                this.currentClassDefinition.constructorNestingLevel = this.nestingLevel + 1;
            }

            var constructorFuncDecl = this.parseFunctionStatements(
                errorRecoverySet | ErrorRecoverySet.RCurly, this.currentClassDefinition.name,
                /*isConstructor:*/ true, /*isMethod:*/ false, args, AllowedElements.Properties,
                minChar, requiresSignature, modifiers);
            constructorFuncDecl.constructorSpan = constructorSpan;
            constructorFuncDecl.preComments = preComments;

            if (requiresSignature && !isAmbient) {
                constructorFuncDecl.isOverload = true;
            }

            constructorFuncDecl.variableArgList = variableArgList;
            this.currentClassDecl = null;
            constructorFuncDecl.returnTypeAnnotation = this.convertToTypeReference(this.currentClassDefinition.name);
            constructorFuncDecl.classDecl = this.currentClassDefinition;

            if (isAmbient) {
                constructorFuncDecl.fncFlags |= FncFlags.Ambient;
            }

            if (requiresSignature) {
                constructorFuncDecl.fncFlags |= FncFlags.Signature;
            }

            if (this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {
                constructorFuncDecl.fncFlags |= FncFlags.Exported;
            }

            if (this.currentClassDefinition.constructorDecl) {
                if (!isAmbient && !this.currentClassDefinition.constructorDecl.isSignature() && !constructorFuncDecl.isSignature()) {
                    this.reportParseError("Duplicate constructor definition");
                }
            }

            if (isAmbient || !constructorFuncDecl.isSignature()) {
                this.currentClassDefinition.constructorDecl = constructorFuncDecl;
            }

            // REVIEW: Should we have a separate flag for class constructors?  (Constructors are not methods)
            constructorFuncDecl.fncFlags |= FncFlags.ClassMethod;

            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = constructorFuncDecl;

            this.parsingClassConstructorDefinition = false;

            return constructorFuncDecl;
        }

        private parseClassMemberVariableDeclaration(text: Identifier, minChar: number, isDeclaredInConstructor: bool, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {

            var varDecl = new VarDecl(text, this.nestingLevel);
            varDecl.minChar = minChar;
            var isStatic = false;
            varDecl.preComments = this.parseComments();

            varDecl.varFlags |= VarFlags.ClassProperty;

            if (this.currentToken.tokenId == TokenID.Colon) {
                this.currentToken = this.scanner.scan();
                varDecl.typeExpr =
                    this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg | ErrorRecoverySet.Comma, false);
                if (varDecl.typeExpr && varDecl.typeExpr.nodeType == NodeType.TypeRef) {
                    var typeExpr = (<TypeReference>varDecl.typeExpr);
                    if (typeExpr.term && typeExpr.term.nodeType == NodeType.FuncDecl) {
                        typeExpr.term.preComments = varDecl.preComments;
                    }
                }
            }

            if (this.currentToken.tokenId == TokenID.Equals) {
                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {
                    this.reportParseError("context does not permit variable initializer");
                    if (this.errorRecovery) {
                        this.skip(errorRecoverySet);
                        varDecl.flags |= ASTFlags.Error;
                        varDecl.limChar = this.scanner.lastTokenLimChar();
                        return varDecl;
                    }
                }

                // TODO: note assignment for language service
                this.currentToken = this.scanner.scan();

                varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,
                                        OperatorPrecedence.Comma, true, TypeContext.NoTypes);

                varDecl.limChar = varDecl.init.limChar;

                // member initializers on instance properties require that super be invoked as the first call within the constructor
                if (!(modifiers & Modifiers.Static)) {
                    this.currentClassDefinition.varFlags |= VarFlags.ClassSuperMustBeFirstCallInConstructor;
                }
            }
            else {
                varDecl.limChar = this.scanner.pos;
            }

            if (modifiers & Modifiers.Static) {
                varDecl.varFlags |= VarFlags.Static;
                isStatic = true;
            }

            if ((modifiers & Modifiers.Private) != Modifiers.None) {
                varDecl.varFlags |= VarFlags.Private;
            }
            else {
                varDecl.varFlags |= VarFlags.Public;
            }

            varDecl.varFlags |= VarFlags.Property;

            if (isDeclaredInConstructor) {
                varDecl.varFlags |= VarFlags.ClassConstructorProperty;
            }

            if (!isDeclaredInConstructor && !isStatic) {
                varDecl.varFlags |= VarFlags.ClassBodyProperty;
            }

            this.currentClassDefinition.knownMemberNames[text.actualText] = true;

            if (!isDeclaredInConstructor) {
                this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = varDecl;
            }

            varDecl.postComments = this.parseComments();
            return varDecl;
        }

        private parseClassMemberFunctionDeclaration(methodName: Identifier, minChar: number, errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers) {
            var wasAccessorID = this.prevIDTok != null;
            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);
            var isStatic = hasFlag(modifiers, Modifiers.Static);

            var isAmbient = this.ambientModule || hasFlag(modifiers, Modifiers.Ambient);

            errorRecoverySet |= ErrorRecoverySet.RParen;

            if (isAccessor && (modifiers & Modifiers.Ambient)) {
                this.reportParseError("Property accessors may not be declared in ambient classes");
            }

            // REVIEW: Why bother passing in isAmbient for both requiresSignature and isAmbient?  Shouldn't just saying its ambient suffice?
            var ast: AST = this.parseFncDecl(errorRecoverySet, true, isAmbient, true, methodName, false, isStatic, isAmbient, modifiers, null, true);
            if (ast.nodeType == NodeType.Error) {
                return ast;
            }

            var funcDecl = <FuncDecl>ast;

            funcDecl.minChar = minChar;
            if (funcDecl.bod !== null)
                funcDecl.limChar = funcDecl.bod.limChar;

            if (modifiers & Modifiers.Private) {
                funcDecl.fncFlags |= FncFlags.Private;
            }
            else {
                funcDecl.fncFlags |= FncFlags.Public;
            }

            if (isStatic) {
                funcDecl.fncFlags |= FncFlags.Static;
            }

            if (isAccessor) {
                // REVIEW: verify return-type annotations and arguments
                if (hasFlag(modifiers, Modifiers.Getter)) {
                    funcDecl.fncFlags |= FncFlags.GetAccessor;
                    funcDecl.hint = "get" + funcDecl.name.actualText;
                }
                else {
                    funcDecl.fncFlags |= FncFlags.SetAccessor;
                    funcDecl.hint = "set" + funcDecl.name.actualText;
                }
                funcDecl.fncFlags |= FncFlags.IsFunctionExpression;
                if (codeGenTarget < CodeGenTarget.ES5) {
                    this.reportParseError("Property accessors are only available when targeting ES5 or greater", funcDecl.minChar, funcDecl.limChar);
                }
            }

            funcDecl.fncFlags |= FncFlags.ClassMethod;

            this.currentClassDefinition.knownMemberNames[methodName.actualText] = true;

            this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = funcDecl;

            return funcDecl;
        }

        private parseTypeMember(errorRecoverySet: ErrorRecoverySet): AST {
            var minChar = this.scanner.startPos;

            var propertyDecl = this.parsePropertyDeclaration(
                errorRecoverySet, Modifiers.Public, /*requireSignature:*/ true, /*isStatic:*/ false);

            if (propertyDecl) {
                propertyDecl.minChar = minChar;

                if (propertyDecl.nodeType == NodeType.VarDecl) {
                    this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet);
                }
            }

            return propertyDecl;
        }

        private parseTypeMemberList(errorRecoverySet: ErrorRecoverySet, members: ASTList) {
            errorRecoverySet |= ErrorRecoverySet.TypeScriptS;
            while (true) {
                switch (this.currentToken.tokenId) {
                    case TokenID.CloseBrace:
                    case TokenID.EndOfFile:
                        members.limChar = this.scanner.pos;
                        return;
                }

                // REVIEW: This code looks suspect.  If parseTypeMember returns null, then 
                // won't we just infinite loop?
                var element = this.parseTypeMember(errorRecoverySet);
                if (element) {
                    members.append(element);
                }
            }
        }

        private parseInterfaceDecl(errorRecoverySet: ErrorRecoverySet, modifiers: Modifiers): InterfaceDeclaration {
            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;

            this.currentToken = this.scanner.scan();
            var minChar = this.scanner.pos;
            var name: Identifier = null;
            if ((this.currentToken.tokenId == TokenID.Identifier) || (!isPrimitiveTypeToken(this.currentToken) && convertTokToID(this.currentToken, this.strictMode))) {
                name = Identifier.fromToken(this.currentToken);
                name.minChar = this.scanner.startPos;
                name.limChar = this.scanner.pos;
                this.currentToken = this.scanner.scan();
            }
            else {
                this.reportParseError("interface missing name");
                if (this.errorRecovery) {
                    name = new MissingIdentifier();
                    name.minChar = this.scanner.pos;
                    name.limChar = this.scanner.pos;
                    name.flags |= ASTFlags.Error;
                }
            }

            var extendsList: ASTList = null;
            var implementsList: ASTList = null;
            if (this.currentToken.tokenId === TokenID.Extends || this.currentToken.tokenId === TokenID.Implements) {
                if (this.currentToken.tokenId === TokenID.Implements) {
                    this.reportParseError("Expected 'extends'");
                }

                extendsList = new ASTList();
                implementsList = new ASTList();
                extendsList.minChar = this.scanner.startPos;
                this.parseBaseList(extendsList, implementsList, errorRecoverySet, /*isClass:*/ false);
            }

            var membersMinChar = this.scanner.startPos;
            this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.TypeScriptS);
            var members = new ASTList();
            members.minChar = membersMinChar;
            var prevInInterfaceDecl = this.inInterfaceDecl;
            this.inInterfaceDecl = true;
            this.parseTypeMemberList(errorRecoverySet | ErrorRecoverySet.RCurly, members);
            this.inInterfaceDecl = prevInInterfaceDecl;
            this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);

            // REVIEW: According to the grammar, an interface declaration should actually just
            // have an 'ObjectType' and not a list of members.  We may want to consider making that
            // change.  Note: it would mean breaking aparat TypeDecl into InterfaceDeclaration and 
            // ClassDeclaration.
            var interfaceDecl = new InterfaceDeclaration(name, null, members, extendsList, null);
            if (hasFlag(modifiers, Modifiers.Private)) {
                interfaceDecl.varFlags |= VarFlags.Private;
            }
            if (hasFlag(modifiers, Modifiers.Public)) {
                interfaceDecl.varFlags |= VarFlags.Public;
            }
            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {
                interfaceDecl.varFlags |= VarFlags.Exported;
            } 

            interfaceDecl.limChar = members.limChar;
            interfaceDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            interfaceDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            return interfaceDecl;
        }

        private makeVarDecl(id: Identifier, nest: number): VarDecl {
            var varDecl = new VarDecl(id, nest);
            var currentVarList = this.topVarList();
            if (currentVarList) {
                currentVarList.append(varDecl);
            }
            return varDecl;
        }

        private parsePropertyDeclaration(
            errorRecoverySet: ErrorRecoverySet,
            modifiers: Modifiers,
            requireSignature: bool,
            isStatic: bool): AST {

            var text: Identifier = null;
            var minChar = this.scanner.startPos;
            var nameLimChar = minChar;
            var isNew = false;
            var isIndexer = false;
            var wasAccessorID = this.prevIDTok != null;
            var isAccessor = hasFlag(modifiers, Modifiers.Getter) || hasFlag(modifiers, Modifiers.Setter);

            if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {
                requireSignature = true;
            }

            if (this.currentToken.tokenId == TokenID.OpenParen && !wasAccessorID) {
                if (!requireSignature && !isStatic) {
                    this.reportParseError("Expected identifier in property declaration");
                    if (this.errorRecovery) {
                        this.skip(errorRecoverySet);
                        //REVIEW: Use something else than "Identifier"?
                        text = new MissingIdentifier();
                    }
                }
            }
            else if (this.currentToken.tokenId == TokenID.New) {
                if (requireSignature) {
                    this.currentToken = this.scanner.scan();
                    if (this.currentToken.tokenId == TokenID.OpenParen) {
                        isNew = true;
                    }
                }

                if (!isNew) {
                    // is identifier
                    if (!requireSignature) {
                        this.currentToken = this.scanner.scan();
                    }
                    text = new Identifier("new");
                    text.minChar = this.scanner.pos - 3;
                    text.limChar = this.scanner.pos;
                    nameLimChar = this.scanner.pos;
                }
            }
            else if ((this.currentToken.tokenId == TokenID.OpenBracket) && requireSignature) {
                // indexer signature
                isIndexer = true;
                //REVIEW: Should we use a special "compiler reserved" identifier node?
                text = new Identifier("__item");
            }
            else if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToIDName(this.currentToken)) && !wasAccessorID) {
                this.reportParseError("Expected identifier in property declaration");
                if (this.errorRecovery) {
                    var eminChar = this.scanner.startPos;
                    var curpos = this.scanner.pos;
                    this.skip(errorRecoverySet & (~ErrorRecoverySet.Comma));
                    if (this.scanner.pos == curpos) {
                        // ensure progress
                        this.currentToken = this.scanner.scan();
                    }

                    var epd = new VarDecl(new MissingIdentifier(), this.nestingLevel);
                    epd.flags |= ASTFlags.Error;
                    epd.minChar = eminChar;
                    epd.limChar = this.scanner.lastTokenLimChar();
                    return epd;
                }
            }
            else {
                if (wasAccessorID) {
                    text = Identifier.fromToken(this.prevIDTok);
                    text.minChar = this.scanner.lastTokenLimChar() - 3;
                    text.limChar = this.scanner.lastTokenLimChar();
                    nameLimChar = text.limChar;

                    if (codeGenTarget < CodeGenTarget.ES5) {
                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                    }

                    // this block guards against 'get' and 'set' tokens that
                    // were coerced into identifiers
                    if (this.currentToken.getText() == text.actualText && this.currentToken != this.prevIDTok) {
                        this.currentToken = this.scanner.scan();
                    } // Otherwise, don't update the token - we're already at '('

                    // reset the previous ID Token
                    this.prevIDTok = null;
                }
                else {
                    text = Identifier.fromToken(this.currentToken);
                    text.minChar = this.scanner.startPos;
                    text.limChar = this.scanner.pos;
                    nameLimChar = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                }
            }

            if (this.currentToken.tokenId == TokenID.Question) {
                if (this.inInterfaceDecl && text) {
                    text.flags |= ASTFlags.OptionalName;
                }
                else {
                    this.reportParseError("Optional properties may only be declared on interface or object types");
                }
                this.currentToken = this.scanner.scan();
            }

            if ((this.currentToken.tokenId == TokenID.OpenParen) ||
                (isIndexer && (this.currentToken.tokenId == TokenID.OpenBracket))) {
                var ers = errorRecoverySet | ErrorRecoverySet.RParen;
                if (isIndexer) {
                    ers = errorRecoverySet | ErrorRecoverySet.RBrack;
                }
                var ast = this.parseFncDecl(ers, true, requireSignature,
                                       this.currentClassDefinition || this.inInterfaceDecl, text, isIndexer, isStatic, (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)), modifiers, null, true);
                var funcDecl: FuncDecl;
                if (ast.nodeType == NodeType.Error) {
                    return ast;
                }
                else {
                    funcDecl = <FuncDecl>ast;
                }
                if (funcDecl.name) {
                    funcDecl.name.minChar = minChar;
                    funcDecl.name.limChar = nameLimChar;
                }
                if ((modifiers & Modifiers.Public) != Modifiers.None) {
                    funcDecl.fncFlags |= FncFlags.Public;
                }
                if ((modifiers & Modifiers.Private) != Modifiers.None) {
                    funcDecl.fncFlags |= FncFlags.Private;
                }
                if (isStatic) {
                    funcDecl.fncFlags |= FncFlags.Static;
                }
                if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {
                    funcDecl.fncFlags |= FncFlags.Ambient;
                }
                if (isAccessor) {
                    // REVIEW: verify return-type annotations and arguments
                    if (hasFlag(modifiers, Modifiers.Getter)) {
                        funcDecl.fncFlags |= FncFlags.GetAccessor;
                        funcDecl.hint = "get" + funcDecl.name.actualText;
                    }
                    else {
                        funcDecl.fncFlags |= FncFlags.SetAccessor;
                        funcDecl.hint = "set" + funcDecl.name.actualText;
                    }
                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;

                    if (modifiers & Modifiers.Ambient) {
                        this.reportParseError("Property accessors may not be declared in ambient types");
                    }
                }

                if (text == null) {
                    if (isNew) {
                        funcDecl.fncFlags |= FncFlags.ConstructMember;
                        funcDecl.hint = "_construct";
                        funcDecl.classDecl = this.currentClassDecl;
                    }
                    else {
                        funcDecl.hint = "_call";
                        funcDecl.fncFlags |= FncFlags.CallMember;
                    }
                }
                return funcDecl;
            }
            else {
                var varDecl = new VarDecl(text, this.nestingLevel);
                varDecl.preComments = this.parseComments();
                varDecl.minChar = minChar;
                if (this.currentToken.tokenId == TokenID.Colon) {
                    this.currentToken = this.scanner.scan();
                    varDecl.typeExpr =
                        this.parseTypeReference(errorRecoverySet | ErrorRecoverySet.Asg |
                                           ErrorRecoverySet.Comma, false);
                    if (varDecl.typeExpr && varDecl.typeExpr.nodeType == NodeType.TypeRef) {
                        var typeExpr = (<TypeReference>varDecl.typeExpr);
                        if (typeExpr.term && typeExpr.term.nodeType == NodeType.FuncDecl) {
                            typeExpr.term.preComments = varDecl.preComments;
                        }
                    }
                }
                if (this.currentToken.tokenId == TokenID.Equals) {
                    if (requireSignature) {
                        this.reportParseError("context does not permit variable initializer");
                        if (this.errorRecovery) {
                            this.skip(errorRecoverySet);
                            varDecl.flags |= ASTFlags.Error;
                            varDecl.limChar = this.scanner.lastTokenLimChar();
                            return varDecl;
                        }
                    }
                    // TODO: note assignment for language service
                    this.currentToken = this.scanner.scan();
                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,
                                           OperatorPrecedence.Comma, true, TypeContext.NoTypes);
                    varDecl.limChar = varDecl.init.limChar;
                    if (varDecl.init.nodeType == NodeType.FuncDecl) {
                        var funcDecl = <FuncDecl>varDecl.init;
                        funcDecl.hint = varDecl.id.text;
                        funcDecl.boundToProperty = varDecl;
                    }
                    else if (isAccessor) {
                        this.reportParseError("Accessors may only be functions");
                    }
                }
                else {
                    varDecl.limChar = this.scanner.pos;
                }
                if ((modifiers & Modifiers.Readonly) != Modifiers.None) {
                    varDecl.varFlags |= VarFlags.Readonly;
                }
                if (isStatic) {
                    varDecl.varFlags |= VarFlags.Static;
                }
                if ((modifiers & Modifiers.Public) != Modifiers.None) {
                    varDecl.varFlags |= VarFlags.Public;
                }
                if ((modifiers & Modifiers.Private) != Modifiers.None) {
                    varDecl.varFlags |= VarFlags.Private;
                }
                varDecl.varFlags |= VarFlags.Property;
                return varDecl;
            }
        }

        private parseVariableDeclaration(
            errorRecoverySet: ErrorRecoverySet,
            modifiers: Modifiers,
            allowIn: bool,
            isStatic: bool): AST {

            var isConst = hasFlag(modifiers, Modifiers.Readonly);
            var minChar = this.scanner.startPos;
            var varDecl: VarDecl = null;
            var declList: ASTList = null;
            var multivar = false;

            this.currentToken = this.scanner.scan();
            var varDeclPreComments = this.parseComments();

            while (true) {
                if ((this.currentToken.tokenId != TokenID.Identifier) && (!convertTokToID(this.currentToken, this.strictMode))) {
                    this.reportParseError("Expected identifier in variable declaration");

                    if (this.errorRecovery) {
                        varDecl = new VarDecl(new MissingIdentifier(), this.nestingLevel);
                        varDecl.minChar = minChar;
                        this.skip(errorRecoverySet);
                        varDecl.flags |= ASTFlags.Error;
                        varDecl.limChar = this.scanner.lastTokenLimChar();
                        return varDecl;
                    }
                }

                var varDeclName = Identifier.fromToken(this.currentToken)
                if (this.strictMode && (varDeclName.text == "eval")) {
                    this.reportParseError("'eval' may not name a variable in strict mode");
                }

                varDecl = this.makeVarDecl(varDeclName, this.nestingLevel);
                varDecl.id.minChar = this.scanner.startPos;
                varDecl.id.limChar = this.scanner.pos;
                varDecl.preComments = varDeclPreComments;

                if (isStatic) {
                    varDecl.varFlags |= VarFlags.Static;
                }
                if (hasFlag(modifiers, Modifiers.Readonly)) {
                    varDecl.varFlags |= VarFlags.Readonly;
                }
                if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {
                    varDecl.varFlags |= VarFlags.Ambient;
                }
                if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {
                    varDecl.varFlags |= VarFlags.Exported;
                }

                varDecl.minChar = minChar;
                if (declList) {
                    declList.append(varDecl);
                }

                // move past ID; with error recovery need a test 
                this.currentToken = this.scanner.scan();
                if (this.currentToken.tokenId == TokenID.Colon) {
                    this.currentToken = this.scanner.scan();
                    var prevInFncDecl = this.inFncDecl;
                    this.inFncDecl = false;
                    varDecl.typeExpr = this.parseTypeReference(
                        errorRecoverySet | ErrorRecoverySet.Asg | ErrorRecoverySet.Comma, /*allowVoid:*/ false);
                    this.inFncDecl = prevInFncDecl;
                }

                if (this.currentToken.tokenId == TokenID.Equals) {
                    if (hasFlag(varDecl.varFlags, VarFlags.Ambient)) {
                        this.reportParseError("Ambient variable can not have an initializer");
                    }

                    // TODO: note assignment for language service
                    this.currentToken = this.scanner.scan();
                    varDecl.init = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,
                                           OperatorPrecedence.Comma, allowIn,
                                           TypeContext.NoTypes);
                    varDecl.limChar = varDecl.init.limChar;

                    if (varDecl.init.nodeType == NodeType.FuncDecl) {
                        // TODO: use 'as' operator when can bootstrap
                        var funcDecl = <FuncDecl>varDecl.init;
                        funcDecl.hint = varDecl.id.actualText;
                    }
                }
                else {
                    if (isConst) {
                        this.reportParseError("const declaration requires initializer");
                    }
                    varDecl.limChar = this.scanner.pos;
                }
                varDecl.postComments = this.parseCommentsForLine(this.scanner.line);

                if (this.currentToken.tokenId != TokenID.Comma) {
                    if (declList) {
                        declList.limChar = varDecl.limChar;
                        return declList;
                    }
                    else {
                        return varDecl;
                    }
                }

                if (!multivar) {
                    declList = new ASTList();
                    declList.minChar = varDecl.minChar;
                    declList.append(varDecl);
                    multivar = true;
                }

                this.currentToken = this.scanner.scan();
                minChar = this.scanner.startPos;
            }
        }

        private parseMemberList(errorRecoverySet: ErrorRecoverySet): ASTList {
            var elements = new ASTList();
            if (this.currentToken.tokenId == TokenID.CloseBrace) {
                return elements;
            }

            var idHint: string = null;
            var memberName: AST = null;
            var memberExpr: AST = null;
            var member: BinaryExpression = null;
            var minChar = this.scanner.startPos;
            var isSet = false;
            var skippedTokenForGetSetId = false;
            var getSetTok: Token = null;
            var getSetStartPos = 0;
            var getSetPos = 0;

            for (; ;) {
                var accessorPattern = false;
                if (this.currentToken.tokenId == TokenID.Get || this.currentToken.tokenId == TokenID.Set) {
                    isSet = this.currentToken.tokenId == TokenID.Set;
                    getSetTok = this.currentToken;
                    getSetStartPos = this.scanner.startPos;
                    getSetPos = this.scanner.pos;

                    this.currentToken = this.scanner.scan();

                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {
                        idHint = isSet ? "set" : "get";
                        idHint = idHint + this.currentToken.getText();
                        memberName = Identifier.fromToken(this.currentToken);
                        memberName.minChar = this.scanner.startPos;
                        accessorPattern = true;
                        if (codeGenTarget < CodeGenTarget.ES5) {
                            this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                        }
                    }
                    else if (this.currentToken.tokenId != TokenID.Colon) {
                        this.reportParseError("Expected identifier, string or number as accessor name");
                    }
                    else {
                        skippedTokenForGetSetId = true;
                        memberName = Identifier.fromToken(getSetTok);
                        memberName.minChar = getSetStartPos;
                        memberName.limChar = getSetPos;
                    }
                }
                else if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToIDName(this.currentToken)) {
                    idHint = this.currentToken.getText();
                    memberName = Identifier.fromToken(this.currentToken);
                    memberName.minChar = this.scanner.startPos;
                    memberName.limChar = this.scanner.pos;
                }
                else if (this.currentToken.tokenId == TokenID.StringLiteral) {
                    idHint = this.currentToken.getText();
                    memberName = new StringLiteral(idHint);
                    memberName.minChar = this.scanner.startPos;
                    memberName.limChar = this.scanner.pos;
                }
                    // TODO: allow reserved words
                else if (this.currentToken.tokenId == TokenID.NumberLiteral) {
                    var ntok = <NumberLiteralToken>this.currentToken;
                    idHint = ntok.value.toString();
                    memberName = new StringLiteral(idHint);
                    memberName.minChar = this.scanner.startPos;
                    memberName.limChar = this.scanner.pos;
                }
                else {
                    this.reportParseError("Expected identifier, string or number as member name");
                    if (this.errorRecovery) {
                        memberName = new MissingIdentifier();
                        memberName.minChar = this.scanner.startPos;
                        memberName.flags |= ASTFlags.Error;
                        this.skip(errorRecoverySet | ErrorRecoverySet.Comma);
                        memberName.limChar = this.scanner.lastTokenLimChar();
                    }
                }

                if (!skippedTokenForGetSetId) {
                    this.currentToken = this.scanner.scan();
                }
                else {
                    skippedTokenForGetSetId = false;
                }

                if (this.currentToken.tokenId == TokenID.Question) {
                    memberName.flags |= ASTFlags.OptionalName;
                    this.currentToken = this.scanner.scan();
                }

                if (accessorPattern) {
                    var args = new ASTList();
                    this.parseFormalParameterList(errorRecoverySet | ErrorRecoverySet.RParen,
                                      args, false, true, false, !isSet, isSet, false, null, true);

                    var funcDecl: FuncDecl =
                        this.parseFunctionStatements(errorRecoverySet | ErrorRecoverySet.RCurly,
                                                <Identifier>memberName, false, true, args,
                                                AllowedElements.None,
                                                this.scanner.startPos, false, Modifiers.None);

                    if (isSet && funcDecl.returnTypeAnnotation) {
                        this.reportParseError("Property setters may not declare a return type");
                    }

                    funcDecl.fncFlags |= isSet ? FncFlags.SetAccessor : FncFlags.GetAccessor;
                    funcDecl.fncFlags |= FncFlags.IsFunctionExpression;
                    funcDecl.hint = idHint;
                    memberExpr = funcDecl;
                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);
                    member.minChar = memberName.minChar;

                    if (memberExpr.nodeType == NodeType.FuncDecl) {
                        var funcDecl = <FuncDecl>memberExpr;
                        funcDecl.hint = idHint;
                    }
                }
                else if (this.currentToken.tokenId == TokenID.Colon) {
                    this.currentToken = this.scanner.scan();
                    memberExpr = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,
                                         OperatorPrecedence.Comma, true, TypeContext.NoTypes);
                    // If the memberExpr is a type reference, we can be certain that it was an
                    // array type declaraion that lacked a "new".  We can realistically only
                    // expect call and name ASTs to be the result of this call to parseExpr.
                    // If it's a constructor without a "new", we'll flag it as an invalid
                    // call site later on.
                    if (memberExpr.nodeType == NodeType.TypeRef) {
                        this.reportParseError("Expected 'new' on array declaration in member definition")
                    }

                    member = new BinaryExpression(NodeType.Member, memberName, memberExpr);
                    member.minChar = memberName.minChar;
                    if (memberExpr.nodeType == NodeType.FuncDecl) {
                        var funcDecl = <FuncDecl>memberExpr;
                        funcDecl.hint = idHint;
                    }
                }
                else {
                    this.reportParseError("Expected ':' in member definition");
                    if (this.errorRecovery) {
                        this.skip(errorRecoverySet);
                        elements.flags |= ASTFlags.Error;
                        elements.minChar = minChar;
                        elements.limChar = this.scanner.lastTokenLimChar();
                        return elements;
                    }
                }

                idHint = null;
                elements.append(member);
                member.limChar = this.scanner.lastTokenLimChar();
                if (this.currentToken.tokenId != TokenID.Comma) {
                    break;
                }
                else {
                    // munch comma
                    this.currentToken = this.scanner.scan();
                }

                // trailing comma allowed
                if (this.currentToken.tokenId == TokenID.CloseBrace) {
                    break;
                }
            }

            if (member) {
                elements.limChar = member.limChar;
            }
            elements.minChar = minChar;
            return elements;
        }

        private parseArrayList(errorRecoverySet: ErrorRecoverySet): ASTList {
            var elements: ASTList = null;
            if (this.currentToken.tokenId == TokenID.CloseBracket) {
                return elements;
            }
            else {
                elements = new ASTList();
                elements.minChar = this.scanner.startPos;
            }

            var arg: AST;

            for (; ;) {
                if ((this.currentToken.tokenId == TokenID.Comma) ||
                    (this.currentToken.tokenId == TokenID.CloseBracket)) {
                    arg = new AST(NodeType.EmptyExpr);
                }
                else {
                    arg = this.parseExpr(ErrorRecoverySet.Comma | errorRecoverySet,
                                  OperatorPrecedence.Comma, true, TypeContext.NoTypes);
                }
                elements.append(arg);
                if (this.currentToken.tokenId != TokenID.Comma) {
                    break;
                }
                this.currentToken = this.scanner.scan();
            }
            elements.limChar = this.scanner.lastTokenLimChar();
            return elements;
        }

        private parseArrayLiteral(errorRecoverySet: ErrorRecoverySet): UnaryExpression {
            var arrayLiteral: UnaryExpression = null;
            arrayLiteral = new UnaryExpression(NodeType.ArrayLit,
                                             this.parseArrayList(errorRecoverySet));
            return arrayLiteral;
        }

        private parseTerm(errorRecoverySet: ErrorRecoverySet, allowCall: bool, typeContext: TypeContext, inCast: bool): AST {
            var ast: AST = null;
            var sawId = false;
            var inNew = false;
            var minChar = this.scanner.startPos;
            var limChar = this.scanner.pos;
            var parseAsLambda = false;
            var expectlambdaRParen = false;

            // keywords first
            switch (this.currentToken.tokenId) {
                case TokenID.Number:
                case TokenID.Bool:
                case TokenID.Any:
                case TokenID.String:
                    var tid = new Identifier(tokenTable[this.currentToken.tokenId].text);
                    if (hasFlag(typeContext, TypeContext.Primitive)) {
                        ast = new TypeReference(tid, 0);
                        sawId = true;
                    }
                    else {
                        ast = tid;
                        sawId = true;
                    }
                    ast.minChar = minChar;
                    this.currentToken = this.scanner.scan();
                    limChar = this.scanner.lastTokenLimChar();
                    break;
                case TokenID.This:
                    ast = new AST(NodeType.This);
                    ast.minChar = minChar;
                    this.currentToken = this.scanner.scan();
                    limChar = this.scanner.lastTokenLimChar();
                    break;
                case TokenID.Super:
                    ast = new AST(NodeType.Super);
                    ast.minChar = minChar;
                    this.currentToken = this.scanner.scan();
                    limChar = this.scanner.lastTokenLimChar();
                    break;
                case TokenID.True:
                    ast = new AST(NodeType.True);
                    this.currentToken = this.scanner.scan();
                    ast.minChar = minChar;
                    break;
                case TokenID.False:
                    ast = new AST(NodeType.False);
                    this.currentToken = this.scanner.scan();
                    ast.minChar = minChar;
                    break;
                case TokenID.Null:
                    ast = new AST(NodeType.Null);
                    this.currentToken = this.scanner.scan();
                    ast.minChar = minChar;
                    break;
                case TokenID.New:
                    minChar = this.scanner.pos;
                    this.currentToken = this.scanner.scan();
                    var target = this.parseTerm(errorRecoverySet, false, TypeContext.AllSimpleTypes, inCast);

                    if (target.nodeType == NodeType.Error || (target.nodeType == NodeType.Index && (<BinaryExpression>target).operand1.nodeType == NodeType.TypeRef)) {
                        this.reportParseError("Cannot invoke 'new' on this expression");
                    } else {
                        ast = new CallExpression(NodeType.New, target, null, null);
                        ast.minChar = minChar;
                        limChar = this.currentToken.tokenId == TokenID.EndOfFile ? this.scanner.pos : this.scanner.lastTokenLimChar();
                        inNew = true;
                    }
                    break;
                case TokenID.Function:
                    minChar = this.scanner.pos;
                    ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, null, true);
                    (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;
                    ast.minChar = minChar;
                    limChar = this.currentToken.tokenId == TokenID.EndOfFile ? this.scanner.pos : this.scanner.lastTokenLimChar();
                    ast.limChar = limChar;
                    break;
            }

            if (ast == null) {
                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {

                    var idText = this.currentToken.getText();
                    ast = this.createRef(idText, (<IdentifierToken>this.currentToken).hasEscapeSequence, minChar);
                    sawId = true;

                    ast.minChar = minChar;
                    this.currentToken = this.scanner.scan();

                    if (this.currentToken.tokenId == TokenID.Question) {
                        ast.flags |= ASTFlags.PossibleOptionalParameter;
                    }

                    limChar = this.scanner.lastTokenLimChar();
                }
            }

            if (inCast) {
                this.checkCurrentToken(TokenID.GreaterThan, errorRecoverySet);
            }

            if (ast == null) {
                switch (this.currentToken.tokenId) {
                    case TokenID.OpenParen:
                        minChar = this.scanner.pos;
                        var prevTokId = this.scanner.previousToken().tokenId;
                        this.currentToken = this.scanner.scan();

                        var couldBeLambda = prevTokId == TokenID.OpenParen || // foo(()=>{});
                                            prevTokId == TokenID.Comma || // foo(x,()=>{});
                                            prevTokId == TokenID.EqualsEquals || // var foo = ()=>{};
                                            prevTokId == TokenID.Colon;    // var x = { foo: ()=> {} };

                        if (couldBeLambda && this.currentToken.tokenId == TokenID.CloseParen) {
                            parseAsLambda = true;
                            expectlambdaRParen = false;
                            this.currentToken = this.scanner.scan();
                        }
                        else if (couldBeLambda && this.currentToken.tokenId == TokenID.DotDotDot) {
                            parseAsLambda = true;
                            expectlambdaRParen = true;
                        }
                        else {
                            ast = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,
                                          OperatorPrecedence.None, true, TypeContext.NoTypes, couldBeLambda);
                            limChar = this.scanner.lastTokenLimChar();
                            parseAsLambda = couldBeLambda && (ast.nodeType == NodeType.Name || ast.nodeType == NodeType.Comma) &&
                                            (this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.Question);
                            expectlambdaRParen = true;
                        }

                        // Check for the RParen if it's not an anonymous '=>' function
                        if ((ast && !parseAsLambda)) {
                            if (hasFlag(ast.flags, ASTFlags.SkipNextRParen)) {
                                // REVIEW: parseExpr resulted in a lambda node, the LParen scanned earlier, is the beginning of that node, and not of a parenthesized expression;
                                //         do not look for a matching RParen for this node, but make sure to remove the flag, so that any enclosing parenthesis are matched correctly.
                                ast.flags = ast.flags & (~(ASTFlags.SkipNextRParen));
                                break;
                            }

                            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);
                            ast.isParenthesized = true;
                        }

                        break;
                    case TokenID.NumberLiteral: {
                        var numTok = <NumberLiteralToken>this.currentToken;
                        this.currentToken = this.scanner.scan();
                        ast = new NumberLiteral(numTok.value, numTok.text);
                        ast.minChar = minChar;
                        limChar = this.scanner.lastTokenLimChar();
                        break;
                    }
                    case TokenID.StringLiteral:
                        ast = new StringLiteral(this.currentToken.getText());
                        this.currentToken = this.scanner.scan();
                        ast.minChar = minChar;
                        limChar = this.scanner.lastTokenLimChar();
                        break;
                    case TokenID.RegularExpressionLiteral: {
                        var rtok = <RegularExpressionLiteralToken>this.currentToken;
                        ast = new RegexLiteral(rtok.text);
                        this.currentToken = this.scanner.scan();
                        ast.minChar = minChar;
                        limChar = this.scanner.lastTokenLimChar();
                        break;
                    }
                    case TokenID.OpenBracket:
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        ast = this.parseArrayLiteral(ErrorRecoverySet.RBrack | errorRecoverySet);
                        ast.minChar = minChar;
                        limChar = this.scanner.pos; // ']'
                        this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet);
                        break;
                    // TODO: rescan regex for TokenID.Div and AsgDiv
                    case TokenID.OpenBrace:
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var members = this.parseMemberList(ErrorRecoverySet.RCurly | errorRecoverySet)
                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);
                        ast = new UnaryExpression(NodeType.ObjectLit, members);
                        ast.minChar = minChar;
                        limChar = this.scanner.lastTokenLimChar();
                        members.minChar = minChar;
                        members.limChar = limChar;
                        break;

                    case TokenID.LessThan:
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var term: AST = this.parseTypeReference(ErrorRecoverySet.BinOp, false);
                        this.checkCurrentToken(TokenID.GreaterThan, errorRecoverySet);
                        ast = new UnaryExpression(NodeType.TypeAssertion, this.parseExpr(errorRecoverySet, OperatorPrecedence.Unary, false, TypeContext.NoTypes));
                        (<UnaryExpression>ast).castTerm = term;
                        break;

                    default:
                        if (this.prevExpr && hasFlag(this.prevExpr.flags, ASTFlags.PossibleOptionalParameter)) {
                            parseAsLambda = true;
                            ast = this.prevExpr;
                        }
                        else {
                            this.reportParseError("Check format of expression term");
                            if (this.errorRecovery) {
                                var ident = new MissingIdentifier();
                                ident.minChar = minChar;
                                ident.flags |= ASTFlags.Error;
                                this.skip(errorRecoverySet | ErrorRecoverySet.Postfix);

                                if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                                    ident.setText(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence);
                                    this.currentToken = this.scanner.scan();
                                    limChar = this.scanner.lastTokenLimChar();
                                }
                                else {
                                    limChar = this.scanner.lastTokenLimChar();
                                    //tok=scanner.scan();
                                }

                                // REVIEW: set sawId
                                ast = ident;
                            }
                        }
                }
            }

            if (parseAsLambda) {
                // If the next token is an fat arrow or a colon, we either have a parameter list, or can rightly assume
                // that we have a typed formal, so we proceed with the lambda parse
                if (
                    this.currentToken.tokenId == TokenID.Colon ||
                    this.currentToken.tokenId == TokenID.Comma ||
                    this.currentToken.tokenId == TokenID.CloseParen ||
                    this.currentToken.tokenId == TokenID.DotDotDot) {

                    // We won't scan in the ':' case, since keeping the ':' simplifies argument handling in parseFormalParameterList
                    // Note that we don't set the minchar in this case
                    ast = this.parseLambdaExpr(errorRecoverySet, ast, true /* skipNextRParen */, expectlambdaRParen);
                    ast.minChar = minChar;
                    limChar = this.scanner.lastTokenLimChar();
                    ast.limChar = limChar;
                }
                else if (ast) {
                    ast.isParenthesized = true;
                }
            }

            if (sawId && (typeContext != TypeContext.NoTypes)) {
                typeContext |= TypeContext.ArraySuffix;
            }

            var postFix = this.parsePostfixOperators(errorRecoverySet, ast, allowCall, inNew, typeContext, minChar, limChar);

            // Defensive error check...
            if (postFix) {
                if (sawId && (postFix.nodeType == NodeType.Index)) {
                    var binExpr = <BinaryExpression>postFix;
                    if (binExpr.operand2 == null) {
                        postFix = this.convertToTypeReference(postFix);
                    }
                }

                ///////////////////////////////////////////////////////////
                //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,
                //      as they are sometimes not specific enough for each expression kind.
                postFix.minChar = minChar;
                // Only update "limChar" if it is not better than "lastTokenLimChar()"
                postFix.limChar = max(postFix.limChar, this.scanner.lastTokenLimChar());
                //
                ///////////////////////////////////////////////////////////
                return postFix;
            }
            else {
                return new AST(NodeType.Error);
            }

        }

        private parseLambdaExpr(errorRecoverySet: ErrorRecoverySet, lambdaArgs: AST, skipNextRParen: bool, expectClosingRParen: bool): AST {
            // REVIEW: Parse the remainder of a lambda expression. The opening paren has been read already, if it existed. 
            //         skipNextRParen sets a flag on the resulting lambda node to tell the calling parseTerm that the LParen it scanned has been matched as part of parsing the formal parameter list
            //         expectClosingRParen indicates that a closing RParen is expected, in the cases with optional parameter or more than one parameter.
            var ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: lambdaArgs }, expectClosingRParen);
            (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;
            (<FuncDecl>ast).fncFlags |= FncFlags.IsFatArrowFunction;
            if (!skipNextRParen) {
                ast.flags |= ASTFlags.SkipNextRParen;
            }
            ast.limChar = this.scanner.lastTokenLimChar();;
            return ast;
        }

        private parseExpr(errorRecoverySet: ErrorRecoverySet, minPrecedence: number, allowIn: bool,
            typeContext: TypeContext, possiblyInLambda: bool = false): AST {
            var ast: AST = null;
            var tokenInfo = lookupToken(this.currentToken.tokenId);
            var canAssign: bool = true;
            var idHint: string = null;
            var minChar = this.scanner.startPos;
            var preComments = this.parseComments();
            var exprIsAnonLambda = false;

            if ((tokenInfo != undefined) && (tokenInfo.unopNodeType != NodeType.None)) {
                canAssign = false;
                this.currentToken = this.scanner.scan();
                var tempExpr = this.parseExpr(ErrorRecoverySet.BinOp | errorRecoverySet,
                                       tokenInfo.unopPrecedence, allowIn,
                                       TypeContext.NoTypes);

                ast = new UnaryExpression(tokenInfo.unopNodeType, tempExpr);
                ast.limChar = tempExpr.limChar;
                ast.minChar = minChar;
            }
            else {
                ast = this.parseTerm(ErrorRecoverySet.BinOp | ErrorRecoverySet.AddOp |
                              errorRecoverySet, true, typeContext, false);
                var id: Identifier;
                var temp: AST;
                if (ast.nodeType == NodeType.Name) {
                    id = <Identifier>ast;
                    idHint = id.actualText;
                }
                else if (ast.nodeType == NodeType.Dot) {

                    // If this is within a class declaration, and the circumstances are right, we need to
                    // transform the dotted expression into a member declaration
                    var subsumedExpr = false;

                    if (this.inferPropertiesFromThisAssignment &&
                        (this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.Equals) &&
                         this.parsingClassConstructorDefinition &&
                         this.nestingLevel == this.currentClassDefinition.constructorNestingLevel && // this nesting level means we're at the top-level in the constructor
                         (<BinaryExpression>ast).operand1.nodeType == NodeType.This) {

                        if ((<BinaryExpression>ast).operand2.nodeType == NodeType.Name) {
                            var op2ID: Identifier = (<Identifier>(<BinaryExpression>ast).operand2);

                            if (!this.currentClassDefinition.knownMemberNames[op2ID.actualText]) {
                                ast = this.parseClassMemberVariableDeclaration(op2ID, ast.minChar, true, errorRecoverySet, Modifiers.Public);
                                subsumedExpr = true;
                            }
                        }
                    }

                    if (!subsumedExpr) {
                        temp = ast;
                        while (temp.nodeType == NodeType.Dot) {
                            var binExpr = <BinaryExpression>temp;
                            temp = binExpr.operand2;
                        }
                        if (temp.nodeType == NodeType.Name) {
                            id = <Identifier>temp;
                            idHint = id.actualText;
                        }
                    }
                }
                if ((!this.scanner.lastTokenHadNewline()) &&
                    ((this.currentToken.tokenId == TokenID.PlusPlus) || (this.currentToken.tokenId == TokenID.MinusMinus))) {
                    canAssign = false;
                    var operand = ast;
                    ast = new UnaryExpression((this.currentToken.tokenId == TokenID.PlusPlus) ? NodeType.IncPost : NodeType.DecPost, operand);
                    ast.limChar = this.scanner.pos;
                    ast.minChar = operand.minChar;
                    this.currentToken = this.scanner.scan();
                }
            }

            for (; ;) {
                tokenInfo = lookupToken(this.currentToken.tokenId);
                if ((tokenInfo == undefined) || (tokenInfo.binopNodeType == NodeType.None)) {
                    break;
                }

                if ((!allowIn) && (tokenInfo.binopNodeType == NodeType.In)) {
                    break;
                }
                if (tokenInfo.binopPrecedence == OperatorPrecedence.Assignment) {
                    if (tokenInfo.binopPrecedence < minPrecedence) {
                        break;
                    }
                    if (!canAssign) {
                        this.reportParseError("illegal assignment");
                    }
                }
                else if (tokenInfo.binopPrecedence <= minPrecedence) {
                    break;
                }

                if (possiblyInLambda && this.currentToken.tokenId == TokenID.Comma && this.scanner.getLookAheadToken().tokenId == TokenID.DotDotDot) {
                    // The ellipsis can only exist in the formal list of a lambda expression, so do not attempt to parse the comma token as the comma binary operator
                    // instead parse it as a lambda
                    exprIsAnonLambda = true;
                    canAssign = false;
                    ast = this.parseLambdaExpr(errorRecoverySet, ast, false, true);
                    break;
                }

                // Precedence is high enough. Consume the operator token.
                this.currentToken = this.scanner.scan();
                canAssign = false;
                if (tokenInfo.binopNodeType == NodeType.ConditionalExpression) {
                    if (possiblyInLambda &&
                        (this.currentToken.tokenId == TokenID.Equals || this.currentToken.tokenId == TokenID.Colon || this.currentToken.tokenId == TokenID.CloseParen || this.currentToken.tokenId == TokenID.Comma)) {
                        // The QMark is not a ternary expression, it is a marker for optional parameter in a lambda expression.
                        exprIsAnonLambda = true;
                        canAssign = true;
                    }
                    else {
                        this.prevExpr = ast;
                        var whenTrue = this.parseExpr(
                            errorRecoverySet | ErrorRecoverySet.Colon, OperatorPrecedence.Assignment, allowIn, TypeContext.NoTypes);

                        // Do not hold onto the prevExpr handle
                        this.prevExpr = null;
                        this.checkCurrentToken(TokenID.Colon, errorRecoverySet | ErrorRecoverySet.ExprStart);

                        var whenFalse = this.parseExpr(
                            errorRecoverySet | ErrorRecoverySet.BinOp, OperatorPrecedence.Assignment, allowIn, TypeContext.NoTypes)
                        ast = new ConditionalExpression(ast, whenTrue, whenFalse);
                    }
                }
                else {
                    var tc = TypeContext.NoTypes;
                    var binExpr2: BinaryExpression;

                    binExpr2 = new BinaryExpression(tokenInfo.binopNodeType, ast,
                                                    this.parseExpr(errorRecoverySet |
                                                            ErrorRecoverySet.BinOp,
                                                            tokenInfo.binopPrecedence,
                                                            allowIn, TypeContext.NoTypes, possiblyInLambda));

                    if (binExpr2.operand2.nodeType == NodeType.FuncDecl) {
                        var funcDecl = <FuncDecl>binExpr2.operand2;
                        funcDecl.hint = idHint;
                    }

                    binExpr2.minChar = ast.minChar;
                    binExpr2.limChar = this.scanner.lastTokenLimChar();
                    idHint = null;
                    ast = binExpr2;
                }
            }
            if (canAssign) {
                ast.flags |= ASTFlags.Writeable;
            }
            if (!exprIsAnonLambda) {
                ///////////////////////////////////////////////////////////
                //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,
                //      as they are sometimes not specific enough for each statement kind.
                ast.minChar = minChar;
                // Only update "limChar" if it is not better than "lastTokenLimChar()"
                ast.limChar = max(ast.limChar, this.scanner.lastTokenLimChar());
                //
                ///////////////////////////////////////////////////////////
                if (preComments) {
                    ast.preComments = ast.preComments ? preComments.concat(ast.preComments) : preComments;
                }

                ast.postComments = this.parseCommentsForLine(this.scanner.line);
            }

            return ast;
        }

        private parsePostfixOperators(errorRecoverySet: ErrorRecoverySet, ast: AST, allowCall: bool, inNew: bool,
            typeContext: TypeContext, lhsMinChar: number, lhsLimChar: number): AST {
            var count = 0;

            if (!ast) {
                ast = new AST(NodeType.EmptyExpr);
                ast.isParenthesized = true;
            }

            ast.minChar = lhsMinChar;
            ast.limChar = lhsLimChar;

            for (; ;) {
                switch (this.currentToken.tokenId) {
                    case TokenID.OpenParen:
                        if (inNew) {
                            var callExpr = <CallExpression>ast;
                            callExpr.arguments = this.parseArgList(errorRecoverySet);
                            inNew = false;
                        }
                        else {
                            if (!allowCall) {
                                return ast;
                            }
                            ast = new CallExpression(NodeType.Call, ast, null, this.parseArgList(errorRecoverySet));
                            ast.minChar = lhsMinChar;
                        }
                        ast.limChar = this.scanner.pos; // ')'
                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);
                        break;
                    case TokenID.OpenBracket:
                        this.currentToken = this.scanner.scan();
                        if (this.currentToken.tokenId == TokenID.CloseBracket) {
                            if (hasFlag(typeContext, TypeContext.ArraySuffix)) {
                                this.currentToken = this.scanner.scan();
                                if (ast.nodeType == NodeType.TypeRef) {
                                    var typeRef = <TypeReference>ast;
                                    typeRef.arrayCount++;
                                }
                                else {
                                    ast = new BinaryExpression(NodeType.Index, ast, null);
                                }
                                ast.limChar = this.scanner.pos;
                                break; // note early exit from case
                            }
                        }

                        ast = new BinaryExpression(NodeType.Index, ast,
                                                 this.parseExpr(errorRecoverySet | ErrorRecoverySet.RBrack,
                                                           OperatorPrecedence.None, true,
                                                           TypeContext.NoTypes));
                        ast.minChar = lhsMinChar;
                        ast.limChar = this.scanner.pos; // ']'
                        this.checkCurrentToken(TokenID.CloseBracket, errorRecoverySet);
                        break;
                    case TokenID.Dot: {
                        var name: Identifier = null;
                        var curpos = this.scanner.pos;
                        this.currentToken = this.scanner.scan();
                        // Don't allow reserved words if immediately after a new line and error recovery is enabled
                        if ((this.currentToken.tokenId == TokenID.Identifier) || ((!this.errorRecovery || !this.scanner.lastTokenHadNewline()) && convertTokToIDName(this.currentToken))) {
                            ast.flags |= ASTFlags.DotLHS;
                            name = this.createRef(this.currentToken.getText(), (<IdentifierToken>this.currentToken).hasEscapeSequence, this.scanner.startPos);
                            name.limChar = this.scanner.pos;
                            this.currentToken = this.scanner.scan();
                        }
                        else {
                            this.reportParseError("Expected identifier following dot");
                            if (this.errorRecovery) {
                                this.skip(errorRecoverySet);
                                ast.flags |= (ASTFlags.Error | ASTFlags.DotLHS);
                                return ast;
                            }
                            else {
                                name = new MissingIdentifier();
                            }
                        }
                        ast = new BinaryExpression(NodeType.Dot, ast, name);
                        ast.minChar = lhsMinChar;
                        ast.limChar = this.scanner.lastTokenLimChar();
                        break;
                    }
                    case TokenID.EqualsGreaterThan:
                        ast = this.parseFncDecl(errorRecoverySet, false, false, false, null, false, false, false, Modifiers.None, { preProcessedLambdaArgs: ast }, false);
                        (<FuncDecl>ast).fncFlags |= FncFlags.IsFunctionExpression;
                        ast.minChar = lhsMinChar;
                        ast.limChar = this.scanner.lastTokenLimChar();
                        break;
                    default:
                        return ast;

                }
            }
        }

        private parseTry(tryNode: Try, errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Try {
            var minChar = this.scanner.startPos;
            var preComments = this.parseComments();
            this.currentToken = this.scanner.scan();
            if (this.currentToken.tokenId != TokenID.OpenBrace) {
                this.reportParseError("Expected '{'");
                if (this.errorRecovery) {
                    var etryNode = tryNode;
                    etryNode.minChar = minChar;
                    etryNode.limChar = this.scanner.lastTokenLimChar();
                    etryNode.flags |= ASTFlags.Error;
                    return etryNode;
                }
            }
            tryNode.body = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers);
            tryNode.minChar = minChar;
            tryNode.limChar = tryNode.body.limChar;
            tryNode.preComments = preComments;
            tryNode.postComments = this.parseComments();
            return tryNode;
        }

        private parseCatch(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Catch {
            var catchMinChar = this.scanner.startPos;
            var preComments = this.parseComments();
            this.currentToken = this.scanner.scan();
            this.checkCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);
            if ((this.currentToken.tokenId != TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                this.reportParseError("Expected identifier in catch header");
                if (this.errorRecovery) {
                    this.skip(errorRecoverySet);

                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),
                                            new Statement(NodeType.Empty));
                    ecatch.statement.minChar = catchMinChar;
                    ecatch.statement.limChar = this.scanner.pos;
                    ecatch.minChar = this.scanner.startPos;
                    ecatch.limChar = this.scanner.pos;
                    ecatch.flags |= ASTFlags.Error;
                    return ecatch;
                }
            }
            var param = new VarDecl(Identifier.fromToken(this.currentToken), this.nestingLevel);
            param.id.minChar = this.scanner.startPos;
            param.id.limChar = this.scanner.pos;
            param.minChar = param.id.minChar;
            param.limChar = param.id.limChar;
            this.currentToken = this.scanner.scan();
            var statementPos = this.scanner.pos;
            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.StmtStart);
            if (this.currentToken.tokenId != TokenID.OpenBrace) {
                this.reportParseError("Expected '{' to start catch body");
                if (this.errorRecovery) {
                    this.skip(errorRecoverySet);

                    var ecatch = new Catch(new VarDecl(new MissingIdentifier(), this.nestingLevel),
                                            new Statement(NodeType.Empty));
                    ecatch.statement.minChar = catchMinChar;
                    ecatch.statement.limChar = statementPos;
                    ecatch.minChar = this.scanner.startPos;
                    ecatch.limChar = this.scanner.pos;
                    ecatch.flags |= ASTFlags.Error;
                    return ecatch;
                }
            }

            var catchStmt = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers);
            var catchNode = new Catch(param, catchStmt);
            catchNode.statement.minChar = catchMinChar;
            catchNode.statement.limChar = statementPos;
            catchNode.minChar = catchMinChar;
            catchNode.limChar = catchStmt.limChar;
            catchNode.preComments = preComments;
            catchNode.postComments = this.parseComments();
            return catchNode;
        }

        private parseFinally(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers): Finally {
            var finMinChar = this.scanner.startPos;
            var preComments = this.parseComments();
            this.currentToken = this.scanner.scan();
            if (this.currentToken.tokenId != TokenID.OpenBrace) {
                this.reportParseError("Expected '{' to start body of finally statement");
                if (this.errorRecovery) {
                    this.skip(errorRecoverySet);
                    var efin = new Finally(new Statement(NodeType.Empty));
                    efin.flags |= ASTFlags.Error;
                    efin.minChar = this.scanner.startPos;
                    efin.limChar = this.scanner.pos;
                    return efin;
                }
            }

            var finBody = this.parseStatement(errorRecoverySet, AllowedElements.None, parentModifiers)
            var fin = new Finally(finBody);
            fin.minChar = finMinChar;
            fin.limChar = fin.body.limChar;
            fin.preComments = preComments;
            fin.postComments = this.parseComments();
            return fin;
        }

        private parseTryCatchFinally(errorRecoverySet: ErrorRecoverySet, parentModifiers: Modifiers, labelList: ASTList): AST {
            var tryPart: AST = new Try(null);
            var tryMinChar = this.scanner.startPos;
            this.pushStmt(<Statement>tryPart, labelList);
            this.parseTry(<Try>tryPart, errorRecoverySet | ErrorRecoverySet.Catch, parentModifiers);
            this.popStmt();
            var tc: TryCatch = null;
            var tf: TryFinally = null;

            if (this.currentToken.tokenId == TokenID.Catch) {
                var catchPart = this.parseCatch(errorRecoverySet | ErrorRecoverySet.Catch, parentModifiers);
                tc = new TryCatch(<Try>tryPart, catchPart);
                tc.minChar = tryPart.minChar;
                tc.limChar = catchPart.limChar;
            }

            if (this.currentToken.tokenId != TokenID.Finally) {
                if (tc == null) {
                    this.reportParseError("try with neither catch nor finally");
                    if (this.errorRecovery) {
                        var etf = new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));
                        etf.flags |= ASTFlags.Error;
                        etf.minChar = this.scanner.startPos;
                        etf.limChar = this.scanner.pos;
                        return etf;
                    }
                    return new TryFinally(tryPart, new Finally(new AST(NodeType.Empty)));
                }
                else {
                    return tc;
                }
            }
            else {
                if (tc) {
                    tryPart = tc;
                }
                var finallyPart = this.parseFinally(errorRecoverySet, parentModifiers)
                tf = new TryFinally(tryPart, finallyPart);
                tf.minChar = tryMinChar;
                tf.limChar = finallyPart.limChar;
                return tf;
            }
        }

        private parseStatement(errorRecoverySet: ErrorRecoverySet, allowedElements: AllowedElements, parentModifiers: Modifiers): AST {
            var ast: AST = null;
            var labelList: ASTList = null;
            var astList: ASTList = null;
            var temp: AST;
            var modifiers = Modifiers.None;
            var minChar = this.scanner.startPos;
            var forInOk = false;
            var needTerminator = false;
            var fnOrVar: AST = null;
            var preComments = this.parseComments();

            function isAmbient() {
                return hasFlag(modifiers, Modifiers.Ambient) || hasFlag(parentModifiers, Modifiers.Ambient);
            }

            function mayNotBeExported() {
                if (hasFlag(modifiers, Modifiers.Exported)) {
                    this.reportError("Statement may not be exported");
                }
            }

            for (; ;) {
                switch (this.currentToken.tokenId) {
                    case TokenID.EndOfFile:
                        ast = new AST(NodeType.Error);
                        ast.minChar = minChar;
                        ast.limChar = this.scanner.pos;
                        break;
                    case TokenID.Function:
                        if (this.parsingDeclareFile || isAmbient() || this.ambientModule) {
                            this.currentToken = this.scanner.scan();
                            fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,
                                                      modifiers, true, false);
                            if (fnOrVar.nodeType == NodeType.VarDecl) {
                                this.reportParseError("function keyword can only introduce function declaration");
                            }
                            else if ((fnOrVar.nodeType == NodeType.FuncDecl) && ((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)) {
                                needTerminator = true;
                            }
                            ast = fnOrVar;
                            if (this.parsingDeclareFile || this.ambientModule && ast.nodeType == NodeType.FuncDecl) {
                                (<FuncDecl>ast).fncFlags |= FncFlags.Exported;
                            }
                        }
                        else {
                            ast = this.parseFncDecl(errorRecoverySet, true, false, false, null, false, false, isAmbient(), modifiers, null, true);
                            if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {
                                needTerminator = true;
                            }
                            if (this.ambientModule) {
                                this.reportParseError("function declaration not permitted within ambient module");
                            }
                            if (hasFlag(modifiers, Modifiers.Exported)) {
                                (<FuncDecl>ast).fncFlags |= FncFlags.Exported;
                            }
                        }
                        break;
                    case TokenID.Module:
                        if ((allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None) {
                            this.reportParseError("module not allowed in this context");
                            this.currentToken = this.scanner.scan();
                            ast = new AST(NodeType.Error);
                            ast.minChar = minChar;
                            ast.limChar = this.scanner.lastTokenLimChar();
                        }
                        else {
                            ast = this.parseModuleDecl(errorRecoverySet, modifiers, preComments);
                            preComments = null;
                        }
                        break;
                    case TokenID.Import:
                        if ((allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None) {
                            this.reportParseError("module not allowed in this context");
                            this.currentToken = this.scanner.scan();
                            ast = new AST(NodeType.Error);
                            ast.minChar = minChar;
                            ast.limChar = this.scanner.lastTokenLimChar();
                        }
                        else {
                            if (hasFlag(modifiers, Modifiers.Exported)) {
                                this.reportParseError("export keyword not permitted on import declaration");
                            }
                            ast = this.parseImportDeclaration(errorRecoverySet, modifiers);
                            needTerminator = true;
                        }
                        break;
                    case TokenID.Export:
                        if ((allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None) {
                            this.reportParseError("'export' statements are only allowed at the global and module levels");
                            this.currentToken = this.scanner.scan();
                            ast = new AST(NodeType.Error);
                            ast.minChar = minChar;
                            ast.limChar = this.scanner.lastTokenLimChar();
                        }
                        if (this.topLevel) {
                            this.hasTopLevelImportOrExport = true;
                        }
                        modifiers |= Modifiers.Exported;
                        this.currentToken = this.scanner.scan();
                        break;
                    case TokenID.Private:
                        modifiers |= Modifiers.Private;

                        this.currentToken = this.scanner.scan();

                        if (this.parsingClassConstructorDefinition) {

                            if (!this.inferPropertiesFromThisAssignment) {
                                this.reportParseError("Property declarations are not permitted within constructor bodies");
                            }

                            minChar = this.scanner.pos;
                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != TokenID.This || (this.currentToken = this.scanner.scan()).tokenId != TokenID.Dot)) {
                                this.reportParseError("Expected 'this.' for property declaration");
                                this.currentToken = this.scanner.scan();
                                ast = new AST(NodeType.Error);
                                ast.minChar = minChar;
                                ast.limChar = this.scanner.lastTokenLimChar();
                            }
                            else {
                                this.currentToken = this.scanner.scan();

                                var id = Identifier.fromToken(this.currentToken);
                                id.minChar = this.scanner.startPos;
                                id.limChar = this.scanner.pos;

                                this.currentToken = this.scanner.scan();
                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);
                            }
                        }
                        else {
                            if (this.currentToken.tokenId != TokenID.Interface) {
                                if (this.currentToken.tokenId == TokenID.Get) {
                                    this.prevIDTok = this.currentToken;
                                    this.currentToken = this.scanner.scan();
                                    if (codeGenTarget < CodeGenTarget.ES5) {
                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                                    }
                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                                        modifiers |= Modifiers.Getter;
                                        this.prevIDTok = null;
                                    }
                                }
                                else if (this.currentToken.tokenId == TokenID.Set) {
                                    this.prevIDTok = this.currentToken;
                                    this.currentToken = this.scanner.scan();
                                    if (codeGenTarget < CodeGenTarget.ES5) {
                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                                    }
                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                                        modifiers |= Modifiers.Setter;
                                        this.prevIDTok = null;
                                    }
                                }
                                fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,
                                                          modifiers, isAmbient(), false);
                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||
                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && (hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction)))) {
                                    needTerminator = true;
                                }
                                ast = fnOrVar;
                            }
                        }
                        break;
                    case TokenID.Public:
                        if (this.parsingClassConstructorDefinition) {

                            if (!this.inferPropertiesFromThisAssignment) {
                                this.reportParseError("Property declarations are not permitted within constructor bodies");
                            }

                            this.currentToken = this.scanner.scan();
                            minChar = this.scanner.pos;
                            modifiers |= Modifiers.Public;
                            if (this.inferPropertiesFromThisAssignment && (this.currentToken.tokenId != TokenID.This || (this.currentToken = this.scanner.scan()).tokenId != TokenID.Dot)) {
                                this.reportParseError("Expected 'this.' for property declaration");
                                this.currentToken = this.scanner.scan();
                                ast = new AST(NodeType.Error);
                                ast.minChar = minChar;
                                ast.limChar = this.scanner.lastTokenLimChar();
                            }
                            else {
                                this.currentToken = this.scanner.scan();

                                var id = Identifier.fromToken(this.currentToken);
                                id.minChar = this.scanner.startPos;
                                id.limChar = this.scanner.pos;

                                this.currentToken = this.scanner.scan();
                                ast = this.parseClassMemberVariableDeclaration(id, minChar, this.parsingClassConstructorDefinition, errorRecoverySet, modifiers);
                            }
                        }
                        else {
                            if ((allowedElements & AllowedElements.Properties) == AllowedElements.None) {
                                this.reportParseError("'property' statements are only allowed within classes");
                                this.currentToken = this.scanner.scan();
                                ast = new AST(NodeType.Error);
                                ast.minChar = minChar;
                                ast.limChar = this.scanner.lastTokenLimChar();
                            }
                            else {
                                modifiers |= Modifiers.Public;
                                this.currentToken = this.scanner.scan();
                                if (this.currentToken.tokenId == TokenID.Get) {
                                    this.prevIDTok = this.currentToken;
                                    this.currentToken = this.scanner.scan();
                                    if (codeGenTarget < CodeGenTarget.ES5) {
                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                                    }
                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                                        modifiers |= Modifiers.Getter;
                                        this.prevIDTok = null;
                                    }
                                }
                                else if (this.currentToken.tokenId == TokenID.Set) {
                                    this.prevIDTok = this.currentToken;
                                    this.currentToken = this.scanner.scan();
                                    if (codeGenTarget < CodeGenTarget.ES5) {
                                        this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                                    }
                                    if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                                        modifiers |= Modifiers.Setter;
                                        this.prevIDTok = null;
                                    }
                                }
                                fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,
                                                            modifiers, isAmbient(), false);
                                if ((fnOrVar.nodeType == NodeType.VarDecl) ||
                                    ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {
                                    needTerminator = true;
                                }
                                ast = fnOrVar;
                            }
                        }
                        break;
                    case TokenID.Declare:
                        if (!(allowedElements & AllowedElements.AmbientDeclarations)) {
                            this.reportParseError("Ambient declarations are only allowed at the top-level or module scopes")
                        }
                        if (!this.parsingDeclareFile && hasFlag(parentModifiers, Modifiers.Ambient)) {
                            this.reportParseError("Duplicate ambient declaration in this context. (Is the enclosing module or class already ambient?)")
                        }
                        modifiers |= Modifiers.Ambient;
                        this.currentToken = this.scanner.scan();
                        break;
                    case TokenID.Class:
                        if ((allowedElements & AllowedElements.ClassDeclarations) == AllowedElements.None) {
                            this.reportParseError("class not allowed in this context");
                            this.currentToken = this.scanner.scan();
                            ast = new AST(NodeType.Error);
                            ast.minChar = minChar;
                            ast.limChar = this.scanner.lastTokenLimChar();
                        }
                        else {
                            ast = this.parseClassDecl(errorRecoverySet, minChar, modifiers);
                        }
                        break;
                    case TokenID.Interface:
                        if ((allowedElements & AllowedElements.InterfaceDeclarations) == AllowedElements.None) {
                            this.reportParseError("interface not allowed in this context");
                            this.currentToken = this.scanner.scan();
                            ast = new AST(NodeType.Error);
                            ast.minChar = minChar;
                            ast.limChar = this.scanner.lastTokenLimChar();
                        }
                        else {
                            ast = this.parseInterfaceDecl(errorRecoverySet, modifiers);
                        }
                        break;
                    case TokenID.Var:
                        var declAst: AST = this.parseVariableDeclaration(errorRecoverySet | ErrorRecoverySet.StmtStart, modifiers,
                                                     true, false);
                        if (declAst.nodeType == NodeType.VarDecl) {
                            ast = declAst;
                        }
                        else {
                            ast = new Block(<ASTList>declAst, false);
                        }
                        needTerminator = true;
                        break;
                    case TokenID.Static:

                        if (this.currentClassDecl == null) {
                            this.reportParseError("Statics may only be class members");
                        }

                        mayNotBeExported();
                        modifiers |= Modifiers.Public;
                        this.currentToken = this.scanner.scan();
                        if (this.currentToken.tokenId == TokenID.Get) {
                            this.prevIDTok = this.currentToken;
                            this.currentToken = this.scanner.scan();
                            if (codeGenTarget < CodeGenTarget.ES5) {
                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                            }
                            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                                modifiers |= Modifiers.Getter;
                                this.prevIDTok = null;
                            }
                        }
                        else if (this.currentToken.tokenId == TokenID.Set) {
                            this.currentToken = this.scanner.scan();
                            if (codeGenTarget < CodeGenTarget.ES5) {
                                this.reportParseError("Property accessors are only available when targeting ES5 or greater");
                            }
                            if ((this.currentToken.tokenId == TokenID.Identifier) || convertTokToID(this.currentToken, this.strictMode)) {
                                modifiers |= Modifiers.Setter;
                            }
                        }
                        if (isAmbient()) {
                            modifiers |= Modifiers.Ambient;
                        }
                        fnOrVar = this.parsePropertyDeclaration(errorRecoverySet | ErrorRecoverySet.SColon,
                                                  modifiers, this.parsingDeclareFile || (modifiers & Modifiers.Ambient) != Modifiers.None, true);

                        var staticsList = this.topStaticsList();
                        if (staticsList && fnOrVar.nodeType == NodeType.VarDecl) {
                            staticsList.append(fnOrVar);
                        }

                        if (fnOrVar.nodeType == NodeType.VarDecl || ((fnOrVar.nodeType == NodeType.FuncDecl) && hasFlag((<FuncDecl>fnOrVar).fncFlags, FncFlags.IsFatArrowFunction))) {
                            needTerminator = true;
                        }

                        ast = fnOrVar;
                        break;
                    case TokenID.For:
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("syntax error: for statement does not take modifiers");
                        }

                        minChar = this.scanner.startPos;
                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);
                        forInOk = true;
                        switch (this.currentToken.tokenId) {
                            case TokenID.Var:
                                temp = this.parseVariableDeclaration(errorRecoverySet | ErrorRecoverySet.SColon |
                                                  ErrorRecoverySet.In, Modifiers.None, false, false);
                                break;
                            case TokenID.Semicolon:
                                temp = null;
                                break;
                            default:
                                temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |
                                               ErrorRecoverySet.In, OperatorPrecedence.None, false,
                                               TypeContext.NoTypes);
                                break;
                        }
                        if (this.currentToken.tokenId == TokenID.In) {
                            if ((temp == null) || (!forInOk)) {
                                this.reportParseError("malformed for statement");
                                if (this.errorRecovery) {
                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);
                                    ast = new AST(NodeType.Empty);
                                    ast.flags |= ASTFlags.Error;
                                }
                            }
                            else {
                                this.currentToken = this.scanner.scan();
                                var forInStmt = new ForInStatement(temp,
                                                                 this.parseExpr(ErrorRecoverySet.RParen |
                                                                           errorRecoverySet,
                                                                           OperatorPrecedence.Comma,
                                                                           false,
                                                                           TypeContext.NoTypes));

                                forInStmt.limChar = this.scanner.pos;
                                forInStmt.statement.minChar = minChar;
                                forInStmt.statement.limChar = this.scanner.pos;
                                this.checkCurrentToken(TokenID.CloseParen, ErrorRecoverySet.StmtStart | errorRecoverySet);
                                this.pushStmt(forInStmt, labelList);
                                forInStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);
                                this.popStmt();
                                forInStmt.minChar = minChar;
                                ast = forInStmt;
                            }
                        }
                        else {
                            var forStmt: ForStatement = new ForStatement(temp);
                            forStmt.minChar = minChar;
                            this.checkCurrentToken(TokenID.Semicolon, errorRecoverySet);
                            if (this.currentToken.tokenId == TokenID.Semicolon) {
                                forStmt.cond = null;
                            }
                            else {
                                forStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |
                                                       ErrorRecoverySet.RParen,
                                                       OperatorPrecedence.None, true,
                                                       TypeContext.NoTypes);
                                if (this.currentToken.tokenId != TokenID.Semicolon) {
                                    this.skip(errorRecoverySet | ErrorRecoverySet.StmtStart);
                                    ast = forStmt;
                                    ast.flags |= ASTFlags.Error;
                                }
                            }
                            this.currentToken = this.scanner.scan();
                            if (this.currentToken.tokenId == TokenID.CloseParen) {
                                forStmt.incr = null;
                            }
                            else {
                                forStmt.incr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon |
                                                       ErrorRecoverySet.RParen,
                                                       OperatorPrecedence.None, true,
                                                       TypeContext.NoTypes);
                            }

                            this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);
                            this.pushStmt(forStmt, labelList);
                            forStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);
                            this.popStmt();
                            forStmt.limChar = forStmt.body.limChar;
                            ast = forStmt;
                        }
                        break;
                    case TokenID.With: {
                        if (codeGenTarget < CodeGenTarget.ES5) {
                            this.reportParseError("'with' statements are only available in ES5 codegen mode or better");
                        }

                        if (this.strictMode) {
                            this.reportParseError("'with' statements are not available in strict mode");
                        }

                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("'with' statement does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart | ErrorRecoverySet.Var);

                        var expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,
                                                            OperatorPrecedence.None, true,
                                                            TypeContext.NoTypes);
                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);

                        var withStmt = new WithStatement(expr);
                        withStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);
                        withStmt.minChar = minChar;
                        withStmt.limChar = withStmt.body.limChar;
                        ast = withStmt;
                    }
                        break;
                    case TokenID.Switch: {
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("'switch' statement does not take modifiers");
                        }
                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);

                        var switchStmt = new SwitchStatement(this.parseExpr(errorRecoverySet |
                                                                     ErrorRecoverySet.RParen,
                                                                     OperatorPrecedence.None,
                                                                     true,
                                                                     TypeContext.NoTypes));
                        switchStmt.statement.minChar = minChar;
                        switchStmt.statement.limChar = this.scanner.pos;
                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.LCurly);
                        var caseListMinChar = this.scanner.startPos;
                        this.checkCurrentToken(TokenID.OpenBrace, errorRecoverySet | ErrorRecoverySet.SCase);
                        switchStmt.defaultCase = null;
                        switchStmt.caseList = new ASTList();
                        var caseStmt: CaseStatement = null;
                        this.pushStmt(switchStmt, labelList);
                        for (; ;) {
                            if ((this.currentToken.tokenId == TokenID.Case) ||
                                (this.currentToken.tokenId == TokenID.Default)) {
                                var isDefault = (this.currentToken.tokenId == TokenID.Default);
                                caseStmt = new CaseStatement();
                                caseStmt.minChar = this.scanner.startPos;
                                this.currentToken = this.scanner.scan();

                                if (isDefault) {
                                    switchStmt.defaultCase = caseStmt;
                                }
                                else {
                                    caseStmt.expr = this.parseExpr(errorRecoverySet | ErrorRecoverySet.Colon,
                                                            OperatorPrecedence.None, true,
                                                            TypeContext.NoTypes);
                                }

                                this.checkCurrentToken(TokenID.Colon, errorRecoverySet | ErrorRecoverySet.StmtStart);
                                caseStmt.body = new ASTList();
                                this.parseStatementList(errorRecoverySet | ErrorRecoverySet.RCurly,
                                              caseStmt.body, false, true, allowedElements, modifiers);
                                caseStmt.limChar = caseStmt.body.limChar;
                                switchStmt.caseList.append(caseStmt);
                            }
                            else {
                                break;
                            }
                        }
                        // end of switch statement
                        switchStmt.caseList.minChar = caseListMinChar;
                        switchStmt.caseList.limChar = this.scanner.pos;
                        switchStmt.limChar = switchStmt.caseList.limChar;
                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);
                        this.popStmt();
                        ast = switchStmt;
                        break;
                    }
                    case TokenID.While: {
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("'while' statement does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        this.checkNextToken(TokenID.OpenParen, ErrorRecoverySet.ExprStart |
                                  errorRecoverySet);
                        var whileStmt = new WhileStatement(this.parseExpr(errorRecoverySet |
                                                                   ErrorRecoverySet.RParen,
                                                                   OperatorPrecedence.None,
                                                                   true, TypeContext.NoTypes));
                        whileStmt.minChar = minChar;
                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet |
                                  ErrorRecoverySet.StmtStart);
                        this.pushStmt(whileStmt, labelList);
                        whileStmt.body = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);
                        whileStmt.limChar = whileStmt.body.limChar;
                        this.popStmt();
                        ast = whileStmt;
                        break;
                    }
                    case TokenID.Do: {
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("'do' statement does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var doStmt = new DoWhileStatement();
                        doStmt.minChar = minChar;
                        this.pushStmt(doStmt, labelList);
                        doStmt.body = this.parseStatement(errorRecoverySet | ErrorRecoverySet.While,
                                                   allowedElements, parentModifiers);
                        this.popStmt();
                        doStmt.whileAST = new Identifier("while");
                        doStmt.whileAST.minChar = this.scanner.startPos;
                        this.checkCurrentToken(TokenID.While, errorRecoverySet | ErrorRecoverySet.LParen);
                        doStmt.whileAST.limChar = doStmt.whileAST.minChar + 5;
                        this.checkCurrentToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);
                        doStmt.cond = this.parseExpr(errorRecoverySet | ErrorRecoverySet.RParen,
                                              OperatorPrecedence.None, true, TypeContext.NoTypes);
                        doStmt.limChar = this.scanner.pos;
                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet);
                        ast = doStmt;
                        // compatibility; more strict would be to require the ';'
                        if (this.currentToken.tokenId == TokenID.Semicolon) {
                            this.currentToken = this.scanner.scan();
                        }
                        break;
                    }
                    case TokenID.If: {
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("if statement does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        this.checkNextToken(TokenID.OpenParen, errorRecoverySet | ErrorRecoverySet.ExprStart);
                        var ifStmt = new IfStatement(this.parseExpr(errorRecoverySet |
                                                             ErrorRecoverySet.LParen,
                                                             OperatorPrecedence.None, true,
                                                             TypeContext.NoTypes));
                        ifStmt.minChar = minChar;
                        ifStmt.statement.minChar = minChar;
                        ifStmt.statement.limChar = this.scanner.pos;
                        this.checkCurrentToken(TokenID.CloseParen, errorRecoverySet | ErrorRecoverySet.StmtStart);
                        this.pushStmt(ifStmt, labelList);
                        ifStmt.thenBod = this.parseStatement(ErrorRecoverySet.Else | errorRecoverySet,
                                                      allowedElements, parentModifiers);
                        ifStmt.limChar = ifStmt.thenBod.limChar;
                        if (this.currentToken.tokenId == TokenID.Else) {
                            this.currentToken = this.scanner.scan();
                            ifStmt.elseBod = this.parseStatement(errorRecoverySet, allowedElements, parentModifiers);
                            ifStmt.limChar = ifStmt.elseBod.limChar;
                        }
                        this.popStmt();
                        ast = ifStmt;
                        break;
                    }
                    case TokenID.Try: {
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("try statement does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        ast = this.parseTryCatchFinally(errorRecoverySet, parentModifiers, labelList);
                        break;
                    }
                    case TokenID.OpenBrace: {
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("block does not take modifiers");
                        }
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var block = new Block(new ASTList(), true);
                        this.pushStmt(block, labelList);
                        this.parseStatementList(
                            errorRecoverySet | ErrorRecoverySet.RCurly, block.statements,
                            /*sourceElements:*/ false, /*noLeadingCase:*/ false, AllowedElements.None, modifiers);
                        this.popStmt();
                        block.statements.minChar = minChar;
                        block.statements.limChar = this.scanner.pos;
                        block.minChar = block.statements.minChar;
                        block.limChar = block.statements.limChar;
                        this.checkCurrentToken(TokenID.CloseBrace, errorRecoverySet);
                        ast = block;
                        break;
                    }
                    case TokenID.Semicolon:
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("modifier can not appear here");
                        }
                        ast = new AST(NodeType.Empty);
                        this.currentToken = this.scanner.scan();
                        break;
                    case TokenID.Break:
                    case TokenID.Continue: {
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("modifiers can not appear before jump statement");
                        }
                        var jump =
                            new Jump((this.currentToken.tokenId == TokenID.Break) ? NodeType.Break : NodeType.Continue);
                        this.currentToken = this.scanner.scan();
                        if ((this.currentToken.tokenId == TokenID.Identifier) && (!this.scanner.lastTokenHadNewline())) {
                            // Labeled break or continue.
                            jump.target = this.currentToken.getText();
                            this.currentToken = this.scanner.scan();
                        }
                        this.resolveJumpTarget(jump);
                        ast = jump;
                        needTerminator = true;
                        break;
                    }
                    case TokenID.Return: {
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("modifiers can not appear before return statement");
                        }
                        if (!this.inFunction) {
                            this.reportParseError("return statement outside of function body");
                        }
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var retStmt = new ReturnStatement();
                        retStmt.minChar = minChar;
                        if ((this.currentToken.tokenId != TokenID.Semicolon) &&
                            (this.currentToken.tokenId != TokenID.CloseBrace) &&
                            (!(this.scanner.lastTokenHadNewline()))) {
                            retStmt.returnExpression = this.parseExpr(errorRecoverySet |
                                                               ErrorRecoverySet.SColon,
                                                               OperatorPrecedence.None,
                                                               true, TypeContext.NoTypes);
                        }
                        needTerminator = true;
                        retStmt.limChar = this.scanner.lastTokenLimChar();
                        ast = retStmt;
                        break;
                    }
                    case TokenID.Throw:
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("modifiers can not appear before a throw statement");
                        }
                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        if ((this.currentToken.tokenId != TokenID.Semicolon) &&
                            (this.currentToken.tokenId != TokenID.CloseBrace) &&
                            (!(this.scanner.lastTokenHadNewline()))) {
                            temp = this.parseExpr(errorRecoverySet | ErrorRecoverySet.SColon,
                                           OperatorPrecedence.None, true, TypeContext.NoTypes);
                        }
                        else {
                            this.reportParseError("throw with no target");
                            temp = null;
                        }
                        ast = new UnaryExpression(NodeType.Throw, temp);
                        ast.limChar = this.scanner.lastTokenLimChar();
                        needTerminator = true;
                        break;
                    case TokenID.Enum:
                        // TODO: check module allowed here
                        //minChar=scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        ast = this.parseEnumDecl(errorRecoverySet, modifiers);
                        ast.minChar = minChar;
                        ast.limChar = this.scanner.lastTokenLimChar();
                        if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Ambient)) {
                            (<ModuleDeclaration>ast).modFlags |= ModuleFlags.Ambient;
                        }
                        if (this.parsingDeclareFile || this.ambientModule || hasFlag(modifiers, Modifiers.Exported)) {
                            (<ModuleDeclaration>ast).modFlags |= ModuleFlags.Exported;
                        }
                        break;
                    case TokenID.Debugger:
                        mayNotBeExported();
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("modifiers can not appear before debugger statement");
                        }

                        minChar = this.scanner.startPos;
                        this.currentToken = this.scanner.scan();
                        var debuggerStmt = new DebuggerStatement();
                        debuggerStmt.minChar = minChar;
                        needTerminator = true;
                        debuggerStmt.limChar = this.scanner.lastTokenLimChar();
                        ast = debuggerStmt;
                        break;
                    default:
                        if (modifiers != Modifiers.None) {
                            this.reportParseError("modifiers can not appear before an expression statement or label");
                        }
                        minChar = this.scanner.startPos;
                        var svPos = this.scanner.pos;
                        temp = this.parseExpr(ErrorRecoverySet.Colon | ErrorRecoverySet.StmtStart |
                                       errorRecoverySet, OperatorPrecedence.None, true,
                                       TypeContext.NoTypes);
                        if (this.scanner.pos == svPos) {
                            // no progress
                            this.currentToken = this.scanner.scan();
                            ast = temp;
                        }
                        else if ((this.currentToken.tokenId == TokenID.Colon) && (!this.scanner.lastTokenHadNewline()) &&
                                        temp && (temp.nodeType == NodeType.Name)) {
                            // It's a label
                            if (labelList == null) {
                                labelList = new ASTList();
                            }
                            labelList.append(new Label(<Identifier>temp));
                            this.currentToken = this.scanner.scan();
                        }
                        else {
                            // expression statement
                            ast = temp;
                            needTerminator = true;
                        }
                }
                if (ast) {
                    break;
                }
            }
            if (needTerminator) {
                switch (this.currentToken.tokenId) {
                    case TokenID.Semicolon:
                        this.currentToken = this.scanner.scan();
                        ast.flags |= ASTFlags.ExplicitSemicolon;
                        break;
                    case TokenID.EndOfFile:
                        // Extend any incomplete statements to include EOF token. This makes sure that this node is in the path 
                        // when completion or parameter help is requested.
                        ast.limChar = this.scanner.pos;
                    // IntentionaCloseBracethrough
                    case TokenID.CloseBrace:
                        ast.flags |= ASTFlags.AutomaticSemicolon;
                        if (this.style_requireSemi) {
                            this.reportParseStyleError("no automatic semicolon");
                        }
                        break;
                    default:
                        if (!this.scanner.lastTokenHadNewline()) {
                            this.reportParseError("Expected ';'");
                        }
                        else {
                            ast.flags |= ASTFlags.AutomaticSemicolon;
                            if (this.style_requireSemi) {
                                this.reportParseStyleError("no automatic semicolon");
                            }
                        }
                        break;
                }
            }
            if (labelList) {
                ast = new LabeledStatement(labelList, ast);
            }

            ///////////////////////////////////////////////////////////
            //TODO: Eventually, we want to remove "minChar" and "limChar" assignments here,
            //      as they are sometimes not specific enough for each statement kind.
            ast.minChar = minChar;
            // Only update "limChar" if it is not better than "lastTokenLimChar()"
            ast.limChar = max(ast.limChar, this.scanner.lastTokenLimChar());
            //
            ///////////////////////////////////////////////////////////

            if (preComments) {
                ast.preComments = ast.preComments ? preComments.concat(ast.preComments) : preComments;
            }
            if (this.ambientModule && (!this.okAmbientModuleMember(ast))) {
                this.reportParseError("statement not permitted within ambient module");
            }
            ast.flags |= ASTFlags.IsStatement;
            return ast;
        }

        private okAmbientModuleMember(ast: AST) {
            var nt = ast.nodeType;

            return (nt == NodeType.ClassDeclaration) || (nt == NodeType.ImportDeclaration) || (nt == NodeType.InterfaceDeclaration) || (nt == NodeType.ModuleDeclaration) ||
                (nt == NodeType.Empty) || (nt == NodeType.VarDecl) ||
                ((nt == NodeType.Block) && !(<Block>ast).isStatementBlock) ||
                ((nt == NodeType.FuncDecl) && ((<FuncDecl>ast).bod == null));
        }

        private parseStatementList(errorRecoverySet: ErrorRecoverySet,
            statements: ASTList,
            sourceElms: bool,
            noLeadingCase: bool,
            allowedElements: AllowedElements,
            parentModifiers: Modifiers): void {
            var directivePrologue = sourceElms;
            statements.minChar = this.scanner.startPos;
            var limChar = this.scanner.pos;
            var innerStmts = (allowedElements & AllowedElements.ModuleDeclarations) == AllowedElements.None;
            var classNope = (allowedElements & AllowedElements.ClassDeclarations) == AllowedElements.None;

            errorRecoverySet |= ErrorRecoverySet.TypeScriptS | ErrorRecoverySet.RCurly;

            var oldStrictMode = this.strictMode;
            this.nestingLevel++;

            for (; ;) {
                if ((this.currentToken.tokenId == TokenID.CloseBrace) ||
                    (noLeadingCase && ((this.currentToken.tokenId == TokenID.Case) || (this.currentToken.tokenId == TokenID.Default))) ||
                    (innerStmts && (this.currentToken.tokenId == TokenID.Export)) ||
                    (classNope && (this.currentToken.tokenId == TokenID.Class)) ||
                    (this.currentToken.tokenId == TokenID.EndOfFile)) {
                    statements.limChar = limChar;
                    if (statements.members.length == 0) {
                        statements.preComments = this.parseComments();
                    }
                    else {
                        statements.postComments = this.parseComments();
                    }
                    this.strictMode = oldStrictMode;
                    this.nestingLevel--;
                    return;
                }

                var stmt = this.parseStatement(errorRecoverySet &
                                        (~(ErrorRecoverySet.Else | ErrorRecoverySet.RParen |
                                           ErrorRecoverySet.Catch | ErrorRecoverySet.Colon)),
                                        allowedElements, parentModifiers);

                if (stmt) {
                    stmt.postComments = this.combineComments(stmt.postComments, this.parseCommentsForLine(this.scanner.prevLine));
                    statements.append(stmt);
                    limChar = stmt.limChar;
                    if (directivePrologue) {
                        if (stmt.nodeType == NodeType.QString) {
                            var qstring = <StringLiteral>stmt;
                            if (qstring.text == "\"use strict\"") {
                                statements.flags |= ASTFlags.StrictMode;
                                this.strictMode = true;
                            }
                            else {
                                directivePrologue = false;
                            }
                        }
                        else {
                            directivePrologue = false;
                        }
                    }
                }
            }
        }

        private fname = "";

        public quickParse(sourceText: ISourceText, filename: string, unitIndex: number): QuickParseResult {
            //TODO: REVIEW: We set this to avoid adding a "module" decl in the resulting script (see parse() method)
            var svGenTarget = TypeScript.moduleGenTarget;
            try {
                TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Local;
                var script = this.parse(sourceText, filename, unitIndex, AllowedElements.QuickParse);
                return new QuickParseResult(script, this.scanner.lexState);
            }
            finally {
                TypeScript.moduleGenTarget = svGenTarget;
            }
        }

        public parse(sourceText: ISourceText, filename: string, unitIndex: number, allowedElements = AllowedElements.Global): Script {
            // Reset all parser state here.  This allows us to be resilient to reentrancy if an 
            // exception is thrown.
            this.fname = filename;
            this.currentUnitIndex = unitIndex;

            this.currentToken = null;
            this.needTerminator = false;
            this.inFunction = false;
            this.inInterfaceDecl = false;
            this.inFncDecl = false;
            this.ambientModule = false;
            this.ambientClass = false;
            this.topLevel = true;
            this.allowImportDeclaration = true;
            this.prevIDTok = null;
            this.statementInfoStack = new IStatementInfo[];
            this.hasTopLevelImportOrExport = false;
            this.strictMode = false;
            this.nestingLevel = 0;
            this.prevExpr = null;
            this.currentClassDefinition = null;
            this.parsingClassConstructorDefinition = false;
            this.parsingDeclareFile = false;
            this.amdDependencies = [];
            this.inferPropertiesFromThisAssignment = false;
            this.requiresExtendsBlock = false;

            this.scanner.resetComments();
            this.scanner.setErrorHandler((message) => this.reportParseError(message));
            this.scanner.setSourceText(sourceText, LexMode.File);

            var leftCurlyCount = this.scanner.leftCurlyCount;
            var rightCurlyCount = this.scanner.rightCurlyCount;

            var minChar = this.scanner.pos;
            this.currentToken = this.scanner.scan();
            this.pushDeclLists();
            var bod = new ASTList();
            bod.minChar = minChar;

            this.parsingDeclareFile = isDSTRFile(filename) || isDTSFile(filename);

            while (true) {
                this.parseStatementList(
                    ErrorRecoverySet.EOF | ErrorRecoverySet.Func,
                    bod, /*sourceElements:*/ true, /*noLeadingCase:*/ false,
                    allowedElements, Modifiers.None);

                if (this.currentToken.tokenId === TokenID.EndOfFile) {
                    break;
                }

                // Still have remaining tokens in the file.  Report error for this unexpected token,
                // skip it, and continue trying to parse statements until we're done. 
                var badToken = tokenTable[this.currentToken.tokenId];
                this.reportParseError("Unexpected statement block terminator '" + badToken.text + "'");

                this.currentToken = this.scanner.scan();
            }

            bod.limChar = this.scanner.pos;

            var topLevelMod: ModuleDeclaration = null;
            if (moduleGenTarget != ModuleGenTarget.Local && this.hasTopLevelImportOrExport) {
                var correctedFileName = switchToForwardSlashes(filename);
                var id: Identifier = new Identifier(correctedFileName);
                topLevelMod = new ModuleDeclaration(id, bod, this.topVarList(), null);

                topLevelMod.modFlags |= ModuleFlags.IsDynamic;
                topLevelMod.modFlags |= ModuleFlags.IsWholeFile;
                topLevelMod.modFlags |= ModuleFlags.Exported;

                if (this.parsingDeclareFile) {
                    topLevelMod.modFlags |= ModuleFlags.Ambient;
                }

                topLevelMod.minChar = minChar;
                topLevelMod.limChar = this.scanner.pos;
                topLevelMod.prettyName = getPrettyName(correctedFileName);
                topLevelMod.containsUnicodeChar = this.scanner.seenUnicodeChar;
                topLevelMod.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;

                topLevelMod.amdDependencies = this.amdDependencies;

                bod = new ASTList();
                bod.minChar = topLevelMod.minChar;
                bod.limChar = topLevelMod.limChar;
                bod.append(topLevelMod);
            }

            var script = new Script(this.topVarList(), this.topScopeList());
            script.bod = bod;
            this.popDeclLists();
            script.minChar = minChar;
            script.limChar = this.scanner.pos;
            script.locationInfo = new LocationInfo(filename, this.scanner.lineMap, unitIndex);
            script.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            script.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            script.isDeclareFile = this.parsingDeclareFile;
            script.topLevelMod = topLevelMod;
            script.containsUnicodeChar = this.scanner.seenUnicodeChar;
            script.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;
            script.requiresExtendsBlock = this.requiresExtendsBlock;
            return script;
        }
    }

    export function quickParse(logger: TypeScript.ILogger, scopeStartAST: AST, sourceText: ISourceText, minChar: number, limChar: number,
        errorCapture: (minChar: number, charLen: number, message: string, unitIndex: number) => void ): QuickParseResult {

        var fragment = sourceText.getText(minChar, limChar);
        logger.log("Quick parse range (" + minChar + "," + limChar + "): \"" + TypeScript.stringToLiteral(fragment, 100) + "\"");

        var quickParser = new Parser();
        quickParser.setErrorRecovery(null);
        quickParser.errorCallback = errorCapture;

        // REVIEW: use enclosing scope to determine this
        // REVIEW: Why even use class here?
        var quickClassDecl = new ClassDeclaration(null, null, null, null, null);
        quickParser.currentClassDecl = quickClassDecl;

        var result = quickParser.quickParse(new StringSourceText(fragment), "", 0);
        return result;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    // TODO: refactor indent logic for use in emit
    export class PrintContext {
        public builder = "";
        public indent1 = "  ";
        public indentStrings: string[] = [];
        public indentAmt = 0;

        constructor (public outfile: ITextWriter, public parser: Parser) {
        }

        public increaseIndent() {
            this.indentAmt++;
        }

        public decreaseIndent() {
            this.indentAmt--;
        }

        public startLine() {
            if (this.builder.length > 0) {
                CompilerDiagnostics.Alert(this.builder);
            }
            var indentString = this.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for (var i = 0; i < this.indentAmt; i++) {
                    indentString += this.indent1;
                }
                this.indentStrings[this.indentAmt] = indentString;
            }
            this.builder += indentString;
        }

        public write(s) {
            this.builder += s;
        }

        public writeLine(s) {
            this.builder += s;
            this.outfile.WriteLine(this.builder);
            this.builder = "";
        }

    }

    export function prePrintAST(ast: AST, parent: AST, walker: IAstWalker) {
        var pc: PrintContext = <PrintContext>walker.state;

        ast.print(pc);
        pc.increaseIndent();
        return ast;
    }


    export function postPrintAST(ast: AST, parent: AST, walker: IAstWalker) {
        var pc: PrintContext = <PrintContext>walker.state;
        pc.decreaseIndent();
        return ast;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='typescript.ts' />

module TypeScript {

    export var LexEOF = (-1);

    export var LexCodeNWL = 0x0A;
    export var LexCodeRET = 0x0D;
    export var LexCodeLS = 0x2028;
    export var LexCodePS = 0x2029;
    export var LexCodeTAB = 0x09;
    export var LexCodeVTAB = 0x0B;
    export var LexCode_e = 'e'.charCodeAt(0);
    export var LexCode_E = 'E'.charCodeAt(0);
    export var LexCode_x = 'x'.charCodeAt(0);
    export var LexCode_X = 'X'.charCodeAt(0);
    export var LexCode_a = 'a'.charCodeAt(0);
    export var LexCode_A = 'A'.charCodeAt(0);
    export var LexCode_f = 'f'.charCodeAt(0);
    export var LexCode_F = 'F'.charCodeAt(0);

    export var LexCode_g = 'g'.charCodeAt(0);
    export var LexCode_m = 'm'.charCodeAt(0);
    export var LexCode_i = 'i'.charCodeAt(0);

    export var LexCode_u = 'u'.charCodeAt(0);

    export var LexCode_0 = '0'.charCodeAt(0);
    export var LexCode_9 = '9'.charCodeAt(0);
    export var LexCode_8 = '8'.charCodeAt(0);
    export var LexCode_7 = '7'.charCodeAt(0);

    export var LexCodeBSL = '\\'.charCodeAt(0);
    export var LexCodeSHP = '#'.charCodeAt(0);
    export var LexCodeBNG = '!'.charCodeAt(0);
    export var LexCodeQUO = '"'.charCodeAt(0);
    export var LexCodeAPO = '\''.charCodeAt(0);
    export var LexCodePCT = '%'.charCodeAt(0);
    export var LexCodeAMP = '&'.charCodeAt(0);
    export var LexCodeLPR = '('.charCodeAt(0);
    export var LexCodeRPR = ')'.charCodeAt(0);
    export var LexCodePLS = '+'.charCodeAt(0);
    export var LexCodeMIN = '-'.charCodeAt(0);
    export var LexCodeMUL = '*'.charCodeAt(0);
    export var LexCodeSLH = '/'.charCodeAt(0);
    export var LexCodeXOR = '^'.charCodeAt(0);
    export var LexCodeCMA = ','.charCodeAt(0);
    export var LexCodeDOT = '.'.charCodeAt(0);
    export var LexCodeLT = '<'.charCodeAt(0);
    export var LexCodeEQ = '='.charCodeAt(0);
    export var LexCodeGT = '>'.charCodeAt(0);
    export var LexCodeQUE = '?'.charCodeAt(0);
    export var LexCodeLBR = '['.charCodeAt(0);
    export var LexCodeRBR = ']'.charCodeAt(0);
    export var LexCodeUSC = '_'.charCodeAt(0);
    export var LexCodeLC = '{'.charCodeAt(0);
    export var LexCodeRC = '}'.charCodeAt(0);
    export var LexCodeBAR = '|'.charCodeAt(0);
    export var LexCodeTIL = '~'.charCodeAt(0);
    export var LexCodeCOL = ':'.charCodeAt(0);
    export var LexCodeSMC = ';'.charCodeAt(0);
    export var LexCodeUnderscore = '_'.charCodeAt(0);
    export var LexCodeDollar = '$'.charCodeAt(0);
    export var LexCodeSpace = 32;
    export var LexCodeAtSign = '@'.charCodeAt(0);
    export var LexCodeASCIIChars = 128;

    export var LexKeywordTable = undefined;
    // TODO: use new Token[128];
    var autoToken: Token[] = new Array(LexCodeASCIIChars);
    var lexIdStartTable: bool[] = new Array(LexCodeASCIIChars);

    // Unicode range maps
    // REVIEW: These range maps have been extracted from the Unicode specifications, they might be missing values, and/or include 
    //         incorrect ranges. but for the most they seem to be correct. A more accurate and thorough review is needed.

    /*
        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
        IdentifierStart :: Can contain Unicode 3.0.0  categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.
        IdentifierPart :: Can contain IdentifierStart + Unicode 3.0.0  categories “Non-spacing mark (Mn)”, “Combining spacing mark (Mc)”, “Decimal number (Nd)”, or “Connector punctuation (Pc)”.
                    
        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
    */
    var unicodeES3IdStart = [
        170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,
        1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611,
        2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970,
        2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517,
        3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138,
        4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885,
        4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147,
        8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588,
        12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140,
        65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,
    ];

    var unicodeES3IdCont = [
        768, 846, 864, 866, 1155, 1158, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1611, 1621, 1632, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 2305, 2307, 2364, 2364, 2366, 2381, 2385, 2388, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492,
        2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2562, 2562, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2662, 2673, 2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2790, 2799, 2817, 2819, 2876, 2876, 2878, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2918, 2927, 2946, 2947, 3006, 3010, 3014, 3016,
        3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3174, 3183, 3202, 3203, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3302, 3311, 3330, 3331, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3633, 3633,
        3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903, 3953, 3972, 3974, 3975, 3984, 3991, 3993, 4028, 4038, 4038, 4140, 4146, 4150, 4153, 4160, 4169, 4182, 4185, 4969, 4977, 6068, 6099, 6112, 6121, 6160, 6169, 6313, 6313,
        8255, 8256, 8400, 8412, 8417, 8417, 12330, 12335, 12441, 12442, 12539, 12539, 64286, 64286, 65056, 65059, 65075, 65076, 65101, 65103, 65296, 65305, 65343, 65343, 65381, 65381,
    ];


    /*
        As per ECMAScript Language Specification 5th Edition, Section 7.6: Identifier Names and Identifiers
        IdentifierStart :: Can contain Unicode 6.2  categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.
        IdentifierPart :: Can contain IdentifierStart + Unicode 6.2  categories “Non-spacing mark (Mn)”, “Combining spacing mark (Mc)”, “Decimal number (Nd)”, “Connector punctuation (Pc)”, <ZWNJ>, or <ZWJ>.
                    
        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
    */
    var unicodeES5IdStart = [
         170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775,
         1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489,
         2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864,
         2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,
         3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743,
         3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680,
         4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000,
         6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957,
         7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486,
         8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726,
         11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606,
         42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595,
         43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262,
         64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,
    ];

    var unicodeES5IdCont = [
        768, 879, 1155, 1159, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1552, 1562, 1611, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 1984, 1993, 2027, 2035, 2070, 2073, 2075, 2083, 2085, 2087, 2089, 2093, 2137, 2139, 2276, 2302, 2304, 2307, 2362, 2364,
        2366, 2383, 2385, 2391, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2561, 2563, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2662, 2673, 2677, 2677, 2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2786, 2787, 2790, 2799, 2817, 2819,
        2876, 2876, 2878, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2914, 2915, 2918, 2927, 2946, 2946, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3046, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3170, 3171, 3174, 3183, 3202, 3203, 3260, 3260, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3298, 3299, 3302, 3311,
        3330, 3331, 3390, 3396, 3398, 3400, 3402, 3405, 3415, 3415, 3426, 3427, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3633, 3633, 3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903,
        3953, 3972, 3974, 3975, 3981, 3991, 3993, 4028, 4038, 4038, 4139, 4158, 4160, 4169, 4182, 4185, 4190, 4192, 4194, 4196, 4199, 4205, 4209, 4212, 4226, 4237, 4239, 4253, 4957, 4959, 5906, 5908, 5938, 5940, 5970, 5971, 6002, 6003, 6068, 6099, 6109, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6313, 6313, 6432, 6443, 6448, 6459, 6470, 6479,
        6576, 6592, 6600, 6601, 6608, 6617, 6679, 6683, 6741, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6912, 6916, 6964, 6980, 6992, 7001, 7019, 7027, 7040, 7042, 7073, 7085, 7088, 7097, 7142, 7155, 7204, 7223, 7232, 7241, 7248, 7257, 7376, 7378, 7380, 7400, 7405, 7405, 7410, 7412, 7616, 7654, 7676, 7679, 8204, 8205, 8255, 8256, 8276, 8276,
        8400, 8412, 8417, 8417, 8421, 8432, 11503, 11505, 11647, 11647, 11744, 11775, 12330, 12335, 12441, 12442, 42528, 42537, 42607, 42607, 42612, 42621, 42655, 42655, 42736, 42737, 43010, 43010, 43014, 43014, 43019, 43019, 43043, 43047, 43136, 43137, 43188, 43204, 43216, 43225, 43232, 43249, 43264, 43273, 43302, 43309, 43335, 43347,
        43392, 43395, 43443, 43456, 43472, 43481, 43561, 43574, 43587, 43587, 43596, 43597, 43600, 43609, 43643, 43643, 43696, 43696, 43698, 43700, 43703, 43704, 43710, 43711, 43713, 43713, 43755, 43759, 43765, 43766, 44003, 44010, 44012, 44013, 44016, 44025, 64286, 64286, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103,
        65296, 65305, 65343, 65343,
    ];

    export function LexLookUpUnicodeMap(code: number, map: number[]): bool {
        // Perform binary search in one of the unicode range maps
        var lo: number = 0;
        var hi: number = map.length;
        var mid: number;

        while (lo + 1 < hi) {
            mid = lo + (hi - lo) / 2;
            // mid has to be even to catch a range's beginning
            mid -= mid % 2;
            if (map[mid] <= code && code <= map[mid + 1])
                return true;
            if (code < map[mid])
                hi = mid;
            else
                lo = mid + 2;
        }
        return false;
    }

    export function LexIsUnicodeDigit(code: number): bool {
        if (codeGenTarget == CodeGenTarget.ES3) {
            return LexLookUpUnicodeMap(code, unicodeES3IdCont);
        } else {
            return LexLookUpUnicodeMap(code, unicodeES5IdCont);
        }
    }

    export function LexIsUnicodeIdStart(code: number): bool {
        if (codeGenTarget == CodeGenTarget.ES3) {
            return LexLookUpUnicodeMap(code, unicodeES3IdStart);
        } else {
            return LexLookUpUnicodeMap(code, unicodeES5IdStart);
        }
    }

    export function LexInitialize() {
        initializeStaticTokens();
        autoToken[LexCodeLPR] = staticTokens[TokenID.OpenParen];
        autoToken[LexCodeRPR] = staticTokens[TokenID.CloseParen];
        autoToken[LexCodeCMA] = staticTokens[TokenID.Comma];
        autoToken[LexCodeSMC] = staticTokens[TokenID.Semicolon];
        autoToken[LexCodeLBR] = staticTokens[TokenID.OpenBracket];
        autoToken[LexCodeRBR] = staticTokens[TokenID.CloseBracket];
        autoToken[LexCodeTIL] = staticTokens[TokenID.Tilde];
        autoToken[LexCodeQUE] = staticTokens[TokenID.Question];
        autoToken[LexCodeLC] = staticTokens[TokenID.OpenBrace];
        autoToken[LexCodeRC] = staticTokens[TokenID.CloseBrace];
        autoToken[LexCodeCOL] = staticTokens[TokenID.Colon];
        LexKeywordTable = new StringHashTable();
        for (var i in (<any>TokenID)._map) {
            if ((<number><any>i) <= TokenID.LimKeyword) {
                LexKeywordTable.add((<any>TokenID)._map[i].toLowerCase(), i);
            }
        }
        for (var j = 0; j < LexCodeASCIIChars; j++) {
            if (LexIsIdentifierStartChar(j)) {
                lexIdStartTable[j] = true;
            }
            else {
                lexIdStartTable[j] = false;
            }
        }
    }

    export function LexAdjustIndent(code, indentAmt) {
        if ((code == LexCodeLBR) || (code == LexCodeLC) || (code == LexCodeLPR)) {
            return indentAmt + 1;
        }
        else if ((code == LexCodeRBR) || (code == LexCodeRC) || (code == LexCodeRPR)) {
            return indentAmt - 1;
        }
        else return indentAmt;
    }

    export function LexIsIdentifierStartChar(code): bool {
        return (((code >= 97) && (code <= 122)) ||
                ((code >= 65) && (code <= 90)) ||
                (code == LexCodeDollar) ||
                (code == LexCodeUnderscore));
    }

    export function LexIsDigit(code): bool {
        return ((code >= 48) && (code <= 57));
    }

    export function LexIsIdentifierChar(code: number) {
        return lexIdStartTable[code] || LexIsDigit(code);
    }

    export function LexMatchingOpen(code) {
        if (code == LexCodeRBR)
            return LexCodeLBR;
        else if (code == LexCodeRC)
            return LexCodeLC;
        else if (code == LexCodeRPR)
            return LexCodeLPR;
        else return 0;
    }

    export enum NumberScanState {
        Start,
        InFraction,
        InEmptyFraction,
        InExponent
    }

    export enum LexState {
        Start,
        InMultilineComment,
        InMultilineSingleQuoteString,
        InMultilineDoubleQuoteString,
    }

    export enum LexMode {
        Line,
        File,
    }

    export enum CommentStyle {
        Line,
        Block
    }

    // Represent a piece of source code which can be read in multiple segments
    export interface ISourceText {
        getText(start: number, end: number): string;
        getLength(): number;
    }

    export class SourceSimpleText implements ISimpleText {
        constructor(private text: ISourceText) {
        }

        public length() {
            return this.text.getLength();
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            StringUtilities.copyTo(this.text.getText(sourceIndex, sourceIndex +count), 0, destination, destinationIndex, count);
        }

        public substr(start: number, length: number, intern: bool): string {
            // TODO: intern as appropriate.
            return this.text.getText(start, start + length);
        }

        public subText(span: TextSpan): ISimpleText {
            return TextFactory.createSimpleSubText(this, span);
        }
    }

    // Implementation on top of a contiguous string
    export class StringSourceText implements ISourceText {
        constructor(public text: string) {
        }

        public getText(start: number, end: number): string {
            return this.text.substring(start, end);
        }

        public getLength(): number {
            return this.text.length;
        }
    }

    export class SourceTextSegment implements ISourceTextSegment {
        constructor(public segmentStart: number,
                    public segmentEnd: number,
                    public segment: string) {
        }

        charCodeAt(index: number): number {
            return this.segment.charCodeAt(index - this.segmentStart);
        }

        substring(start: number, end: number): string {
            return this.segment.substring(start - this.segmentStart, end - this.segmentStart);
        }
    }

    export class AggerateSourceTextSegment implements ISourceTextSegment {
        constructor(public seg1: SourceTextSegment, public seg2: SourceTextSegment) {
        }

        public charCodeAt(index: number): number {
            if (this.seg1.segmentStart <= index && index < this.seg1.segmentEnd)
                return this.seg1.segment.charCodeAt(index - this.seg1.segmentStart);

            return this.seg2.segment.charCodeAt(index - this.seg2.segmentStart);
        }

        public substring(start: number, end: number): string {
            if (this.seg1.segmentStart <= start && end <= this.seg1.segmentEnd)
                return this.seg1.segment.substring(start - this.seg1.segmentStart, end - this.seg1.segmentStart);

            return this.seg2.segment.substring(start - this.seg2.segmentStart) + this.seg1.segment.substring(0, end - this.seg1.segmentStart);
        }
    }

    export interface ISourceTextSegment {
        charCodeAt(index: number): number;
        substring(start: number, end: number): string;
    }

    export class ScannerTextStream {
        static emptySegment = new SourceTextSegment(0, 0, "");
        public agg: AggerateSourceTextSegment;
        public len: number;

        constructor(public sourceText: ISourceText) {
            this.agg = new AggerateSourceTextSegment(ScannerTextStream.emptySegment, ScannerTextStream.emptySegment);
            this.len = this.sourceText.getLength();
        }

        public max(a: number, b: number): number {
            return a >= b ? a : b;
        }

        public min(a: number, b: number): number {
            return a <= b ? a : b;
        }

        public fetchSegment(start: number, end: number): ISourceTextSegment {
            // Common case
            if (this.agg.seg1.segmentStart <= start && end <= this.agg.seg1.segmentEnd)
                return this.agg.seg1;

            // Common overlap case
            if (this.agg.seg2.segmentStart <= start && end <= this.agg.seg1.segmentEnd)
                return this.agg;

            // if overlapping outside of fetched segment(s), fetch a new segment
            var prev = this.agg.seg1;

            var s = prev.segmentEnd;
            var e = max(s + 512, end); // ensure we move forward at least 512 characters or "end"
            e = min(e, this.len);    // but don't go past the end of the source text

            var src = this.sourceText.getText(s, e);
            var newSeg = new SourceTextSegment(s, e, src);
            this.agg.seg2 = prev;
            this.agg.seg1 = newSeg;
            return this.agg;
        }

        public charCodeAt(index: number): number {
            return this.fetchSegment(index, index + 1).charCodeAt(index);
        }

        public substring(start: number, end: number) {
            return this.fetchSegment(start, end).substring(start, end);
        }
    }

    export interface IScanner {
        startPos: number;
        pos: number;
        scan(): Token;
        previousToken(): Token;
        prevLine: number;
        line: number;
        col: number;
        leftCurlyCount: number;
        rightCurlyCount: number;
        lastTokenLimChar(): number;
        lastTokenHadNewline(): bool;
        lexState: number;
        getComments(): CommentToken[];
        getCommentsForLine(line: number): CommentToken[];
        resetComments(): void;
        lineMap: number[];
        setSourceText(newSrc: ISourceText, textMode: number): void;
        setErrorHandler(reportError: (message: string) => void ): void;
        seenUnicodeChar: bool;
        seenUnicodeCharInComment: bool;
        getLookAheadToken(): Token;
    }

    export class SavedTokens implements IScanner {
        public prevToken: Token = null;
        public curSavedToken: SavedToken = null;
        public prevSavedToken: SavedToken = null;
        public currentTokenIndex: number;
        public currentTokens: SavedToken[];
        public tokensByLine: SavedToken[][];
        public lexStateByLine: LexState[];
        public previousToken(): Token { return this.prevToken; }
        public currentToken = 0;
        public tokens = new SavedToken[];
        public startPos: number;
        public pos: number;
        public seenUnicodeChar: bool = false;
        seenUnicodeCharInComment: bool = false;

        public startLine: number;
        public prevLine = 1;
        public line = 1;
        public col = 0;
        public leftCurlyCount: number;
        public rightCurlyCount: number;

        public lexState = LexState.Start;
        public commentStack: CommentToken[] = new CommentToken[];

        public lineMap: number[] = [];

        public addToken(tok: Token, scanner: IScanner) {
            this.tokens[this.currentToken++] = new SavedToken(tok, scanner.startPos, scanner.pos);
        }

        public scan(): Token {
            // TODO: curly count
            this.startLine = this.line;
            this.startPos = this.col;
            if (this.currentTokenIndex == this.currentTokens.length) {
                if (this.line < this.lineMap.length) {
                    this.line++;
                    this.col = 0;
                    this.currentTokenIndex = 0;
                    this.currentTokens = this.tokensByLine[this.line];
                }
                else {
                    return staticTokens[TokenID.EndOfFile];
                }
            }

            if (this.currentTokenIndex < this.currentTokens.length) {
                this.prevToken = this.curSavedToken.tok;
                this.prevSavedToken = this.curSavedToken;
                this.curSavedToken = this.currentTokens[this.currentTokenIndex++];
                var curToken = this.curSavedToken.tok;
                this.pos = this.curSavedToken.limChar;
                this.col += (this.curSavedToken.limChar - this.curSavedToken.minChar);
                this.startPos = this.curSavedToken.minChar;
                this.prevLine = this.line;
                return curToken;
            }
            else {
                return staticTokens[TokenID.EndOfFile];
            }
        }

        public lastTokenLimChar(): number {
            if (this.prevSavedToken !== null) {
                return this.prevSavedToken.limChar;
            }
            else {
                return 0;
            }
        }

        public lastTokenHadNewline(): bool {
            return this.prevLine != this.startLine;
        }

        public getComments() {
            var stack = this.commentStack;
            this.commentStack = [];
            return stack;
        }

        public getCommentsForLine(line: number) {
            var comments: CommentToken[] = null;
            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {
                if (comments == null) {
                    comments = [this.commentStack.shift()];
                }
                else {
                    comments = comments.concat([this.commentStack.shift()]);
                }

            }
            return comments;
        }

        public resetComments() {
            this.commentStack = [];
        }

        public setSourceText(newSrc: ISourceText, textMode: number) {
        }

        public setErrorHandler(reportError: (message: string) => void ) {
        }

        public getLookAheadToken(): Token {
            throw new Error("Invalid operation.");
        }
    }

    export class Scanner implements IScanner {
        // REVIEW: When adding new variables make sure to handle storing them in getLookAheadToken. 
        //         The method works by storing the state before scanning and restoring it later on,
        //         missing a member variable could result in an inconsistent state.
        public prevLine = 1;
        public line = 1;
        public col = 0;
        public pos = 0;
        public startPos = 0;
        public startCol: number;
        public startLine: number;
        public src: string;
        public len = 0;
        public lineMap: number[] = [];

        public ch = LexEOF;
        public lexState = LexState.Start;
        public mode = LexMode.File;
        public scanComments: bool = true;
        public interveningWhitespace = false; // Was there a whitespace token between the last token and the current one?
        private interveningWhitespacePos = 0; //  If yes, this contains the start position of the whitespace
        public leftCurlyCount = 0;
        public rightCurlyCount = 0;
        public commentStack: CommentToken[] = new CommentToken[];
        public saveScan: SavedTokens = null;
        public seenUnicodeChar: bool = false;
        seenUnicodeCharInComment: bool = false;

        private reportError: (message: string) => void;

        private prevTok = staticTokens[TokenID.EndOfFile];

        constructor() {
            this.startCol = this.col;
            this.startLine = this.line;
            this.lineMap[1] = 0;

            if (!LexKeywordTable) {
                LexInitialize();
            }
        }

        public previousToken() { return this.prevTok; }

        public setSourceText(newSrc: ISourceText, textMode: number) {
            this.mode = textMode;
            this.scanComments = (this.mode === LexMode.Line);
            this.pos = 0;
            this.interveningWhitespacePos = 0;
            this.startPos = 0;
            this.line = 1;
            this.col = 0;
            this.startCol = this.col;
            this.startLine = this.line;
            this.len = 0;
            this.src = newSrc.getText(0, newSrc.getLength());
            this.len = this.src.length;
            this.lineMap = [];
            this.lineMap[1] = 0;
            this.commentStack = [];
            this.leftCurlyCount = 0;
            this.rightCurlyCount = 0;
            this.seenUnicodeChar = false;
            this.seenUnicodeCharInComment = false;
        }

        public setErrorHandler(reportError: (message: string) => void ) {
            this.reportError = reportError;
        }

        public setText(newSrc: string, textMode: number) {
            this.setSourceText(new StringSourceText(newSrc), textMode);
        }

        public setScanComments(value: bool) {
            this.scanComments = value;
        }

        public tokenStart(): void {
            this.startPos = this.pos;
            this.startLine = this.line;
            this.startCol = this.col;
            this.interveningWhitespace = false;
        }

        public peekChar(): number {
            if (this.pos < this.len) {
                return this.src.charCodeAt(this.pos);
            }
            else {
                return LexEOF;
            }
        }

        public peekCharAt(index: number): number {
            if (index < this.len) {
                return this.src.charCodeAt(index);
            }
            else {
                return LexEOF;
            }
        }

        public IsHexDigit(c: number) {
            return ((c >= LexCode_0) && (c <= LexCode_9)) || ((c >= LexCode_A) && (c <= LexCode_F)) ||
                ((c >= LexCode_a) && (c <= LexCode_f));
        }

        public IsOctalDigit(c: number) {
            return ((c >= LexCode_0) && (c <= LexCode_7)) ||
                ((c >= LexCode_a) && (c <= LexCode_f));
        }

        public scanHexDigits(): Token {
            var atLeastOneDigit = false;
            for (; ;) {
                if (this.IsHexDigit(this.ch)) {
                    this.nextChar();
                    atLeastOneDigit = true;
                }
                else {
                    if (atLeastOneDigit) {
                        var text = this.src.substring(this.startPos, this.pos);
                        return new NumberLiteralToken(parseInt(text), text);
                    }
                    else {
                        return null;
                    }
                }
            }

        }

        public scanOctalDigits(): Token {
            var atLeastOneDigit = false;
            for (; ;) {
                if (this.IsOctalDigit(this.ch)) {
                    this.nextChar();
                    atLeastOneDigit = true;
                }
                else {
                    if (atLeastOneDigit) {
                        var text = this.src.substring(this.startPos, this.pos);
                        return new NumberLiteralToken(parseInt(text), text);
                    }
                    else {
                        return null;
                    }
                }
            }

        }

        public scanDecimalNumber(state: number): Token {
            var atLeastOneDigit = false;
            var svPos = this.pos;
            var svCol = this.col;
            for (; ;) {
                if (LexIsDigit(this.ch)) {
                    atLeastOneDigit = true;
                    if (this.ch != LexCode_0 && state == NumberScanState.InEmptyFraction) {
                        state = NumberScanState.InFraction;
                    }
                    this.nextChar();
                }
                else if (this.ch == LexCodeDOT) {
                    if (state == NumberScanState.Start) {
                        // DecimalDigit* .
                        this.nextChar();
                        state = NumberScanState.InEmptyFraction;
                    }
                    else {
                        // dot not part of number
                        if (atLeastOneDigit) {
                            // DecimalDigit* . DecimalDigit+
                            var text = this.src.substring(this.startPos, this.pos);
                            return new NumberLiteralToken(parseFloat(text), text);
                        }
                        else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    }
                } else if ((this.ch == LexCode_e) || (this.ch == LexCode_E)) {
                    if (state == NumberScanState.Start) {
                        if (atLeastOneDigit) {
                            // DecimalDigit+ (. DecimalDigit*) [eE] [+-]DecimalDigit+
                            atLeastOneDigit = false;
                            this.nextChar();
                            state = NumberScanState.InExponent;
                        }
                        else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    }
                    else if (state == NumberScanState.InFraction || state == NumberScanState.InEmptyFraction) {
                        // DecimalDigit+ . DecimalDigit* [eE]
                        this.nextChar();
                        state = NumberScanState.InExponent;
                        atLeastOneDigit = false;
                    }
                    else {
                        // DecimalDigit+ . DecimalDigit* [eE] DecimalDigit+
                        if (atLeastOneDigit) {
                            var text = this.src.substring(this.startPos, this.pos);
                            return new NumberLiteralToken(parseFloat(text), text);
                        }
                        else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    }
                }
                else if ((this.ch == LexCodePLS) || (this.ch == LexCodeMIN)) {
                    if (state == NumberScanState.InExponent) {
                        if (!atLeastOneDigit) {
                            this.nextChar();
                        }
                        else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    }
                    else if (state == NumberScanState.InEmptyFraction || state == NumberScanState.InFraction) {
                        // This case will not generate bad javascript if we miss the fractional part, but we just want to be consistent with the dot case
                        var text = this.src.substring(this.startPos, this.pos);
                        return new NumberLiteralToken(parseFloat(text), text);
                    }
                    else {
                        if (!atLeastOneDigit) {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                        else {
                            var text = this.src.substring(this.startPos, this.pos);
                            return new NumberLiteralToken(parseFloat(text), text);
                        }
                    }
                }
                else {
                    if (!atLeastOneDigit) {
                        this.pos = svPos;
                        this.col = svCol;
                        return null;
                    }
                    else {
                        var text = this.src.substring(this.startPos, this.pos);
                        return new NumberLiteralToken(parseFloat(text), text);
                    }
                }
            }
        }

        // 0 [xX] hexDigits
        // 0 octalDigits
        // 0 [89] decimalDigits
        // decimalDigits? fraction? exponent?

        public scanNumber(): Token {
            if (this.peekChar() == LexCode_0) {
                switch (this.peekCharAt(this.pos + 1)) {
                    case LexCode_x:
                    case LexCode_X:
                        // Hex
                        this.advanceChar(2);
                        return this.scanHexDigits();
                    case LexCode_8:
                    case LexCode_9:
                    case LexCodeDOT:
                        return this.scanDecimalNumber(NumberScanState.Start);
                    default:
                        // Octal
                        return this.scanOctalDigits();
                }
            }
            else {
                return this.scanDecimalNumber(NumberScanState.Start);
            }
        }

        public scanFraction(): Token {
            return this.scanDecimalNumber(NumberScanState.InFraction);
        }

        public newLine(): void {
            this.col = 0;
            if (this.mode == LexMode.File) {
                this.line++;
                this.lineMap[this.line] = this.pos + 1;
            }
        }

        public finishMultilineComment(): bool {
            var ch2: number;
            this.lexState = LexState.InMultilineComment;
            while (this.pos < this.len) {
                if (this.ch == LexCodeMUL) {
                    ch2 = this.peekCharAt(this.pos + 1);
                    if (ch2 == LexCodeSLH) {
                        this.advanceChar(2);
                        if (this.mode == LexMode.File) {
                            this.tokenStart();
                        }
                        this.lexState = LexState.Start;
                        return true;
                    }
                }
                else if (this.ch == LexCodeNWL) {
                    this.newLine();
                    if (this.mode == LexMode.Line) {
                        this.nextChar();
                        return false;
                    }
                }
                else if (this.ch >= LexCodeASCIIChars) {
                    this.seenUnicodeCharInComment = true;
                }
                this.nextChar();
            }
            return false;
        }

        public pushComment(comment: CommentToken) {
            this.commentStack.push(comment);
        }

        public getComments() {
            var stack = this.commentStack;
            this.commentStack = [];
            return stack;
        }

        public getCommentsForLine(line: number) {
            var comments: CommentToken[] = null;
            while ((this.commentStack.length > 0) && (this.commentStack[0].line == line)) {
                if (comments == null) {
                    comments = [this.commentStack.shift()];
                }
                else {
                    comments = comments.concat([this.commentStack.shift()]);
                }

            }
            return comments;
        }

        public resetComments() {
            this.commentStack = [];
        }

        public endsLine(c: number) {
            return (c == LexCodeNWL) || (c == LexCodeRET) || (c == LexCodeLS) || (c == LexCodePS);
        }

        public finishSinglelineComment() {
            while (this.pos < this.len) {
                if (this.endsLine(this.ch))
                    break;
                if (this.ch >= LexCodeASCIIChars) {
                    this.seenUnicodeCharInComment = true;
                }
                this.nextChar();
            }

            if (this.mode == LexMode.File) {
                this.tokenStart();
            }
        }

        public findClosingSLH() {
            var index = this.pos;
            var ch2 = this.src.charCodeAt(index);
            var prevCh = 0;
            var liveEsc = false;
            while (!this.endsLine(ch2) && (index < this.len)) {
                if ((ch2 == LexCodeSLH) && (!liveEsc)) {
                    return index;
                }
                prevCh = ch2;
                index++;
                if (liveEsc) {
                    liveEsc = false;
                }
                else {
                    liveEsc = (prevCh == LexCodeBSL);
                }

                ch2 = this.src.charCodeAt(index);
            }
            return -1;
        }

        public speculateRegex(): Token {
            if (noRegexTable[this.prevTok.tokenId] != undefined) {
                return null;
            }
            var svPos = this.pos;
            var svCol = this.col;
            // first char is '/' and has been skipped
            var index = this.findClosingSLH();
            if (index > 0) {
                // found closing /
                var pattern = this.src.substring(svPos, index);
                var flags = "";
                this.pos = index + 1;
                this.ch = this.peekChar();
                var flagsStart = this.pos;
                // TODO: check for duplicate flags
                while ((this.ch == LexCode_i) || (this.ch == LexCode_g) || (this.ch == LexCode_m)) {
                    this.nextChar();
                }

                if ((this.pos - flagsStart) > 3) {
                    return null;
                }
                else {
                    flags = this.src.substring(flagsStart, this.pos);
                }

                var regex = undefined;
                try {
                    regex = new RegExp(pattern, flags);
                }
                catch (regexException) {
                }

                if (regex) {
                    // no line boundary in regex string
                    this.col = svCol + (this.pos - this.startPos);
                    return new RegularExpressionLiteralToken(this.src.substring(svPos - 1, this.pos));
                }
            }

            this.pos = svPos;
            this.col = svCol;

            return null;
        }

        public lastTokenHadNewline() {
            return this.prevLine != this.startLine;
        }

        public lastTokenLimChar() {
            return this.interveningWhitespace ? this.interveningWhitespacePos : this.startPos;
        }

        // use only when known not to skip line terminators
        public advanceChar(amt: number) {
            this.pos += amt;
            this.col += amt;
            this.ch = this.peekChar();
        }

        public nextChar() {
            this.pos++;
            this.col++;
            this.ch = this.peekChar();
        }

        public getLookAheadToken(): Token {
            // REVIEW: This method is only used for parsing varargs in lambda expressions. If this 
            //         functionality is needed for more common cases, it needs to be designed. 
            //         Look-ahead token needs to be integrated in the scanner design to allow for 
            //         an efficient lookup.

            // Store the scanner state
            var prevLine = this.prevLine;
            var line = this.line;
            var col = this.col;
            var pos = this.pos;
            var startPos = this.startPos;
            var startCol = this.startCol;
            var startLine = this.startLine;
            var ch = this.ch;
            var prevTok = this.prevTok;
            var lexState = this.lexState;
            var interveningWhitespace = this.interveningWhitespace;
            var interveningWhitespacePos = this.interveningWhitespacePos;
            var leftCurlyCount = this.leftCurlyCount;
            var rightCurlyCount = this.rightCurlyCount;
            var seenUnicodeChar = this.seenUnicodeChar;
            var seenUnicodeCharInComment = this.seenUnicodeCharInComment;
            var commentStackLength = this.commentStack.length;

            var lookAheadToken = this.scan();

            // Restore state
            this.prevLine = prevLine;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.startPos = startPos;
            this.startCol = startCol;
            this.startLine = startLine;
            this.ch = ch;
            this.prevTok = prevTok;
            this.lexState = lexState;
            this.interveningWhitespace = interveningWhitespace;
            this.interveningWhitespacePos = interveningWhitespacePos;
            this.leftCurlyCount = leftCurlyCount;
            this.rightCurlyCount = rightCurlyCount;
            this.seenUnicodeChar = seenUnicodeChar;
            this.seenUnicodeCharInComment = seenUnicodeCharInComment;
            this.commentStack.length = commentStackLength;

            return lookAheadToken;
        }

        public scanInLine(): Token {
            if ((this.lexState == LexState.InMultilineComment) && (this.scanComments)) {
                this.ch = this.peekChar();
                var commentLine = this.line;
                this.finishMultilineComment();
                if (this.startPos < this.pos) {
                    var commentText = this.src.substring(this.startPos, this.pos);
                    this.tokenStart();
                    return new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, this.startPos, commentLine,/*endsLine*/true);
                }
                else {
                    return staticTokens[TokenID.EndOfFile];
                }
            }
            else if (this.lexState == LexState.InMultilineSingleQuoteString && this.pos < this.len) {
                this.ch = LexCodeAPO;
                this.lexState = LexState.Start;
                return this.scanStringConstant();
            }
            else if (this.lexState == LexState.InMultilineDoubleQuoteString && this.pos < this.len) {
                this.ch = LexCodeQUO;
                this.lexState = LexState.Start;
                return this.scanStringConstant();
            }
            this.prevLine = this.line;
            var prevTok = this.innerScan();

            // Ingore white spaces
            if (prevTok.tokenId != TokenID.Whitespace) {
                this.prevTok = prevTok;
            }
            return prevTok;
        }

        public scan(): Token {
            this.prevLine = this.line;
            this.prevTok = this.innerScan();
            if (this.saveScan) {
                this.saveScan.addToken(this.prevTok, this);
            }
            return this.prevTok;
        }

        private isValidUnicodeIdentifierChar(): bool {
            var valid = LexIsUnicodeIdStart(this.ch) || LexIsUnicodeDigit(this.ch);
            this.seenUnicodeChar = this.seenUnicodeChar || valid;
            return valid;
        }

        private scanStringConstant(): Token {
            var endCode = this.ch;

            // Skip the first quote
            this.nextChar();

            // Accumulate with escape characters
            scanStringConstantLoop:
            for (; ;) {
                switch (this.ch) {
                    case LexEOF:
                        // Unexpected end of file
                        this.reportScannerError("Unterminated string constant");
                        break scanStringConstantLoop;

                    case LexCodeLS:
                    case LexCodePS:
                        this.seenUnicodeChar = true;
                    // Intentional fall through
                    case LexCodeRET:
                    case LexCodeNWL:
                        this.reportScannerError("Unterminated string constant");
                        break scanStringConstantLoop;

                    case LexCodeAPO:
                    case LexCodeQUO:
                        if (this.ch == endCode) {
                            // Found string terminator. Skip past end code.
                            this.nextChar();
                            break scanStringConstantLoop;
                        }
                        break;

                    case LexCodeBSL:
                        // Consume the current slash
                        this.nextChar();

                        switch (this.ch) {
                            case LexCodeAPO:
                            case LexCodeQUO:
                            case LexCodeBSL:
                                // Valid escape sequences
                                this.nextChar();
                                continue scanStringConstantLoop;

                            case LexCodeLS:
                            case LexCodePS:
                                this.seenUnicodeChar = true;
                            // Intentional fall through
                            case LexCodeRET:
                            case LexCodeNWL:
                                // Skip /r in a /r/n sequence
                                if (this.ch == LexCodeRET && this.peekCharAt(this.pos + 1) == LexCodeNWL) {
                                    this.nextChar();
                                }

                                // Consume the new line char
                                this.nextChar();

                                // Record new line
                                this.newLine();

                                if (this.mode == LexMode.Line) {
                                    this.lexState = endCode == LexCodeAPO ? LexState.InMultilineSingleQuoteString : LexState.InMultilineDoubleQuoteString;
                                    break scanStringConstantLoop;
                                }
                                break;

                            case LexCode_x:
                            case LexCode_u:
                                var expectedHexDigits = this.ch == LexCode_x ? 2 : 4;
                                this.nextChar();
                                for (var i = 0; i < expectedHexDigits; i++) {
                                    if (this.IsHexDigit(this.ch)) {
                                        this.nextChar();
                                    }
                                    else {
                                        this.reportScannerError("Invalid Unicode escape sequence");
                                        break;
                                    }
                                }
                                continue scanStringConstantLoop;
                        }
                        break;
                }

            // Record seeing a Unicode char
                if (this.ch >= LexCodeASCIIChars) {
                    this.seenUnicodeChar = true;
                }

                this.nextChar();
            }

            return new StringLiteralToken(this.src.substring(this.startPos, this.pos));
        }

        private scanIdentifier(): Token {
            var hasEscape = false;
            var isFirstChar = (this.ch == LexCodeBSL);
            var hasUnicode: any = false;

            for (; ;) {
                while (lexIdStartTable[this.ch] || LexIsDigit(this.ch) ||
                      (this.ch >= LexCodeASCIIChars && this.isValidUnicodeIdentifierChar())) {
                    this.nextChar();
                }
                if (this.ch == LexCodeBSL) {
                    this.nextChar();
                    if (this.ch == LexCode_u) {
                        // 4 hex digits
                        this.nextChar();
                        for (var h = 0; h < 4 ; h++) {
                            if (this.IsHexDigit(this.ch)) {
                                this.nextChar();
                            }
                            else {
                                this.reportScannerError("Invalid Unicode escape sequence");
                                return staticTokens[TokenID.Error];
                            }
                        }
                        var hexChar = parseInt(this.src.substring(this.pos - 4, this.pos), 16);

                        // Verify is valid ID char 
                        if (lexIdStartTable[hexChar] || (!isFirstChar && LexIsDigit(hexChar)) ||
                            (hexChar >= LexCodeASCIIChars && (LexIsUnicodeIdStart(hexChar) || (!isFirstChar && LexIsUnicodeDigit(hexChar))))) {
                        }
                        else {
                            this.reportScannerError("Invalid identifier character");
                            return staticTokens[TokenID.Error];
                        }

                        hasEscape = true;
                        isFirstChar = false;
                        continue;
                    }

                    this.reportScannerError("Invalid Unicode escape sequence");
                    return staticTokens[TokenID.Error];
                }
                break;
            }

            var id: number;
            var text = this.src.substring(this.startPos, this.pos);
            if (!hasEscape && (id = LexKeywordTable.lookup(text)) != null) {
                return staticTokens[id];
            }
            else {
                return new IdentifierToken(text, hasEscape);
            }
        }

        public innerScan(): Token {
            var rtok;
            this.tokenStart();
            this.ch = this.peekChar();

            start: while (this.pos < this.len) {
                if (lexIdStartTable[this.ch] || this.ch == LexCodeBSL || (this.ch >= LexCodeASCIIChars && LexIsUnicodeIdStart(this.ch))) {
                    // identifier or keyword
                    return this.scanIdentifier();
                }
                else if (this.ch == LexCodeSpace) {
                    if (!this.interveningWhitespace) {
                        this.interveningWhitespacePos = this.pos;
                    }
                    do {
                        this.nextChar();
                    } while (this.ch == LexCodeSpace);
                    if (this.mode == LexMode.Line) {
                        var whitespaceText = this.src.substring(this.startPos, this.pos);
                        return new WhitespaceToken(TokenID.Whitespace, whitespaceText);
                    }
                    else {
                        this.tokenStart();
                        this.interveningWhitespace = true;
                    }
                }
                else if (this.ch == LexCodeSLH) {
                    this.nextChar();
                    var commentText;
                    if (this.ch == LexCodeSLH) {
                        if (!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos - 1;
                        }
                        var commentStartPos = this.pos - 1;
                        var commentStartLine = this.line;
                        this.finishSinglelineComment();
                        var commentText = this.src.substring(commentStartPos, this.pos);
                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/false, commentStartPos, commentStartLine,/*endsLine*/false);
                        if (this.scanComments) {
                            // respect scanner contract: when returning a token, startPos is the start position of the token
                            this.startPos = commentStartPos;
                            return commentToken;
                        }
                        else {
                            this.pushComment(commentToken);
                        }

                        this.interveningWhitespace = true;
                    }
                    else if (this.ch == LexCodeMUL) {
                        if (!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos - 1;
                        }
                        var commentStartPos = this.pos - 1;
                        var commentStartLine = this.line;
                        this.nextChar();  // Skip the "*"
                        this.finishMultilineComment();
                        var commentText = this.src.substring(commentStartPos, this.pos);
                        var endsLine = this.endsLine(this.peekChar());
                        var commentToken = new CommentToken(TokenID.Comment, commentText,/*isBlock*/true, commentStartPos, commentStartLine, endsLine);
                        if (this.scanComments) {
                            // respect scanner contract: when returning a token, startPos is the start position of the token
                            this.startPos = commentStartPos;
                            return commentToken;
                        }
                        else {
                            this.pushComment(commentToken);
                        }
                        this.interveningWhitespace = true;
                    }
                    else {
                        var regexTok = this.speculateRegex();
                        if (regexTok) {
                            return regexTok;
                        }
                        else {
                            if (this.peekCharAt(this.pos) == LexCodeEQ) {
                                this.nextChar();
                                return staticTokens[TokenID.SlashEquals];
                            }
                            else {
                                return staticTokens[TokenID.Slash];
                            }
                        }
                    }
                }
                else if (this.ch == LexCodeSMC) {
                    this.nextChar();
                    return staticTokens[TokenID.Semicolon];
                }
                else if ((this.ch == LexCodeAPO) || (this.ch == LexCodeQUO)) {
                    return this.scanStringConstant();
                }
                else if (autoToken[this.ch]) {
                    var atok = autoToken[this.ch];
                    if (atok.tokenId == TokenID.OpenBrace) {
                        this.leftCurlyCount++;
                    }
                    else if (atok.tokenId == TokenID.CloseBrace) {
                        this.rightCurlyCount++;
                    }
                    this.nextChar();
                    return atok;
                }
                else if ((this.ch >= LexCode_0) && (this.ch <= LexCode_9)) {
                    rtok = this.scanNumber();
                    if (rtok) {
                        return rtok;
                    }
                    else {
                        this.nextChar();
                        return staticTokens[TokenID.Error];
                    }
                }
                else switch (this.ch) {
                    // TAB
                    case LexCodeTAB:
                    case LexCodeVTAB:
                        if (!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos;
                        }
                        if (this.mode == LexMode.Line) {
                            do {
                                this.nextChar();
                            } while ((this.ch == LexCodeSpace) || (this.ch == 9));
                            var wsText = this.src.substring(this.startPos, this.pos);
                            return new WhitespaceToken(TokenID.Whitespace, wsText);
                        }
                        else {
                            this.interveningWhitespace = true;
                        }
                    // Newlines and BOM
                    case 0xFF: // UTF16 SEQUENCE
                    case 0xFE:
                    case 0xEF:    // UTF8 SEQUENCE
                    case 0xBB:
                    case 0xBF:
                    case LexCodeLS:
                    case LexCodePS:
                    case LexCodeNWL:
                    case LexCodeRET:
                        if (this.ch == LexCodeNWL) {
                            this.newLine();
                            if (this.mode == LexMode.Line) {
                                return staticTokens[TokenID.EndOfFile];
                            }
                        }
                        if (!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos;
                        }
                        this.nextChar();
                        this.tokenStart();
                        this.interveningWhitespace = true;
                        break;
                    case LexCodeDOT: {
                        if (this.peekCharAt(this.pos + 1) == LexCodeDOT) {
                            if (this.peekCharAt(this.pos + 2) == LexCodeDOT) {
                                this.advanceChar(3);
                                return staticTokens[TokenID.DotDotDot];
                            }
                            else {
                                this.nextChar();
                                return staticTokens[TokenID.Dot];
                            }
                        }
                        else {
                            this.nextChar();
                            rtok = this.scanFraction();
                            if (rtok) {
                                return rtok;
                            }
                            else {
                                return staticTokens[TokenID.Dot];
                            }
                        }
                        // break;
                    }
                    case LexCodeEQ:
                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {
                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {
                                this.advanceChar(3);
                                return staticTokens[TokenID.EqualsEqualsEquals];
                            }
                            else {
                                this.advanceChar(2);
                                return staticTokens[TokenID.EqualsEquals];
                            }
                        }
                        else if (this.peekCharAt(this.pos + 1) == LexCodeGT) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.EqualsGreaterThan];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Equals];
                        }
                    // break;
                    case LexCodeBNG:
                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {
                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {
                                this.advanceChar(3);
                                return staticTokens[TokenID.ExclamationEqualsEquals];
                            }
                            else {
                                this.advanceChar(2);
                                return staticTokens[TokenID.ExclamationEquals];
                            }
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Exclamation];
                        }
                    // break;
                    case LexCodePLS:
                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.PlusEquals];
                        }
                        else if (this.peekCharAt(this.pos + 1) == LexCodePLS) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.PlusPlus];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Plus];
                        }
                    // break;
                    case LexCodeMIN:
                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.MinusEquals];
                        }
                        else if (this.peekCharAt(this.pos + 1) == LexCodeMIN) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.MinusMinus];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Minus];
                        }
                    // break;
                    case LexCodeMUL:
                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.AsteriskEquals];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Asterisk];
                        }
                    // break;
                    case LexCodePCT:
                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.PercentEquals];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Percent];
                        }
                    // break;
                    case LexCodeLT:
                        if (this.peekCharAt(this.pos + 1) == LexCodeLT) {
                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {
                                this.advanceChar(3);
                                return staticTokens[TokenID.LessThanLessThanEquals];
                            }
                            else {
                                this.advanceChar(2);
                                return staticTokens[TokenID.LessThanLessThan];
                            }
                        }
                        else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.LessThanEquals];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.LessThan];
                        }
                    //  break;
                    case LexCodeGT:
                        if (this.peekCharAt(this.pos + 1) == LexCodeGT) {
                            if (this.peekCharAt(this.pos + 2) == LexCodeEQ) {
                                this.advanceChar(3);
                                return staticTokens[TokenID.GreaterThanGreaterThanEquals];
                            }
                            else if (this.peekCharAt(this.pos + 2) == LexCodeGT) {
                                if (this.peekCharAt(this.pos + 3) == LexCodeEQ) {
                                    this.advanceChar(4);
                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThanEquals];
                                }
                                else {
                                    this.advanceChar(3);
                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThan];
                                }
                            }
                            else {
                                this.advanceChar(2);
                                return staticTokens[TokenID.GreaterThanGreaterThan];
                            }
                        }
                        else if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.GreaterThanEquals];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.GreaterThan];
                        }
                    // break;
                    case LexCodeXOR:
                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.CaretEquals];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Caret];
                        }
                    //  break;
                    case LexCodeBAR:
                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.BarEquals];
                        }
                        else if (this.peekCharAt(this.pos + 1) == LexCodeBAR) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.BarBar];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Bar];
                        }
                    //  break;
                    case LexCodeAMP:
                        if (this.peekCharAt(this.pos + 1) == LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.AmpersandEquals];
                        }
                        else if (this.peekCharAt(this.pos + 1) == LexCodeAMP) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.AmpersandAmpersand];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.And];
                        }
                    //  break;
                    default:
                        // Report error
                        this.reportScannerError("Invalid character");
                        this.nextChar();

                        continue start;
                }
            }
            return staticTokens[TokenID.EndOfFile];
        }

        private reportScannerError(message: string) {
            if (this.reportError) {
                this.reportError(message);
            }
        }
    }

    // Reseverved words only apply to Identifiers, not IdentifierNames
    export function convertTokToIDName(tok: Token): bool {
        return convertTokToIDBase(tok, true, false);
    }

    export function convertTokToID(tok: Token, strictMode: bool): bool {
        return convertTokToIDBase(tok, false, strictMode);
    }

    function convertTokToIDBase(tok: Token, identifierName: bool, strictMode: bool): bool {
        if (tok.tokenId <= TokenID.LimKeyword) {
            var tokInfo = lookupToken(tok.tokenId);
            if (tokInfo != undefined) {
                var resFlags = Reservation.Javascript | Reservation.JavascriptFuture;
                if (strictMode) {
                    resFlags |= Reservation.JavascriptFutureStrict;
                }
                if (identifierName || !hasFlag(tokInfo.reservation, resFlags)) {
                    return true;
                }
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }

    // Return the (1-based) line number from a character offset using the provided linemap.
    export function getLineNumberFromPosition(lineMap: number[], position: number): number {
        if (position === -1)
            return 0;

        // Binary search
        var min = 0;
        var max = lineMap.length - 1;
        while (min < max) {
            var med = (min + max) >> 1;
            if (position < lineMap[med]) {
                max = med - 1;
            }
            else if (position < lineMap[med + 1]) {
                min = max = med; // found it
            }
            else {
                min = med + 1;
            }
        }

        return min;
    }

    /// Return the [line, column] data for a given offset and a lineMap.
    /// Note that the returned line is 1-based, while the column is 0-based.
    export function getSourceLineColFromMap(lineCol: ILineCol, minChar: number, lineMap: number[]): void {
        var line = getLineNumberFromPosition(lineMap, minChar);

        if (line > 0) {
            lineCol.line = line;
            lineCol.col = (minChar - lineMap[line]);
        }
    }

    // Return the [line, column] (both 1 based) corresponding to a given position in a given script.
    export function getLineColumnFromPosition(script: TypeScript.Script, position: number): ILineCol {
        var result = { line: -1, col: -1 };
        getSourceLineColFromMap(result, position, script.locationInfo.lineMap);
        if (result.col >= 0) {
            result.col++;   // Make it 1-based
        }
        return result;
    }

    //
    // Return the position (offset) corresponding to a given [line, column] (both 1-based) in a given script.
    //
    export function getPositionFromLineColumn(script: TypeScript.Script, line: number, column: number): number {
        return script.locationInfo.lineMap[line] + (column - 1);
    }

    // Return true if the token is a primitive type
    export function isPrimitiveTypeToken(token: Token) {
        switch (token.tokenId) {
            case TokenID.Any:
            case TokenID.Bool:
            case TokenID.Number:
            case TokenID.String:
                return true;
        }
        return false;
    }

    // Return true if the token is a primitive type
    export function isModifier(token: Token) {
        switch (token.tokenId) {
            case TokenID.Public:
            case TokenID.Private:
            case TokenID.Static:
                return true;
        }
        return false;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export class AssignScopeContext {
        constructor (public scopeChain: ScopeChain,
                     public typeFlow: TypeFlow,
                     public modDeclChain: ModuleDeclaration[]) {
        }
    }

    export function pushAssignScope(scope: SymbolScope,
        context: AssignScopeContext,
        type: Type,
        classType: Type,
        fnc: FuncDecl) {

        var chain = new ScopeChain(null, context.scopeChain, scope);
        chain.thisType = type;
        chain.classType = classType;
        chain.fnc = fnc;
        context.scopeChain = chain;
    }

    export function popAssignScope(context: AssignScopeContext) {
        context.scopeChain = context.scopeChain.previous;
    }

    export function instanceCompare(a: Symbol, b: Symbol) {
        if (((a == null) || (!a.isInstanceProperty()))) {
            return b;
        }
        else {
            return a;
        }
    }

    export function instanceFilterStop(s: Symbol) {
        return s.isInstanceProperty();
    }

    export class ScopeSearchFilter {

        constructor (public select: (a: Symbol, b: Symbol) =>Symbol,
                            public stop: (s: Symbol) =>bool) { }

        public result: Symbol = null;

        public reset() {
            this.result = null;
        }

        public update(b: Symbol): bool {
            this.result = this.select(this.result, b);
            if (this.result) {
                return this.stop(this.result);
            }
            else {
                return false;
            }
        }
    }

    export var instanceFilter = new ScopeSearchFilter(instanceCompare, instanceFilterStop);

    export function preAssignModuleScopes(ast: AST, context: AssignScopeContext) {
        var moduleDecl = <ModuleDeclaration>ast;
        var memberScope: SymbolTableScope = null;
        var aggScope: SymbolAggregateScope = null;

        if (moduleDecl.name && moduleDecl.mod) {
            moduleDecl.name.sym = moduleDecl.mod.symbol;
        }

        var mod = moduleDecl.mod;

        // We're likely here because of error recovery
        if (!mod) {
            return;
        }

        memberScope = new SymbolTableScope(mod.members, mod.ambientMembers, mod.enclosedTypes, mod.ambientEnclosedTypes, mod.symbol);
        mod.memberScope = memberScope;
        context.modDeclChain.push(moduleDecl);
        context.typeFlow.checker.currentModDecl = moduleDecl;
        aggScope = new SymbolAggregateScope(mod.symbol);
        aggScope.addParentScope(memberScope);
        aggScope.addParentScope(context.scopeChain.scope);
        pushAssignScope(aggScope, context, null, null, null);
        mod.containedScope = aggScope;
        if (mod.symbol) {
            context.typeFlow.addLocalsFromScope(mod.containedScope, mod.symbol, moduleDecl.vars, mod.members.privateMembers, true);
        }
    }

    export function preAssignClassScopes(ast: AST, context: AssignScopeContext) {
        var classDecl = <InterfaceDeclaration>ast;
        var memberScope: SymbolTableScope = null;
        var aggScope: SymbolAggregateScope = null;

        if (classDecl.name && classDecl.type) {
            classDecl.name.sym = classDecl.type.symbol;
        }

        var classType = ast.type;

        if (classType) {
            var classSym = classType.symbol;
            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(classType);

            aggScope = new SymbolAggregateScope(classType.symbol);
            aggScope.addParentScope(memberScope);
            aggScope.addParentScope(context.scopeChain.scope);

            classType.containedScope = aggScope;
            classType.memberScope = memberScope;

            var instanceType = classType.instanceType;
            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(instanceType);
            instanceType.memberScope = memberScope;

            aggScope = new SymbolAggregateScope(instanceType.symbol);
            aggScope.addParentScope(context.scopeChain.scope);

            pushAssignScope(aggScope, context, instanceType, classType, null);
            instanceType.containedScope = aggScope;
        }
        else {
            ast.type = context.typeFlow.anyType;
        }
    }

    export function preAssignInterfaceScopes(ast: AST, context: AssignScopeContext) {
        var interfaceDecl = <InterfaceDeclaration>ast;
        var memberScope: SymbolTableScope = null;
        var aggScope: SymbolAggregateScope = null;

        if (interfaceDecl.name && interfaceDecl.type) {
            interfaceDecl.name.sym = interfaceDecl.type.symbol;
        }

        var interfaceType = ast.type;
        memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(interfaceType);
        interfaceType.memberScope = memberScope;
        aggScope = new SymbolAggregateScope(interfaceType.symbol);
        aggScope.addParentScope(memberScope);
        aggScope.addParentScope(context.scopeChain.scope);
        pushAssignScope(aggScope, context, null, null, null);
        interfaceType.containedScope = aggScope;
    }

    export function preAssignWithScopes(ast: AST, context: AssignScopeContext) {
        var withStmt = <WithStatement>ast;
        var withType = withStmt.type;

        var members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
        var ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));

        var withType = new Type();
        var withSymbol = new WithSymbol(withStmt.minChar, context.typeFlow.checker.locationInfo.unitIndex, withType);
        withType.members = members;
        withType.ambientMembers = ambientMembers;
        withType.symbol = withSymbol;
        withType.setHasImplementation();
        withStmt.type = withType;

        var withScope = new TypeScript.SymbolScopeBuilder(withType.members, withType.ambientMembers, null, null, context.scopeChain.scope, withType.symbol);

        pushAssignScope(withScope, context, null, null, null);
        withType.containedScope = withScope;
    }

    export function preAssignFuncDeclScopes(ast: AST, context: AssignScopeContext) {
        var funcDecl = <FuncDecl>ast;

        var container: Symbol = null;
        var localContainer: Symbol = null;
        if (funcDecl.type) {
            localContainer = ast.type.symbol;
        }

        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);
        var isInnerStatic = isStatic && context.scopeChain.fnc != null;
        // for inner static functions, use the parent's member scope, so local vars cannot be captured
        var parentScope = isInnerStatic ? context.scopeChain.fnc.type.memberScope : context.scopeChain.scope;

        // if this is not a method, but enclosed by class, use constructor as
        // the enclosing scope
        // REVIEW: Some twisted logic here - this needs to be cleaned up once old classes are removed
        //  - if it's a new class, always use the contained scope, since we initialize the constructor scope below
        if (context.scopeChain.thisType &&
            (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod))) {
            var instType = context.scopeChain.thisType;

            if (!(instType.typeFlags & TypeFlags.IsClass) && !hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
                if (!funcDecl.isMethod() || isStatic) {
                    parentScope = instType.constructorScope;
                }
                else {
                    // use constructor scope if a method as well
                    parentScope = instType.containedScope;
                }
            }
            else {
                if (context.scopeChain.previous.scope.container &&
                    context.scopeChain.previous.scope.container.declAST &&
                    context.scopeChain.previous.scope.container.declAST.nodeType == NodeType.FuncDecl &&
                    (<FuncDecl>context.scopeChain.previous.scope.container.declAST).isConstructor) {

                        // if the parent is the class constructor, use the constructor scope
                    parentScope = instType.constructorScope;
                }
                else if (isStatic && context.scopeChain.classType) {
                    parentScope = context.scopeChain.classType.containedScope;
                }
                else {
                    // else, use the contained scope
                    parentScope = instType.containedScope;
                }
            }
            container = instType.symbol;
        }
        else if (funcDecl.isConstructor && context.scopeChain.thisType) {
            // sets the container to the class type's symbol (which is shared by the instance type)
            container = context.scopeChain.thisType.symbol;
        }

        if (funcDecl.type == null || hasFlag(funcDecl.type.symbol.flags, SymbolFlags.TypeSetDuringScopeAssignment)) {
            if (context.scopeChain.fnc && context.scopeChain.fnc.type) {
                container = context.scopeChain.fnc.type.symbol;
            }

            var funcScope = null;
            var outerFnc: FuncDecl = context.scopeChain.fnc;
            var nameText = funcDecl.name ? funcDecl.name.actualText : null;
            var fgSym: TypeSymbol = null;

            if (isStatic) {
                // In the case of function-nested statics, no member list will have bee initialized for the function, so we need
                // to copy it over.  We don't set this by default because having a non-null member list will throw off assignment
                // compatibility tests
                if (outerFnc.type.members == null && container.getType().memberScope) {
                    outerFnc.type.members = (<SymbolScopeBuilder>(<TypeSymbol>container).type.memberScope).valueMembers;
                }
                funcScope = context.scopeChain.fnc.type.memberScope;
                outerFnc.innerStaticFuncs[outerFnc.innerStaticFuncs.length] = funcDecl;
            }
            else {
                funcScope = context.scopeChain.scope;
            }

            // REVIEW: We don't search for another sym for accessors to prevent us from
            // accidentally coalescing function signatures with the same name (E.g., a function
            // 'f' the outer scope and a setter 'f' in an object literal within that scope)
            if (nameText && nameText != "__missing" && !funcDecl.isAccessor()) {
                if (isStatic) {
                    fgSym = funcScope.findLocal(nameText, false, false);
                }
                else {
                    // REVIEW: This logic should be symmetric with preCollectClassTypes
                    fgSym = funcScope.findLocal(nameText, false, false);
                }
            }

            context.typeFlow.checker.createFunctionSignature(funcDecl, container,
                                                            funcScope, fgSym, fgSym == null);

            // it's a getter or setter for a class property                     
            if (!funcDecl.accessorSymbol && 
                (funcDecl.fncFlags & FncFlags.ClassMethod) &&
                container && 
                ((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || 
                    (fgSym && fgSym.isAccessor())) 
            {
                funcDecl.accessorSymbol = context.typeFlow.checker.createAccessorSymbol(funcDecl, fgSym, container.getType(), (funcDecl.isMethod() && isStatic), true, funcScope, container);
            }

            funcDecl.type.symbol.flags |= SymbolFlags.TypeSetDuringScopeAssignment;
        }

        // Set the symbol for functions and their overloads
        if (funcDecl.name && funcDecl.type) {
            funcDecl.name.sym = funcDecl.type.symbol;
        }

        // Keep track of the original scope type, because target typing might override
        // the "type" member. We need the original "Scope type" for completion list, etc.
        funcDecl.scopeType = funcDecl.type;

        // Overloads have no scope, so bail here
        if (funcDecl.isOverload) {
            return;
        }

        var funcTable = new StringHashTable();
        var funcMembers = new ScopedMembers(new DualStringHashTable(funcTable, new StringHashTable()));
        var ambientFuncTable = new StringHashTable();
        var ambientFuncMembers = new ScopedMembers(new DualStringHashTable(ambientFuncTable, new StringHashTable()));
        var funcStaticTable = new StringHashTable();
        var funcStaticMembers = new ScopedMembers(new DualStringHashTable(funcStaticTable, new StringHashTable()));
        var ambientFuncStaticTable = new StringHashTable();
        var ambientFuncStaticMembers = new ScopedMembers(new DualStringHashTable(ambientFuncStaticTable, new StringHashTable()));

        // REVIEW: Is it a problem that this is being set twice for properties and constructors?
        funcDecl.unitIndex = context.typeFlow.checker.locationInfo.unitIndex;

        var locals = new SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer);
        var statics = new SymbolScopeBuilder(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null);

        if (funcDecl.isConstructor && context.scopeChain.thisType) {
            context.scopeChain.thisType.constructorScope = locals;
        }

        // basically, there are two problems
        // - Above, for new classes, we were overwriting the constructor scope with the containing scope.  This caused constructor params to be
        // in scope everywhere
        // - Below, we're setting the contained scope table to the same table we were overwriting the constructor scope with, which we need to
        // fish lambda params, etc, out (see funcTable below)
        //
        // A good first approach to solving this would be to change addLocalsFromScope to take a scope instead of a table, and add to the
        // constructor scope as appropriate

        funcDecl.symbols = funcTable;

        if (!funcDecl.isSpecialFn()) {
            var group = funcDecl.type;
            var signature = funcDecl.signature;

            if (!funcDecl.isConstructor) {
                group.containedScope = locals;
                locals.container = group.symbol;

                group.memberScope = statics;
                statics.container = group.symbol;
            }
            funcDecl.enclosingFnc = context.scopeChain.fnc;
            group.enclosingType = isStatic ? context.scopeChain.classType : context.scopeChain.thisType;
            // for mapping when type checking
            var fgSym = <TypeSymbol>ast.type.symbol;
            if (((funcDecl.fncFlags & FncFlags.Signature) == FncFlags.None) && funcDecl.vars) {
                context.typeFlow.addLocalsFromScope(locals, fgSym, funcDecl.vars,
                                                    funcTable, false);
                context.typeFlow.addLocalsFromScope(statics, fgSym, funcDecl.statics,
                                                    funcStaticTable, false);
            }
            if (signature.parameters) {
                var len = signature.parameters.length;
                for (var i = 0; i < len; i++) {
                    var paramSym: ParameterSymbol = signature.parameters[i];
                    context.typeFlow.checker.resolveTypeLink(locals,
                                                                paramSym.parameter.typeLink, true);
                }
            }
            context.typeFlow.checker.resolveTypeLink(locals, signature.returnType,
                                                        funcDecl.isSignature());
        }

        if (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
            var thisType = (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) ? context.scopeChain.thisType : null;
            pushAssignScope(locals, context, thisType, null, funcDecl);
        }

        if (funcDecl.name && hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {
            // If the function is an expression, the name will not be visible in the enclosing scope.
            // Add the function symbol under its name to the local scope to allow for recursive calls.
            if (funcDecl.name.sym) {
                funcTable.add(funcDecl.name.actualText, funcDecl.name.sym);
            }
        }
    }

    export function preAssignCatchScopes(ast: AST, context: AssignScopeContext) {
        var catchBlock = <Catch>ast;
        if (catchBlock.param) {
            var catchTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable())); // REVIEW: Should we be allocating a public table instead of a private one?
            var catchLocals = new SymbolScopeBuilder(catchTable, null, null, null, context.scopeChain.scope,
                                                   context.scopeChain.scope.container);
            catchBlock.containedScope = catchLocals;
            pushAssignScope(catchLocals, context, context.scopeChain.thisType, context.scopeChain.classType, context.scopeChain.fnc);
        }
    }

    export function preAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {
        var context:AssignScopeContext = walker.state;
        var go = true;

        if (ast) {
            if (ast.nodeType == NodeType.List) {
                var list = <ASTList>ast;
                list.enclosingScope = context.scopeChain.scope;
            }
            else if (ast.nodeType == NodeType.ModuleDeclaration) {
                preAssignModuleScopes(ast, context);
            }
            else if (ast.nodeType == NodeType.ClassDeclaration) {
                preAssignClassScopes(ast, context);
            }
            else if (ast.nodeType == NodeType.InterfaceDeclaration) {
                preAssignInterfaceScopes(ast, context);
            }
            else if (ast.nodeType == NodeType.With) {
                preAssignWithScopes(ast, context);
            }
            else if (ast.nodeType == NodeType.FuncDecl) {
                preAssignFuncDeclScopes(ast, context);
            }
            else if (ast.nodeType == NodeType.Catch) {
                preAssignCatchScopes(ast, context);
            }
            else if (ast.nodeType == NodeType.TypeRef) {
                go = false;
            }
        }
        walker.options.goChildren = go;
        return ast;
    }

    export function postAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {
        var context:AssignScopeContext = walker.state;
        var go = true;
        if (ast) {
            if (ast.nodeType == NodeType.ModuleDeclaration) {
                var prevModDecl = <ModuleDeclaration>ast;

                popAssignScope(context);

                context.modDeclChain.pop();
                if (context.modDeclChain.length >= 1) {
                    context.typeFlow.checker.currentModDecl = context.modDeclChain[context.modDeclChain.length - 1];
                }
            }
            else if (ast.nodeType == NodeType.ClassDeclaration) {
                popAssignScope(context);
            }
            else if (ast.nodeType == NodeType.InterfaceDeclaration) {
                popAssignScope(context);
            }
            else if (ast.nodeType == NodeType.With) {
                popAssignScope(context);
            }
            else if (ast.nodeType == NodeType.FuncDecl) {
                var funcDecl = <FuncDecl>ast;
                if ((!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) && !funcDecl.isOverload) {
                    popAssignScope(context);
                }
            }
            else if (ast.nodeType == NodeType.Catch) {
                var catchBlock = <Catch>ast;
                if (catchBlock.param) {
                    popAssignScope(context);
                }
            }
            else {
                go = false;
            }
        }
        walker.options.goChildren = go;
        return ast;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class TypeCollectionContext {
        public script: Script = null;

        constructor (public scopeChain: ScopeChain, public checker: TypeChecker) {
        }
    }

    export class MemberScopeContext {
        public type: Type = null;
        public ast: AST = null;
        public scope: SymbolScope;
        public options = new AstWalkOptions();

        constructor (public flow: TypeFlow, public pos: number, public matchFlag: ASTFlags) {
        }
    }

    export class EnclosingScopeContext {

        public scopeGetter: () => SymbolScope = null;
        public objectLiteralScopeGetter: () => SymbolScope = null;
        public scopeStartAST: AST = null;
        public skipNextFuncDeclForClass = false;
        public deepestModuleDecl: ModuleDeclaration = null;
        public enclosingClassDecl: TypeDeclaration = null;
        public enclosingObjectLit: UnaryExpression = null;
        public publicsOnly = true;
        public useFullAst = false;
        private scriptFragment: Script;

        constructor (public logger: ILogger,
                    public script: Script,
                    public text: ISourceText,
                    public pos: number,
                    public isMemberCompletion: bool) {
        }

        public getScope(): SymbolScope {
            return this.scopeGetter();
        }

        public getObjectLiteralScope(): SymbolScope {
            return this.objectLiteralScopeGetter();
        }

        public getScopeAST() {
            return this.scopeStartAST;
        }

        public getScopePosition() {
            return this.scopeStartAST.minChar;
        }

        public getScriptFragmentStartAST(): AST {
            return this.scopeStartAST;
        }

        public getScriptFragmentPosition(): number {
            return this.getScriptFragmentStartAST().minChar;
        }

        public getScriptFragment(): Script {
            if (this.scriptFragment == null) {
                var ast = this.getScriptFragmentStartAST();
                var minChar = ast.minChar;
                var limChar = (this.isMemberCompletion ? this.pos : this.pos + 1);
                this.scriptFragment = TypeScript.quickParse(this.logger, ast, this.text, minChar, limChar, null/*errorCapture*/).Script;
            }
            return this.scriptFragment;
        }
    }

    export function preFindMemberScope(ast: AST, parent: AST, walker: IAstWalker) {
        var memScope: MemberScopeContext = walker.state;
        if (hasFlag(ast.flags, memScope.matchFlag) && ((memScope.pos < 0) || (memScope.pos == ast.limChar))) {
            memScope.ast = ast;
            if ((ast.type == null) && (memScope.pos >= 0)) {
                memScope.flow.inScopeTypeCheck(ast, memScope.scope);
            }
            memScope.type = ast.type;
            memScope.options.stopWalk();
        }
        return ast;
    }

    export function pushTypeCollectionScope(container: Symbol,
        valueMembers: ScopedMembers,
        ambientValueMembers: ScopedMembers,
        enclosedTypes: ScopedMembers,
        ambientEnclosedTypes: ScopedMembers,
        context: TypeCollectionContext,
        thisType: Type,
        classType: Type,
        moduleDecl: ModuleDeclaration) {
        var builder = new SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container);
        var chain: ScopeChain = new ScopeChain(container, context.scopeChain, builder);
        chain.thisType = thisType;
        chain.classType = classType;
        chain.moduleDecl = moduleDecl;
        context.scopeChain = chain;
    }

    export function popTypeCollectionScope(context: TypeCollectionContext) {
        context.scopeChain = context.scopeChain.previous;
    }

    export function preFindEnclosingScope(ast: AST, parent: AST, walker: IAstWalker) {
        var context: EnclosingScopeContext = walker.state;
        var minChar = ast.minChar;
        var limChar = ast.limChar;

        // Account for the fact completion list may be called at the end of a file which
        // is has not been fully re-parsed yet.
        if (ast.nodeType == NodeType.Script && context.pos > limChar)
            limChar = context.pos;

        if ((minChar <= context.pos) &&
            (limChar >= context.pos)) {
            switch (ast.nodeType) {
                case NodeType.Script:
                    var script = <Script>ast;
                    context.scopeGetter = function () {
                        return script.bod === null ? null : script.bod.enclosingScope;
                    };
                    context.scopeStartAST = script;
                    break;

                case NodeType.ClassDeclaration:
                    context.scopeGetter = function () {
                        return (ast.type === null || ast.type.instanceType.containedScope === null) ? null : ast.type.instanceType.containedScope;
                    };
                    context.scopeStartAST = ast;
                    context.enclosingClassDecl = <TypeDeclaration>ast;
                    break;

                case NodeType.ObjectLit:
                    var objectLit = <UnaryExpression>ast;
                    // Only consider target-typed object literals
                    if (objectLit.targetType) {
                        context.scopeGetter = function () {
                            return objectLit.targetType.containedScope;
                        };
                        context.objectLiteralScopeGetter = function () {
                            return objectLit.targetType.memberScope;
                        }
                        context.enclosingObjectLit = objectLit;
                    }
                    break;

                case NodeType.ModuleDeclaration:
                    context.deepestModuleDecl = <ModuleDeclaration>ast;
                    context.scopeGetter = function () {
                        return ast.type === null ? null : ast.type.containedScope;
                    };
                    context.scopeStartAST = ast;
                    break;

                case NodeType.InterfaceDeclaration:
                    context.scopeGetter = function () {
                        return (ast.type === null) ? null : ast.type.containedScope;
                    };
                    context.scopeStartAST = ast;
                    break;

                case NodeType.FuncDecl: {
                    var funcDecl = <FuncDecl>ast;
                    if (context.skipNextFuncDeclForClass) {
                        context.skipNextFuncDeclForClass = false;
                    }
                    else {
                        context.scopeGetter = function () {
                            // The scope of a class constructor is hidden somewhere we don't expect :-S
                            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
                                if (ast.type && ast.type.enclosingType) {
                                    return ast.type.enclosingType.constructorScope;
                                }
                            }

                            if (funcDecl.scopeType) {
                                return funcDecl.scopeType.containedScope;
                            }

                            if (funcDecl.type) {
                                return funcDecl.type.containedScope;
                            }
                            return null;
                        };
                        context.scopeStartAST = ast;
                    }
                }
                    break;
            }
            walker.options.goChildren = true;
        }
        else {
            walker.options.goChildren = false;
        }
        return ast;
    }

    //
    // Find the enclosing scope context from a position inside a script AST.
    // The "scopeStartAST" of the returned scope is always valid.
    // Return "null" if the enclosing scope can't be found.
    //
    export function findEnclosingScopeAt(logger: ILogger, script: Script, text: ISourceText, pos: number, isMemberCompletion: bool): EnclosingScopeContext {
        var context = new EnclosingScopeContext(logger, script, text, pos, isMemberCompletion);

        TypeScript.getAstWalkerFactory().walk(script, preFindEnclosingScope, null, null, context);

        if (context.scopeStartAST === null)
            return null;
        return context;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class Signature {
        public hasVariableArgList = false;
        public returnType: TypeLink;
        public parameters: ParameterSymbol[] = null;
        public declAST: FuncDecl = null;
        public typeCheckStatus = TypeCheckStatus.NotStarted;
        public nonOptionalParameterCount = 0;

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Signature {
            var result = new Signature();
            if (this.hasVariableArgList) {
                result.hasVariableArgList = true;
            }
            result.returnType = new TypeLink();
            if (this.returnType.type) {
                result.returnType.type =
                    this.returnType.type.specializeType(pattern, replacement, checker, false);
            }
            else {
                result.returnType.type = checker.anyType;
            }

            if (this.parameters) {
                result.parameters = [];
                for (var i = 0, len = this.parameters.length; i < len; i++) {
                    var oldSym:ParameterSymbol = this.parameters[i];
                    var paramDef = new ValueLocation();
                    var paramSym = new ParameterSymbol(oldSym.name, oldSym.location,
                                                     checker.locationInfo.unitIndex,
                                                     paramDef);

                    paramSym.declAST = this.declAST;
                    paramDef.symbol = paramSym;
                    paramDef.typeLink = new TypeLink();
                    result.parameters[i] = paramSym;
                    var oldType = oldSym.getType();
                    if (oldType) {
                        paramDef.typeLink.type = oldType.specializeType(pattern, replacement, checker, false);
                        paramSym.declAST.type = paramDef.typeLink.type;
                    }
                    else {
                        paramDef.typeLink.type = checker.anyType;
                    }
                }
            }
            result.nonOptionalParameterCount = this.nonOptionalParameterCount;
            result.declAST = this.declAST;

            return result;
        }

        public toString() {
            return this.toStringHelper(false, false, null);
        }

        public toStringHelper(shortform: bool, brackets: bool, scope: SymbolScope) {
            return this.toStringHelperEx(shortform, brackets, scope).toString();
        }

        public toStringHelperEx(shortform: bool, brackets: bool, scope: SymbolScope, prefix?: string = ""): MemberNameArray {
            var builder = new MemberNameArray();
            if (brackets) {
                builder.prefix =  prefix + "[";
            }
            else {
                builder.prefix = prefix + "(";
            }

            var paramLen = this.parameters.length;
            var len = this.hasVariableArgList ? paramLen - 1 : paramLen;
            for (var i = 0; i < len; i++) {
                builder.add(MemberName.create(this.parameters[i].name + (this.parameters[i].isOptional() ? "?" : "") + ": "));
                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));
                if (i < paramLen - 1) {
                    builder.add(MemberName.create(", "));
                }
            }

            if (this.hasVariableArgList) {
                builder.add(MemberName.create("..." + this.parameters[i].name + ": "));
                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));
            }

            if (shortform) {
                if (brackets) {
                    builder.add(MemberName.create("] => "));
                }
                else {
                    builder.add(MemberName.create(") => "));
                }
            }
            else {
                if (brackets) {
                    builder.add(MemberName.create("]: "));
                }
                else {
                    builder.add(MemberName.create("): "));
                }
            }

            if (this.returnType.type) {
                 builder.add(this.returnType.type.getScopedTypeNameEx(scope));
            }
            else {
                builder.add(MemberName.create("any"));
            }
            return builder;
        }
    }

    export class SignatureGroup {
        public signatures: Signature[] = [];
        public hasImplementation = true;
        public definitionSignature: Signature = null;
        public hasBeenTypechecked = false;
        public flags: SignatureFlags = SignatureFlags.None;
        public addSignature(signature: Signature) {
            if (this.signatures == null) {
                this.signatures = new Signature[];
            }
            this.signatures[this.signatures.length] = signature;
            
            // REVIEW: duplicates should be found within createFunctionSignature,
            // so we won't check for them here
            if (signature.declAST &&
                !signature.declAST.isOverload &&
                !signature.declAST.isSignature() && 
                !hasFlag(signature.declAST.fncFlags, FncFlags.Ambient) &&
                !hasFlag(signature.declAST.fncFlags, FncFlags.Signature)) {
                this.definitionSignature = signature;
            }
        }

        public toString() { return this.signatures.toString(); }
        public toStrings(prefix: string, shortform: bool, scope: SymbolScope, getPrettyTypeName? : bool, useSignature? : Signature) {
            var result : MemberName[] = [];  
            var len = this.signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }

            var getMemberNameOfSignature = (signature: Signature) => {
                if (this.flags & SignatureFlags.IsIndexer) {
                    return signature.toStringHelperEx(shortform, true, scope);
                }
                else {
                    return signature.toStringHelperEx(shortform, false, scope, prefix);
                }
            }

            if (useSignature) {
                result.push(getMemberNameOfSignature(useSignature));
            } else {
                for (var i = 0; i < len; i++) {
                    // the definition signature shouldn't be printed if there are overloads
                    if (len > 1 && this.signatures[i] == this.definitionSignature) {
                        continue;
                    }

                    result.push(getMemberNameOfSignature(this.signatures[i]));
                    if (getPrettyTypeName) {
                        break;
                    }
                }
            }

            if (getPrettyTypeName && len > 1) {
                var lastMemberName = <MemberNameArray>result[result.length - 1];
                var overloadString = " (+ " + ((this.definitionSignature != null) ? len - 2 : len - 1) + " overload(s))";
                lastMemberName.add(MemberName.create(overloadString));
            }

            return result;
        }

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): SignatureGroup {
            var result = new SignatureGroup();
            if (this.signatures) {
                for (var i = 0, len = this.signatures.length; i < len; i++) {
                    result.addSignature(this.signatures[i].specializeType(pattern, replacement, checker));
                }
            }
            return result;
        }

        // verifies that signatures are
        //  - unique within a given group
        //  - compatible with the declaration signature
        public verifySignatures(checker: TypeChecker) {

            var len = 0;
            
            // TODO: verify no signature pair with identical parameters
            if (this.signatures && ((len = this.signatures.length) > 0)) {
                
                for (var i = 0; i < len; i++) {
                    
                    for (var j = i + 1; j < len; j++) {
                        // next check for equivalence between overloads - no two can be exactly the same                     
                        if (this.signatures[i].declAST && this.signatures[j].declAST &&
                            (hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Signature) && hasFlag(this.signatures[j].declAST.fncFlags, FncFlags.Signature)) &&
                            checker.signaturesAreIdentical(this.signatures[i], this.signatures[j])) {
                            checker.errorReporter.simpleError(this.signatures[i].declAST, (this.signatures[i].declAST && this.signatures[i].declAST.name) ? "Signature for '" + this.signatures[i].declAST.name.actualText + "' is duplicated" :"Signature is duplicated");
                        }
                    }
                    
                    // finally, ensure that the definition is assignable to each signature
                    if (this.definitionSignature) {
                        if (!checker.signatureIsAssignableToTarget(this.definitionSignature, this.signatures[i])) {
                            checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload signature is not compatible with function definition");
                        }
                    }
                }
            }
        }

        public typeCheck(checker: TypeChecker, ast: AST, hasConstruct:bool) {
            
            if (this.hasBeenTypechecked) {
                return;
            }
            
            // set here to prevent us from recursively invoking typeCheck again
            this.hasBeenTypechecked = true;
            
            var len = 0;
            
            if (this.signatures && ((len = this.signatures.length) > 0)) {
                
                // first, typecheck each signature
                for (var i = 0; i < len; i++) {

                    if (!hasConstruct && !this.definitionSignature && this.signatures[i].declAST && this.signatures[i].declAST.isOverload && !hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Ambient)) {
                        checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload declaration lacks definition");
                    }

                    // If we're typechecking a constructor via one of its overloads, ensure that the outer class is typechecked, since we need to validate its inheritance properties
                    // to properly check that 'super' is being used correctly
                    if (this.signatures[i].declAST && this.signatures[i].declAST.isConstructor && this.signatures[i].declAST.classDecl && this.signatures[i].declAST.classDecl.type.symbol.typeCheckStatus == TypeCheckStatus.NotStarted) {
                        checker.typeFlow.typeCheck(this.signatures[i].declAST.classDecl);
                    }

                    checker.typeFlow.typeCheck(this.signatures[i].declAST);
                }

                this.verifySignatures(checker);
            }
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export enum TypeCheckStatus {
        NotStarted,
        Started,
        Finished,
    }

    // For lexically-scoped constructs
    export function aLexicallyEnclosesB(a: Symbol, b: Symbol) {
        if (a.declAST && b && b.declAST && a.declAST.nodeType == NodeType.FuncDecl) {
            return a.declAST.minChar <= b.declAST.minChar && a.declAST.limChar >= b.declAST.limChar;
        }
        else {
            return false;
        }
    }

    export function aEnclosesB(a: Symbol, b: Symbol) {
        while (a.container) {
            if (a == b || aLexicallyEnclosesB(a.container, b)) {
                return true;
            }
            a = a.container;
        }
        return false;
    }

    export interface PhasedTypecheckObject {
        typeCheckStatus: TypeCheckStatus;
    }

    export class Symbol {
        public bound = false;
        public container: Symbol;
        public instanceScope(): SymbolScope { return null; }
        public isVariable() { return false; }
        public isMember() { return false; }
        public isInferenceSymbol() { return false; }
        public isWith() { return false; }
        public writeable() { return false; }
        public isType(): bool { return false; }
        public getType(): Type { return null; }
        public flags: SymbolFlags = SymbolFlags.None;
        public refs: Identifier[];
        public isAccessor() { return false; }
        public isObjectLitField = false;

        public declAST: AST = null;
        public declModule: ModuleDeclaration = null;  // if child of module, this is the module that declared it

        public passSymbolCreated: number = CompilerDiagnostics.analysisPass;

        constructor(public name: string, public location: number, public length: number,
                 public unitIndex: number) { }

        public isInstanceProperty() {
            return hasFlag(this.flags, SymbolFlags.Property) && (!hasFlag(this.flags, SymbolFlags.ModuleMember));
        }

        public getTypeName(scope: SymbolScope): string {
            return this.getTypeNameEx(scope).toString();
        }
        
        public getTypeNameEx(scope: SymbolScope): MemberName {
            return MemberName.create(this.toString());
        }

        public getOptionalNameString() {
            return hasFlag(this.flags, SymbolFlags.Optional) ? "?" : "";
        }

        public pathToRoot() {
            var path = new Symbol[];
            var node = this;
            while (node && (node.name != globalId)) {
                path[path.length] = node;
                node = node.container;
            }
            return path;
        }

        public findCommonAncestorPath(b: Symbol) {
            if (this.container == null) {
                return new Symbol[];
            }
            var aPath = this.container.pathToRoot();
            var bPath: Symbol[];
            if (b) {
                bPath = b.pathToRoot();
            }
            else {
                bPath = new Symbol[];
            }
            var commonNodeIndex = -1;
            for (var i = 0, aLen = aPath.length; i < aLen; i++) {
                var aNode = aPath[i];
                for (var j = 0, bLen = bPath.length; j < bLen; j++) {
                    var bNode = bPath[j];
                    if (aNode == bNode) {
                        commonNodeIndex = i;
                        break;
                    }
                }
                if (commonNodeIndex >= 0) {
                    break;
                }
            }
            if (commonNodeIndex >= 0) {
                return aPath.slice(0, commonNodeIndex);
            }
            else {
                return aPath;
            }
        }

        // Gets the pretty Name for the symbol withing the scope
        public getPrettyName(scopeSymbol: Symbol) {
            return this.name;
        }

        public scopeRelativeName(scope: SymbolScope): string {
            if (scope == null) {
                return this.getPrettyName(null) + this.getOptionalNameString();
            }
            var lca = this.findCommonAncestorPath(scope.container);
            var builder = "";
            for (var i = 0, len = lca.length; i < len; i++) {
                var prettyName = lca[i].getPrettyName(i == len - 1 ? scope.container : lca[i + 1]);
                builder = prettyName + "." + builder;
            }
            builder += this.getPrettyName(len == 0 ? scope.container : lca[0]) + this.getOptionalNameString();
            return builder;
        }

        public fullName(scope?: SymbolScope): string {
            var scopeSymbol = !scope ? null : scope.container;
            var scopeRootPath: Symbol[] = !scopeSymbol ? [] : scopeSymbol.pathToRoot();
            var dynamicModuleRoot: Symbol = null;
            if (scopeRootPath.length > 0 && scopeRootPath[scopeRootPath.length - 1].declAST &&
                scopeRootPath[scopeRootPath.length - 1].declAST.nodeType == NodeType.ModuleDeclaration &&
                (<ModuleDeclaration>scopeRootPath[scopeRootPath.length - 1].declAST).isWholeFile()) {
                dynamicModuleRoot = scopeRootPath[scopeRootPath.length - 1];
            }
            var builder = this.getPrettyName(scopeSymbol);
            var ancestor = this.container;
            while (ancestor && (ancestor.name != globalId) && ancestor != dynamicModuleRoot) {
                builder = ancestor.getPrettyName(scopeSymbol) + "." + builder;
                ancestor = ancestor.container;
            }
            return builder;
        }

        public isExternallyVisible(checker: TypeChecker) {
            // Global module is not hidden
            if (this == checker.gloMod) {
                return true;
            }

            // private symbol
            if (hasFlag(this.flags, SymbolFlags.Private)) {
                return false;
            }

            // If the current container is not exported
            // If its in global - it is visible, otherwise it isn't
            if (!hasFlag(this.flags, SymbolFlags.Exported)) {
                return this.container == checker.gloMod;
            }

            // It is visible if its container is visible too
            return this.container.isExternallyVisible(checker);
        }

        public visible(scope: SymbolScope, checker: TypeChecker) {
            if (checker == null || this.container == checker.gloMod) {
                return true;
            }

            if (hasFlag(this.flags, SymbolFlags.ModuleMember)) {

                if (hasFlag(this.flags, SymbolFlags.Exported)) {
                    if (!hasFlag(this.flags, SymbolFlags.Private)) {
                        return true;
                    }
                    else {
                        return aEnclosesB(this, scope.container);
                    }
                }
                else {
                    // REVIEW:
                    // Note that in the scope-assignment and binding phases,
                    // currentModDecl will point to the "master" module decl,
                    // and not necessarily the one that the symbol in question
                    // was declared in.
                    // That's ok - there's no harm done in attributing the symbol
                    // to the master mod decl in either of those phases, so long
                    // as we reference the actual module fragment of declaration
                    // during typecheck.  Doing this also prevents us from printing
                    // multiple error messages if the symbol is not visible.
                    return checker && (checker.currentModDecl == this.declModule) ||
                                                (checker.currentModDecl &&
                                                    checker.currentModDecl.mod &&
                                                    checker.currentModDecl.mod.symbol &&
                                                    this.declModule &&
                                                    this.declModule.mod &&
                                                    this.declModule.mod.symbol &&
                                                    aEnclosesB(checker.currentModDecl.mod.symbol, this.declModule.mod.symbol));
                }
            }
            else {
                // field or method
                var isFunction = this.declAST && this.declAST.nodeType == NodeType.FuncDecl;
                var isMethod = isFunction && (<FuncDecl>this.declAST).isMethod();
                var isStaticFunction = isFunction && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Static)
                var isPrivateMethod = isMethod && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Private);
                var isAlias = this.isType() && (<TypeSymbol>this).aliasLink;

                if (this.isMember() || isMethod || isStaticFunction || isAlias) {
                    if (hasFlag(this.flags, SymbolFlags.Private) || isPrivateMethod) {
                        if (scope.container == null && this.container != scope.container) {
                            return false; // it's an inner member being accessed by the global scope
                        }
                        else {
                            return this.container == null ? true : aEnclosesB(scope.container, this.container);
                        }
                    }
                    else {
                        return true;
                    }
                }
                else if (this.container) {
                    return aEnclosesB(this, scope.container);
                }
                else {
                    return true;
                }
            }
        }

        public addRef(identifier: Identifier) {
            if (!this.refs) {
                this.refs = [];
            }
            this.refs[this.refs.length] = identifier;
        }

        public toString() {
            if (this.name) {
                return this.name;
            }
            else {
                return "_anonymous";
            }
        }

        public print(outfile) {
            outfile.Write(this.toString());
        }

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {
            throw new Error("please implement in derived class");
        }

        public setType(type: Type) {
            throw new Error("please implement in derived class");
        }

        public kind(): SymbolKind {
            throw new Error("please implement in derived class");
        }

        public getInterfaceDeclFromSymbol(checker: TypeChecker) {
            if (this.declAST != null) {
                if (this.declAST.nodeType == NodeType.InterfaceDeclaration) {
                    return <InterfaceDeclaration>this.declAST;
                } else if (this.container != null && this.container != checker.gloMod && this.container.declAST.nodeType == NodeType.InterfaceDeclaration) {
                    return <InterfaceDeclaration>this.container.declAST;
                }
            }

            return null;
        }

        public getVarDeclFromSymbol() {
            if (this.declAST != null && this.declAST.nodeType == NodeType.VarDecl) {
                return <VarDecl>this.declAST;
            }

            return null;
        }

        public getDocComments() : Comment[] {
            if (this.declAST != null) {
                return this.declAST.getDocComments();
            }

            return [];
        }

        public isStatic() {
            return hasFlag(this.flags, SymbolFlags.Static);
        }
    }

    export class ValueLocation {
        public symbol: Symbol;
        public typeLink: TypeLink;
    }

    export class InferenceSymbol extends Symbol {
        constructor (name: string, location: number, length: number, unitIndex: number) {
            super(name, location, length, unitIndex);
        }

        public typeCheckStatus = TypeCheckStatus.NotStarted;
        public isInferenceSymbol() { return true; }
        public transferVarFlags(varFlags: VarFlags) {
            if (hasFlag(varFlags, VarFlags.Ambient)) {
                this.flags |= SymbolFlags.Ambient;
            }
            if (hasFlag(varFlags, VarFlags.Constant)) {
                this.flags |= SymbolFlags.Constant;
            }
            if (hasFlag(varFlags, VarFlags.Static)) {
                this.flags |= SymbolFlags.Static;
            }
            if (hasFlag(varFlags, VarFlags.Property)) {
                this.flags |= SymbolFlags.Property;
            }
            if (hasFlag(varFlags, VarFlags.Private)) {
                this.flags |= SymbolFlags.Private;
            }
            if (hasFlag(varFlags, VarFlags.Public)) {
                this.flags |= SymbolFlags.Public;
            }
            if (hasFlag(varFlags, VarFlags.Readonly)) {
                this.flags |= SymbolFlags.Readonly;
            }
            if (hasFlag(varFlags, VarFlags.Exported)) {
                this.flags |= SymbolFlags.Exported;
            }
        }
    }

    export class TypeSymbol extends InferenceSymbol {
        public additionalLocations: number[];
        public expansions: Type[] = []; // For types that may be "split", keep track of the subsequent definitions
        public expansionsDeclAST: AST[] = [];
        public isDynamic = false;

        constructor (locName: string, location: number, length: number, unitIndex: number, public type: Type) {
            super(locName, location, length, unitIndex);
            this.prettyName = this.name;
        }

        public addLocation(loc: number) {
            if (this.additionalLocations == null) {
                this.additionalLocations = [];
            }
            this.additionalLocations[this.additionalLocations.length] = loc;
        }
        public isMethod = false;
        public aliasLink:ImportDeclaration = null;
        public kind() { return SymbolKind.Type; }
        public isType(): bool { return true; }
        public getType() { return this.type; }
        public prettyName: string;
        public onlyReferencedAsTypeRef = optimizeModuleCodeGen;

        public getTypeNameEx(scope: SymbolScope) {
            return this.type.getMemberTypeNameEx(this.name ? this.name + this.getOptionalNameString() : "", false, false, scope);
        }

        public instanceScope(): SymbolScope {
            // Don't use the constructor scope for a class body or methods - use the contained scope
            if (!(this.type.typeFlags & TypeFlags.IsClass) && this.type.isClass()) {
                return this.type.instanceType.constructorScope;
            }
            else {
                return this.type.containedScope;
            }
        }
        // corresponding instance type if this is a class
        public instanceType: Type;

        public toString() {
            var result = this.type.getTypeName();
            if (this.name) {
                result = this.name + ":" + result;
            }
            return result;
        }

        public isClass() { return this.instanceType != null; }
        public isFunction() { return this.declAST != null && this.declAST.nodeType == NodeType.FuncDecl; }

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {
            if (this.type == pattern) {
                return replacement.symbol;
            }
            else {
                var replType = this.type.specializeType(pattern, replacement, checker, false);
                if (replType != this.type) {
                    var result = new TypeSymbol(this.name, -1, 0, -1, replType);
                    return result;
                }
                else {
                    return this;
                }
            }
        }

        // Gets the pretty name of the symbol with respect to symbol of the scope (scopeSymbol)
        // searchTillRoot specifies if the name need to searched in the root path of the scope
        public getPrettyName(scopeSymbol: Symbol) {
            if (!!scopeSymbol && isQuoted(this.prettyName) && this.type.isModuleType()) {
                // Its a dynamic module - and need to be specialized with the scope
                // Check in exported module members in each scope
                var symbolPath = scopeSymbol.pathToRoot();
                var prettyName = this.getPrettyNameOfDynamicModule(symbolPath);
                if (prettyName != null) {
                    return prettyName.name;
                }
            }

            return this.prettyName;
        }

        public getPrettyNameOfDynamicModule(scopeSymbolPath: Symbol[]) {
            var scopeSymbolPathLength = scopeSymbolPath.length;
            var externalSymbol: { name: string; symbol: Symbol; } = null;
            if (scopeSymbolPath.length > 0 &&
                scopeSymbolPath[scopeSymbolPathLength - 1].getType().isModuleType() &&
                (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 1]).isDynamic) {

                // Check if submodule is dynamic
                if (scopeSymbolPathLength > 1 &&
                    scopeSymbolPath[scopeSymbolPathLength - 2].getType().isModuleType() &&
                    (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 2]).isDynamic) {
                    var moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 2].getType();
                    externalSymbol = moduleType.findDynamicModuleName(this.type);

                }

                if (externalSymbol == null) {
                    // Check in this module
                    var moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 1].getType();
                    externalSymbol = moduleType.findDynamicModuleName(this.type);
                }
            }

            return externalSymbol;
        }

        public getDocComments(): Comment[]{
            var comments : Comment[] = [];
            if (this.declAST != null) {
                comments = comments.concat(this.declAST.getDocComments());
            }

            for (var i = 0; i < this.expansionsDeclAST.length; i++) {
                comments = comments.concat(this.expansionsDeclAST[i].getDocComments());
            }

            return comments;
        }
    }

    export class WithSymbol extends TypeSymbol {
        constructor (location: number, unitIndex: number, withType: Type) {
            super("with", location, 4, unitIndex, withType);
        }
        public isWith() { return true; }
    }

    export class FieldSymbol extends InferenceSymbol {
        public name: string;
        public location: number;

        constructor (name: string, location: number, unitIndex: number, public canWrite: bool,
                      public field: ValueLocation) {

            super(name, location, name.length, unitIndex);
            this.name = name;
            this.location = location;
        }
        public kind() { return SymbolKind.Field; }
        public writeable() { return this.isAccessor() ? this.setter != null : this.canWrite; }
        public getType() { return this.field.typeLink.type; }
        public getTypeNameEx(scope: SymbolScope) {
            return MemberName.create(this.field.typeLink.type.getScopedTypeNameEx(scope), this.name + this.getOptionalNameString() + ": ", "");
        }

        public isMember() { return true; }
        public setType(type: Type) {
            this.field.typeLink.type = type;
        }

        public getter: TypeSymbol = null;
        public setter: TypeSymbol = null;
        public hasBeenEmitted = false; // since getters and setters are emitted together, need to track if one has been emitted

        public isAccessor() { return this.getter != null || this.setter != null; }

        public isVariable() { return true; }
        public toString() { return this.getTypeNameEx(null).toString(); }
        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {
            var rType = this.field.typeLink.type.specializeType(pattern, replacement, checker, false);
            if (rType != this.field.typeLink.type) {
                var fieldDef = new ValueLocation();
                var result = new FieldSymbol(this.name, 0, checker.locationInfo.unitIndex,
                                           this.canWrite, fieldDef);
                result.flags = this.flags;
                fieldDef.symbol = result;
                fieldDef.typeLink = new TypeLink();
                result.setType(rType);
                result.typeCheckStatus = TypeCheckStatus.Finished;
                return result;
            }
            else {
                return this;
            }
        }

        public getDocComments(): Comment[] {
            if (this.getter != null || this.setter != null) {
                var comments : Comment[] = [];
                if (this.getter != null) {
                    comments = comments.concat(this.getter.getDocComments());
                }
                if (this.setter != null) {
                    comments = comments.concat(this.setter.getDocComments());
                }
                return comments;
            }
            else if (this.declAST != null) {
                return this.declAST.getDocComments();
            }

            return [];
        }

    }

    export class ParameterSymbol extends InferenceSymbol {
        public name: string;
        public location: number;
        private paramDocComment: string = null;
        public funcDecl: AST = null;
        
        constructor (name: string, location: number, unitIndex: number,
                          public parameter: ValueLocation) {
            super(name, location, name.length, unitIndex);

            this.name = name;
            this.location = location;
        }
        public kind() { return SymbolKind.Parameter; }
        public writeable() { return true; }
        public getType() { return this.parameter.typeLink.type; }
        public setType(type: Type) {
            this.parameter.typeLink.type = type;
        }
        public isVariable() { return true; }
        public argsOffset = (-1);
        public isOptional() {
            if (this.parameter && this.parameter.symbol && this.parameter.symbol.declAST) {
                return (<ArgDecl>this.parameter.symbol.declAST).isOptional;
            }
            else {
                return false;
            }
        }

        public getTypeNameEx(scope: SymbolScope) {
            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + (this.isOptional() ? "?" : "") + ": ", "");
        }

        public toString() { return this.getTypeNameEx(null).toString(); }

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {
            var rType = this.parameter.typeLink.type.specializeType(pattern, replacement, checker, false);
            if (this.parameter.typeLink.type != rType) {
                var paramDef = new ValueLocation();
                var result = new ParameterSymbol(this.name, 0, checker.locationInfo.unitIndex,
                                               paramDef);
                paramDef.symbol = result;
                result.setType(rType);
                return result;
            }
            else {
                return this;
            }
        }

        public getParameterDocComments() {
            if (!this.paramDocComment) {
                var parameterComments: string[] = [];
                if (this.funcDecl) {
                    var fncDocComments = this.funcDecl.getDocComments();
                    var paramComment = Comment.getParameterDocCommentText(this.name, fncDocComments);
                    if (paramComment != "") {
                        parameterComments.push(paramComment);
                    }
                }
                var docComments = TypeScript.Comment.getDocCommentText(this.getDocComments());
                if (docComments != "") {
                    parameterComments.push(docComments);
                }
                
                this.paramDocComment = parameterComments.join("\n");
            }

            return this.paramDocComment;
        }

        public fullName(): string {
            return this.name;
        }
    }

    export class VariableSymbol extends InferenceSymbol {

        constructor (name: string, location: number, unitIndex: number, public variable: ValueLocation) {
            super(name, location, name.length, unitIndex);
        }
        public kind() { return SymbolKind.Variable; }
        public writeable() { return true; }
        public getType() { return this.variable.typeLink.type; }
        public getTypeNameEx(scope: SymbolScope) {
            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + ": ", "");
        }

        public setType(type: Type) {
            this.variable.typeLink.type = type;
        }
        public isVariable() { return true; }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    // private members are private to the scope
    // public members are public to the scope
    export class ScopedMembers {

        public allMembers: IHashTable;
        public publicMembers: IHashTable;
        public privateMembers: IHashTable;

        constructor (public dualMembers: DualStringHashTable) { 
            this.allMembers = this.dualMembers;
            this.publicMembers = this.dualMembers.primaryTable;
            this.privateMembers = this.dualMembers.secondaryTable;
        }

        // add a public member
        public addPublicMember(key: string, data) { return this.dualMembers.primaryTable.add(key, data); }

        // add a private member 
        public addPrivateMember(key: string, data) { return this.dualMembers.secondaryTable.add(key, data); }
    }

    export enum SymbolKind {
        None,
        Type,
        Field,
        Parameter,
        Variable,
    }

    export class SymbolScope {
        constructor (public container: Symbol) { }
        public printLabel() { return "base"; }
        public getAllSymbolNames(members: bool): string[]{
            return ["please", "implement", "in", "derived", "classes"];
        }
        public getAllTypeSymbolNames(members: bool): string[]{
            return ["please", "implement", "in", "derived", "classes"];
        }
        public getAllValueSymbolNames(members: bool): string[]{
            return ["please", "implement", "in", "derived", "classes"];
        }
        // advanced search using a filter
        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool): Symbol { return null; }
        // find in this immediate scope
        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }
        // find in value namespace 
        public find(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }
        // find symbol that supplies an implementation
        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }
        // restrict the search to ambient values
        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }
        public print(outfile: ITextWriter) {
            if (this.container) {
                outfile.WriteLine(this.printLabel() + " scope with container: " + this.container.name + "...");
            }
            else {
                outfile.WriteLine(this.printLabel() + " scope...");
            }
        }

        public enter(container: Symbol, ast: AST, symbol: Symbol, errorReporter: ErrorReporter, publicOnly: bool,
            typespace: bool, ambient: bool): void {
            throw new Error("please implement in derived class");
        }

        public getTable(): IHashTable {
            throw new Error("please implement in derived class");
        }
    }

    function symbolCanBeUsed(sym: Symbol, publicOnly) {
        return publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||
                            (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))
                          : true;
    }

    export class SymbolAggregateScope extends SymbolScope {
        public printLabel() { return "agg"; }
        public valueCache: IHashTable = null;
        public valueImplCache: IHashTable = null;
        public valueAmbientCache: IHashTable = null;
        public typeCache: IHashTable = null;
        public typeImplCache: IHashTable = null;
        public typeAmbientCache: IHashTable = null;
        public parents: SymbolScope[] = null;
        public container: Symbol;

        constructor (container: Symbol) {
            super(container);
            this.container = container;
        }

        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {
            if (this.parents) {
                for (var i = 0; i < this.parents.length; i++) {
                    var sym = this.parents[i].search(filter, name, publicOnly, typespace);
                    if (sym) {
                        if (filter.update(sym)) {
                            return sym;
                        }
                    }
                }
            }
            return filter.result;
        }

        public getAllSymbolNames(members: bool): string[]{
            var result: string[] = [];
            if (this.parents) {
                for (var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        }

        public getAllTypeSymbolNames(members: bool): string[]{
            var result: string[] = [];
            if (this.parents) {
                for (var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllTypeSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        }

        public getAllValueSymbolNames(members: bool): string[]{
            var result: string[] = [];
            if (this.parents) {
                for (var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllValueSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        }

        public print(outfile: ITextWriter) {
            super.print(outfile);
            if (this.parents) {
                for (var i = 0; i < this.parents.length; i++) {
                    this.parents[i].print(outfile);
                }
            }
        }

        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var i = 0;
            var implCache = this.valueImplCache;

            if (typespace) {
                implCache = this.typeImplCache;
            }
            if (implCache &&
                ((sym = implCache.lookup(name)) != null) &&
                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||
                                        (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))
                                        : true)) {
                return sym;
            }
            if (this.parents) {
                for (i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].findImplementation(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (implCache) {
                if (typespace) {
                    this.typeImplCache = new StringHashTable();
                    implCache = this.typeImplCache;
                }
                else {
                    this.valueImplCache = new StringHashTable();
                    implCache = this.valueImplCache;
                }
            }
            implCache.add(name, sym);
            return sym;
        }

        public find(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var i = 0;
            var cache = this.valueCache;

            if (typespace) {
                cache = this.typeCache;
            }
            if (cache &&
                ((sym = cache.lookup(name)) != null) &&
                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||
                                        (sym.declAST && sym.declAST.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))
                                        : true)) {
                return sym;
            }
            if (this.parents) {
                for (i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].find(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (cache == null) {
                if (typespace) {
                    this.typeCache = new StringHashTable();
                    cache = this.typeCache;
                }
                else {
                    this.valueCache = new StringHashTable();
                    cache = this.valueCache;
                }
            }
            cache.add(name, sym);
            return sym;
        }

        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var i = 0;
            var cache = this.valueAmbientCache;
            if (typespace) {
                cache = this.typeAmbientCache;
            }
            if (cache && ((sym = cache.lookup(name)) != null)) {
                return sym;
            }
            if (this.parents) {
                for (i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].findAmbient(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (cache == null) {
                if (typespace) {
                    this.typeAmbientCache = new StringHashTable();
                    cache = this.typeAmbientCache;
                }
                else {
                    this.valueAmbientCache = new StringHashTable();
                    cache = this.valueAmbientCache;
                }
            }
            cache.add(name, sym);
            return sym;
        }

        public addParentScope(parent: SymbolScope): void {
            if (this.parents == null) {
                this.parents = new SymbolScope[];
            }
            this.parents[this.parents.length] = parent;
        }
    }

    export class SymbolTableScope extends SymbolScope {
        public container: Symbol;

        constructor(public valueMembers: ScopedMembers,
                            public ambientValueMembers: ScopedMembers,
                            public enclosedTypes: ScopedMembers,
                            public ambientEnclosedTypes: ScopedMembers,
                            container: Symbol)
        {
            super(container);
            this.container = container;
        }

        public printLabel() { return "table"; }

        public getAllSymbolNames(members: bool): string[]{
            var result = this.getAllTypeSymbolNames(members);

            return result.concat(this.getAllValueSymbolNames(members));
        }

        public getAllTypeSymbolNames(members: bool): string[]{
            var result = [];
            if (this.ambientEnclosedTypes) {
                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());
            }
            if (this.enclosedTypes) {
                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());
            }
            return result;
        }

        public getAllValueSymbolNames(members: bool): string[]{
            var result = [];
            if (this.ambientValueMembers) {
                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());
            }
            if (this.valueMembers) {
                result = result.concat(this.valueMembers.allMembers.getAllKeys());
            }
            return result;
        }

        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {
            var sym = this.find(name, publicOnly, typespace);
            filter.update(sym);
            return filter.result;
        }

        public find(name: string, publicOnly: bool, typespace: bool): Symbol {
            var table: IHashTable = null;
            var ambientTable: IHashTable = null;

            if (typespace) {
                table = (this.enclosedTypes == null) ? null :
                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes == null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            else {
                table = (this.valueMembers == null) ? null :
                                publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
                ambientTable = (this.ambientValueMembers == null) ? null :
                                    publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            }
            if (ambientTable) {
                var s = ambientTable.lookup(name);
                if (s) { return s; }
            }
            if (table) {
                var s = table.lookup(name);
                if (s) { return s; }
            }

            return null;
        }

        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {
            var ambientTable = (this.ambientValueMembers == null) ? null :
                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                ambientTable = (this.ambientEnclosedTypes == null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable) {
                var s = ambientTable.lookup(name);
                if (s) { return s; }
            }

            return null;
        }

        public print(outfile: ITextWriter) {
            super.print(outfile);
            if (this.ambientValueMembers) {
                this.ambientValueMembers.allMembers.map(function (key, sym, context) {
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.valueMembers) {
                this.valueMembers.allMembers.map(function (key, sym, context) {
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.ambientEnclosedTypes) {
                this.ambientEnclosedTypes.allMembers.map(function (key, sym, context) {
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.enclosedTypes) {
                this.enclosedTypes.allMembers.map(function (key, sym, context) {
                    outfile.WriteLine("  " + key);
                }, null);
            }
        }

        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym = this.find(name, publicOnly, typespace);
            if (sym) {
                if (sym.kind() == SymbolKind.Type) {
                    var typeSym = <TypeSymbol>sym;
                    if (!typeSym.type.hasImplementation()) {
                        sym = null;
                    }
                }
                else if (sym.container) {
                    if (sym.container.kind() == SymbolKind.Type) {
                        var ctypeSym = <TypeSymbol>sym.container;
                        if (!ctypeSym.type.hasImplementation()) {
                            sym = null;
                        }
                    }
                }
            }
            return sym;
        }

        public getTable() {
            return this.valueMembers.publicMembers;
        }
    }

    export class SymbolScopeBuilder extends SymbolScope {
        public container: Symbol;
        
        constructor (public valueMembers: ScopedMembers,
                    public ambientValueMembers: ScopedMembers,
                    public enclosedTypes: ScopedMembers,
                    public ambientEnclosedTypes: ScopedMembers,
                    public parent: SymbolScope,
                    container: Symbol)
        {
            super(container);
            this.container = container;
        }

        public printLabel() { return "builder"; }
        public getAllSymbolNames(members: bool): string[]{
            var result: string[] = this.getAllTypeSymbolNames(members);
            return result.concat(this.getAllValueSymbolNames(members));
        }

        public getAllTypeSymbolNames(members: bool): string[]{
            var result: string[] = [];
            if (this.ambientEnclosedTypes) {
                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());
            }
            if (this.enclosedTypes) {
                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());
            }
            if (!members && this.parent) {
                var parentResult = this.parent.getAllTypeSymbolNames(members);
                if (parentResult) {
                    result = result.concat(parentResult);
                }
            }
            return result;
        }

        public getAllValueSymbolNames(members: bool): string[]{
            var result: string[] = [];
            if (this.ambientValueMembers) {
                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());
            }
            if (this.valueMembers) {
                result = result.concat(this.valueMembers.allMembers.getAllKeys());
            }
            if (!members && this.parent) {
                var parentResult = this.parent.getAllValueSymbolNames(members);
                if (parentResult) {
                    result = result.concat(parentResult);
                }
            }
            return result;
        }

        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {
            var sym: Symbol = null;
            var table = (this.valueMembers == null) ? null :
                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers == null) ? null :
                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes == null) ? null :
                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes == null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable) {
                if ((sym = ambientTable.lookup(name)) != null) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            if (table) {
                if ((sym = table.lookup(name)) != null) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            if (this.parent) {
                sym = this.parent.search(filter, name, publicOnly, typespace);
                if (sym) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            return filter.result;
        }

        public print(outfile: ITextWriter) {
            super.print(outfile);
            if (this.ambientValueMembers) {
                this.ambientValueMembers.allMembers.map(function (key, s, context) {
                    var sym = <Symbol>s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.valueMembers) {
                this.valueMembers.allMembers.map(function (key, s, context) {
                    var sym = <Symbol>s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.ambientEnclosedTypes) {
                this.ambientEnclosedTypes.allMembers.map(function (key, s, context) {
                    var sym = <Symbol>s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.enclosedTypes) {
                this.enclosedTypes.allMembers.map(function (key, s, context) {
                    var sym = <Symbol>s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.parent) {
                this.parent.print(outfile);
            }
        }

        public find(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var table = (this.valueMembers == null) ? null :
                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers == null) ? null :
                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes == null) ? null :
                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes == null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {
                return sym;
            }
            if (table && ((sym = table.lookup(name)) != null)) {
                return sym;
            }
            if (this.parent) {
                return this.parent.find(name, publicOnly, typespace);
            }
            return null;
        }

        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var ambientTable = (this.ambientValueMembers == null) ? null :
                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                ambientTable = (this.ambientEnclosedTypes == null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {
                return sym;
            }
            if (this.parent) {
                return this.parent.findAmbient(name, publicOnly, typespace);
            }
            return null;
        }

        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var table = (this.valueMembers == null) ? null :
                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers == null) ? null :
                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes == null) ? null :
                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes == null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (table) {
                if ((sym = table.lookup(name)) != null) {
                    if (sym) { return sym; }
                }
            }
            if (ambientTable) {
                if ((sym = ambientTable.lookup(name)) != null) {
                    if (sym) { return sym; }
                }
            }
            return null;
        }

        public enter(container: Symbol, ast: AST, symbol: Symbol, errorReporter: ErrorReporter, insertAsPublic: bool, typespace: bool, ambient: bool): void {
            var table = null;

            if (ambient) {
                if (typespace) {
                    table = (this.ambientEnclosedTypes == null) ? null :
                                    insertAsPublic ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.privateMembers;
                }
                else {
                    table = (this.ambientValueMembers == null) ? null :
                                insertAsPublic ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.privateMembers;
                }
            }
            else {
                if (typespace) {
                    table = (this.enclosedTypes == null) ? null :
                                insertAsPublic ? this.enclosedTypes.publicMembers : this.enclosedTypes.privateMembers;
                }
                else {
                    table = (this.valueMembers == null) ? null :
                                insertAsPublic ? this.valueMembers.publicMembers : this.valueMembers.privateMembers;
                }
            }

            if (table) {
                if (!table.add(symbol.name, symbol)) {
                    errorReporter.duplicateIdentifier(ast, symbol.name);
                }
            }
            else {
                CompilerDiagnostics.Alert("YYYYY");  // REVIEW: Surely we can do better than this...
            }
            symbol.container = container;
        }

        public getTable() { return this.valueMembers.allMembers; }
    }

    export class FilteredSymbolScope extends SymbolScope {
        constructor (public scope: SymbolScope, container: Symbol, public filter: ScopeSearchFilter) {
            super(container);
        }
        public print(outfile: ITextWriter) {
            this.scope.print(outfile);
        }

        public find(name: string, publicOnly: bool, typespace: bool) {
            this.filter.reset();
            return this.scope.search(this.filter, name, publicOnly, typespace);
        }
        public findLocal(name: string, publicOnly: bool, typespace: bool) { return this.scope.findLocal(name, publicOnly, typespace); }
    }

    export class FilteredSymbolScopeBuilder extends SymbolScopeBuilder {
        constructor (valueMembers: ScopedMembers, parent: SymbolScope, container: Symbol, public filter: (sym: Symbol) =>bool) {
            super(valueMembers, null, null, null, parent, container);
        }
        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym = super.findLocal(name, publicOnly, typespace);
            if (sym) {
                if (!this.filter(sym)) {
                    return null;
                }
            }
            return sym;
        }

        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool):Symbol {
            throw new Error("please implement");
        }

        public find(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym = super.findLocal(name, publicOnly, typespace);
            if (sym) {
                if (!this.filter(sym)) {
                    return null;
                }
            }
            return super.find(name, publicOnly, typespace);
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export enum TokenID {
        // Keywords
        Any,
        Bool,
        Break,
        Case,
        Catch,
        Class,
        Const,
        Continue,
        Debugger,
        Default,
        Delete,
        Do,
        Else,
        Enum,
        Export,
        Extends,
        Declare,
        False,
        Finally,
        For,
        Function,
        Constructor,
        Get,
        If,
        Implements,
        Import,
        In,
        InstanceOf,
        Interface,
        Let,
        Module,
        New,
        Number,
        Null,
        Package,
        Private,
        Protected,
        Public,
        Return,
        Set,
        Static,
        String,
        Super,
        Switch,
        This,
        Throw,
        True,
        Try,
        TypeOf,
        Var,
        Void,
        With,
        While,
        Yield,
        // Punctuation
        Semicolon,
        OpenParen,
        CloseParen,
        OpenBracket,
        CloseBracket,
        OpenBrace,
        CloseBrace,
        Comma,
        Equals,
        PlusEquals,
        MinusEquals,
        AsteriskEquals,
        SlashEquals,
        PercentEquals,
        AmpersandEquals,
        CaretEquals,
        BarEquals,
        LessThanLessThanEquals,
        GreaterThanGreaterThanEquals,
        GreaterThanGreaterThanGreaterThanEquals,
        Question,
        Colon,
        BarBar,
        AmpersandAmpersand,
        Bar,
        Caret,
        And,
        EqualsEquals,
        ExclamationEquals,
        EqualsEqualsEquals,
        ExclamationEqualsEquals,
        LessThan,
        LessThanEquals,
        GreaterThan,
        GreaterThanEquals,
        LessThanLessThan,
        GreaterThanGreaterThan,
        GreaterThanGreaterThanGreaterThan,
        Plus,
        Minus,
        Asterisk,
        Slash,
        Percent,
        Tilde,
        Exclamation,
        PlusPlus,
        MinusMinus,
        Dot,
        DotDotDot,
        Error,
        EndOfFile,
        EqualsGreaterThan,
        Identifier,
        StringLiteral,
        RegularExpressionLiteral,
        NumberLiteral,
        Whitespace,
        Comment,
        Lim,
        LimFixed = EqualsGreaterThan,
        LimKeyword = Yield,
    }

    export var tokenTable = new TokenInfo[];
    export var nodeTypeTable = new string[];
    export var nodeTypeToTokTable = new number[];
    export var noRegexTable = new bool[];

    noRegexTable[TokenID.Identifier] = true;
    noRegexTable[TokenID.StringLiteral] = true;
    noRegexTable[TokenID.NumberLiteral] = true;
    noRegexTable[TokenID.RegularExpressionLiteral] = true;
    noRegexTable[TokenID.This] = true;
    noRegexTable[TokenID.PlusPlus] = true;
    noRegexTable[TokenID.MinusMinus] = true;
    noRegexTable[TokenID.CloseParen] = true;
    noRegexTable[TokenID.CloseBracket] = true;
    noRegexTable[TokenID.CloseBrace] = true;
    noRegexTable[TokenID.True] = true;
    noRegexTable[TokenID.False] = true;

    export enum OperatorPrecedence {
        None,
        Comma,
        Assignment,
        Conditional,
        LogicalOr,
        LogicalAnd,
        BitwiseOr,
        BitwiseExclusiveOr,
        BitwiseAnd,
        Equality,
        Relational,
        Shift,
        Additive,
        Multiplicative,
        Unary,
        Lim
    }

    export enum Reservation {
        None = 0,
        Javascript = 1,
        JavascriptFuture = 2,
        TypeScript = 4,
        JavascriptFutureStrict = 8,
        TypeScriptAndJS = Javascript | TypeScript,
        TypeScriptAndJSFuture = JavascriptFuture | TypeScript,
        TypeScriptAndJSFutureStrict = JavascriptFutureStrict | TypeScript,
    }

    export class TokenInfo {
        constructor (public tokenId: TokenID, public reservation: Reservation,
                    public binopPrecedence: number, public binopNodeType: number,
                    public unopPrecedence: number, public unopNodeType: number,
                    public text: string, public ers: ErrorRecoverySet) { }
    }

    function setTokenInfo(tokenId: TokenID, reservation: number, binopPrecedence: number,
        binopNodeType: number, unopPrecedence: number, unopNodeType: number,
        text: string, ers: ErrorRecoverySet) {
        if (tokenId !== undefined) {
            tokenTable[tokenId] = new TokenInfo(tokenId, reservation, binopPrecedence,
                                              binopNodeType, unopPrecedence, unopNodeType, text, ers);
            if (binopNodeType != NodeType.None) {
                nodeTypeTable[binopNodeType] = text;
                nodeTypeToTokTable[binopNodeType] = tokenId;
            }
            if (unopNodeType != NodeType.None) {
                nodeTypeTable[unopNodeType] = text;
            }
        }
    }

    setTokenInfo(TokenID.Any, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "any", ErrorRecoverySet.PrimType);
    setTokenInfo(TokenID.Bool, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "bool", ErrorRecoverySet.PrimType);
    setTokenInfo(TokenID.Break, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "break", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.Case, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "case", ErrorRecoverySet.SCase);
    setTokenInfo(TokenID.Catch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "catch", ErrorRecoverySet.Catch);
    setTokenInfo(TokenID.Class, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "class", ErrorRecoverySet.TypeScriptS);
    setTokenInfo(TokenID.Const, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "const", ErrorRecoverySet.Var);
    setTokenInfo(TokenID.Continue, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "continue", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.Debugger, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.Debugger, "debugger", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.Default, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "default", ErrorRecoverySet.SCase);
    setTokenInfo(TokenID.Delete, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Delete, "delete", ErrorRecoverySet.Prefix);
    setTokenInfo(TokenID.Do, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "do", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.Else, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "else", ErrorRecoverySet.Else);
    setTokenInfo(TokenID.Enum, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "enum", ErrorRecoverySet.TypeScriptS);
    setTokenInfo(TokenID.Export, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "export", ErrorRecoverySet.TypeScriptS);
    setTokenInfo(TokenID.Extends, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "extends", ErrorRecoverySet.None);
    setTokenInfo(TokenID.Declare, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "declare", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.False, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "false", ErrorRecoverySet.RLit);
    setTokenInfo(TokenID.Finally, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "finally", ErrorRecoverySet.Catch);
    setTokenInfo(TokenID.For, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "for", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.Function, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "function", ErrorRecoverySet.Func);
    setTokenInfo(TokenID.Constructor, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "constructor", ErrorRecoverySet.Func);
    setTokenInfo(TokenID.Get, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "get", ErrorRecoverySet.Func);
    setTokenInfo(TokenID.Set, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "set", ErrorRecoverySet.Func);
    setTokenInfo(TokenID.If, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "if", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.Implements, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "implements", ErrorRecoverySet.None);
    setTokenInfo(TokenID.Import, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "import", ErrorRecoverySet.TypeScriptS);
    setTokenInfo(TokenID.In, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, NodeType.In, OperatorPrecedence.None, NodeType.None, "in", ErrorRecoverySet.None);
    setTokenInfo(TokenID.InstanceOf, Reservation.TypeScriptAndJS, OperatorPrecedence.Relational, NodeType.InstOf, OperatorPrecedence.None, NodeType.None, "instanceof", ErrorRecoverySet.BinOp);
    setTokenInfo(TokenID.Interface, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "interface", ErrorRecoverySet.TypeScriptS);
    setTokenInfo(TokenID.Let, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "let", ErrorRecoverySet.None);
    setTokenInfo(TokenID.Module, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "module", ErrorRecoverySet.TypeScriptS);
    setTokenInfo(TokenID.New, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "new", ErrorRecoverySet.PreOp);
    setTokenInfo(TokenID.Number, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "number", ErrorRecoverySet.PrimType);
    setTokenInfo(TokenID.Null, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "null", ErrorRecoverySet.RLit);
    setTokenInfo(TokenID.Package, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "package", ErrorRecoverySet.None);
    setTokenInfo(TokenID.Private, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "private", ErrorRecoverySet.TypeScriptS);
    setTokenInfo(TokenID.Protected, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "protected", ErrorRecoverySet.None);
    setTokenInfo(TokenID.Public, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "public", ErrorRecoverySet.TypeScriptS);
    setTokenInfo(TokenID.Return, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "return", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.Static, Reservation.TypeScriptAndJSFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "static", ErrorRecoverySet.None);
    setTokenInfo(TokenID.String, Reservation.TypeScript, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "string", ErrorRecoverySet.PrimType);
    setTokenInfo(TokenID.Super, Reservation.TypeScriptAndJSFuture, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "super", ErrorRecoverySet.RLit);
    setTokenInfo(TokenID.Switch, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "switch", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.This, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "this", ErrorRecoverySet.RLit);
    setTokenInfo(TokenID.Throw, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "throw", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.True, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "true", ErrorRecoverySet.RLit);
    setTokenInfo(TokenID.Try, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "try", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.TypeOf, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Typeof, "typeof", ErrorRecoverySet.Prefix);
    setTokenInfo(TokenID.Var, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "var", ErrorRecoverySet.Var);
    setTokenInfo(TokenID.Void, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Void, "void", ErrorRecoverySet.Prefix);
    setTokenInfo(TokenID.With, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.With, "with", ErrorRecoverySet.Stmt);
    setTokenInfo(TokenID.While, Reservation.TypeScriptAndJS, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "while", ErrorRecoverySet.While);
    setTokenInfo(TokenID.Yield, Reservation.JavascriptFutureStrict, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "yield", ErrorRecoverySet.None);

    setTokenInfo(TokenID.Identifier, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "identifier", ErrorRecoverySet.ID);
    setTokenInfo(TokenID.NumberLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "numberLiteral", ErrorRecoverySet.Literal);
    setTokenInfo(TokenID.RegularExpressionLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "regex", ErrorRecoverySet.RegExp);
    setTokenInfo(TokenID.StringLiteral, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "qstring", ErrorRecoverySet.Literal);

    // Non-operator non-identifier tokens
    setTokenInfo(TokenID.Semicolon, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ";", ErrorRecoverySet.SColon); // ;
    setTokenInfo(TokenID.CloseParen, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ")", ErrorRecoverySet.RParen); // )
    setTokenInfo(TokenID.CloseBracket, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "]", ErrorRecoverySet.RBrack); // ]
    setTokenInfo(TokenID.OpenBrace, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "{", ErrorRecoverySet.LCurly); // {
    setTokenInfo(TokenID.CloseBrace, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "}", ErrorRecoverySet.RCurly); // }
    setTokenInfo(TokenID.DotDotDot, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "...", ErrorRecoverySet.None); // ...

    // Operator non-identifier tokens
    setTokenInfo(TokenID.Comma, Reservation.None, OperatorPrecedence.Comma, NodeType.Comma, OperatorPrecedence.None, NodeType.None, ",", ErrorRecoverySet.Comma); // ,
    setTokenInfo(TokenID.Equals, Reservation.None, OperatorPrecedence.Assignment, NodeType.Asg, OperatorPrecedence.None, NodeType.None, "=", ErrorRecoverySet.Asg); // =
    setTokenInfo(TokenID.PlusEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgAdd, OperatorPrecedence.None, NodeType.None, "+=", ErrorRecoverySet.BinOp); // +=
    setTokenInfo(TokenID.MinusEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgSub, OperatorPrecedence.None, NodeType.None, "-=", ErrorRecoverySet.BinOp); // -=
    setTokenInfo(TokenID.AsteriskEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgMul, OperatorPrecedence.None, NodeType.None, "*=", ErrorRecoverySet.BinOp); // *=

    setTokenInfo(TokenID.SlashEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgDiv, OperatorPrecedence.None, NodeType.None, "/=", ErrorRecoverySet.BinOp); // /=
    setTokenInfo(TokenID.PercentEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgMod, OperatorPrecedence.None, NodeType.None, "%=", ErrorRecoverySet.BinOp); // %=
    setTokenInfo(TokenID.AmpersandEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgAnd, OperatorPrecedence.None, NodeType.None, "&=", ErrorRecoverySet.BinOp); // &=
    setTokenInfo(TokenID.CaretEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgXor, OperatorPrecedence.None, NodeType.None, "^=", ErrorRecoverySet.BinOp); // ^=
    setTokenInfo(TokenID.BarEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgOr, OperatorPrecedence.None, NodeType.None, "|=", ErrorRecoverySet.BinOp); // |=
    setTokenInfo(TokenID.LessThanLessThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgLsh, OperatorPrecedence.None, NodeType.None, "<<=", ErrorRecoverySet.BinOp); // <<=
    setTokenInfo(TokenID.GreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgRsh, OperatorPrecedence.None, NodeType.None, ">>=", ErrorRecoverySet.BinOp); // >>=
    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThanEquals, Reservation.None, OperatorPrecedence.Assignment, NodeType.AsgRs2, OperatorPrecedence.None, NodeType.None, ">>>=", ErrorRecoverySet.BinOp); // >>>=
    setTokenInfo(TokenID.Question, Reservation.None, OperatorPrecedence.Conditional, NodeType.ConditionalExpression, OperatorPrecedence.None, NodeType.None, "?", ErrorRecoverySet.BinOp); // ?
    setTokenInfo(TokenID.Colon, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ":", ErrorRecoverySet.Colon); // :
    setTokenInfo(TokenID.BarBar, Reservation.None, OperatorPrecedence.LogicalOr, NodeType.LogOr, OperatorPrecedence.None, NodeType.None, "||", ErrorRecoverySet.BinOp); // ||
    setTokenInfo(TokenID.AmpersandAmpersand, Reservation.None, OperatorPrecedence.LogicalAnd, NodeType.LogAnd, OperatorPrecedence.None, NodeType.None, "&&", ErrorRecoverySet.BinOp); // &&
    setTokenInfo(TokenID.Bar, Reservation.None, OperatorPrecedence.BitwiseOr, NodeType.Or, OperatorPrecedence.None, NodeType.None, "|", ErrorRecoverySet.BinOp); // |
    setTokenInfo(TokenID.Caret, Reservation.None, OperatorPrecedence.BitwiseExclusiveOr, NodeType.Xor, OperatorPrecedence.None, NodeType.None, "^", ErrorRecoverySet.BinOp); // ^
    setTokenInfo(TokenID.And, Reservation.None, OperatorPrecedence.BitwiseAnd, NodeType.And, OperatorPrecedence.None, NodeType.None, "&", ErrorRecoverySet.BinOp); // &
    setTokenInfo(TokenID.EqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Eq, OperatorPrecedence.None, NodeType.None, "==", ErrorRecoverySet.BinOp); // ==
    setTokenInfo(TokenID.ExclamationEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Ne, OperatorPrecedence.None, NodeType.None, "!=", ErrorRecoverySet.BinOp); // !=
    setTokenInfo(TokenID.EqualsEqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.Eqv, OperatorPrecedence.None, NodeType.None, "===", ErrorRecoverySet.BinOp); // ===
    setTokenInfo(TokenID.ExclamationEqualsEquals, Reservation.None, OperatorPrecedence.Equality, NodeType.NEqv, OperatorPrecedence.None, NodeType.None, "!==", ErrorRecoverySet.BinOp); // !==
    setTokenInfo(TokenID.LessThan, Reservation.None, OperatorPrecedence.Relational, NodeType.Lt, OperatorPrecedence.None, NodeType.None, "<", ErrorRecoverySet.BinOp); // <
    setTokenInfo(TokenID.LessThanEquals, Reservation.None, OperatorPrecedence.Relational, NodeType.Le, OperatorPrecedence.None, NodeType.None, "<=", ErrorRecoverySet.BinOp); // <=
    setTokenInfo(TokenID.GreaterThan, Reservation.None, OperatorPrecedence.Relational, NodeType.Gt, OperatorPrecedence.None, NodeType.None, ">", ErrorRecoverySet.BinOp); // >
    setTokenInfo(TokenID.GreaterThanEquals, Reservation.None, OperatorPrecedence.Relational, NodeType.Ge, OperatorPrecedence.None, NodeType.None, ">=", ErrorRecoverySet.BinOp); // >=
    setTokenInfo(TokenID.LessThanLessThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Lsh, OperatorPrecedence.None, NodeType.None, "<<", ErrorRecoverySet.BinOp); // <<
    setTokenInfo(TokenID.GreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Rsh, OperatorPrecedence.None, NodeType.None, ">>", ErrorRecoverySet.BinOp); // >>
    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThan, Reservation.None, OperatorPrecedence.Shift, NodeType.Rs2, OperatorPrecedence.None, NodeType.None, ">>>", ErrorRecoverySet.BinOp); // >>>
    setTokenInfo(TokenID.Plus, Reservation.None, OperatorPrecedence.Additive, NodeType.Add, OperatorPrecedence.Unary, NodeType.Pos, "+", ErrorRecoverySet.AddOp); // +
    setTokenInfo(TokenID.Minus, Reservation.None, OperatorPrecedence.Additive, NodeType.Sub, OperatorPrecedence.Unary, NodeType.Neg, "-", ErrorRecoverySet.AddOp); // -
    setTokenInfo(TokenID.Asterisk, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Mul, OperatorPrecedence.None, NodeType.None, "*", ErrorRecoverySet.BinOp); // *
    setTokenInfo(TokenID.Slash, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Div, OperatorPrecedence.None, NodeType.None, "/", ErrorRecoverySet.BinOp); // /
    setTokenInfo(TokenID.Percent, Reservation.None, OperatorPrecedence.Multiplicative, NodeType.Mod, OperatorPrecedence.None, NodeType.None, "%", ErrorRecoverySet.BinOp); // %
    setTokenInfo(TokenID.Tilde, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Not, "~", ErrorRecoverySet.PreOp); // ~
    setTokenInfo(TokenID.Exclamation, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.LogNot, "!", ErrorRecoverySet.PreOp); // !
    setTokenInfo(TokenID.PlusPlus, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.IncPre, "++", ErrorRecoverySet.PreOp); // ++
    setTokenInfo(TokenID.MinusMinus, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.DecPre, "--", ErrorRecoverySet.PreOp); // --
    setTokenInfo(TokenID.OpenParen, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "(", ErrorRecoverySet.LParen); // (
    setTokenInfo(TokenID.OpenBracket, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "[", ErrorRecoverySet.LBrack); // [
    setTokenInfo(TokenID.Dot, Reservation.None, OperatorPrecedence.Unary, NodeType.None, OperatorPrecedence.None, NodeType.None, ".", ErrorRecoverySet.Dot); // .
    setTokenInfo(TokenID.EndOfFile, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "<EOF>", ErrorRecoverySet.EOF); // EOF
    setTokenInfo(TokenID.EqualsGreaterThan, Reservation.None, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "=>", ErrorRecoverySet.None); // =>

    export function lookupToken(tokenId: TokenID): TokenInfo {
        return tokenTable[tokenId];
    }

    export enum TokenClass {
        Punctuation,
        Keyword,
        Operator,
        Comment,
        Whitespace,
        Identifier,
        NumberLiteral,
        StringLiteral,
        RegExpLiteral,
    }

    export class SavedToken {
        constructor (public tok: Token, public minChar: number, public limChar: number) { }
    }

    export class Token {
        constructor (public tokenId: TokenID) {
        }

        public toString() {
            return "token: " + this.tokenId + " " + this.getText() + " (" + (<any>TokenID)._map[this.tokenId] + ")";
        }

        public print(line: number, outfile) {
            outfile.WriteLine(this.toString() + ",on line" + line);
        }

        public getText(): string {
            return tokenTable[this.tokenId].text;
        }

        public classification(): TokenClass {
            if (this.tokenId <= TokenID.LimKeyword) {
                return TokenClass.Keyword;
            }
            else {
                var tokenInfo = lookupToken(this.tokenId);
                if (tokenInfo != undefined) {
                    if ((tokenInfo.unopNodeType != NodeType.None) ||
                        (tokenInfo.binopNodeType != NodeType.None)) {
                        return TokenClass.Operator;
                    }
                }
            }

            return TokenClass.Punctuation;
        }
    }

    export class NumberLiteralToken extends Token {
        constructor (public value: number, public text: string) {
            super(TokenID.NumberLiteral);
        }

        public getText(): string {
            return this.text;
        }

        public classification(): TokenClass {
            return TokenClass.NumberLiteral;
        }
    }

    export class StringLiteralToken extends Token {
        constructor (public value: string) {
            super(TokenID.StringLiteral);
        }

        public getText(): string {
            return this.value;
        }
        
        public classification(): TokenClass {
            return TokenClass.StringLiteral;
        }
    }

    export class IdentifierToken extends Token {
        constructor (public value: string, public hasEscapeSequence : bool) {
            super(TokenID.Identifier);
        }
        public getText(): string {
            return this.value;
        }
        public classification(): TokenClass {
            return TokenClass.Identifier;
        }
    }

    export class WhitespaceToken extends Token {
        constructor (tokenId: TokenID, public value: string) {
            super(tokenId);
        }

        public getText(): string {
            return this.value;
        }

        public classification(): TokenClass {
            return TokenClass.Whitespace;
        }
    }

    export class CommentToken extends Token {
        constructor (tokenID: TokenID, public value: string, public isBlock: bool, public startPos: number, public line: number, public endsLine: bool) {
            super(tokenID);
        }

        public getText(): string {
            return this.value;
        }

        public classification(): TokenClass {
            return TokenClass.Comment;
        }
    }

    export class RegularExpressionLiteralToken extends Token {
        constructor(public text: string) {
            super(TokenID.RegularExpressionLiteral);
        }

        public getText(): string {
            return this.text;
        }

        public classification(): TokenClass {
            return TokenClass.RegExpLiteral;
        }
    }

    // TODO: new with length TokenID.LimFixed
    export var staticTokens = new Token[];
    export function initializeStaticTokens() {
        for (var i = 0; i <= TokenID.LimFixed; i++) {
            staticTokens[i] = new Token(i);
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class ArrayCache {
        public arrayType: Type;
        public arrayBase: Type = null;

        public specialize(arrInstType: Type, checker: TypeChecker): Type {
            if (this.arrayBase == null) {
                this.arrayBase = arrInstType.specializeType(checker.wildElm.type, this.arrayType.elementType,
                                                   checker, true);
            }
            return this.arrayBase;
        }
    }

    export class TypeComparisonInfo {
        public onlyCaptureFirstError = false;
        public flags: TypeRelationshipFlags = TypeRelationshipFlags.SuccessfulComparison;
        public message = "";

        public addMessageToFront(message) {
            if (!this.onlyCaptureFirstError) {
                this.message = this.message ? message + ":\n\t" + this.message : message;
            }
            else {
                this.setMessage(message);
            }
        }

        public setMessage(message) {
            this.message = message;
        }
    }

    export interface SignatureData {
        parameters: ParameterSymbol[];
        nonOptionalParameterCount: number;
    }

    export interface ApplicableSignature {
        signature: Signature;
        hadProvisionalErrors: bool;
    }

    export enum TypeCheckCollectionMode {
        Resident,
        Transient
    }

    export class PersistentGlobalTypeState {
        public importedGlobalsTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
        public importedGlobalsTypeTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));

        public importedGlobals: SymbolScopeBuilder;

        // transient state
        public globals: IHashTable = null;
        public globalTypes: IHashTable = null;
        public ambientGlobals: IHashTable = null;
        public ambientGlobalTypes: IHashTable = null;

        // resident state
        public residentGlobalValues = new StringHashTable();
        public residentGlobalTypes = new StringHashTable();
        public residentGlobalAmbientValues = new StringHashTable();
        public residentGlobalAmbientTypes = new StringHashTable();

        // dual resident/transient state

        // REVIEW: We shouldn't need to allocate private hash tables for these, since there's no private global scope
        // REVIEW: In general, we should audit each instance of DualStringHashTable to ensure that both the primary
        // and secondary tables are necessary.  If it's not necessary, we should sub in a constant sentinel value.
        public dualGlobalValues: DualStringHashTable;
        public dualGlobalTypes: DualStringHashTable;
        public dualAmbientGlobalValues: DualStringHashTable;
        public dualAmbientGlobalTypes: DualStringHashTable;

        public globalScope: SymbolScope;

        public voidType: Type;
        public booleanType: Type;
        public doubleType: Type;

        public stringType: Type;
        public anyType: Type;
        public nullType: Type;
        public undefinedType: Type;

        // Use this flag to turn resident checking on and off
        public residentTypeCheck: bool = true;

        public mod: ModuleType = null;
        public gloMod: TypeSymbol = null;

        public wildElm: TypeSymbol = null;

        constructor (public errorReporter: ErrorReporter) {
            this.importedGlobals = new SymbolScopeBuilder(null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null);

            this.dualGlobalValues = new DualStringHashTable(this.residentGlobalValues, new StringHashTable());
            this.dualGlobalTypes = new DualStringHashTable(this.residentGlobalTypes, new StringHashTable());
            this.dualAmbientGlobalValues = new DualStringHashTable(this.residentGlobalAmbientValues, new StringHashTable());
            this.dualAmbientGlobalTypes = new DualStringHashTable(this.residentGlobalAmbientTypes, new StringHashTable());

            var dualGlobalScopedMembers = new ScopedMembers(new DualStringHashTable(this.dualGlobalValues, new StringHashTable()));
            var dualGlobalScopedAmbientMembers = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalValues, new StringHashTable()));
            var dualGlobalScopedEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualGlobalTypes, new StringHashTable()));
            var dualGlobalScopedAmbientEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalTypes, new StringHashTable()));

            this.globalScope = new SymbolScopeBuilder(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null);

            this.voidType = this.enterPrimitive(Primitive.Void, "void");
            this.booleanType = this.enterPrimitive(Primitive.Boolean, "bool");
            this.doubleType = this.enterPrimitive(Primitive.Double, "number");
            this.importedGlobals.ambientEnclosedTypes.addPublicMember("number", this.doubleType.symbol);

            this.stringType = this.enterPrimitive(Primitive.String, "string");
            this.anyType = this.enterPrimitive(Primitive.Any, "any");
            this.nullType = this.enterPrimitive(Primitive.Null, "null");
            this.undefinedType = this.enterPrimitive(Primitive.Undefined, "undefined");

            // shared global state is resident
            this.setCollectionMode(TypeCheckCollectionMode.Resident);

            this.wildElm = new TypeSymbol("_element", -1, 0, -1, new Type());
            this.importedGlobalsTypeTable.addPublicMember(this.wildElm.name, this.wildElm);

            this.mod = new ModuleType(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes);
            this.mod.members = dualGlobalScopedMembers;
            this.mod.ambientMembers = dualGlobalScopedAmbientMembers;
            this.mod.containedScope = this.globalScope;

            this.gloMod = new TypeSymbol(globalId, -1, 0, -1, this.mod);
            this.mod.members.addPublicMember(this.gloMod.name, this.gloMod);

            this.defineGlobalValue("undefined", this.undefinedType);
        }


        public enterPrimitive(flags: number, name: string) {
            var primitive = new Type();
            primitive.primitiveTypeClass = flags;
            var symbol = new TypeSymbol(name, -1, name.length, -1, primitive);
            symbol.typeCheckStatus = TypeCheckStatus.Finished;
            primitive.symbol = symbol;
            this.importedGlobals.enter(null, null, symbol, this.errorReporter, true, true, true);
            return primitive;
        }

        public setCollectionMode(mode: TypeCheckCollectionMode) {
            this.residentTypeCheck =
                this.dualGlobalValues.insertPrimary =
                    this.dualGlobalTypes.insertPrimary =
                        this.dualAmbientGlobalValues.insertPrimary =
                            this.dualAmbientGlobalTypes.insertPrimary = mode == TypeCheckCollectionMode.Resident;
        }

        public refreshPersistentState() {
            this.globals = new StringHashTable();
            this.globalTypes = new StringHashTable();
            this.ambientGlobals = new StringHashTable();
            this.ambientGlobalTypes = new StringHashTable();

            // add global types to the global scope
            this.globalTypes.add(this.voidType.symbol.name, this.voidType.symbol);
            this.globalTypes.add(this.booleanType.symbol.name, this.booleanType.symbol);
            this.globalTypes.add(this.doubleType.symbol.name, this.doubleType.symbol);
            this.globalTypes.add("number", this.doubleType.symbol);
            this.globalTypes.add(this.stringType.symbol.name, this.stringType.symbol);
            this.globalTypes.add(this.anyType.symbol.name, this.anyType.symbol);
            this.globalTypes.add(this.nullType.symbol.name, this.nullType.symbol);
            this.globalTypes.add(this.undefinedType.symbol.name, this.undefinedType.symbol);

            this.dualGlobalValues.secondaryTable = this.globals;
            this.dualGlobalTypes.secondaryTable = this.globalTypes;
            this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals;
            this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes;
        }

        public defineGlobalValue(name: string, type: Type) {
            var valueLocation = new ValueLocation();
            valueLocation.typeLink = new TypeLink();
            var sym = new VariableSymbol(name, 0, -1, valueLocation);
            sym.setType(type);
            sym.typeCheckStatus = TypeCheckStatus.Finished;
            sym.container = this.gloMod;
            this.importedGlobalsTable.addPublicMember(name, sym);
        }
    }

    export class ContextualTypeContext {
        public targetSig: Signature = null;
        public targetThis: Type = null;
        public targetAccessorType: Type = null;

        constructor (public contextualType: Type,
            public provisional: bool, public contextID: number) { }
    }

    export class ContextualTypingContextStack {
        private contextStack: ContextualTypeContext[] = [];
        static contextID = TypeCheckStatus.Finished + 1;
        public pushContextualType(type: Type, provisional: bool) { this.contextStack.push(new ContextualTypeContext(type, provisional, ContextualTypingContextStack.contextID++)); this.checker.errorReporter.pushToErrorSink = provisional; }
        public hadProvisionalErrors = false; // somewhere in the chain a provisional typecheck error was thrown
        public popContextualType() {
            var tc = this.contextStack.pop();
            this.checker.errorReporter.pushToErrorSink = this.isProvisional();
            this.hadProvisionalErrors = this.hadProvisionalErrors || (tc.provisional && (this.checker.errorReporter.getCapturedErrors().length));
            this.checker.errorReporter.freeCapturedErrors();
            return tc;
        }
        public getContextualType(): ContextualTypeContext { return (!this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1]); }
        public getContextID() { return (!this.contextStack.length ? TypeCheckStatus.Finished : this.contextStack[this.contextStack.length - 1].contextID); }
        public isProvisional() { return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional); }

        constructor (public checker: TypeChecker) { }
    }

    export class TypeChecker {
        public errorReporter: ErrorReporter = null;
        public globalScope: SymbolScope;

        public checkControlFlow = false;
        public printControlFlowGraph = false;
        public checkControlFlowUseDef = false;
        public styleSettings: StyleSettings = null;

        public units: LocationInfo[] = null;

        public voidType: Type;
        public booleanType: Type;
        public numberType: Type;
        public stringType: Type;
        public anyType: Type;
        public nullType: Type;
        public undefinedType: Type;

        public anon = "_anonymous";

        public globals: DualStringHashTable;
        public globalTypes: DualStringHashTable;
        public ambientGlobals: DualStringHashTable;
        public ambientGlobalTypes: DualStringHashTable;
        public gloModType: ModuleType;
        public gloMod: TypeSymbol;
        public wildElm: TypeSymbol;

        public locationInfo: LocationInfo = null;
        public typeFlow: TypeFlow = null;

        public currentCompareA: Symbol = null;
        public currentCompareB: Symbol = null;

        public currentModDecl: ModuleDeclaration = null;

        public inBind = false;
        public inWith = false;
        public errorsOnWith = true;

        public typingContextStack: ContextualTypingContextStack;
        public currentContextualTypeContext: ContextualTypeContext = null;

        public resolvingBases = false;

        public canCallDefinitionSignature = false;

        public assignableCache: any[] = <any>{};
        public subtypeCache: any[] = <any>{};
        public identicalCache: any[] = <any>{};

        public provisionalStartedTypecheckObjects: PhasedTypecheckObject[] = [];

        public mustCaptureGlobalThis = false;

        constructor (public persistentState: PersistentGlobalTypeState) {
            this.voidType = this.persistentState.voidType;
            this.booleanType = this.persistentState.booleanType;
            this.numberType = this.persistentState.doubleType;
            this.stringType = this.persistentState.stringType;
            this.anyType = this.persistentState.anyType;
            this.nullType = this.persistentState.nullType;
            this.undefinedType = this.persistentState.undefinedType;

            this.globals = this.persistentState.dualGlobalValues;
            this.globalTypes = this.persistentState.dualGlobalTypes;
            this.ambientGlobals = this.persistentState.dualAmbientGlobalValues;
            this.ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes;
            this.gloModType = this.persistentState.mod;
            this.gloMod = this.persistentState.gloMod;
            this.wildElm = this.persistentState.wildElm;

            this.globalScope = this.persistentState.globalScope;

            this.typingContextStack = new ContextualTypingContextStack(this);
        }

        public setStyleOptions(style: StyleSettings) {
            this.styleSettings = style;
        }

        // Contextual typing
        public setContextualType(type: Type, provisional: bool) {
            this.typingContextStack.pushContextualType(type, provisional);
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
        }

        public unsetContextualType() {
            var lastTC = this.typingContextStack.popContextualType();
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
            return lastTC;
        }

        public hadProvisionalErrors() {
            return this.typingContextStack.hadProvisionalErrors;
        }
        public resetProvisionalErrors() {
            if (!this.typingContextStack.getContextualType()) {
                this.typingContextStack.hadProvisionalErrors = false;
            }
        }

        public typeCheckWithContextualType(contextType: Type, provisional: bool, condition: bool, ast: AST) {
            if (condition) {
                this.setContextualType(contextType, this.typingContextStack.isProvisional() || provisional);
            }
            this.typeFlow.typeCheck(ast);
            if (condition) {
                this.unsetContextualType();
            }
        }

        public resetTargetType() {
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
        }

        // Unset the current contextual type without disturbing the stack, effectively "killing" the contextual typing process
        public killCurrentContextualType() { this.currentContextualTypeContext = null; this.errorReporter.pushToErrorSink = false; }
        public hasTargetType() { return this.currentContextualTypeContext && this.currentContextualTypeContext.contextualType; }
        public getTargetTypeContext() { return this.currentContextualTypeContext; }

        public inProvisionalTypecheckMode() {
            return this.typingContextStack.isProvisional();
        }

        public getTypeCheckFinishedStatus() {
            if (this.inProvisionalTypecheckMode()) {
                return this.typingContextStack.getContextID();
            }
            return TypeCheckStatus.Finished;
        }

        public typeStatusIsFinished(status: TypeCheckStatus) {

            return status == TypeCheckStatus.Finished ||
                   (this.inProvisionalTypecheckMode() && status == this.typingContextStack.getContextID());
        }

        public addStartedPTO(pto: PhasedTypecheckObject) {
            if (this.inProvisionalTypecheckMode()) {
                this.provisionalStartedTypecheckObjects[this.provisionalStartedTypecheckObjects.length] = pto;
            }
        }

        public cleanStartedPTO() {
            for (var i = 0; i < this.provisionalStartedTypecheckObjects.length; i++) {
                if (this.provisionalStartedTypecheckObjects[i].typeCheckStatus >= this.typingContextStack.getContextID()) {
                    this.provisionalStartedTypecheckObjects[i].typeCheckStatus = TypeCheckStatus.NotStarted;
                }
            }
            this.provisionalStartedTypecheckObjects = [];
        }

        // type collection      
        public collectTypes(ast: AST): void {
            if (ast.nodeType == NodeType.Script) {
                var script = <Script>ast;
                this.locationInfo = script.locationInfo;
            }
            var globalChain = new ScopeChain(this.gloMod, null, this.globalScope);
            var context = new TypeCollectionContext(globalChain, this);
            getAstWalkerFactory().walk(ast, preCollectTypes, postCollectTypes, null, context);
        }

        public makeArrayType(type: Type): Type {
            if (type.arrayCache == null) {
                type.arrayCache = new ArrayCache();
                type.arrayCache.arrayType = new Type();
                type.arrayCache.arrayType.elementType = type;
                type.arrayCache.arrayType.symbol = type.symbol;
            }
            return type.arrayCache.arrayType;
        }

        public getParameterList(funcDecl: FuncDecl, container: Symbol): SignatureData {
            var args = funcDecl.arguments;
            var parameterTable = null;
            var parameterBuilder = null;
            var len = args.members.length;
            var nonOptionalParams = 0;
            var result: ParameterSymbol[] = [];

            if (len > 0) {
                parameterTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                parameterBuilder = new SymbolScopeBuilder(parameterTable, null, null, null, null, container);

                for (var i = 0; i < len; i++) {
                    var parameter = <ArgDecl>args.members[i];
                    var paramDef = new ValueLocation();
                    var parameterSymbol = new ParameterSymbol(parameter.id.text, parameter.minChar,
                                                            this.locationInfo.unitIndex, paramDef);
                    parameterSymbol.declAST = parameter;
                    parameterSymbol.funcDecl = funcDecl;
                    parameter.id.sym = parameterSymbol;
                    parameter.sym = parameterSymbol;
                    paramDef.symbol = parameterSymbol;
                    paramDef.typeLink = getTypeLink(parameter.typeExpr, this, false);
                    parameterBuilder.enter(null, parameter, parameterSymbol, this.errorReporter, true, false, false); // REVIEW: Should this be entered into the private scope?
                    result[result.length] = parameterSymbol;
                    if (!parameter.isOptionalArg()) {
                        nonOptionalParams++;
                    }
                }
            }
            return { parameters: result, nonOptionalParameterCount: nonOptionalParams };
        }

        // Create a signature for a function definition
        //  (E.g., has a function body - function declarations, property declarations, lambdas)
        public createFunctionSignature(funcDecl: FuncDecl, container: Symbol, scope: SymbolScope, overloadGroupSym: Symbol, addToScope: bool): Signature {

            var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) || container == this.gloMod;
            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);
            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);
            var isDefinition = !hasFlag(funcDecl.fncFlags, FncFlags.Signature);
            var isAmbient = hasFlag(funcDecl.fncFlags, FncFlags.Ambient);
            var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;
            var isGlobal = container == this.gloMod;

            var signature: Signature = new Signature();
            var isLambda = funcDecl.fncFlags & FncFlags.IsFunctionExpression;

            // If a return type has been declared for the signature, set the type link.
            // Otherwise:
            //  if it's a signature, its type will be 'any'
            //  if it's a definition, the return type will be inferred  
            if (funcDecl.returnTypeAnnotation || isDefinition) {
                signature.returnType = getTypeLink(funcDecl.returnTypeAnnotation, this, false);
            }
            else {
                signature.returnType = new TypeLink();
                signature.returnType.type = this.anyType;
            }

            signature.hasVariableArgList = funcDecl.variableArgList;

            var sigData = this.getParameterList(funcDecl, container);

            signature.parameters = sigData.parameters;
            signature.nonOptionalParameterCount = sigData.nonOptionalParameterCount;

            funcDecl.signature = signature;
            signature.declAST = funcDecl;

            var useOverloadGroupSym =
                overloadGroupSym &&
                overloadGroupSym.getType() &&
                !overloadGroupSym.isAccessor() &&
                (funcDecl.isSignature() || (isAmbient == hasFlag(overloadGroupSym.flags, SymbolFlags.Ambient)));

            if (useOverloadGroupSym && isPrivate != hasFlag(overloadGroupSym.flags, SymbolFlags.Private)) {
                this.errorReporter.simpleError(funcDecl, "Public/Private visibility of overloads does not agree");
            }

            var groupType = useOverloadGroupSym ? overloadGroupSym.getType() : new Type();

            if (isConstructor) {
                if (groupType.construct == null) {
                    groupType.construct = new SignatureGroup();
                }
                groupType.construct.addSignature(signature);
                groupType.construct.hasImplementation = !(funcDecl.isSignature());
                if (groupType.construct.hasImplementation) {
                    groupType.setHasImplementation();
                }
            }
            else if (funcDecl.isIndexerMember()) {
                if (groupType.index == null) {
                    groupType.index = new SignatureGroup();
                    groupType.index.flags |= SignatureFlags.IsIndexer;
                }

                groupType.index.addSignature(signature);
                groupType.index.hasImplementation = !(funcDecl.isSignature());
                if (groupType.index.hasImplementation) {
                    groupType.setHasImplementation();
                }
            }
            else {
                if (groupType.call == null) {
                    groupType.call = new SignatureGroup();
                }
                groupType.call.addSignature(signature);

                groupType.call.hasImplementation = !(funcDecl.isSignature());
                if (groupType.call.hasImplementation) {
                    groupType.setHasImplementation();
                }
            }

            var instanceType = groupType.instanceType;

            // Ensure that the function's symbol is properly configured
            // (If there were overloads, we'll already have a symbol, otherwise we need to create one)
            var funcName: string = null;

            // Set the function's name:
            //  In the case of anonymous or functions resulting from error
            //  correction in the parser (isMissing() == true), we do not
            //  want to set a function name, since they shouldn't be inserted
            //  into the enclosing scope

            // usedHint prevents functions bound to object literal fields from being added to the
            // enclosing scope
            var usedHint = false;
            if (funcDecl.name && !funcDecl.name.isMissing()) {
                funcName = funcDecl.name.text;
            }
            else if (funcDecl.hint) {
                funcName = funcDecl.hint;
                usedHint = true;
            }

            if (groupType.symbol == null) {
                groupType.symbol =
                    new TypeSymbol(funcName ? funcName : this.anon,
                                    funcDecl.minChar, funcDecl.limChar - funcDecl.minChar,
                                    this.locationInfo.unitIndex,
                                    groupType);
                if (!useOverloadGroupSym) {
                    groupType.symbol.declAST = funcDecl;
                }
            }

            // REVIEW: Are we missing any other flags?
            if (isStatic) {
                groupType.symbol.flags |= SymbolFlags.Static;
            }

            if (isAmbient) {
                groupType.symbol.flags |= SymbolFlags.Ambient;
            }

            if (isPrivate) {
                groupType.symbol.flags |= SymbolFlags.Private;
            }

            groupType.symbol.isMethod = funcDecl.isMethod();
            if (groupType.symbol.isMethod) {
                groupType.symbol.flags |= SymbolFlags.Property;
            }

            funcDecl.type = groupType;

            // Add the function symbol to the appropriate scope
            // if the funcDecl is a constructor, it will be added to the enclosing scope as a class
            if (!isConstructor) {
                // Add the function's symbol to its enclosing scope
                if (funcName && !isLambda && !funcDecl.isAccessor() && !usedHint) {

                    // REVIEW: We're not setting the isDecl flags for fuctions bound to object literal properties
                    // so removing the isDefiniton clause would break object literals
                    if (addToScope) {  // REVIEW: If we combine this with createFunctionDeclarationSignature, we'll need to broaden this for both decls and defs                      
                        // if it's a static method, enter directly into the container's scope
                        if (funcDecl.isMethod() && isStatic) {

                            // REVIEW: What about private statics?
                            if (!(<TypeSymbol>container).type.members.publicMembers.add(funcName, groupType.symbol)) {
                                this.errorReporter.duplicateIdentifier(funcDecl, funcName);
                            }

                            groupType.symbol.container = container;
                        } // REVIEW: Another check for overloads...
                        else if (overloadGroupSym == null || (overloadGroupSym.declAST && !(<FuncDecl>overloadGroupSym.declAST).isOverload && (container.isType()))) {
                            scope.enter(container, funcDecl, groupType.symbol, this.errorReporter, !isPrivate && (isExported || isStatic || isGlobal), false, isAmbient);
                        }
                    }
                    else if (!funcDecl.isSpecialFn()) {
                        groupType.symbol.container = container; // REVIEW: Set container for overloads or anonymous?
                    }
                }
                else if (!funcDecl.isSpecialFn()) {
                    groupType.symbol.container = container; // REVIEW: Set container for lambdas and accessors?
                }
            }

            // If, say, a call signature overload was declared before the class type was, we want to reuse
            // the type that's already been instantiated for the class type, rather than allocate a new one
            if (useOverloadGroupSym) {
                var overloadGroupType = overloadGroupSym ? overloadGroupSym.getType() : null;
                var classType = groupType;

                if (classType != overloadGroupType) {
                    if (classType.construct == null) {
                        if (overloadGroupType && overloadGroupType.construct) {
                            classType.construct = overloadGroupType.construct;
                        }
                        else {
                            classType.construct = new SignatureGroup();
                        }
                    }
                    else if (overloadGroupType) {
                        if (overloadGroupType.construct) {
                            classType.construct.signatures.concat(overloadGroupType.construct.signatures);
                        }
                    }

                    // sync call and index signatures as well, but don't allocate should they not
                    // already exist
                    if (overloadGroupType) {
                        if (classType.call == null) {
                            classType.call = overloadGroupType.call;
                        }
                        else if (overloadGroupType.call) {
                            classType.call.signatures.concat(overloadGroupType.call.signatures);
                        }

                        // if the function is not static, we need to add any call overloads onto the
                        // instance type's call signature list
                        if (!isStatic) {

                            if (classType.instanceType == null) {
                                classType.instanceType = overloadGroupType.instanceType;
                            }

                            var instanceType = classType.instanceType;

                            if (instanceType) {
                                if (instanceType.call == null) {
                                    instanceType.call = overloadGroupType.call;
                                }
                                else if (overloadGroupType.call) {
                                    instanceType.call.signatures.concat(overloadGroupType.call.signatures);
                                }
                            }
                        }

                        if (classType.index == null) {
                            classType.index = overloadGroupType.index;
                        }
                        else if (overloadGroupType.index) {
                            classType.index.signatures.concat(overloadGroupType.index.signatures);
                        }
                    }
                }
            }

            return signature;
        }

        // Creates a new symbol for an accessor property
        // Note that funcDecl.type.symbol and fgSym may not be the same (E.g., in the case of type collection)
        public createAccessorSymbol(funcDecl: FuncDecl, fgSym: Symbol, enclosingClass: Type, addToMembers: bool, isClassProperty: bool, scope: SymbolScope, container: Symbol) {
            var accessorSym: FieldSymbol = null
            var sig = funcDecl.signature;
            var nameText = funcDecl.name.text;
            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);
            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);

            if (fgSym == null) {
                var field = new ValueLocation();
                accessorSym = new FieldSymbol(nameText, funcDecl.minChar, this.locationInfo.unitIndex, false, field);
                field.symbol = accessorSym;
                accessorSym.declAST = funcDecl; // REVIEW: need to reset for getters and setters

                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                    if (accessorSym.getter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");
                    }
                    accessorSym.getter = <TypeSymbol>sig.declAST.type.symbol;
                }
                else {
                    if (accessorSym.setter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");
                    }
                    accessorSym.setter = <TypeSymbol>sig.declAST.type.symbol;
                }

                field.typeLink = getTypeLink(null, this, false);

                // if it's static, enter it into the class's member list directly
                if (addToMembers) {
                    if (enclosingClass) {
                        if (!enclosingClass.members.publicMembers.add(nameText, accessorSym)) {
                            this.errorReporter.duplicateIdentifier(funcDecl, accessorSym.name);
                        }
                        accessorSym.container = enclosingClass.symbol;
                    }
                    else {
                        this.errorReporter.simpleError(funcDecl, "Accessor property may not be added in this context");
                    }
                }
                else {
                    scope.enter(container, funcDecl, accessorSym, this.errorReporter, !isPrivate || isStatic, false, false);
                }

                // We set the flags here, instead of below, because the accessor symbol does not yet have a type
                if (isClassProperty) {
                    accessorSym.flags |= SymbolFlags.Property;
                }
                if (isStatic) {
                    accessorSym.flags |= SymbolFlags.Static;
                }

                if (isPrivate) {
                    accessorSym.flags |= SymbolFlags.Private;
                }
                else {
                    accessorSym.flags |= SymbolFlags.Public;
                }
            }
            else {
                accessorSym = <FieldSymbol>(<any>fgSym);

                if (isPrivate != hasFlag(accessorSym.flags, SymbolFlags.Private)) {
                    this.errorReporter.simpleError(funcDecl, "Getter and setter accessors do not agree in visibility");
                }

                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                    if (accessorSym.getter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");
                    }
                    accessorSym.getter = <TypeSymbol>funcDecl.type.symbol;
                }
                else {
                    if (accessorSym.setter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");
                    }
                    accessorSym.setter = <TypeSymbol>funcDecl.type.symbol;
                }
            }

            return accessorSym;
        }

        public addBases(resultScope: SymbolAggregateScope, type: Type, baseContext: { base: string; baseId: number; }): void {
            resultScope.addParentScope(new SymbolTableScope(type.members, type.ambientMembers, type.getAllEnclosedTypes(), type.getAllAmbientEnclosedTypes(), type.symbol));
            var i = 0;
            var parent: Type;
            if (type.extendsList) {
                for (var len = type.extendsList.length; i < len; i++) {
                    parent = type.extendsList[i];
                    if (baseContext.baseId == parent.typeID) {
                        this.errorReporter.reportErrorFromSym(parent.symbol, "Type '" + baseContext.base + "' is recursively referenced as a base class of itself");
                        parent.symbol.flags |= SymbolFlags.RecursivelyReferenced;
                        break;
                    }
                    this.addBases(resultScope, parent, baseContext);
                }
            }
        }

        public scopeOf(type: Type): SymbolScope {
            var resultScope = new SymbolAggregateScope(type.symbol);
            var baseContext = { base: type.symbol && type.symbol.name ? type.symbol.name : "{}", baseId: type.typeID };
            this.addBases(resultScope, type, baseContext);
            return resultScope;
        }

        public lookupMemberTypeSymbol(containingType: Type, name: string): Symbol {
            var symbol: Symbol = null;
            if (containingType.containedScope) {
                symbol = containingType.containedScope.find(name, false, true);
            }
            else if (containingType.members) {
                symbol = containingType.members.allMembers.lookup(name);

                if (symbol == null && containingType.ambientMembers) {
                    symbol = containingType.ambientMembers.allMembers.lookup(name);
                }
            }
            if (symbol == null) {
                var typeMembers = containingType.getAllEnclosedTypes();
                var ambientTypeMembers = containingType.getAllAmbientEnclosedTypes();
                if (typeMembers) {
                    symbol = typeMembers.allMembers.lookup(name);

                    if (symbol == null && ambientTypeMembers) {
                        symbol = ambientTypeMembers.allMembers.lookup(name);
                    }

                }
            }
            if (symbol && symbol.isType()) {
                return symbol;
            }
            else {
                return null;
            }
        }

        public findSymbolForDynamicModule(idText: string, currentFileName: string, search: (id: string) =>Symbol): Symbol {
            var originalIdText = idText;
            var symbol = search(idText);
           
            if (symbol == null) {
                // perhaps it's a dynamic module?
                if (!symbol) {
                    idText = swapQuotes(originalIdText);
                    symbol = search(idText);
                }

                // Check the literal path first
                if (!symbol) {
                    idText = stripQuotes(originalIdText) + ".ts";
                    symbol = search(idText);
                }

                if (!symbol) {
                    idText = stripQuotes(originalIdText) + ".str";
                    symbol = search(idText);
                }

                // Check check for .d.str
                if (!symbol) {
                    idText = stripQuotes(originalIdText) + ".d.ts";
                    symbol = search(idText);
                }

                if (!symbol) {
                    idText = stripQuotes(originalIdText) + ".d.str";
                    symbol = search(idText);
                }

                // If the literal path doesn't work, begin the search
                if (!symbol && !isRelative(originalIdText)) {
                    // check the full path first, as this is the most likely scenario
                    idText = originalIdText;

                    var strippedIdText = stripQuotes(idText);

                    // REVIEW: Technically, we shouldn't have to normalize here - we should normalize in addUnit.
                    // Still, normalizing here alows any language services to be free of assumptions
                    var path = getRootFilePath(switchToForwardSlashes(currentFileName));

                    while (symbol == null && path != "") {
                        idText = normalizePath(path + strippedIdText + ".ts");
                        symbol = search(idText);

                        // check for .str
                        if (symbol == null) {
                            idText = changePathToSTR(idText);
                            symbol = search(idText);
                        }

                        // check for .d.ts
                        if (symbol == null) {
                            idText = changePathToDTS(idText);
                            symbol = search(idText);
                        }

                        // check for .d.str
                        if (symbol == null) {
                            idText = changePathToDSTR(idText);
                            symbol = search(idText);
                        }

                        if (symbol == null) {
                                                        if(path === '/') {
                                                                path = '';
                                                        } else {
                                                                path = normalizePath(path + "..");
                                                                path = path && path != '/' ? path + '/' : path;
                                                        }
                        }
                    }
                }
            }

            return symbol;
        }

        public resolveTypeMember(scope: SymbolScope, dotNode: BinaryExpression): Type {
            var lhs = dotNode.operand1;
            var rhs = dotNode.operand2;
            var resultType = this.anyType;
            var lhsType = this.anyType;

            if (lhs && rhs && (rhs.nodeType == NodeType.Name)) {
                if (lhs.nodeType == NodeType.Dot) {
                    lhsType = this.resolveTypeMember(scope, <BinaryExpression>lhs);
                }
                else if (lhs.nodeType == NodeType.Name) {
                    var identifier = <Identifier>lhs;
                    var symbol = scope.find(identifier.text, false, true);
                    if (symbol == null) {
                        this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);
                    }
                    else if (symbol.isType()) {

                        var typeSymbol = <TypeSymbol> symbol;

                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {
                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;
                            var modSym = this.findSymbolForDynamicModule(modPath, this.locationInfo.filename, (id) => scope.find(id, false, true));
                            if (modSym) {
                                typeSymbol.type = modSym.getType();
                            }
                        }

                        if (optimizeModuleCodeGen && symbol) {
                            var symType = symbol.getType();
                            // Once the type has been referenced outside of a type ref position, there's
                            // no going back                        
                            if (symType && typeSymbol.aliasLink && typeSymbol.onlyReferencedAsTypeRef) {

                                var modDecl = <ModuleDeclaration>symType.symbol.declAST;
                                if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic)) {
                                    typeSymbol.onlyReferencedAsTypeRef = !this.resolvingBases;
                                }
                            }
                        }
                        if (!symbol.visible(scope, this)) {
                            this.errorReporter.simpleError(lhs, "The symbol '" + identifier.actualText + "' is not visible at this point");
                        }
                        lhsType = symbol.getType();

                        identifier.sym = symbol;
                    }
                    else {
                        this.errorReporter.simpleError(lhs, "Expected type");
                    }

                }

                // if the LHS type is a module alias, we won't be able to resolve it until
                // typecheck type.  If this is called during binding, lhsType will be null
                if (!lhsType) {
                    lhsType = this.anyType;
                }

                if (lhsType != this.anyType) {
                    var rhsIdentifier = <Identifier>rhs;
                    var resultSymbol = this.lookupMemberTypeSymbol(lhsType, rhsIdentifier.text);
                    if (resultSymbol == null) {
                        resultType = this.anyType;
                        this.errorReporter.simpleError(dotNode, "Expected type");
                    }
                    else {
                        resultType = resultSymbol.getType();
                        if (!resultSymbol.visible(scope, this)) {
                            this.errorReporter.simpleError(lhs, "The symbol '" + (<Identifier>rhs).actualText + "' is not visible at this point");
                        }
                    }
                    rhsIdentifier.sym = resultType.symbol;
                }
            }
            if (resultType.isClass()) {
                resultType = resultType.instanceType;
            }
            return resultType;
        }

        public resolveFuncDecl(funcDecl: FuncDecl, scope: SymbolScope,
            fgSym: TypeSymbol): Symbol {
            var functionGroupSymbol = this.createFunctionSignature(funcDecl, scope.container, scope, fgSym, false).declAST.type.symbol;
            var signatures: Signature[];
            if (funcDecl.isConstructMember()) {
                signatures = functionGroupSymbol.type.construct.signatures;
            }
            else if (funcDecl.isIndexerMember()) {
                signatures = functionGroupSymbol.type.getInstanceType().index.signatures;
            }
            else {
                signatures = functionGroupSymbol.type.call.signatures;
            }

            var signature = signatures[signatures.length - 1];
            var len = signature.parameters.length;
            for (var i = 0; i < len; i++) {
                var paramSym: ParameterSymbol = signature.parameters[i];
                this.resolveTypeLink(scope, paramSym.parameter.typeLink, true);
            }

            // If a vararg list is present, check that the type is an array type
            if (len && funcDecl.variableArgList) {
                if (!signature.parameters[len - 1].parameter.typeLink.type.elementType) {
                    this.errorReporter.simpleErrorFromSym(signature.parameters[len - 1].parameter.symbol, "... parameter must have array type");
                    signature.parameters[len - 1].parameter.typeLink.type = this.makeArrayType(signature.parameters[len - 1].parameter.typeLink.type);
                }
            }
            this.resolveTypeLink(scope, signature.returnType,
                            funcDecl.isSignature());
            return functionGroupSymbol;
        }

        public resolveVarDecl(varDecl: VarDecl, scope: SymbolScope): Symbol {
            var field = new ValueLocation();
            var fieldSymbol =
                new FieldSymbol(varDecl.id.text, varDecl.minChar, this.locationInfo.unitIndex,
                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,
                                field);
            fieldSymbol.transferVarFlags(varDecl.varFlags);
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = varDecl;
            field.typeLink = getTypeLink(varDecl.typeExpr, this, varDecl.init == null);
            this.resolveTypeLink(scope, field.typeLink, true);
            varDecl.sym = fieldSymbol;
            varDecl.type = field.typeLink.type;
            return fieldSymbol;
        }

        public resolveTypeLink(scope: SymbolScope, typeLink: TypeLink, supplyVar: bool): void {
            var arrayCount = 0;
            if (typeLink.type == null) {
                var ast: AST = typeLink.ast;
                if (ast) {
                    while (typeLink.type == null) {
                        switch (ast.nodeType) {
                            case NodeType.Name:
                                var identifier = <Identifier>ast;
                                var symbol = scope.find(identifier.text, false, true);
                                if (symbol == null) {
                                    typeLink.type = this.anyType;
                                    this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);
                                }
                                else if (symbol.isType()) {
                                    if (!symbol.visible(scope, this)) {
                                        this.errorReporter.simpleError(ast, "The symbol '" + identifier.actualText + "' is not visible at this point");
                                    }
                                    identifier.sym = symbol;
                                    typeLink.type = symbol.getType();
                                    if (typeLink.type) {
                                        if (typeLink.type.isClass()) {
                                            typeLink.type = typeLink.type.instanceType;
                                        }
                                    }
                                    else {
                                        typeLink.type = this.anyType;
                                    }
                                }
                                else {
                                    typeLink.type = this.anyType;
                                    this.errorReporter.simpleError(ast, "Expected type");
                                }
                                break;
                            case NodeType.Dot:
                                typeLink.type = this.resolveTypeMember(scope, <BinaryExpression>ast);
                                break;
                            case NodeType.TypeRef:
                                var typeRef = <TypeReference>ast;
                                arrayCount = typeRef.arrayCount;
                                ast = typeRef.term;
                                if (ast == null) {
                                    typeLink.type = this.anyType;
                                }
                                break;
                            case NodeType.InterfaceDeclaration:
                                var interfaceDecl = <InterfaceDeclaration>ast;
                                var interfaceType = new Type();
                                var interfaceSymbol = new TypeSymbol((<Identifier>interfaceDecl.name).text,
                                                                   ast.minChar,
                                                                   ast.limChar - ast.minChar,
                                                                   this.locationInfo.unitIndex,
                                                                   interfaceType);
                                interfaceType.symbol = interfaceSymbol;
                                interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));

                                interfaceType.containedScope =
                                    new SymbolTableScope(interfaceType.members, null, null, null,
                                                         interfaceSymbol);

                                interfaceType.containedScope.container = interfaceSymbol;
                                interfaceType.memberScope = interfaceType.containedScope;

                                var memberList = <ASTList>interfaceDecl.members;
                                var props: AST[] = memberList.members;
                                var propsLen = props.length;

                                for (var j = 0; j < propsLen; j++) {
                                    var propDecl = props[j];
                                    var propSym: Symbol = null;
                                    var addMember = true;
                                    var id: Identifier = null;
                                    if (propDecl.nodeType == NodeType.FuncDecl) {
                                        var funcDecl = <FuncDecl>propDecl;
                                        id = funcDecl.name;
                                        propSym = interfaceType.members.allMembers.lookup(funcDecl.getNameText());
                                        addMember = (propSym == null);
                                        if (funcDecl.isSpecialFn()) {
                                            addMember = false;
                                            propSym = this.resolveFuncDecl(funcDecl, scope, interfaceSymbol);
                                        }
                                        else {
                                            propSym = this.resolveFuncDecl(funcDecl, scope, <TypeSymbol>propSym);
                                        }
                                        funcDecl.type = (<TypeSymbol>propSym).type;
                                    }
                                    else {
                                        id = (<VarDecl>propDecl).id;
                                        propSym = this.resolveVarDecl(<VarDecl>propDecl, scope);

                                        // Don't add the member if it was missing a name.  This 
                                        // generally just leads to cascading errors that make things
                                        // more confusing for the user.
                                        addMember = !id.isMissing();
                                    }

                                    if (addMember) {
                                        if (id && hasFlag(id.flags, ASTFlags.OptionalName)) {
                                            propSym.flags |= SymbolFlags.Optional;
                                        }
                                        if (!interfaceType.members.allMembers.add(propSym.name, propSym)) {
                                            this.errorReporter.duplicateIdentifier(ast, propSym.name);
                                        }
                                    }
                                }

                                ast.type = interfaceType;
                                typeLink.type = interfaceType;

                                break;
                            case NodeType.FuncDecl:
                                var tsym = <TypeSymbol>this.resolveFuncDecl(<FuncDecl>ast, scope, null);
                                typeLink.type = tsym.type;
                                break;
                            default:
                                typeLink.type = this.anyType;
                                this.errorReporter.simpleError(ast, "Expected type");
                                break;
                        }
                    }
                }
                for (var count = arrayCount; count > 0; count--) {
                    typeLink.type = this.makeArrayType(typeLink.type);
                }
                if (supplyVar && (typeLink.type == null)) {
                    typeLink.type = this.anyType;
                }
                if (typeLink.ast) {
                    typeLink.ast.type = typeLink.type;
                }
            }
            // else wait for type inference
        }

        public resolveBaseTypeLink(typeLink: TypeLink, scope: SymbolScope) {
            this.resolvingBases = true;
            this.resolveTypeLink(scope, typeLink, true);
            this.resolvingBases = false;
            var extendsType: Type = null;
            if (typeLink.type.isClass()) {
                extendsType = typeLink.type.instanceType;
            }
            else {
                extendsType = typeLink.type;
            }

            return extendsType;
        }

        public findMostApplicableSignature(signatures: ApplicableSignature[], args: ASTList): { sig: Signature; ambiguous: bool; } {

            if (signatures.length == 1) {
                return { sig: signatures[0].signature, ambiguous: false };
            }

            var best: ApplicableSignature = signatures[0];
            var Q: ApplicableSignature = null;
            var AType: Type = null;
            var PType: Type = null;
            var QType: Type = null;
            var ambiguous = false;

            for (var qSig = 1; qSig < signatures.length; qSig++) {
                Q = signatures[qSig];
                var i = 0;
                // find the better conversion
                for (i = 0; args && i < args.members.length; i++) {
                    AType = args.members[i].type;
                    PType = i < best.signature.parameters.length ? best.signature.parameters[i].getType() : best.signature.parameters[best.signature.parameters.length - 1].getType().elementType;
                    QType = i < Q.signature.parameters.length ? Q.signature.parameters[i].getType() : Q.signature.parameters[Q.signature.parameters.length - 1].getType().elementType;

                    if (this.typesAreIdentical(PType, QType)) {
                        continue;
                    }
                    else if (this.typesAreIdentical(AType, PType)) {
                        break;
                    }
                    else if (this.typesAreIdentical(AType, QType)) {
                        best = Q;
                        break;
                    }
                    else if (this.sourceIsSubtypeOfTarget(PType, QType)) {
                        break;
                    }
                    else if (this.sourceIsSubtypeOfTarget(QType, PType)) {
                        best = Q;
                        break;
                    }
                    else if (Q.hadProvisionalErrors) {
                        break;
                    }
                    else if (best.hadProvisionalErrors) {
                        best = Q;
                        break;
                    }
                }

                if (!args || i == args.members.length) {
                    var collection: ITypeCollection = {
                        getLength: () => { return 2; },
                        setTypeAtIndex: (index: number, type: Type) => { }, // no contextual typing here, so no need to do anything
                        getTypeAtIndex: (index: number) => { return index ? Q.signature.returnType.type : best.signature.returnType.type; } // we only want the "second" type - the "first" is skipped
                    }
                    var bct = this.findBestCommonType(best.signature.returnType.type, null, collection, true);
                    ambiguous = !bct;
                }
                else {
                    ambiguous = false;
                }
            }

            return { sig: best.signature, ambiguous: ambiguous };
        }

        public getApplicableSignatures(signatures: Signature[], args: ASTList, comparisonInfo: TypeComparisonInfo): ApplicableSignature[] {

            var applicableSigs: ApplicableSignature[] = [];
            var memberType: Type = null;
            var miss = false;
            var cxt: ContextualTypeContext = null;
            var hadProvisionalErrors = false;

            for (var i = 0; i < signatures.length; i++) {
                miss = false;

                for (var j = 0; j < args.members.length; j++) {

                    if (j >= signatures[i].parameters.length) {
                        continue;
                    }
                    memberType = signatures[i].parameters[j].getType();

                    // account for varargs
                    if (signatures[i].declAST.variableArgList && (j >= signatures[i].nonOptionalParameterCount - 1) && memberType.isArray()) {
                        memberType = memberType.elementType;
                    }

                    if (memberType == this.anyType) {
                        continue;
                    }
                    else if (args.members[j].nodeType == NodeType.FuncDecl) {
                        if (this.typeFlow.functionInterfaceType && memberType == this.typeFlow.functionInterfaceType) {
                            continue;
                        }
                        if (!this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], true)) {
                            // if it's just annotations that are blocking us, typecheck the function and add it to the list
                            if (this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], false)) {
                                this.typeFlow.typeCheck(args.members[j]);
                                if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                                    break;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        else { // if it can be contextually typed, try it out...

                            this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                            this.cleanStartedPTO();
                            hadProvisionalErrors = this.hadProvisionalErrors();

                            if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                                if (comparisonInfo) {
                                    comparisonInfo.setMessage("Could not apply type '" + memberType.getTypeName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                                }
                                miss = true;
                            }

                            // clean the type
                            //if (hadProvisionalErrors) {
                            //    cxt = this.currentContextualTypeContext;
                            //    this.typeCheckWithContextualType(null, true, true, args.members[j]);
                            //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {
                            //        miss = true;
                            //    }
                            //    this.cleanStartedPTO();
                            //}

                            this.resetProvisionalErrors();
                            if (miss) {
                                break;
                            }
                        }
                    }
                    else if (args.members[j].nodeType == NodeType.ObjectLit) {
                        // now actually attempt to typecheck as the contextual type
                        if (this.typeFlow.objectInterfaceType && memberType == this.typeFlow.objectInterfaceType) {
                            continue;
                        }

                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                        this.cleanStartedPTO();
                        hadProvisionalErrors = this.hadProvisionalErrors(); 

                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.getTypeName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                            }
                            miss = true;
                        }

                        // clean the type
                        //if (hadProvisionalErrors) {
                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);

                        //    // is the "cleaned" type even assignable?
                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {
                        //        miss = true;
                        //    }

                        //    this.cleanStartedPTO();
                        //}

                        this.resetProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    }
                    else if (args.members[j].nodeType == NodeType.ArrayLit) {
                        // attempt to contextually type the array literal
                        if (this.typeFlow.arrayInterfaceType && memberType == this.typeFlow.arrayInterfaceType) {
                            continue;
                        }

                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                        this.cleanStartedPTO();
                        hadProvisionalErrors = this.hadProvisionalErrors(); 

                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.getTypeName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                            }
                            break;
                        }

                        // clean the type
                        //if (hadProvisionalErrors) {
                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);
                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {
                        //        miss = true;
                        //    }

                        //    this.cleanStartedPTO();
                        //}

                        this.resetProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    }
                }

                if (j == args.members.length) {
                    applicableSigs[applicableSigs.length] = { signature: signatures[i], hadProvisionalErrors: hadProvisionalErrors };
                }
                hadProvisionalErrors = false;
            }

            return applicableSigs;
        }

        public canContextuallyTypeFunction(candidateType: Type, funcDecl: FuncDecl, beStringent: bool): bool {

            // in these cases, we do not attempt to apply a contextual type
            //  RE: isInlineCallLiteral - if the call target is a function literal, we don't want to apply the target type
            //  to its body - instead, it should be applied to its return type
            if (funcDecl.isParenthesized ||
                funcDecl.isMethod() ||
                beStringent && funcDecl.returnTypeAnnotation ||
                funcDecl.isInlineCallLiteral) {
                return false;
            }

            beStringent = beStringent || (this.typeFlow.functionInterfaceType == candidateType);

            // At this point, if we're not being stringent, there's no need to check for multiple call sigs
            // or count parameters - we just want to unblock typecheck
            if (!beStringent) {
                return true;
            }

            // If we're coming from an in-scope typecheck, lambdas may not have had function signatures created for them
            // REVIEW: Should we search out the overload group here?
            if (!funcDecl.signature) {
                this.createFunctionSignature(funcDecl, this.typeFlow.scope.container, this.typeFlow.scope, null, null);
                this.typeFlow.typeCheck(funcDecl);
            }

            var signature = funcDecl.signature;
            var paramLen = signature.parameters.length;

            // Check that the argument declarations have no type annotations
            for (var i = 0; i < paramLen; i++) {
                var param = signature.parameters[i];
                var symbol = <ParameterSymbol>param;
                var argDecl = <ArgDecl>symbol.declAST;

                // REVIEW: a valid typeExpr is a requirement for varargs,
                // so we may want to revise our invariant
                if (beStringent && argDecl.typeExpr) {
                    return false;
                }
            }

            if (candidateType.construct && candidateType.call) {
                return false;
            }

            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;

            if (!candidateSigs || candidateSigs.signatures.length > 1) {
                return false;
            }

            // if we're here, the contextual type can be applied to the function
            return true;
        }

        public canContextuallyTypeObjectLiteral(targetType: Type, objectLit: UnaryExpression): bool {

            if (targetType == this.typeFlow.objectInterfaceType) {
                return true;
            }

            var memberDecls = <ASTList>objectLit.operand;

            if (!(memberDecls && targetType.memberScope)) {
                return false;
            }

            var id: AST = null;
            var targetMember: Symbol = null;
            var text = "";
            var foundSyms = {};

            // Check that each property in the object literal is present in the target
            // type
            for (var i = 0; i < memberDecls.members.length; i++) {
                id = (<BinaryExpression>memberDecls.members[i]).operand1;

                if (id.nodeType == NodeType.Name) {
                    text = (<Identifier>id).text;
                }
                else if (id.nodeType == NodeType.QString) {
                    // TODO: set text to unescaped string
                    var idText = (<StringLiteral>id).text;
                    text = idText.substring(1, idText.length - 1);
                }
                else {
                    return false;
                }

                targetMember = targetType.memberScope.find(text, true, false);

                if (!targetMember) {
                    return false;
                }

                foundSyms[text] = true;
            }

            // Check that all members in the target type are present in the object literal
            var targetMembers = targetType.memberScope.getAllValueSymbolNames(true);

            for (var i = 0; i < targetMembers.length; i++) {
                var memberName = targetMembers[i];
                var memberSym = targetType.memberScope.find(memberName, true, false);

                if (!foundSyms[targetMembers[i]] &&
                    !hasFlag(memberSym.flags, SymbolFlags.Optional)) {
                    return false;
                }
            }

            return true;
        }

        public widenType(t: Type) {
            if (t == this.undefinedType || t == this.nullType) { // REVIEW: not isNullOrUndefinedType for perf reasons
                return this.anyType;
            }

            return t;
        }

        public isNullOrUndefinedType(t: Type) {
            return t == this.undefinedType || t == this.nullType;
        }

        public findBestCommonType(initialType: Type, targetType: Type, collection: ITypeCollection, acceptVoid:bool, comparisonInfo?: TypeComparisonInfo) {
            var i = 0;
            var len = collection.getLength();
            var nlastChecked = 0;
            var bestCommonType = initialType;

            if (targetType) {
                bestCommonType = bestCommonType ? bestCommonType.mergeOrdered(targetType, this, acceptVoid) : targetType;
            }

            // it's important that we set the convergence type here, and not in the loop,
            // since the first element considered may be the contextual type
            var convergenceType: Type = bestCommonType;

            while (nlastChecked < len) {

                for (i = 0; i < len; i++) {

                    // no use in comparing a type against itself
                    if (i == nlastChecked) {
                        continue;
                    }

                    if (convergenceType && (bestCommonType = convergenceType.mergeOrdered(collection.getTypeAtIndex(i), this, acceptVoid, comparisonInfo))) {
                        convergenceType = bestCommonType;
                    }

                    if (bestCommonType == this.anyType || bestCommonType == null) {
                        break;
                    }
                    else if (targetType) { // set the element type to the target type
                        collection.setTypeAtIndex(i, targetType);
                    }
                }

                // use the type if we've agreed upon it
                if (convergenceType && bestCommonType) {
                    break;
                }

                nlastChecked++;
                if (nlastChecked < len) {
                    convergenceType = collection.getTypeAtIndex(nlastChecked);
                }
            }

            return acceptVoid ? bestCommonType : (bestCommonType == this.voidType ? null : bestCommonType);
        }

        // Type Identity

        public typesAreIdentical(t1: Type, t2: Type) {

            // This clause will cover both primitive types (since the type objects are shared),
            // as well as shared brands
            if (t1 == t2) {
                return true;
            }

            if (!t1 || !t2) {
                return false;
            }

            if (t1.isClass() || t1.isClassInstance()) {
                return false;
            }

            var comboId = (t2.typeID << 16) | t1.typeID;

            if (this.identicalCache[comboId]) {
                return true;
            }

            // If one is an enum, and they're not the same type, they're not identical
            if ((t1.typeFlags & TypeFlags.IsEnum) || (t2.typeFlags & TypeFlags.IsEnum)) {
                return false;
            }

            if (t1.isArray() || t2.isArray()) {
                if (!(t1.isArray() && t2.isArray())) {
                    return false;
                }
                this.identicalCache[comboId] = false;
                var ret = this.typesAreIdentical(t1.elementType, t2.elementType);
                if (ret) {
                    this.subtypeCache[comboId] = true;
                }
                else {
                    this.subtypeCache[comboId] = undefined;
                }

                return ret;
            }

            if (t1.primitiveTypeClass != t2.primitiveTypeClass) {
                return false;
            }

            this.identicalCache[comboId] = false;

            // properties are identical in name, optionality, and type
            // REVIEW: TypeChanges - The compiler does not currently check against the members of parent types!
            // REVIEW: TypeChanges - What about ambientMembers?
            if (t1.memberScope && t2.memberScope) {
                var t1MemberKeys = t1.memberScope.getAllValueSymbolNames(true).sort();
                var t2MemberKeys = t2.memberScope.getAllValueSymbolNames(true).sort();

                if (t1MemberKeys.length != t2MemberKeys.length) {
                    this.identicalCache[comboId] = undefined;
                    return false;
                }

                var t1MemberSymbol: Symbol = null;
                var t2MemberSymbol: Symbol = null;

                var t1MemberType: Type = null;
                var t2MemberType: Type = null;

                for (var iMember = 0; iMember < t1MemberKeys.length; iMember++) {
                    if (t1MemberKeys[iMember] != t2MemberKeys[iMember]) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }

                    t1MemberSymbol = <Symbol>t1.memberScope.find(t1MemberKeys[iMember], false, false);
                    t2MemberSymbol = <Symbol>t2.memberScope.find(t2MemberKeys[iMember], false, false);

                    if ((t1MemberSymbol.flags & SymbolFlags.Optional) != (t2MemberSymbol.flags & SymbolFlags.Optional)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }

                    t1MemberType = t1MemberSymbol.getType();
                    t2MemberType = t2MemberSymbol.getType();

                    // catch the mutually recursive or cached cases
                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.typeID << 16) | t1MemberType.typeID] != undefined)) {
                        continue;
                    }

                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                }
            }
            else if (t1.memberScope || t2.memberScope) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1.call, t2.call)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1.construct, t2.construct)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1.index, t2.index)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            this.identicalCache[comboId] = true;
            return true;
        }

        public signatureGroupsAreIdentical(sg1: SignatureGroup, sg2: SignatureGroup) {

            // covers the null case
            if (sg1 == sg2) {
                return true;
            }

            // covers the mixed-null case
            if (!sg1 || !sg2) {
                return false;
            }

            if (sg1.signatures.length != sg2.signatures.length) {
                return false;
            }

            var sig1: Signature = null;
            var sig2: Signature = null;
            var sigsMatch = false;

            // The signatures in the signature group may not be ordered...
            // REVIEW: Should definition signatures be required to be identical as well?
            for (var iSig1 = 0; iSig1 < sg1.signatures.length; iSig1++) {
                sig1 = sg1.signatures[iSig1];

                for (var iSig2 = 0; iSig2 < sg2.signatures.length; iSig2++) {
                    sig2 = sg2.signatures[iSig2];

                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }

                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }

                // no match found for a specific signature
                return false;
            }

            return true;
        }

        public signaturesAreIdentical(s1: Signature, s2: Signature) {

            if (s1.hasVariableArgList != s2.hasVariableArgList) {
                return false;
            }

            if (s1.nonOptionalParameterCount != s2.nonOptionalParameterCount) {
                return false;
            }

            if (s1.parameters.length != s2.parameters.length) {
                return false;
            }

            if (!this.typesAreIdentical(s1.returnType.type, s2.returnType.type)) {
                return false;
            }

            for (var iParam = 0; iParam < s1.parameters.length; iParam++) {
                if (!this.typesAreIdentical(s1.parameters[iParam].parameter.typeLink.type, s2.parameters[iParam].parameter.typeLink.type)) {
                    return false;
                }
            }

            return true;
        }

        // Subtyping and Assignment compatibility

        public sourceIsSubtypeOfTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, comparisonInfo); }
        public signatureGroupIsSubtypeOfTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, comparisonInfo); }
        public signatureIsSubtypeOfTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, comparisonInfo); }

        public sourceIsAssignableToTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, comparisonInfo); }
        public signatureGroupIsAssignableToTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, comparisonInfo); }
        public signatureIsAssignableToTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, comparisonInfo); }

        public sourceIsRelatableToTarget(source: Type, target: Type, assignableTo: bool, comparisonCache: any, comparisonInfo: TypeComparisonInfo) {

            // REVIEW: Does this check even matter?
            //if (this.typesAreIdentical(source, target)) {
            //    return true;
            //}
            if (source == target) {
                return true;
            }

            // An error has already been reported in this case
            if (!(source && target)) {
                return true;
            }

            var comboId = (source.typeID << 16) | target.typeID;

            // In the case of a 'false', we want to short-circuit a recursive typecheck
            if (comparisonCache[comboId] != undefined) {
                return true;
            }

            // this is one difference between subtyping and assignment compatibility
            if (assignableTo) {
                if (source == this.anyType || target == this.anyType) {
                    return true;
                }
            }
            else {
                // This is one difference between assignment compatibility and subtyping
                if (target == this.anyType) {
                    return true;
                }
            }

            if (source == this.undefinedType) {
                return true;
            }

            if ((source == this.nullType) && (target != this.undefinedType && target != this.voidType)) {
                return true;
            }

            // REVIEW: enum types aren't explicitly covered in the spec
            if (target == this.numberType && (source.typeFlags & TypeFlags.IsEnum)) {
                return true;
            }
            if (source == this.numberType && (target.typeFlags & TypeFlags.IsEnum)) {
                return true;
            }
            if ((source.typeFlags & TypeFlags.IsEnum) || (target.typeFlags & TypeFlags.IsEnum)) {
                return false;
            }

            if (source.isArray() || target.isArray()) {
                if (!(source.isArray() && target.isArray())) {
                    return false;
                }
                comparisonCache[comboId] = false;
                var ret = this.sourceIsRelatableToTarget(source.elementType, target.elementType, assignableTo, comparisonCache, comparisonInfo);
                if (ret) {
                    comparisonCache[comboId] = true;
                }
                else {
                    comparisonCache[comboId] = undefined;
                }

                return ret;
            }

            // this check ensures that we only operate on object types from this point forward,
            // since the checks involving primitives occurred above
            if (source.primitiveTypeClass != target.primitiveTypeClass) {

                if (target.primitiveTypeClass == Primitive.None) {
                    if (source == this.numberType && this.typeFlow.numberInterfaceType) {
                        source = this.typeFlow.numberInterfaceType;
                    }
                    else if (source == this.stringType && this.typeFlow.stringInterfaceType) {
                        source = this.typeFlow.stringInterfaceType;
                    }
                    else if (source == this.booleanType && this.typeFlow.booleanInterfaceType) {
                        source = this.typeFlow.booleanInterfaceType;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }

            comparisonCache[comboId] = false;

            if (source.hasBase(target)) {
                comparisonCache[comboId] = true;
                return true;
            }

            if (this.typeFlow.objectInterfaceType && target == this.typeFlow.objectInterfaceType) {
                return true;
            }

            if (this.typeFlow.functionInterfaceType && (source.call || source.construct) && target == this.typeFlow.functionInterfaceType) {
                return true;
            }

            // REVIEW: We should perhaps do this, though it wouldn't be quite right without generics support
            //if (this.typeFlow.arrayInterfaceType && (source.index) && target == this.typeFlow.arrayInterfaceType) {
            //    return true;
            //}

            // At this point, if the target is a class, but not the source or a parent of the source, bail
            if (target.isClass() || target.isClassInstance()) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (target.memberScope && source.memberScope) {
                var mPropKeys = target.memberScope.getAllValueSymbolNames(true);
                var mProp: Symbol = null;
                var nProp: Symbol = null;
                var mPropType: Type = null;
                var nPropType: Type = null;
                var inferenceSymbol: InferenceSymbol = null;

                for (var iMProp = 0; iMProp < mPropKeys.length; iMProp++) {
                    mProp = target.memberScope.find(mPropKeys[iMProp], false, false);
                    nProp = source.memberScope.find(mPropKeys[iMProp], false, false);

                    // methods do not have the "arguments" field
                    if (mProp.name == "arguments" &&
                        this.typeFlow.iargumentsInterfaceType &&
                        (this.typeFlow.iargumentsInterfaceType.symbol.flags & SymbolFlags.CompilerGenerated) &&
                        mProp.kind() == SymbolKind.Variable &&
                        (<VariableSymbol>mProp).variable.typeLink.type == this.typeFlow.iargumentsInterfaceType) {
                        continue;
                    }

                    if (mProp.isInferenceSymbol()) {
                        inferenceSymbol = <InferenceSymbol>mProp;
                        if (inferenceSymbol.typeCheckStatus == TypeCheckStatus.NotStarted) {
                            // REVIEW: TypeChanges: Does this ever really happen?  Maybe for out-of-order typecheck?
                            this.typeFlow.typeCheck(mProp.declAST);
                        }
                    }
                    mPropType = mProp.getType();

                    if (!nProp) {
                        // If it's not present on the type in question, look for the property on 'Object'
                        if (this.typeFlow.objectInterfaceType) {
                            nProp = this.typeFlow.objectInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);
                        }

                        if (!nProp) {
                            // Now, the property was not found on Object, but the type in question is a function, look
                            // for it on function
                            if (this.typeFlow.functionInterfaceType && (mPropType.call || mPropType.construct)) {
                                nProp = this.typeFlow.functionInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);
                            }

                            // finally, check to see if the property is optional
                            if (!nProp) {
                                if (!(mProp.flags & SymbolFlags.Optional)) {
                                    comparisonCache[comboId] = undefined;
                                    if (comparisonInfo) { // only surface the first error
                                        comparisonInfo.flags |= TypeRelationshipFlags.RequiredPropertyIsMissing;
                                        comparisonInfo.addMessageToFront("Type '" + source.getTypeName() + "' is missing property '" + mPropKeys[iMProp] + "' from type '" + target.getTypeName() + "'");
                                    }
                                    return false;
                                }
                                else {
                                    continue;
                                }
                            }
                        }
                    }

                    if (nProp.isInferenceSymbol()) {
                        inferenceSymbol = <InferenceSymbol>nProp;
                        if (inferenceSymbol.typeCheckStatus == TypeCheckStatus.NotStarted) {
                            this.typeFlow.typeCheck(nProp.declAST);
                        }
                    }


                    nPropType = nProp.getType();

                    // catch the mutually recursive or cached cases
                    if (mPropType && nPropType && (comparisonCache[(nPropType.typeID << 16) | mPropType.typeID] != undefined)) {
                        continue;
                    }

                    if (!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, comparisonInfo)) {
                        comparisonCache[comboId] = undefined;
                        if (comparisonInfo) { // only surface the first error
                            comparisonInfo.flags |= TypeRelationshipFlags.IncompatiblePropertyTypes;
                            comparisonInfo.addMessageToFront("Types of property '" + mProp.name + "' of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        }
                        return false;
                    }
                }
            }

            // check signature groups
            if (source.call || target.call) {
                if (!this.signatureGroupIsRelatableToTarget(source.call, target.call, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (source.call && target.call) {
                            comparisonInfo.addMessageToFront("Call signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        }
                        else {
                            var hasSig = target.call ? target.getTypeName() : source.getTypeName();
                            var lacksSig = !target.call ? target.getTypeName() : source.getTypeName();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a call signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            if (source.construct || target.construct) {
                if (!this.signatureGroupIsRelatableToTarget(source.construct, target.construct, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (source.construct && target.construct) {
                            comparisonInfo.addMessageToFront("Construct signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        }
                        else {
                            var hasSig = target.construct ? target.getTypeName() : source.getTypeName();
                            var lacksSig = !target.construct ? target.getTypeName() : source.getTypeName();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a construct signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            if (target.index) {
                var targetIndex = !target.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : target.index;
                var sourceIndex = !source.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : source.index;

                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.addMessageToFront("Index signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            comparisonCache[comboId] = true;
            return true;
        }

        // REVIEW: TypeChanges: Return an error context object so the user can get better diagnostic info
        public signatureGroupIsRelatableToTarget(sourceSG: SignatureGroup, targetSG: SignatureGroup, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {
            if (sourceSG == targetSG) {
                return true;
            }

            if (!(sourceSG && targetSG)) {
                return false;
            }

            var mSig: Signature = null;
            var nSig: Signature = null;
            var foundMatch = false;

            for (var iMSig = 0; iMSig < targetSG.signatures.length; iMSig++) {
                mSig = targetSG.signatures[iMSig];

                for (var iNSig = 0; iNSig < sourceSG.signatures.length; iNSig++) {
                    nSig = sourceSG.signatures[iNSig];
                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, comparisonInfo)) {
                        foundMatch = true;
                        break;
                    }
                }

                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }

            return true;
        }

        public signatureIsRelatableToTarget(sourceSig: Signature, targetSig: Signature, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {

            if (!sourceSig.parameters || !targetSig.parameters) {
                return false;
            }

            var targetVarArgCount = targetSig.hasVariableArgList ? targetSig.nonOptionalParameterCount - 1 : targetSig.nonOptionalParameterCount;
            var sourceVarArgCount = sourceSig.hasVariableArgList ? sourceSig.nonOptionalParameterCount - 1 : sourceSig.nonOptionalParameterCount;

            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableArgList) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= TypeRelationshipFlags.SourceSignatureHasTooManyParameters;
                    comparisonInfo.addMessageToFront("Call signature expects " + targetVarArgCount + " or fewer parameters");
                }
                return false;
            }

            var sourceReturnType = sourceSig.returnType.type;
            var targetReturnType = targetSig.returnType.type;

            if (targetReturnType != this.voidType) {
                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleReturnTypes;
                        // No need to print this one here - it's printed as part of the signature error in sourceIsRelatableToTarget
                        //comparisonInfo.addMessageToFront("Incompatible return types: '" + sourceReturnType.getTypeName() + "' and '" + targetReturnType.getTypeName() + "'");
                    }
                    return false;
                }
            }

            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableArgList) ? targetVarArgCount : sourceVarArgCount;
            var sourceParamType: Type = null;
            var targetParamType: Type = null;
            var sourceParamName = "";
            var targetParamName = "";

            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {

                if (!sourceSig.hasVariableArgList || iSource < sourceVarArgCount) {
                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;
                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;
                }
                else if (iSource == sourceVarArgCount) {
                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;
                    if (sourceParamType.elementType) {
                        sourceParamType = sourceParamType.elementType;
                    }
                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;
                }

                if (iTarget < targetSig.parameters.length && iTarget < targetVarArgCount) {
                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;
                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;
                }
                else if (targetSig.hasVariableArgList && iTarget == targetVarArgCount) {
                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;
                    if (targetParamType.elementType) {
                        targetParamType = targetParamType.elementType;
                    }
                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;
                }

                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, comparisonInfo) ||
                        this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, comparisonInfo))) {

                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleParameterTypes;
                    }
                    return false;
                }
            }
            return true;
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class Continuation {
        public exceptionBlock = -1;
        constructor (public normalBlock: number) { }
    }

    function getBaseTypeLinks(bases: ASTList, baseTypeLinks: TypeLink[]) {
        if (bases) {
            var len = bases.members.length;
            if (baseTypeLinks == null) {
                baseTypeLinks = new TypeLink[];
            }
            for (var i = 0; i < len; i++) {
                var baseExpr = bases.members[i];
                var name = baseExpr;
                var typeLink = new TypeLink();
                typeLink.ast = name;
                baseTypeLinks[baseTypeLinks.length] = typeLink;
            }
        }
        return baseTypeLinks;
    }

    function getBases(type: Type, typeDecl: TypeDeclaration) {
        type.extendsTypeLinks = getBaseTypeLinks(typeDecl.extendsList, type.extendsTypeLinks);
        type.implementsTypeLinks = getBaseTypeLinks(typeDecl.implementsList, type.implementsTypeLinks);
    }

    function addPrototypeField(classType: Type, ast: AST, context: TypeCollectionContext) {
        var field = new ValueLocation();
        field.typeLink = new TypeLink();
        field.typeLink.ast = ast;
        field.typeLink.type = classType.instanceType;

        var fieldSymbol =
            new FieldSymbol("prototype", ast.minChar,
                            context.checker.locationInfo.unitIndex, true, field);
        fieldSymbol.flags |= (SymbolFlags.Property | SymbolFlags.BuiltIn);
        field.symbol = fieldSymbol;
        fieldSymbol.declAST = ast;
        classType.members.addPublicMember("prototype", fieldSymbol);
    }

    export function createNewConstructGroupForType(type: Type) {
        var signature = new Signature();
        signature.returnType = new TypeLink();
        signature.returnType.type = type.instanceType;
        signature.parameters = [];

        type.construct = new SignatureGroup();
        type.construct.addSignature(signature);     
    }

    export function cloneParentConstructGroupForChildType(child: Type, parent: Type) {
        child.construct = new SignatureGroup();
        var sig: Signature = null;

        if (!parent.construct) {
            createNewConstructGroupForType(parent);
        }

        for (var i = 0; i < parent.construct.signatures.length; i++) { 
            sig = new Signature();
            sig.parameters = parent.construct.signatures[i].parameters;
            sig.nonOptionalParameterCount = parent.construct.signatures[i].nonOptionalParameterCount;
            sig.typeCheckStatus = parent.construct.signatures[i].typeCheckStatus;
            sig.declAST = parent.construct.signatures[i].declAST;
            sig.returnType = new TypeLink();
            sig.returnType.type = child.instanceType;
            child.construct.addSignature(sig);
        }

    }

    export var globalId = "__GLO";

    export interface IAliasScopeContext {
        topLevelScope: ScopeChain;
        members: IHashTable;
        tcContext: TypeCollectionContext;
    }

    function findTypeSymbolInScopeChain(name: string, scopeChain: ScopeChain): Symbol {
        var symbol = scopeChain.scope.find(name, false, true);

        if (symbol == null && scopeChain.previous) {
            symbol = findTypeSymbolInScopeChain(name, scopeChain.previous);
        }

        return symbol;
    }

    function findSymbolFromAlias(alias: AST, context: IAliasScopeContext): Symbol {
        var symbol: Symbol = null;
        switch (alias.nodeType) {
            case NodeType.Name:
                var name = (<Identifier>alias).text;
                var isDynamic = isQuoted(name);

                var findSym = (id: string) => {
                    if (context.members) {
                        return context.members.lookup(name);
                    }
                    else {
                        return findTypeSymbolInScopeChain(name, context.topLevelScope);
                    }
                }

                if (isDynamic) {
                    symbol = context.tcContext.checker.findSymbolForDynamicModule(name, context.tcContext.script.locationInfo.filename, findSym);
                }
                else {
                    symbol = findSym(name);
                }

                break;

            case NodeType.Dot:
                var dottedExpr = <BinaryExpression>alias;
                var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context);

                if (op1Sym && op1Sym.getType()) {
                    symbol = findSymbolFromAlias(dottedExpr.operand2, context);
                }

                break;

            default:
                break;
        }

        if (symbol) {
            var symType = symbol.getType();
            if (symType) {
                var members = symType.members;
                if (members) {
                    context.members = members.publicMembers;
                }
            }
        }

        return symbol;
    }

    export function preCollectImportTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;
        var typeSymbol: TypeSymbol = null;
        var modType: ModuleType = null;
        var importDecl = <ImportDeclaration>ast;

        // REVIEW: technically, this call isn't strictly necessary, since we'll find the type during the call to resolveTypeMembers
        var aliasedModSymbol = findSymbolFromAlias(importDecl.alias, { topLevelScope: scopeChain, members: null, tcContext: context });
        var isGlobal = context.scopeChain.container == context.checker.gloMod;

        if (aliasedModSymbol) {
            var aliasedModType = aliasedModSymbol.getType();

            if (aliasedModType) {
                modType = <ModuleType>aliasedModType;
            }
        }

        typeSymbol = new TypeSymbol(importDecl.id.text, importDecl.id.minChar, importDecl.limChar - importDecl.minChar,
                                    context.checker.locationInfo.unitIndex, modType);

        typeSymbol.aliasLink = importDecl;

        if (context.scopeChain.moduleDecl) {
            typeSymbol.flags |= SymbolFlags.ModuleMember;
            typeSymbol.declModule = context.scopeChain.moduleDecl;
        }

        typeSymbol.declAST = importDecl;
        importDecl.id.sym = typeSymbol;
        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,
                                context.checker.errorReporter, isGlobal, true, false);
        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,
                                context.checker.errorReporter, isGlobal, false, false);
        return true;
    }

    export function preCollectModuleTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;

        var moduleDecl: ModuleDeclaration = <ModuleDeclaration>ast;

        var isAmbient = hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient);
        var isEnum = hasFlag(moduleDecl.modFlags, ModuleFlags.IsEnum);
        var isGlobal = context.scopeChain.container == context.checker.gloMod;
        var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);
        var modName = (<Identifier>moduleDecl.name).text;

        var isDynamic = isQuoted(modName);

        var symbol = scopeChain.scope.findLocal(modName, false, false);
        var typeSymbol: TypeSymbol = null;
        var modType: ModuleType = null;

        if (symbol && symbol.declAST && symbol.declAST.nodeType != NodeType.ModuleDeclaration) {
            context.checker.errorReporter.simpleError(moduleDecl, "Conflicting symbol name for module '" + modName + "'");
            // Create a new type symbol for the module but keep it anonyms
            symbol = null;
            modName = "";
        }

        if ((symbol == null) || (symbol.kind() != SymbolKind.Type)) {

            if (modType == null) {
                var enclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);
                if (isEnum) {
                    modType.typeFlags |= TypeFlags.IsEnum;
                }
                modType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                modType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                modType.setHasImplementation();
            }

            typeSymbol = new TypeSymbol(modName, moduleDecl.name.minChar, modName.length,
                                        context.checker.locationInfo.unitIndex, modType);
            typeSymbol.isDynamic = isQuoted(moduleDecl.prettyName);

            if (context.scopeChain.moduleDecl) {
                typeSymbol.declModule = context.scopeChain.moduleDecl;
            }
            typeSymbol.declAST = moduleDecl;
            typeSymbol.prettyName = moduleDecl.prettyName;
            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,
                                    context.checker.errorReporter, isExported || isGlobal, true, isAmbient);
            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,
                                    context.checker.errorReporter, isExported || isGlobal, false, isAmbient);
            modType.symbol = typeSymbol;
        }
        else {
            typeSymbol = <TypeSymbol>symbol;

            // initialize new private scope for the type
            var publicEnclosedTypes = typeSymbol.type.getAllEnclosedTypes().publicMembers;
            var publicEnclosedTypesTable = (publicEnclosedTypes == null) ? new StringHashTable() : publicEnclosedTypes;
            var enclosedTypes = new ScopedMembers(new DualStringHashTable(publicEnclosedTypesTable, new StringHashTable()));

            var publicEnclosedAmbientTypes = typeSymbol.type.getAllAmbientEnclosedTypes().publicMembers;
            var publicAmbientEnclosedTypesTable = (publicEnclosedAmbientTypes == null) ? new StringHashTable() : publicEnclosedAmbientTypes;
            var ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(publicAmbientEnclosedTypesTable, new StringHashTable()));

            var publicMembers = typeSymbol.type.members.publicMembers;
            var publicMembersTable = (publicMembers == null) ? new StringHashTable() : publicMembers;
            var members = new ScopedMembers(new DualStringHashTable(publicMembersTable, new StringHashTable()));

            var publicAmbientMembers = typeSymbol.type.ambientMembers.publicMembers;
            var publicAmbientMembersTable = (publicAmbientMembers == null) ? new StringHashTable() : publicAmbientMembers;
            var ambientMembers = new ScopedMembers(new DualStringHashTable(publicAmbientMembersTable, new StringHashTable()));

            modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);
            if (isEnum) {
                modType.typeFlags |= TypeFlags.IsEnum;
            }
            modType.members = members;
            modType.ambientMembers = ambientMembers;
            modType.setHasImplementation();
            modType.symbol = typeSymbol;

            typeSymbol.addLocation(moduleDecl.minChar);
            typeSymbol.expansions.push(modType);
            typeSymbol.expansionsDeclAST.push(moduleDecl);

        }
        if (context.scopeChain.moduleDecl) {
            context.scopeChain.moduleDecl.recordNonInterface();
        }
        // REVIEW: If multiple disparate module decls for the same module don't agree
        // in export privileges, how should we handle it?
        if (isExported) {
            typeSymbol.flags |= SymbolFlags.Exported;
        }
        if ((context.scopeChain.moduleDecl) ||
            (context.scopeChain.container == context.checker.gloMod)) {
            typeSymbol.flags |= SymbolFlags.ModuleMember;
        }

        moduleDecl.mod = modType;
        pushTypeCollectionScope(typeSymbol, modType.members,
                                modType.ambientMembers,
                                modType.enclosedTypes,
                                modType.ambientEnclosedTypes,
                                context, null, null, moduleDecl);

        return true;
    }

    export function preCollectClassTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;
        var classDecl = <ClassDeclaration>ast;

        var classType: Type;
        var instanceType: Type;
        var typeSymbol: TypeSymbol = null;
        var className = (<Identifier>classDecl.name).text;
        var alreadyInScope = false;
        var isAmbient = hasFlag(classDecl.varFlags, VarFlags.Ambient);
        var isExported = hasFlag(classDecl.varFlags, VarFlags.Exported);
        var isGlobal = context.scopeChain.container == context.checker.gloMod;
        var containerMod = <TypeSymbol>scopeChain.container;
        var foundValSymbol = false;

        typeSymbol = <TypeSymbol>scopeChain.scope.findLocal(className, false, true);
        
        // check the value space, since an override may have been declared with the type's name
        // REVIEW-CLASSES
        if (!typeSymbol) {
            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false);
            
            if (valTypeSymbol &&
                valTypeSymbol.isType() &&
                valTypeSymbol.declAST &&
                valTypeSymbol.declAST.nodeType == NodeType.FuncDecl &&
                (<FuncDecl>valTypeSymbol.declAST).isSignature()) {
                
                typeSymbol = <TypeSymbol>valTypeSymbol;
                foundValSymbol = true;
                
                if (isExported) {
                    typeSymbol.flags |= SymbolFlags.Exported;
                }
            
                if (isAmbient) {
                    typeSymbol.flags |= SymbolFlags.Ambient;
                }                
                
                // the class was never entered into type space, so add it
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,
                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);                
            }
        }
        
        if (typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl)) {
            typeSymbol = null;
        }

        if (typeSymbol == null) {
            var valueSymbol = scopeChain.scope.findLocal(className, false, false);
            classType = new Type();
            classType.setHasImplementation();
            instanceType = new Type();
            instanceType.setHasImplementation();
            classType.instanceType = instanceType;
            classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            addPrototypeField(classType, classDecl, context);
            instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            instanceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            typeSymbol = new TypeSymbol(className, classDecl.name.minChar, className.length,
                                        context.checker.locationInfo.unitIndex, classType);
            typeSymbol.declAST = classDecl;
            typeSymbol.instanceType = instanceType;
            classType.symbol = typeSymbol;
            instanceType.symbol = typeSymbol;

            if (context.scopeChain.moduleDecl) {
                context.scopeChain.moduleDecl.recordNonInterface();
                typeSymbol.declModule = context.scopeChain.moduleDecl;
                typeSymbol.flags |= SymbolFlags.ModuleMember;
            }

            if (isExported) {
                typeSymbol.flags |= SymbolFlags.Exported;
            }
            
            if (isAmbient) {
                typeSymbol.flags |= SymbolFlags.Ambient;
            }

            ast.type = classType;

            // class in both name spaces (type for instance type; constructor representative in value space)
            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,
                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);

            if (valueSymbol == null) {
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,
                                            context.checker.errorReporter, isExported || isGlobal, false, isAmbient);
            }
        }
        else {                            
            classType = typeSymbol.type;
            
            // If the instance type is null, a call overload was likely declared before the class constructor
            if (classType.instanceType == null) {
                classType.instanceType = new Type();
                classType.instanceType.setHasImplementation();
                classType.instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                classType.instanceType.symbol = classType.symbol;
                classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            }
            
            instanceType = classType.instanceType;
            ast.type = classType;
        }
        
        // if the class has no declared constructor, either create a default signature or adapt 
        // it's base class's signature group
        if (!classDecl.constructorDecl) {

            if (typeSymbol && typeSymbol.declAST && typeSymbol.declAST.type && typeSymbol.declAST.type.call && !(<FuncDecl>typeSymbol.declAST).isOverload) {
                context.checker.errorReporter.duplicateIdentifier(typeSymbol.declAST, typeSymbol.name);
            }

            createNewConstructGroupForType(classDecl.type);
        }

        classType.typeFlags |= TypeFlags.IsClass;
        instanceType.typeFlags |= TypeFlags.IsClass;

        getBases(instanceType, classDecl);
        pushTypeCollectionScope(typeSymbol, instanceType.members, instanceType.ambientMembers, null, null,
                                context, instanceType, classType, null);
        return true;
    }

    export function preCollectInterfaceTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;
        var interfaceDecl = <InterfaceDeclaration>ast;
        var interfaceSymbol: TypeSymbol = null;
        var interfaceType: Type = null;
        var isExported = hasFlag(interfaceDecl.varFlags, VarFlags.Exported);
        var isGlobal = context.scopeChain.container == context.checker.gloMod;
        var alreadyInScope = true;

        alreadyInScope = false;
        var interfaceName = (<Identifier>interfaceDecl.name).text;
        interfaceSymbol = <TypeSymbol>scopeChain.scope.findLocal(interfaceName, false, true);
        if (interfaceSymbol == null) {
            interfaceType = new Type();
            interfaceSymbol = new TypeSymbol(interfaceName,
                                        interfaceDecl.name.minChar,
                                        interfaceName.length,
                                        context.checker.locationInfo.unitIndex,
                                        interfaceType);
            interfaceType.symbol = interfaceSymbol;
            // REVIEW: Shouldn't allocate another table for interface privates
            interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            interfaceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            interfaceSymbol.declAST = interfaceDecl;
            interfaceSymbol.declModule = context.scopeChain.moduleDecl;
        }
        else {
            alreadyInScope = true;
            interfaceType = interfaceSymbol.type;
        }

        if (!interfaceType) {
            interfaceType = context.checker.anyType;
        }

        ast.type = interfaceType;
        getBases(interfaceType, interfaceDecl);

        if (isExported) {
            interfaceSymbol.flags |= SymbolFlags.Exported;
        }

        if (context.scopeChain.moduleDecl) {
            interfaceSymbol.flags |= SymbolFlags.ModuleMember;
        }

        if (!alreadyInScope) {
            context.scopeChain.scope.enter(context.scopeChain.container, ast,
                                            interfaceSymbol, context.checker.errorReporter, isGlobal || isExported, true, false); // REVIEW: Technically, interfaces should be ambient
        }
        pushTypeCollectionScope(interfaceSymbol, interfaceType.members, interfaceType.ambientMembers, null, null,
                                context, interfaceType, null, null);
        return true;
    }

    export function preCollectArgDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;
        var argDecl = <ArgDecl>ast;
        if (hasFlag(argDecl.varFlags, VarFlags.Public | VarFlags.Private)) {
            var field = new ValueLocation();
            var isPrivate = hasFlag(argDecl.varFlags, VarFlags.Private);
            var fieldSymbol =
                new FieldSymbol(argDecl.id.text, argDecl.id.minChar,
                                context.checker.locationInfo.unitIndex,
                                !hasFlag(argDecl.varFlags, VarFlags.Readonly),
                                field);
            fieldSymbol.transferVarFlags(argDecl.varFlags);
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = ast;
            argDecl.parameterPropertySym = fieldSymbol;

            context.scopeChain.scope.enter(context.scopeChain.container, ast,
                                            fieldSymbol, context.checker.errorReporter, !isPrivate, false, false);

            field.typeLink = getTypeLink(argDecl.typeExpr, context.checker, argDecl.init == null);
            argDecl.sym = fieldSymbol;
        }
        return false;
    }

    export function preCollectVarDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;
        var varDecl = <VarDecl>ast;
        var isAmbient = hasFlag(varDecl.varFlags, VarFlags.Ambient);
        var isExported = hasFlag(varDecl.varFlags, VarFlags.Exported);
        var isGlobal = context.scopeChain.container == context.checker.gloMod;
        var isProperty = hasFlag(varDecl.varFlags, VarFlags.Property);
        var isStatic = hasFlag(varDecl.varFlags, VarFlags.Static);
        var isPrivate = hasFlag(varDecl.varFlags, VarFlags.Private);
        var isOptional = hasFlag(varDecl.id.flags, ASTFlags.OptionalName);

        if (context.scopeChain.moduleDecl) {
            context.scopeChain.moduleDecl.recordNonInterface();
        }
        if (isProperty ||
            isExported ||
            (context.scopeChain.container == context.checker.gloMod) ||
            context.scopeChain.moduleDecl) {
            if (isAmbient) {
                var existingSym =
                    <FieldSymbol>scopeChain.scope.findLocal(varDecl.id.text, false, false);
                if (existingSym) {
                    varDecl.sym = existingSym;
                    return false;
                }
            }

            // Defensive error detection...
            if (varDecl.id == null) {
                context.checker.errorReporter.simpleError(varDecl, "Expected variable identifier at this location");
                return false;
            }

            var field = new ValueLocation();
            var fieldSymbol =
                new FieldSymbol(varDecl.id.text, varDecl.id.minChar,
                                context.checker.locationInfo.unitIndex,
                                (varDecl.varFlags & VarFlags.Readonly) == VarFlags.None,
                                field);
            fieldSymbol.transferVarFlags(varDecl.varFlags);
            if (isOptional) {
                fieldSymbol.flags |= SymbolFlags.Optional;
            }
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = ast;
            if ((context.scopeChain.moduleDecl) ||
                (context.scopeChain.container == context.checker.gloMod)) {
                fieldSymbol.flags |= SymbolFlags.ModuleMember;
                fieldSymbol.declModule = context.scopeChain.moduleDecl;
            }

            // if it's static, enter it into the class's member list directly
            if (hasFlag(varDecl.varFlags, VarFlags.Property) && isStatic && context.scopeChain.classType) {
                if (!context.scopeChain.classType.members.publicMembers.add(varDecl.id.text, fieldSymbol)) {
                    context.checker.errorReporter.duplicateIdentifier(ast, fieldSymbol.name);
                }
                fieldSymbol.container = context.scopeChain.classType.symbol;
            }
            else {
                context.scopeChain.scope.enter(context.scopeChain.container,
                                                ast,
                                                fieldSymbol,
                                                context.checker.errorReporter,
                                                !isPrivate && (isProperty || isExported || isGlobal || isStatic),
                                                false,
                                                isAmbient);
            }

            if (hasFlag(varDecl.varFlags, VarFlags.Exported)) {
                fieldSymbol.flags |= SymbolFlags.Exported;
            }

            field.typeLink = getTypeLink(varDecl.typeExpr, context.checker,
                                        varDecl.init == null);
            varDecl.sym = fieldSymbol;
        }
        return false;
    }

    export function preCollectFuncDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;

        // REVIEW: This will have to change when we move to "export"
        if (context.scopeChain.moduleDecl) {
            context.scopeChain.moduleDecl.recordNonInterface();
        }

        var funcDecl = <FuncDecl>ast;
        var fgSym: TypeSymbol = null;
        var nameText = funcDecl.getNameText();
        var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported);
        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);
        var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);
        var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;
        var containerSym:TypeSymbol = <TypeSymbol> (((funcDecl.isMethod() && isStatic) || funcDecl.isAccessor()) && context.scopeChain.classType ? context.scopeChain.classType.symbol : context.scopeChain.container);
        var containerScope: SymbolScope = context.scopeChain.scope;
        var isGlobal = containerSym == context.checker.gloMod;
        var isOptional = funcDecl.name && hasFlag(funcDecl.name.flags, ASTFlags.OptionalName);
        var go = false;
        var foundSymbol = false; 

        // If this is a class constructor, the "container" is actually the class declaration
        if (isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
            containerSym = <TypeSymbol>containerSym.container;
            containerScope = scopeChain.previous.scope;
        }

        funcDecl.unitIndex = context.checker.locationInfo.unitIndex;
        
        // If the parent is the constructor, and this isn't an instance method, skip it.
        // That way, we'll set the type during scope assignment, and can be sure that the
        // function will be placed in the constructor-local scope
        if (!funcDecl.isConstructor &&
            containerSym &&
            containerSym.declAST &&
            containerSym.declAST.nodeType == NodeType.FuncDecl &&
            (<FuncDecl>containerSym.declAST).isConstructor &&
            !funcDecl.isMethod()) {
            return go;
        }        

        // Interfaces and overloads
        if (hasFlag(funcDecl.fncFlags, FncFlags.Signature)) {
            var instType = context.scopeChain.thisType;                       

            // If the function is static, search in the class type's
            if (nameText && nameText != "__missing") {
                if (isStatic) {
                    fgSym = containerSym.type.members.allMembers.lookup(nameText);
                }
                else {
                    // REVIEW: This logic should be symmetric with preCollectClassTypes
                    fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);
                    
                    // If we could not find the function symbol in the value context, look
                    // in the type context.
                    // This would be the case, for example, if a class constructor override
                    // were declared before a call override for a given class
                    if (fgSym == null) {
                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, true);
                    }
                }
                
                if (fgSym) {
                    foundSymbol = true;
                    
                    // We'll combine ambient and non-ambient funcdecls during typecheck (for contextual typing).,
                    // So, if they don't agree, don't use the symbol we've found                    
                    if (!funcDecl.isSignature() && (hasFlag(funcDecl.fncFlags, FncFlags.Ambient) != hasFlag(fgSym.flags, SymbolFlags.Ambient))) {
                       fgSym = null;
                    }
                }                
            }
            
            // a function with this symbol has not yet been declared in this scope
            // REVIEW: In the code below, we need to ensure that only function overloads are considered
            //  (E.g., if a vardecl has the same id as a function or class, we may use the vardecl symbol
            //  as the overload.)  Defensively, however, the vardecl won't have a type yet, so it should
            //  suffice to just check for a null type when considering the overload symbol in
            //  createFunctionSignature
            if (fgSym == null) {
                if (!(funcDecl.isSpecialFn())) {                    
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, null, !foundSymbol).declAST.type.symbol;
                }
                else {
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, containerSym, false).declAST.type.symbol;                                                                         
                }
                
                // set the symbol's declAST, which will point back to the first declaration (symbol or otherwise)
                // related to this symbol
                if (fgSym.declAST == null || !funcDecl.isSpecialFn()) {
                    fgSym.declAST = ast;
                }
            }
            else { // there exists a symbol with this name
                
                if ((fgSym.kind() == SymbolKind.Type)) {

                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, false).declAST.type.symbol;
                }
                else {
                    context.checker.errorReporter.simpleError(funcDecl, "Function or method '" + funcDecl.name.actualText + "' already declared as a property");
                }
            }
         
            if (funcDecl.isSpecialFn() && !isStatic) {
                funcDecl.type = instType ? instType : fgSym.type; 
            }
            else {
                funcDecl.type = fgSym.type;
            }            
        }
        else {
            // declarations
            
            if (nameText) {
                if (isStatic) {
                    fgSym = containerSym.type.members.allMembers.lookup(nameText);
                }
                else {
                    // in the constructor case, we want to check the parent scope for overloads
                    if (funcDecl.isConstructor && context.scopeChain.previous) {
                        fgSym = <TypeSymbol>context.scopeChain.previous.scope.findLocal(nameText, false, false);
                    }
                    
                    if (fgSym == null) {
                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);
                    }
                }
                if (fgSym) {
                    foundSymbol = true;
                    
                    if (!isConstructor && fgSym.declAST.nodeType == NodeType.FuncDecl && !(<FuncDecl>fgSym.declAST).isAccessor() && !(<FuncDecl>fgSym.declAST).isSignature()) {
                        fgSym = null;
                        foundSymbol = false;
                    }
                }                
            }

            // REVIEW: Move this check into the typecheck phase?  It's only being run over properties...
            if (fgSym &&
                !fgSym.isAccessor() &&
                fgSym.type &&
                fgSym.type.construct &&
                fgSym.type.construct.signatures != [] &&
                (fgSym.type.construct.signatures[0].declAST == null ||
                    !hasFlag(fgSym.type.construct.signatures[0].declAST.fncFlags, FncFlags.Ambient)) &&
                !funcDecl.isConstructor) {
                context.checker.errorReporter.simpleError(funcDecl, "Functions may not have class overloads");
            }

            if (fgSym && !(fgSym.kind() == SymbolKind.Type) && funcDecl.isMethod() && !funcDecl.isAccessor() && !funcDecl.isConstructor) {
                context.checker.errorReporter.simpleError(funcDecl, "Function or method '" + funcDecl.name.actualText + "' already declared as a property");
                fgSym.type = context.checker.anyType;
            }
            // If the current function is accessor and the existing symbol isnt, set the symbol to null so
            // we could error about duplicate symbol
            if (fgSym && !fgSym.isAccessor() && funcDecl.isAccessor()) {
                fgSym = null;
            }
            var sig = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, !foundSymbol);

            // it's a getter or setter function                                   
            if (((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {
                funcDecl.accessorSymbol = context.checker.createAccessorSymbol(funcDecl, fgSym, containerSym.type, (funcDecl.isMethod() && isStatic), true, containerScope, containerSym);
            }

            funcDecl.type.symbol.declAST = ast;
            if (funcDecl.isConstructor) { // REVIEW: Remove when classes completely replace oldclass
                go = true;
            };
        }
        if (isExported) {
            if (funcDecl.type.call) {
                funcDecl.type.symbol.flags |= SymbolFlags.Exported;
            }
            
            // Accessors are set to 'exported' above
            if (fgSym && !fgSym.isAccessor() && fgSym.kind() == SymbolKind.Type && fgSym.type.call) {
                fgSym.flags |= SymbolFlags.Exported;
            }
        }
        if (context.scopeChain.moduleDecl && !funcDecl.isSpecialFn()) {
            funcDecl.type.symbol.flags |= SymbolFlags.ModuleMember;
            funcDecl.type.symbol.declModule = context.scopeChain.moduleDecl;
        }

        if (fgSym && isOptional) {
            fgSym.flags |= SymbolFlags.Optional;
        }

        return go;
    }

    export function preCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {
        var context: TypeCollectionContext = walker.state;
        var go = false;
        var scopeChain = context.scopeChain;

        if (ast.nodeType == NodeType.Script) {
            var script: Script = <Script>ast;
            context.script = script;
            go = true;
        }
        else if (ast.nodeType == NodeType.List) {
            go = true;
        }
        else if (ast.nodeType == NodeType.ImportDeclaration) {
            go = preCollectImportTypes(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.With) {
            go = false;
        }
        else if (ast.nodeType == NodeType.ModuleDeclaration) {
            go = preCollectModuleTypes(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.ClassDeclaration) {
            go = preCollectClassTypes(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.Block) {
            go = true;
        }
        else if (ast.nodeType == NodeType.InterfaceDeclaration) {
            go = preCollectInterfaceTypes(ast, parent, context);
        }
        // This will be a constructor arg because this pass only traverses
        // constructor arg lists
        else if (ast.nodeType == NodeType.ArgDecl) {
            go = preCollectArgDeclTypes(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.VarDecl) {
            go = preCollectVarDeclTypes(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.FuncDecl) {
            go = preCollectFuncDeclTypes(ast, parent, context);
        }
        else {
            if (ast.isStatementOrExpression() && context.scopeChain.moduleDecl) {
                context.scopeChain.moduleDecl.recordNonInterface();
            }
        }
        walker.options.goChildren = go;
        return ast;
    }

    export function postCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {
        var context: TypeCollectionContext = walker.state;

        if (ast.nodeType == NodeType.ModuleDeclaration) {
            popTypeCollectionScope(context);
        }
        else if (ast.nodeType == NodeType.ClassDeclaration) {
            popTypeCollectionScope(context);
        }
        else if (ast.nodeType == NodeType.InterfaceDeclaration) {
            popTypeCollectionScope(context);
        }
        return ast;
    }

}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class ScopeChain {
        public thisType: Type;
        public classType: Type;
        public fnc: FuncDecl;
        public moduleDecl: ModuleDeclaration;

        constructor (public container: Symbol, public previous: ScopeChain,
                     public scope: SymbolScope) { }
    }

    export class BBUseDefInfo {
        public defsBySymbol = new bool[];
        public gen: BitVector;
        public kill: BitVector;
        public top: BitVector;
        // use lists by symbol 
        public useIndexBySymbol = new number[][];

        constructor (public bb: BasicBlock) { }

        public updateTop() {
            var temp = new BitVector(this.top.bitCount);
            for (var i = 0, succLen = this.bb.successors.length; i < succLen; i++) {
                var succ = this.bb.successors[i];
                if (succ.useDef) {
                    temp.union(succ.useDef.top);
                }
            }
            temp.difference(this.kill);
            temp.union(this.gen);
            var changed = temp.notEq(this.top);
            this.top = temp;
            return changed;
        }


        public initialize(useDefContext: UseDefContext) {
            var defSym = (sym: Symbol, context: UseDefContext) => {
                if (context.isLocalSym(sym)) {
                    var index = context.getSymbolIndex(sym);
                    // clear pending uses
                    this.useIndexBySymbol[index] = new number[];
                    this.defsBySymbol[index] = true;
                }
            }

            var useSym = (sym: Symbol, context: UseDefContext, ast: AST) => {
                if (context.isLocalSym(sym)) {
                    var symIndex = context.getSymbolIndex(sym);
                    if (this.useIndexBySymbol[symIndex] == undefined) {
                        this.useIndexBySymbol[symIndex] = new number[];
                    }
                    var symUses = this.useIndexBySymbol[symIndex];
                    var astIndex = context.getUseIndex(ast);
                    context.addUse(symIndex, astIndex);
                    symUses.push(astIndex);
                }
            }

            function initUseDefPre(cur: AST, parent: AST, walker: IAstWalker) {
                var context: UseDefContext = walker.state;
                if (cur == null) {
                    cur = null;
                }
                if (cur.nodeType == NodeType.VarDecl) {
                    var varDecl = <BoundDecl>cur;
                    if (varDecl.init || hasFlag(varDecl.varFlags, VarFlags.AutoInit)) {
                        defSym(varDecl.sym, context);
                    }
                }
                else if (cur.nodeType == NodeType.Name) {
                    // use
                    if (parent) {
                        if (parent.nodeType == NodeType.Asg) {
                            var asg = <BinaryExpression>parent;
                            if (asg.operand1 == cur) {
                                return cur;
                            }
                        }
                        else if (parent.nodeType == NodeType.VarDecl) {
                            var parentDecl = <BoundDecl>parent;
                            if (parentDecl.id == cur) {
                                return cur;
                            }
                        }
                    }
                    var id = <Identifier>cur;
                    useSym(id.sym, context, cur);
                }
                else if ((cur.nodeType >= NodeType.Asg) && (cur.nodeType <= NodeType.LastAsg)) {
                    // def
                    var asg = <BinaryExpression>cur;
                    if (asg.operand1 && (asg.operand1.nodeType == NodeType.Name)) {
                        var id = <Identifier>asg.operand1;
                        defSym(id.sym, context);
                    }
                }
                else if (cur.nodeType == NodeType.FuncDecl) {
                    walker.options.goChildren = false;
                }

                return cur;
            }

            var options = new AstWalkOptions();
            // traverse ASTs in reverse order of execution (to match uses with preceding defs)
            options.reverseSiblings = true;

            getAstWalkerFactory().walk(this.bb.content, initUseDefPre, null, options, useDefContext);
        }

        public initializeGen(useDefContext: UseDefContext) {
            var symbolLen = this.useIndexBySymbol.length;
            var bitCount = useDefContext.uses.length;
            this.gen = new BitVector(bitCount);
            for (var s = 0; s < symbolLen; s++) {
                var symUses = this.useIndexBySymbol[s];
                if ((symUses != undefined) && (symUses.length > 0)) {
                    for (var u = 0, uLen = symUses.length; u < uLen; u++) {
                        this.gen.set(symUses[u], true);
                    }
                }
            }
            this.top = this.gen;
        }

        public initializeKill(useDefContext: UseDefContext) {
            this.kill = new BitVector(this.gen.bitCount);
            for (var s = 0, symbolLen = this.defsBySymbol.length; s < symbolLen; s++) {
                if (this.defsBySymbol[s]) {
                    var globalSymUses = useDefContext.useIndexBySymbol[s];
                    if (globalSymUses) {
                        for (var u = 0, useLen = globalSymUses.length; u < useLen; u++) {
                            this.kill.set(globalSymUses[u], true);
                        }
                    }
                }
            }
        }
    }

    export class UseDefContext {
        // global use lists by symbol
        public useIndexBySymbol = new number[][];
        // global list of uses (flat)
        public uses = new AST[];
        public symbols = new VariableSymbol[];
        public symbolMap = new StringHashTable();
        public symbolCount = 0;
        public func: Symbol;

        constructor () {
        }

        public getSymbolIndex(sym: Symbol) {
            var name = sym.name;
            var index = <number>(this.symbolMap.lookup(name));
            if (index == null) {
                index = this.symbolCount++;
                this.symbols[index] = <VariableSymbol>sym;
                this.symbolMap.add(name, index);
            }
            return index;
        }

        public addUse(symIndex: number, astIndex: number) {
            var useBySym = this.useIndexBySymbol[symIndex];
            if (useBySym == undefined) {
                useBySym = new number[];
                this.useIndexBySymbol[symIndex] = useBySym;
            }
            useBySym[useBySym.length] = astIndex;
        }

        public getUseIndex(ast: AST) {
            this.uses[this.uses.length] = ast;
            return this.uses.length - 1;
        }

        public isLocalSym(sym: Symbol) { return (sym && (sym.container == this.func) && (sym.kind() == SymbolKind.Variable)); }

        public killSymbol(sym: VariableSymbol, bbUses: BitVector) {
            var index: number = this.symbolMap.lookup(sym.name);
            var usesOfSym = this.useIndexBySymbol[index];
            for (var k = 0, len = usesOfSym.length; k < len; k++) {
                bbUses.set(usesOfSym[k], true);
            }
        }
    }

    export class BitVector {
        static packBits = 30;
        public firstBits = 0;
        public restOfBits: number[] = null;

        constructor (public bitCount: number) {
            if (this.bitCount > BitVector.packBits) {
                this.restOfBits = new number[];
                var len = Math.floor(this.bitCount / BitVector.packBits);
                for (var i = 0; i < len; i++) {
                    this.restOfBits[i] = 0;
                }
            }
        }

        public set(bitIndex: number, value: bool) {
            if (bitIndex < BitVector.packBits) {
                if (value) {
                    this.firstBits |= (1 << bitIndex);
                }
                else {
                    this.firstBits &= (~(1 << bitIndex));
                }
            }
            else {
                var offset = Math.floor(bitIndex / BitVector.packBits) - 1;
                var localIndex = bitIndex % BitVector.packBits;
                if (value) {
                    this.restOfBits[offset] |= (1 << localIndex);
                }
                else {
                    this.restOfBits[offset] &= (~(1 << localIndex));
                }
            }
        }

        public map(fn: (index: number) =>any) {
            var k: number;
            for (k = 0; k < BitVector.packBits; k++) {
                if (k == this.bitCount) {
                    return;
                }
                if (((1 << k) & this.firstBits) != 0) {
                    fn(k);
                }
            }
            if (this.restOfBits) {
                var len: number;
                var cumu = BitVector.packBits;
                for (k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    for (var j = 0; j < BitVector.packBits; j++) {
                        if (((1 << j) & myBits) != 0) {
                            fn(cumu);
                        }
                        cumu++;
                        if (cumu == this.bitCount) {
                            return;
                        }
                    }
                }
            }
        }

        // assume conforming sizes
        public union(b: BitVector) {
            this.firstBits |= b.firstBits;
            if (this.restOfBits) {
                for (var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] = myBits | bBits;
                }
            }
        }

        // assume conforming sizes
        public intersection(b: BitVector) {
            this.firstBits &= b.firstBits;
            if (this.restOfBits) {
                for (var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] = myBits & bBits;
                }
            }
        }

        // assume conforming sizes
        public notEq(b: BitVector) {
            if (this.firstBits != b.firstBits) {
                return true;
            }
            if (this.restOfBits) {
                for (var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    if (myBits != bBits) {
                        return true;
                    }
                }
            }
            return false;
        }

        public difference(b: BitVector) {
            var oldFirstBits = this.firstBits;
            this.firstBits &= (~b.firstBits);
            if (this.restOfBits) {
                for (var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] &= (~bBits);
                }
            }
        }
    }

    export class BasicBlock {
        // blocks that branch to the block after this one
        public predecessors = new BasicBlock[];
        public index = -1;
        public markValue = 0;
        public marked(markBase: number) { return this.markValue > markBase; }
        public mark() {
            this.markValue++;
        }
        public successors = new BasicBlock[];
        public useDef: BBUseDefInfo = null;
        public content = new ASTList();
        public addSuccessor(successor: BasicBlock): void {
            this.successors[this.successors.length] = successor;
            successor.predecessors[successor.predecessors.length] = this;
        }
    }

    export interface ITargetInfo {
        stmt: AST;
        continueBB: BasicBlock;
        breakBB: BasicBlock;
    }

    export class ControlFlowContext {
        public entry = null;
        // first unreachable ast for each unreachable code segment
        public unreachable: AST[] = null;
        public noContinuation = false;
        // statements enclosing the current statement
        public statementStack = new ITargetInfo[];
        public currentSwitch = new BasicBlock[];
        public walker: IAstWalker;

        constructor (public current: BasicBlock,
                     public exit: BasicBlock) {
            this.entry = this.current;
        }

        public walk(ast: AST, parent: AST) {
            return this.walker.walk(ast, parent);
        }

        public pushSwitch(bb: BasicBlock) {
            this.currentSwitch.push(bb);
        }

        public popSwitch() {
            return this.currentSwitch.pop();
        }

        public reportUnreachable(er: ErrorReporter) {
            if (this.unreachable && (this.unreachable.length > 0)) {
                var len = this.unreachable.length;
                for (var i = 0; i < len; i++) {
                    var unreachableAST = this.unreachable[i];
                    if (unreachableAST.nodeType != NodeType.EndCode) {
                        er.simpleError(unreachableAST, "unreachable code");
                    }
                }
            }
        }

        private printAST(ast: AST, outfile: ITextWriter) {
            var printContext = new PrintContext(outfile, null);

            printContext.increaseIndent();
            //ast.walk(prePrintAST, postPrintAST, null, printContext);
            getAstWalkerFactory().walk(ast, prePrintAST, postPrintAST, null, printContext);

            printContext.decreaseIndent();
        }

        private printBlockContent(bb: BasicBlock, outfile: ITextWriter) {
            var content = bb.content;
            for (var i = 0, len = content.members.length; i < len; i++) {
                var ast = content.members[i];
                this.printAST(ast, outfile);
            }
        }

        public markBase = 0;

        public bfs(nodeFunc: (bb: BasicBlock) =>void , edgeFunc: (node1: BasicBlock, node2: BasicBlock) =>void ,
            preEdges: () =>void , postEdges: () =>void ) {
            var markValue = this.markBase++;
            var q = new BasicBlock[];
            q[q.length] = this.entry;

            while (q.length > 0) {
                var bb = q.pop();
                if (!(bb.marked(markValue))) {
                    bb.mark();
                    if (nodeFunc) {
                        nodeFunc(bb);
                    }
                    var succLen = bb.successors.length;
                    if (succLen > 0) {
                        if (preEdges) {
                            preEdges();
                        }
                        for (var j = succLen - 1; j >= 0; j--) {
                            var successor = bb.successors[j];
                            if (!(successor.marked(this.markBase))) {
                                if (edgeFunc) {
                                    edgeFunc(bb, successor);
                                }
                                q[q.length] = successor;
                            }
                        }
                        if (postEdges) {
                            postEdges();
                        }
                    }
                }
            }
        }

        public linearBBs = new BasicBlock[];

        public useDef(er: ErrorReporter, funcSym: Symbol) {
            var useDefContext = new UseDefContext();
            useDefContext.func = funcSym;
            var useDefInit = (bb: BasicBlock) => {
                bb.useDef = new BBUseDefInfo(bb);
                bb.useDef.initialize(useDefContext);
                this.linearBBs[this.linearBBs.length] = bb;
            }
            this.bfs(useDefInit, null, null, null);
            var i: number, bbLen: number;
            for (i = 0, bbLen = this.linearBBs.length; i < bbLen; i++) {
                this.linearBBs[i].useDef.initializeGen(useDefContext);
                this.linearBBs[i].useDef.initializeKill(useDefContext);
            }
            var changed = true;

            while (changed) {
                changed = false;
                for (i = 0; i < bbLen; i++) {
                    changed = this.linearBBs[i].useDef.updateTop() || changed;
                }
            }

            var top = this.entry.useDef.top;
            top.map((index) => {
                var ast = <Identifier>useDefContext.uses[<number>index];
                er.simpleError(ast, "use of variable '" + ast.actualText + "' that is not definitely assigned");
            });
        }

        public print(outfile: ITextWriter) {
            var index = 0;
            var node = (bb: BasicBlock) => {
                if (bb.index < 0) {
                    bb.index = index++;
                }
                if (bb == this.exit) {
                    outfile.WriteLine("Exit block with index " + bb.index);
                }
                else {
                    outfile.WriteLine("Basic block with index " + bb.index);
                    this.printBlockContent(bb, outfile);
                }
            }

            function preEdges() {
                outfile.Write("  Branches to ");
            }

            function postEdges() {
                outfile.WriteLine("");
            }

            function edge(node1: BasicBlock, node2: BasicBlock) {
                if (node2.index < 0) {
                    node2.index = index++;
                }
                outfile.Write(node2.index + " ");
            }

            this.bfs(node, edge, preEdges, postEdges);
            if (this.unreachable != null) {
                for (var i = 0, len = this.unreachable.length; i < len; i++) {
                    outfile.WriteLine("Unreachable basic block ...");
                    this.printAST(this.unreachable[i], outfile);
                }
            }
        }

        public pushStatement(stmt: Statement, continueBB: BasicBlock, breakBB: BasicBlock) {
            this.statementStack.push({ stmt: stmt, continueBB: continueBB, breakBB: breakBB });
        }

        public popStatement() { return this.statementStack.pop(); }

        public returnStmt() {
            // TODO: make successor finally block if return stmt inside of try/finally 
            this.current.addSuccessor(this.exit);
            this.setUnreachable();
        }

        public setUnreachable() {
            this.current = null;
            this.noContinuation = true;
        }

        public addUnreachable(ast: AST) {
            if (this.unreachable === null) {
                this.unreachable = new AST[];
            }
            this.unreachable[this.unreachable.length] = ast;
        }

        public unconditionalBranch(target: AST, isContinue: bool) {
            var targetBB = null;
            for (var i = 0, len = this.statementStack.length; i < len; i++) {
                var targetInfo = this.statementStack[i];
                if (targetInfo.stmt == target) {
                    if (isContinue) {
                        targetBB = targetInfo.continueBB;
                    }
                    else {
                        targetBB = targetInfo.breakBB;
                    }
                    break;
                }
            }
            if (targetBB) {
                this.current.addSuccessor(targetBB);
            }
            this.setUnreachable();
        }

        public addContent(ast: AST): void {
            if (this.current) {
                this.current.content.append(ast);
            }
        }
    }

    export interface IResolutionData {
        actuals: Type[];
        exactCandidates: Signature[];
        conversionCandidates: Signature[];
        id: number;
    }

    export class ResolutionDataCache {
        public cacheSize = 16;
        public rdCache: IResolutionData[] = [];
        public nextUp: number = 0;

        constructor () {
            for (var i = 0; i < this.cacheSize; i++) {
                this.rdCache[i] = {
                    actuals: new Type[],
                    exactCandidates: new Signature[],
                    conversionCandidates: new Signature[],
                    id: i
                };
            }
        }

        public getResolutionData(): IResolutionData {
            var rd: IResolutionData = null;

            if (this.nextUp < this.cacheSize) {
                rd = this.rdCache[this.nextUp];
            }

            if (rd == null) {
                this.cacheSize++;
                rd = {
                    actuals: new Type[],
                    exactCandidates: new Signature[],
                    conversionCandidates: new Signature[],
                    id: this.cacheSize
                };
                this.rdCache[this.cacheSize] = rd;
            }

            // cache operates as a stack - RD is always served up in-order
            this.nextUp++;

            return rd;
        }

        public returnResolutionData(rd: IResolutionData) {
            // Pop to save on array allocations, which are a bottleneck
            // REVIEW: On some VMs, Array.pop doesn't always pop the last value in the array
            rd.actuals.length = 0;
            rd.exactCandidates.length = 0;
            rd.conversionCandidates.length = 0;

            this.nextUp = rd.id;
        }
    }

    export class TypeFlow {
        public scope: SymbolScope;
        public globalScope: SymbolScope;

        public thisType: Type;
        public thisFnc: FuncDecl = null;
        public thisClassNode: TypeDeclaration = null;
        public enclosingFncIsMethod = false;

        // REVIEW: Prune in favor of typechecker fields
        public doubleType: Type;
        public booleanType: Type;
        public stringType: Type;
        public anyType: Type;
        public regexType: Type;
        public nullType: Type;
        public voidType: Type;
        public arrayAnyType: Type;

        public arrayInterfaceType: Type = null;
        public stringInterfaceType: Type = null;
        public objectInterfaceType: Type = null;
        public functionInterfaceType: Type = null;
        public numberInterfaceType: Type = null;
        public booleanInterfaceType: Type = null;
        public iargumentsInterfaceType: Type = null;

        public currentScript: Script = null;

        public inImportTypeCheck = false;
        public inTypeRefTypeCheck = false;
        public inArrayElementTypeCheck = false;
        public resolutionDataCache = new ResolutionDataCache();
        public nestingLevel = 0;
        public inSuperCall = false;

        constructor (public logger: ILogger, public initScope: SymbolScope, public parser: Parser,
                   public checker: TypeChecker) {
            this.checker.typeFlow = this;
            this.scope = this.initScope;
            this.globalScope = this.initScope;
            this.doubleType = this.checker.numberType;
            this.booleanType = this.checker.booleanType;
            this.stringType = this.checker.stringType;
            this.anyType = this.checker.anyType;
            this.regexType = this.anyType;
            this.nullType = this.checker.nullType;
            this.voidType = this.checker.voidType;
            this.arrayAnyType = this.checker.makeArrayType(this.anyType);
        }

        public initLibs() {
            var arraySym = this.globalScope.find("Array", false, true);
            if (arraySym && (arraySym.kind() == SymbolKind.Type)) {
                this.arrayInterfaceType = (<TypeSymbol>arraySym).type;
            }
            var stringSym = this.globalScope.find("String", false, true);
            if (stringSym && (stringSym.kind() == SymbolKind.Type)) {
                this.stringInterfaceType = (<TypeSymbol>stringSym).type;
            }
            var objectSym = this.globalScope.find("Object", false, true);
            if (objectSym && (objectSym.kind() == SymbolKind.Type)) {
                this.objectInterfaceType = (<TypeSymbol>objectSym).type;
            }
            var fnSym = this.globalScope.find("Function", false, true);
            if (fnSym && (fnSym.kind() == SymbolKind.Type)) {
                this.functionInterfaceType = (<TypeSymbol>fnSym).type;
            }
            var numberSym = this.globalScope.find("Number", false, true);
            if (numberSym && (numberSym.kind() == SymbolKind.Type)) {
                this.numberInterfaceType = (<TypeSymbol>numberSym).type;
            }
            var booleanSym = this.globalScope.find("Boolean", false, true);
            if (booleanSym && (booleanSym.kind() == SymbolKind.Type)) {
                this.booleanInterfaceType = (<TypeSymbol>booleanSym).type;
            }
            var regexSym = this.globalScope.find("RegExp", false, true);
            if (regexSym && (regexSym.kind() == SymbolKind.Type)) {
                this.regexType = (<TypeSymbol>regexSym).type;
            }
        }

        public cast(ast: AST, type: Type): AST {
            return this.castWithCoercion(ast, type, true, false);
        }

        public castWithCoercion(ast: AST, type: Type, applyCoercion: bool, typeAssertion: bool): AST {
            var comparisonInfo = new TypeComparisonInfo();
            if (this.checker.sourceIsAssignableToTarget(ast.type, type, comparisonInfo) || (typeAssertion && this.checker.sourceIsAssignableToTarget(type, ast.type, comparisonInfo))) {
                if (applyCoercion) {
                    if (type == null) {
                        ast.type = this.anyType;
                    }
                    else if (type.isClass()) {
                        ast.type = type.instanceType;
                    }
                    else {
                        ast.type = type;
                    }
                }
                return ast;
            }
            else {
                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, null, this.scope, comparisonInfo);
                return ast;
            }
        }

        public inScopeTypeCheck(ast: AST, enclosingScope: SymbolScope): AST {
            var prevScope = this.scope;
            this.scope = enclosingScope;
            var svThisFnc = this.thisFnc;
            var svThisType = this.thisType;
            var svThisClassNode = this.thisClassNode;
            var svCurrentModDecl = this.checker.currentModDecl;
            var prevMethodStatus = this.enclosingFncIsMethod;
            var container = this.scope.container;
            var fnc: FuncDecl = null;
            while (container) {
                if (container.kind() == SymbolKind.Type) {
                    var typeSym = <TypeSymbol>container;
                    var type = typeSym.type;
                    if (type.call) {
                        if (fnc == null) {
                            // use innermost function
                            this.enclosingFncIsMethod = typeSym.isMethod;
                            fnc = <FuncDecl>container.declAST;
                        }
                    }
                    if (type.isClass()) {
                        this.thisType = type.instanceType;
                        if (typeSym.declAST &&
                            (typeSym.declAST.nodeType == NodeType.ClassDeclaration)) {
                            this.thisClassNode = <TypeDeclaration>typeSym.declAST;
                        }
                        // use innermost class
                        break;
                    }
                    if (type.isModuleType()) {
                        this.checker.currentModDecl = <ModuleDeclaration>typeSym.declAST;
                        // use innermost module
                        break;
                    }
                }
                container = container.container;
            }
            this.thisFnc = fnc;

            var updated = this.typeCheck(ast);

            this.thisFnc = svThisFnc;
            this.thisType = svThisType;
            this.thisClassNode = svThisClassNode;
            this.checker.currentModDecl = svCurrentModDecl;
            this.enclosingFncIsMethod = prevMethodStatus;
            this.scope = prevScope;
            return updated;
        }

        public typeCheck(ast: AST): AST {
            if (ast) {
                return ast.typeCheck(this);
            }
            else {
                return null;
            }
        }

        public inScopeTypeCheckDecl(ast: AST) {
            if (ast.nodeType == NodeType.VarDecl || ast.nodeType == NodeType.ArgDecl) {
                this.inScopeTypeCheckBoundDecl(<BoundDecl>ast);
            }
            else if (ast.nodeType == NodeType.FuncDecl) {

                var funcDecl = <FuncDecl>ast;

                if (funcDecl.isAccessor()) {
                    this.typeCheckFunction(funcDecl);
                }
            }
        }

        public inScopeTypeCheckBoundDecl(varDecl: BoundDecl) {
            var sym = varDecl.sym;
            var svThisFnc = this.thisFnc;
            var svThisType = this.thisType;
            var prevMethodStatus = this.enclosingFncIsMethod;
            var prevLocationInfo = this.checker.locationInfo;
            if (sym && sym.container) {
                var instanceScope = hasFlag(varDecl.varFlags, VarFlags.ClassConstructorProperty) ? sym.container.getType().constructorScope : sym.container.instanceScope();
                if (hasFlag(varDecl.varFlags, VarFlags.Property) && sym.container.declAST.nodeType == NodeType.FuncDecl) {
                    this.thisFnc = <FuncDecl>sym.container.declAST;
                }
                if (instanceScope) {
                    var prevScope = this.scope;
                    this.scope = instanceScope;
                    var container = sym.container;
                    var svCurrentModDecl = this.checker.currentModDecl;
                    if (this.checker.units &&
                        (sym.unitIndex >= 0) &&
                        (sym.unitIndex < this.checker.units.length)) {
                        this.checker.locationInfo = this.checker.units[sym.unitIndex];
                    }
                    else {
                        this.checker.locationInfo = unknownLocationInfo;
                    }
                    // REVIEW: container linkage for function expressions
                    while (container) {
                        if (container.kind() == SymbolKind.Type) {
                            var typeSym = <TypeSymbol>container;
                            var type = typeSym.type;
                            if (type.call) {
                                this.enclosingFncIsMethod = typeSym.isMethod;
                            }
                            if (type.isClass()) {
                                this.thisType = type.instanceType;
                            }
                            if (type.isModuleType()) {
                                this.checker.currentModDecl = <ModuleDeclaration>container.declAST;
                                break;
                            }
                        }
                        container = container.container;
                    }

                    this.typeCheckBoundDecl(varDecl);
                    this.checker.currentModDecl = svCurrentModDecl;
                    this.scope = prevScope;
                }
            }
            this.thisFnc = svThisFnc;
            this.thisType = svThisType;
            this.checker.locationInfo = prevLocationInfo;
            this.enclosingFncIsMethod = prevMethodStatus;
        }

        public resolveBoundDecl(varDecl: BoundDecl) {
            if (varDecl.typeExpr) {
                if (varDecl.typeExpr.type == null ||
                    (varDecl.typeExpr.type && varDecl.typeExpr.type == this.anyType && this.scope) ||
                    varDecl.typeExpr.type.symbol == null ||
                    !this.checker.typeStatusIsFinished(varDecl.typeExpr.type.symbol.typeCheckStatus)) {
                    this.typeCheck(varDecl.typeExpr);
                }
                varDecl.type = varDecl.typeExpr.type;
                if (varDecl.sym) {
                    varDecl.sym.setType(varDecl.type);
                }
            }
            else if (varDecl.init == null) {
                if (this.checker.styleSettings.implicitAny) {
                    this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                }
                varDecl.type = this.anyType;
                if (varDecl.sym) {
                    if (varDecl.sym.isType()) {
                        var tsym = <TypeSymbol>varDecl.sym;
                        if (tsym.isMethod) {
                            this.checker.errorReporter.simpleError(varDecl, "Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)");
                            return;
                        }
                        else {
                            this.checker.errorReporter.simpleError(varDecl, "Cannot bind type to variable");
                            return;
                        }
                    }
                    varDecl.sym.setType(varDecl.type);
                }
            }
        }

        public typeCheckBoundDecl(varDecl: BoundDecl): VarDecl {
            // symbol has already been added to the scope
            var infSym = <InferenceSymbol>varDecl.sym;
            if (infSym == null) {
                if (varDecl.init) {
                    varDecl.init = this.typeCheck(varDecl.init);
                    varDecl.type = this.checker.widenType(varDecl.init.type);
                }
                else {
                    if (this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                    }
                    varDecl.type = this.anyType;
                }
            }
            else {
                if (infSym.typeCheckStatus == TypeCheckStatus.Started) {
                    if (this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                    }
                    varDecl.type = this.anyType;
                    infSym.setType(this.anyType);
                }
                else if (infSym.typeCheckStatus == TypeCheckStatus.NotStarted) {
                    infSym.typeCheckStatus = TypeCheckStatus.Started;
                    this.checker.addStartedPTO(infSym);
                    var resolved = false;
                    if (varDecl.type == null) {
                        // propagate declared type
                        if (varDecl.typeExpr) {
                            this.resolveBoundDecl(varDecl);
                            resolved = true;
                            varDecl.type = varDecl.typeExpr.type;
                            infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                        }
                    }

                    if (varDecl.init) {
                        // if the bound decl is a function-local static, we need to set the
                        // encapsulating scope to the function's member scope
                        var isLocalStatic = hasFlag(varDecl.varFlags, VarFlags.LocalStatic);
                        var prevScope = this.scope;
                        var applyTargetType = !varDecl.init.isParenthesized;
                        if (isLocalStatic) {
                            this.scope = varDecl.sym.container.getType().memberScope;
                        }

                        // Mark Lambda expressions with IsPropertyBound flag
                        if (hasFlag(varDecl.varFlags, VarFlags.Property) && this.thisClassNode) {
                            getAstWalkerFactory().walk(varDecl.init, (ast: AST, parent: AST, walker: IAstWalker) => {
                                if (ast && ast.nodeType == NodeType.FuncDecl) {
                                    if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {
                                        // Found a Lambda, mark it
                                        (<FuncDecl>ast).fncFlags |= FncFlags.IsPropertyBound;
                                    }
                                    // Only mark the top level functions
                                    walker.options.goChildren = false;
                                }
                                return ast;
                            });
                        }

                        this.checker.typeCheckWithContextualType(varDecl.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, varDecl.init);

                        this.scope = prevScope;
                        if (varDecl.type) {
                            // If the cast is to a target type, in the case of a funcdecl,
                            // we may overwrite the init's type with one generated from a signature.
                            // In that case, we need to preserve the contained scope of the actual decl
                            var preserveScope = false;
                            var preservedContainedScope = null;

                            if (varDecl.init.type) {
                                preservedContainedScope = varDecl.init.type.containedScope;
                                preserveScope = true;
                                if (varDecl.init.type == this.voidType) {
                                    this.checker.errorReporter.simpleError(varDecl, "Cannot assign type 'void' to variable '" + varDecl.id.actualText + "'");
                                }
                            }

                            varDecl.init = this.castWithCoercion(varDecl.init, varDecl.type, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);

                            if (preserveScope && varDecl.init.type.containedScope == null) {
                                varDecl.init.type.containedScope = preservedContainedScope;
                            }
                        }
                        else {
                            varDecl.type = this.checker.widenType(varDecl.init.type);
                            if (varDecl.type == this.voidType) {
                                this.checker.errorReporter.simpleError(varDecl, "Cannot assign type 'void' to variable '" + varDecl.id.actualText + "'");
                                varDecl.type = this.anyType;
                            }
                        }
                        infSym.setType(varDecl.type);
                    }
                    else {
                        if (!resolved) {
                            this.resolveBoundDecl(varDecl);
                        }
                    }
                    infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                }
                else if (this.checker.typeStatusIsFinished(infSym.typeCheckStatus) &&
                         (infSym.declAST != varDecl)) {
                    if (varDecl.init) {
                        varDecl.init = this.typeCheck(varDecl.init);
                        varDecl.type = infSym.getType();
                        varDecl.init = this.cast(varDecl.init, varDecl.type);
                    }
                }
            }
            if (varDecl.id && varDecl.sym) {
                varDecl.id.sym = varDecl.sym;
            }

            // Check if variable satisfies type privacy
            if (varDecl.sym && varDecl.sym.container) {
                this.checkTypePrivacy(varDecl.sym.getType(), varDecl.sym, (typeName: string, isModuleName: bool) => this.varPrivacyErrorReporter(varDecl, typeName, isModuleName));
            }
            return <VarDecl>varDecl;
        }

        private varPrivacyErrorReporter(varDecl: BoundDecl, typeName: string, isModuleName: bool) {
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }

            if (hasFlag(varDecl.varFlags, VarFlags.Public)) {
                if (varDecl.sym.container.declAST.nodeType == NodeType.InterfaceDeclaration) {
                    this.checker.errorReporter.simpleError(varDecl, "property '" + varDecl.sym.name + "' of exported interface" + typestring);
                } else {
                    this.checker.errorReporter.simpleError(varDecl, "public member '" + varDecl.sym.name + "' of exported class" + typestring);
                }
            } else {
                this.checker.errorReporter.simpleError(varDecl, "exported variable '" + varDecl.sym.name + "'" + typestring);
            }
        }

        public typeCheckSuper(ast: AST): AST {
            if (this.thisType && (this.enclosingFncIsMethod && !this.thisFnc.isStatic()) && this.thisType.baseClass()) {
                ast.type = this.thisType.baseClass();
            }
            else {
                // redirect 'super' used within lambdas
                if (!this.enclosingFncIsMethod &&
                    this.thisType && this.thisType.baseClass() &&
                    this.thisFnc && hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {
                    // Find the closest non lambda function
                    var enclosingFnc = this.thisFnc.enclosingFnc;
                    while (hasFlag(enclosingFnc.fncFlags, FncFlags.IsFatArrowFunction)) {
                        enclosingFnc = enclosingFnc.enclosingFnc;
                    }

                    // If the lambda is enclosed is a valid member, use the base type
                    if (enclosingFnc && (enclosingFnc.isMethod() || enclosingFnc.isConstructor) && !enclosingFnc.isStatic()) {
                        ast.type = this.thisType.baseClass();
                        enclosingFnc.setHasSuperReferenceInFatArrowFunction();
                        return ast;
                    }
                }

                ast.type = this.anyType;
                this.checker.errorReporter.invalidSuperReference(ast);
            }
            return ast;
        }

        public typeCheckThis(ast: AST): AST {
           ast.type = this.anyType;
            var illegalThisRef = false;
            if (this.thisFnc == null) {
                // 'this' in class bodies should bind to 'any'
                if (this.thisType) {
                    if (this.thisClassNode && this.thisClassNode.nodeType == NodeType.ClassDeclaration) {
                        illegalThisRef = true;
                    }
                    else {
                        ast.type = this.thisType;
                    }
                }
                else if (this.checker.currentModDecl) {
                    this.checker.errorReporter.simpleError(ast, "'this' may not be referenced within module bodies");
                }
            }
            else {
                if (this.thisClassNode && (hasFlag(this.thisFnc.fncFlags, FncFlags.IsPropertyBound) || (this.inSuperCall && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor)))) {
                    illegalThisRef = true;
                }
                if (this.thisFnc.isMethod() || this.thisFnc.isConstructor || this.thisFnc.isTargetTypedAsMethod) {
                    if (this.thisType && !(this.thisFnc.fncFlags & FncFlags.Static)) {
                        ast.type = this.thisType;
                    }
                }
            }

            // redirect 'this' used within lambdas
            if (!this.enclosingFncIsMethod &&
                this.thisFnc &&
                hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {

                    // if the enclosing function was bound to a property,
                    // checkInitSelf would not have been able to mark the 
                    // function for a self init
                if (this.thisFnc.boundToProperty) {
                    var container = this.thisFnc.boundToProperty.sym.container;
                    if (container.declAST.nodeType == NodeType.FuncDecl) {
                        (<FuncDecl>container.declAST).setHasSelfReference();
                    }
                }
                else {
                    var encFnc = this.thisFnc.enclosingFnc;
                    var firstEncFnc = encFnc;

                    while (encFnc) {
                        if (this.thisClassNode && hasFlag(encFnc.fncFlags, FncFlags.IsPropertyBound)) {
                            illegalThisRef = true;
                        }

                        if (!hasFlag(encFnc.fncFlags, FncFlags.IsFatArrowFunction) || encFnc.hasSelfReference()) {
                            encFnc.setHasSelfReference();
                            break;
                        }

                        encFnc = encFnc.enclosingFnc;
                    }

                    if (!encFnc && firstEncFnc) {
                        encFnc = firstEncFnc;
                        encFnc.setHasSelfReference();
                    }
                    else if (!encFnc) { // the lambda is bound at the top-level...
                        if (this.thisClassNode) {
                            (<ClassDeclaration>this.thisClassNode).varFlags |= VarFlags.MustCaptureThis;
                        }
                        else if (this.checker.currentModDecl) {
                            this.checker.currentModDecl.modFlags |= ModuleFlags.MustCaptureThis;
                        }
                        else {
                            this.checker.mustCaptureGlobalThis = true;
                        }
                    }

                    if (encFnc && (encFnc.isMethod() || encFnc.isConstructor) && this.thisType && !hasFlag(encFnc.fncFlags, FncFlags.Static)) {
                        ast.type = this.thisType;
                    }
                }
            }

            if (illegalThisRef) {
                this.checker.errorReporter.simpleError(ast, "Keyword 'this' cannot be referenced in initializers in a class body, or in super constructor calls");
            }
            return ast;
        }

        public setTypeFromSymbol(ast: AST, symbol: Symbol): void {
            if (symbol.isVariable()) {
                if (symbol.isInferenceSymbol()) {
                    var infSym = <InferenceSymbol>symbol;
                    if (infSym.declAST &&
                        !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {
                        this.inScopeTypeCheckDecl(infSym.declAST);
                    }
                    if (!this.checker.styleSettings.innerScopeDeclEscape) {
                        if (infSym.declAST && (infSym.declAST.nodeType == NodeType.VarDecl)) {
                            if (this.nestingLevel < (<VarDecl>infSym.declAST).nestingLevel) {
                                this.checker.errorReporter.styleError(ast, "Illegal reference to a variable defined in more nested scope");
                            }
                        }
                    }
                }
                ast.type = symbol.getType();
                if (!symbol.writeable()) {
                    ast.flags = ast.flags & (~(ASTFlags.Writeable));
                }
            }
            else if (symbol.isType()) {
                ast.type = symbol.getType();
                ast.flags = ast.flags & (~(ASTFlags.Writeable));
            }
            else {
                ast.type = this.anyType;
                this.checker.errorReporter.symbolDoesNotReferToAValue(ast, symbol.name);
            }
        }

        public typeCheckName(ast: AST): AST {
            var identifier = <Identifier>ast;

            if (this.checker.inWith) {
                identifier.type = this.anyType;
            }
            else {
                var typespace = this.inTypeRefTypeCheck;
                var idText = identifier.text;
                var originalIdText = idText;
                var isDynamicModuleName = isQuoted(identifier.text);

                var symbol = this.scope.find(idText, false, typespace);

                if (symbol == null && isDynamicModuleName) {
                    symbol = this.checker.findSymbolForDynamicModule(idText, this.currentScript.locationInfo.filename, (id) => this.scope.find(id, false, typespace));
                }

                if (!symbol) {
                    if (!identifier.isMissing()) {
                        this.checker.errorReporter.unresolvedSymbol(identifier, identifier.text);
                    }
                    identifier.type = this.anyType;
                }
                else {
                    if (optimizeModuleCodeGen && symbol && symbol.isType()) {
                        var symType = symbol.getType();
                        // Once the type has been referenced outside of a type ref position, there's
                        // no going back                        
                        if (symType && (<TypeSymbol>symbol).aliasLink && (<TypeSymbol>symbol).onlyReferencedAsTypeRef) {

                            var modDecl = <ModuleDeclaration>symType.symbol.declAST;
                            if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic)) {
                                (<TypeSymbol>symbol).onlyReferencedAsTypeRef = this.inTypeRefTypeCheck;
                            }
                        }
                    }

                    if (symbol.declAST &&
                        symbol.declAST.nodeType == NodeType.FuncDecl &&
                        !(<FuncDecl>symbol.declAST).returnTypeAnnotation &&
                        (<FuncDecl>symbol.declAST).signature.typeCheckStatus == TypeCheckStatus.Started) {
                        (<FuncDecl>symbol.declAST).type.symbol.flags |= SymbolFlags.RecursivelyReferenced;
                        (<FuncDecl>symbol.declAST).signature.returnType.type = this.anyType;
                    }

                    this.setTypeFromSymbol(ast, symbol);
                    identifier.sym = symbol;
                    if (this.thisFnc) {
                        if (this.thisFnc.type && symbol.container != this.thisFnc.type.symbol) {
                            this.thisFnc.freeVariables[this.thisFnc.freeVariables.length] = symbol;
                        }
                    }
                }
            }
            return ast;
        }

        public typeCheckScript(script: Script): Script {
            this.checker.locationInfo = script.locationInfo;
            this.scope = this.checker.globalScope;

            // if it's a top-level module, the globals have already been added to the implicit
            // module decl
            if (!script.topLevelMod) {
                this.addLocalsFromScope(this.scope, this.checker.gloMod,
                                   script.vars, this.checker.globals, true);
            }

            this.currentScript = script;
            script.bod = <ASTList>this.typeCheck(script.bod);
            this.currentScript = null;
            return script;
        }

        public typeCheckBitNot(ast: AST): AST {
            var unex = <UnaryExpression>ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.doubleType;
            return unex;
        }

        public typeCheckUnaryNumberOperator(ast: AST): AST {
            var unex = <UnaryExpression>ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.doubleType;
            return ast;
        }

        public typeCheckLogNot(ast: AST): AST {
            var unex = <UnaryExpression>ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.booleanType;
            return unex;
        }

        public astIsWriteable(ast: AST): bool {
            return hasFlag(ast.flags, ASTFlags.Writeable);
        }

        public typeCheckIncOrDec(ast: AST): AST {
            var unex = <UnaryExpression>ast;
            var lval = unex.operand;
            if (!this.astIsWriteable(unex)) {
                this.checker.errorReporter.valueCannotBeModified(unex);
                unex.type = this.doubleType;
            }
            else {
                unex = <UnaryExpression> this.typeCheckUnaryNumberOperator(ast);
                if (unex.operand.type != this.checker.numberType && unex.operand.type != this.checker.anyType && !(unex.operand.type.typeFlags & TypeFlags.IsEnum)) {
                    this.checker.errorReporter.simpleError(ast, "'++' and '--' may only be applied to operands of type 'number' or 'any'");
                }
            }
            return unex;
        }

        public typeCheckBitwiseOperator(ast: AST, assignment: bool): AST {
            var binex = <BinaryExpression>ast;
            var resultType: Type = null;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;

            if (assignment && (!this.astIsWriteable(binex))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }

            if (this.checker.styleSettings.bitwise) {
                this.checker.errorReporter.styleError(ast, "use of " + nodeTypeTable[binex.nodeType]);
            }

            if (this.checker.sourceIsSubtypeOfTarget(leftType, this.doubleType) && (this.checker.sourceIsSubtypeOfTarget(rightType, this.doubleType))) {
                resultType = this.doubleType;
            }
            else if ((leftType == this.booleanType) &&
                     (rightType == this.booleanType)) {
                resultType = this.booleanType;
            }
            else if (leftType == this.anyType) {
                if ((rightType == this.anyType) ||
                    (rightType == this.doubleType) ||
                    (rightType == this.booleanType)) {
                    resultType = this.anyType;
                }
            }
            else if (rightType == this.anyType) {
                if ((leftType == this.anyType) ||
                    (leftType == this.doubleType) ||
                    (leftType == this.booleanType)) {
                    resultType = this.anyType;
                }
            }
            if (resultType == null) {
                resultType = this.anyType;
                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,
                                                        binex.printLabel(), this.scope);
            }
            binex.type = resultType;
            return binex;
        }

        public typeCheckArithmeticOperator(ast: AST, assignment: bool): AST {
            var binex = <BinaryExpression>ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;

            if (assignment && (!this.astIsWriteable(binex.operand1))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }

            if (this.checker.styleSettings.bitwise &&
                ((binex.nodeType == NodeType.And) ||
                (binex.nodeType == NodeType.Or) ||
                (binex.nodeType == NodeType.AsgAnd) ||
                (binex.nodeType == NodeType.AsgOr))) {
                this.checker.errorReporter.styleError(ast, "use of " + nodeTypeTable[binex.nodeType]);
            }

            if (leftType == null || rightType == null) {
                this.checker.errorReporter.simpleError(binex, "Could not typecheck arithmetic operation.  Possible recursive typecheck error?");
                binex.type = this.anyType;
                return binex;
            }
            var nodeType = binex.nodeType;

            if (this.checker.isNullOrUndefinedType(leftType)) {
                leftType = rightType;
            }
            if (this.checker.isNullOrUndefinedType(rightType)) {
                rightType = leftType;
            }
            leftType = this.checker.widenType(leftType);
            rightType = this.checker.widenType(rightType);

            if (nodeType == NodeType.Add || nodeType == NodeType.AsgAdd) {

                if (leftType == this.checker.stringType || rightType == this.checker.stringType) {
                    binex.type = this.checker.stringType;
                }
                else if (leftType == this.checker.numberType && rightType == this.checker.numberType) {
                    binex.type = this.checker.numberType;
                }
                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {
                    binex.type = this.checker.numberType;
                }
                else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {
                    binex.type = this.checker.anyType;
                }
                else {
                    binex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,
                                                            binex.printLabel(), this.scope);
                }
            }
            else {
                if (leftType == this.checker.numberType && rightType == this.checker.numberType) {
                    binex.type = this.checker.numberType;
                }
                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {
                    binex.type = this.checker.numberType;
                }
                else if (leftType == this.checker.anyType || rightType == this.checker.anyType) {
                    binex.type = this.checker.numberType;
                }
                else {
                    binex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,
                                                            binex.printLabel(), this.scope);
                }
            }

            return binex;
        }

        public typeCheckDotOperator(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            var leftIsFnc = false;
            binex.operand1 = this.typeCheck(binex.operand1);
            var leftType = binex.operand1.type;
            var leftScope: SymbolScope = null;
            // REVIEW: replace with get member scope
            if (leftType) {
                if (leftType == this.anyType) {
                    binex.type = this.anyType;
                    return binex;
                }
                else if (leftType == this.stringType) {
                    if (this.stringInterfaceType) {
                        leftScope = this.stringInterfaceType.memberScope;
                    }
                    else {
                        binex.type = this.anyType;
                        return binex;
                    }
                }
                else if (leftType == this.doubleType) {
                    if (this.numberInterfaceType) {
                        leftScope = this.numberInterfaceType.memberScope;
                    }
                    else {
                        binex.type = this.anyType;
                        return binex;
                    }
                }
                else if (leftType == this.booleanType) {
                    if (this.booleanInterfaceType) {
                        leftScope = this.booleanInterfaceType.memberScope;
                    }
                    else {
                        binex.type = this.anyType;
                        return binex;
                    }
                }
                else if ((leftType.call || leftType.construct) && leftType.members == null) {
                    if (this.functionInterfaceType) {
                        leftScope = this.functionInterfaceType.memberScope;
                    }
                    else {
                        binex.type = this.anyType;
                        return binex;
                    }
                }
                else if (leftType.elementType) {
                    if (this.arrayInterfaceType) {
                        var arrInstType = leftType.elementType.getArrayBase(this.arrayInterfaceType, this.checker);
                        leftScope = arrInstType.memberScope;
                    }
                    else {
                        binex.type = this.anyType;
                        return binex;
                    }
                }
                else {
                    leftScope = leftType.memberScope;
                }
            }
            if (leftScope == null) {
                this.checker.errorReporter.expectedClassOrInterface(binex);
                binex.type = this.anyType;
            }
            else {
                var propertyName = <Identifier>binex.operand2;
                var lhsIsEnclosingType = (this.thisClassNode && binex.operand1.type == this.thisClassNode.type.instanceType) || this.inTypeRefTypeCheck;
                var symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, this.inTypeRefTypeCheck); // only search the public members, unless the rhs is a 'this' pointer

                // If the symbol wasn't found, delegate to the appropriate 'virtual' parent type
                if (!symbol) {
                    if (this.objectInterfaceType && leftType) {
                        // check 'Object' for the symbol
                        if (leftType.isReferenceType()) {
                            symbol = this.objectInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);
                        }
                        if (!symbol) {
                            // check 'Function', if appropriate
                            if (this.functionInterfaceType && (leftType.call || leftType.construct)) {
                                symbol = this.functionInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);
                            }
                        }
                    }
                }

                if (!symbol || (!symbol.visible(leftScope, this.checker))) {
                    binex.type = this.anyType;

                    if (symbol == null) {
                        this.checker.errorReporter.simpleError(propertyName, "The property '" + propertyName.actualText + "' does not exist on value of type '" + leftType.getScopedTypeName(this.scope) + "'");
                    }
                    else if (!this.inTypeRefTypeCheck) {  // if it's a dotted type reference, we'll catch the visibility error during binding
                        this.checker.errorReporter.simpleError(binex, "The property '" + propertyName.actualText + " on type '" + leftType.getScopedTypeName(this.scope) + "' is not visible");
                    }
                }
                else {
                    if (symbol.isVariable()) {
                        if (symbol.isInferenceSymbol()) {
                            var infSym = <InferenceSymbol>symbol;
                            if (infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {
                                this.inScopeTypeCheckDecl(infSym.declAST);
                            }
                        }
                    }
                    propertyName.sym = symbol;
                    binex.type = symbol.getType();
                }
            }
            if (binex.type == null) {
                binex.type = this.anyType;
            }

            return binex;
        }

        public typeCheckBooleanOperator(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            if ((!(this.checker.sourceIsAssignableToTarget(leftType, rightType))) &&
                (!(this.checker.sourceIsAssignableToTarget(rightType, leftType)))) {
                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);
            }
            binex.type = this.booleanType;
            return binex;
        }

        public typeCheckAsgOperator(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            var applyTargetType = !binex.operand2.isParenthesized;
            binex.operand1 = this.typeCheck(binex.operand1);

            this.checker.typeCheckWithContextualType(binex.operand1.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, binex.operand2);

            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;

            if (!(this.astIsWriteable(binex.operand1))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }
            if (binex.operand1.nodeType == NodeType.Call) {
                var callEx = <CallExpression>binex.operand1;
            }
            var preserveScope = false;
            var preservedContainedScope = null;
            if (binex.operand2.type) {
                preservedContainedScope = binex.operand2.type.containedScope;
                preserveScope = true;
            }
            // Do not re-write the AST in provisional typecheck mode
            binex.operand2 = this.castWithCoercion(binex.operand2, leftType, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);
            if (preserveScope && binex.operand2.type.containedScope == null) {
                binex.operand2.type.containedScope = preservedContainedScope;
            }
            binex.type = rightType;
            return binex;
        }

        public typeCheckIndex(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            binex.operand1 = this.typeCheck(binex.operand1); // ObjExpr
            binex.operand2 = this.typeCheck(binex.operand2); // IndexExpr

            if (!this.checker.styleSettings.literalSubscript) {
                if (binex.operand2.nodeType == NodeType.QString) {
                    this.checker.errorReporter.styleError(ast, "use literal subscript ('.') notation instead)");
                }
            }

            var objExprType = binex.operand1.type;
            var indexExprType = binex.operand2.type;

            if (objExprType.elementType) { // arrays
                if (indexExprType == this.checker.anyType || indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)) {
                    binex.type = objExprType.elementType;
                }
                else if (indexExprType == this.checker.stringType) {
                    binex.type = this.checker.anyType;
                }
                else {
                    this.checker.errorReporter.simpleError(binex, "Illegal property access");
                    binex.type = this.checker.anyType;
                }
            }
            else if (objExprType.index) { // types with index sigs

                if (indexExprType == this.checker.anyType ||
                    !((objExprType.index.flags & SignatureFlags.IsStringIndexer) || (objExprType.index.flags & SignatureFlags.IsNumberIndexer)) || // REVIEW: unvalidated type expression
                    ((objExprType.index.flags & SignatureFlags.IsStringIndexer) && indexExprType == this.checker.stringType) ||
                    ((objExprType.index.flags & SignatureFlags.IsNumberIndexer) && (indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) {
                    var sig = this.resolveOverload(ast, objExprType.index);
                    if (sig) {
                        binex.type = sig.returnType.type;//objExprType.index.signatures[0].returnType.type;
                    }
                    else {
                        binex.type = this.checker.anyType;
                    }
                }
                else if (indexExprType == this.checker.stringType) {
                    binex.type = this.checker.anyType;
                }
                else {
                    this.checker.errorReporter.simpleError(binex, "Illegal property access");
                    binex.type = this.checker.anyType;
                }
            }
            else if ((objExprType == this.checker.anyType ||
                     objExprType == this.checker.stringType ||
                     objExprType == this.checker.numberType ||
                     objExprType == this.checker.booleanType ||
                     objExprType.isReferenceType()) &&
                     (indexExprType == this.checker.anyType ||
                      indexExprType == this.checker.stringType ||
                      (indexExprType == this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) { // REVIEW: Do we want to allow indexes of type 'number'?
                binex.type = this.checker.anyType;
            }
            else {
                this.checker.errorReporter.simpleError(binex, "Illegal property access");
                binex.type = this.checker.anyType;
            }

            return binex;
        }

        public typeCheckInOperator(binex: BinaryExpression): BinaryExpression {
            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.stringType);
            binex.operand2 = this.typeCheck(binex.operand2);

            if (!((binex.operand1.type == this.checker.anyType || binex.operand1.type == this.checker.stringType) &&
                    (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.objectInterfaceType)))) {
                this.checker.errorReporter.simpleError(binex, "The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type");
            }

            binex.type = this.booleanType;
            return binex;
        }

        public typeCheckShift(binex: BinaryExpression, assignment: bool): BinaryExpression {
            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.doubleType);
            binex.operand2 = this.cast(this.typeCheck(binex.operand2), this.doubleType);
            if (assignment && (!(this.astIsWriteable(binex.operand1)))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }
            binex.type = this.doubleType;
            return binex;
        }

        public typeCheckQMark(trinex: ConditionalExpression): ConditionalExpression {
            trinex.operand1 = this.typeCheck(trinex.operand1);
            trinex.operand2 = this.typeCheck(trinex.operand2);
            trinex.operand3 = this.typeCheck(trinex.operand3);
            var leftType = trinex.operand2.type;
            var rightType = trinex.operand3.type;

            if (leftType == rightType) {
                trinex.type = leftType;
            }
            else {
                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {
                    trinex.type = rightType;
                }
                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {
                    trinex.type = leftType;
                }
                else {
                    trinex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(trinex, leftType, rightType, trinex.printLabel(), this.scope);
                }
            }

            return trinex;
        }

        public addFormals(container: Symbol, signature: Signature,
            table: IHashTable) {
            var len = signature.parameters.length;
            for (var i = 0; i < len; i++) {
                var symbol = <ParameterSymbol>signature.parameters[i];
                symbol.container = container;
                table.add(symbol.name, symbol);
            }
        }

        // REVIEW: We use isModContainer instead of container.getType().isModuleType because container.type may be null at this
        // juncture
        public addLocalsFromScope(scope: SymbolScope, container: Symbol, vars: ASTList, table: IHashTable, isModContainer: bool) {
            var len = vars.members.length;
            var hasArgsDef = false;
            for (var i = 0; i < len; i++) {
                var local = <VarDecl>vars.members[i];
                if (((local.sym == null) || (local.sym.kind() != SymbolKind.Field))) {
                    var result: Symbol = null;
                    if ((result = table.lookup(local.id.text)) == null) {
                        var localVar: ValueLocation = new ValueLocation();
                        localVar.typeLink = new TypeLink();
                        var varSym = null;

                        if (hasFlag(local.varFlags, VarFlags.Static)) {
                            local.varFlags |= VarFlags.LocalStatic;
                            varSym = new FieldSymbol(local.id.text, local.minChar,
                                                      this.checker.locationInfo.unitIndex,
                                                      true, localVar);
                        }
                        else {
                            varSym = new VariableSymbol(local.id.text, local.minChar,
                                                      this.checker.locationInfo.unitIndex,
                                                      localVar);
                        }
                        varSym.transferVarFlags(local.varFlags);
                        localVar.symbol = varSym;
                        varSym.declAST = local;
                        localVar.typeLink.ast = local.typeExpr;
                        this.checker.resolveTypeLink(scope, localVar.typeLink, false);
                        if ((local.type == null) && (local.init == null)) {
                            local.type = this.anyType;
                        }
                        localVar.typeLink.type = local.type;
                        localVar.symbol.container = container;
                        local.sym = localVar.symbol;
                        table.add(local.id.text, varSym);
                        if (local.id.text == "arguments") {
                            hasArgsDef = true;
                        }
                    }
                    else {
                        local.type = result.getType();
                        local.sym = result;
                    }
                }
            }
            if (!isModContainer) {
                if (!hasArgsDef) {
                    var argLoc = new ValueLocation();
                    argLoc.typeLink = new TypeLink();
                    var theArgSym = new VariableSymbol("arguments", vars.minChar,
                                                     this.checker.locationInfo.unitIndex,
                                                     argLoc);

                    // if the user is using a custom lib.d.ts where IArguments has not been defined
                    // (or they're compiling with the --nolib option), use 'any' as the argument type
                    if (!this.iargumentsInterfaceType) {
                        var argumentsSym = scope.find("IArguments", false, true);

                        if (argumentsSym) {
                            argumentsSym.flags |= SymbolFlags.CompilerGenerated;
                            this.iargumentsInterfaceType = argumentsSym.getType();
                        }
                        else {
                            this.iargumentsInterfaceType = this.anyType;
                        }
                    }
                    argLoc.typeLink.type = this.iargumentsInterfaceType;
                    table.add("arguments", theArgSym);
                }
            }
        }

        // REVIEW: isClass param may now be redundant
        public addConstructorLocalArgs(constructorDecl: FuncDecl, table: IHashTable, isClass: bool): void {
            var container = constructorDecl.type.symbol;
            var args = constructorDecl.arguments;
            if (args) {
                var len = args.members.length;
                for (var i = 0; i < len; i++) {
                    var local = <ArgDecl>args.members[i];
                    if ((local.sym == null) ||
                        (isClass || (local.sym.kind() != SymbolKind.Field))) {
                        var result: Symbol = null;
                        if ((result = table.lookup(local.id.text)) == null) {
                            this.resolveBoundDecl(local);
                            var localVar: ValueLocation = new ValueLocation();
                            localVar.typeLink = new TypeLink();
                            var varSym = new ParameterSymbol(local.id.text, local.minChar,
                                                                   this.checker.locationInfo.unitIndex,
                                                                   localVar);
                            varSym.funcDecl = constructorDecl;
                            varSym.declAST = local;
                            localVar.symbol = varSym;
                            localVar.typeLink.type = local.type;
                            localVar.symbol.container = container;
                            local.sym = localVar.symbol;
                            table.add(local.id.text, varSym);
                        }
                        else {
                            local.type = result.getType();
                            local.sym = result;
                        }
                    }
                }
            }
        }

        public checkInitSelf(funcDecl: FuncDecl): bool {
            if (!funcDecl.isMethod()) {
                var freeVars = funcDecl.freeVariables;
                for (var k = 0, len = freeVars.length; k < len; k++) {
                    var sym = freeVars[k];
                    if (sym.isInstanceProperty()) {
                        return true;
                    }
                }
            }
            var fns = funcDecl.scopes;
            var fnsLen = fns.members.length;

            for (var j = 0; j < fnsLen; j++) {
                var fn = <FuncDecl>fns.members[j];
                if (this.checkInitSelf(fn)) {
                    return true;
                }
            }
            return false;
        }

        public checkPromoteFreeVars(funcDecl: FuncDecl, constructorSym: Symbol): void {
            var freeVars = funcDecl.freeVariables;
            for (var k = 0, len = freeVars.length; k < len; k++) {
                var sym = freeVars[k];
                if ((!sym.isInstanceProperty()) && (sym.container == constructorSym)) {
                    instanceFilter.reset();
                    if (this.scope.search(instanceFilter, sym.name, false, false)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variable shadows class property '" + sym.name + "'. To access the class property, use 'self." + sym.name + "'");
                    }

                    this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable '" + sym.name + "' to a class property")
                }
            }
        }

        public allReturnsAreVoid(funcDecl: FuncDecl) {
            // in the case of a function or method with no declared return type, walk the body to 
            // pre-emptively determine if the function has a return type of void
            //
            // REVIEW: Eventually, we'll want to perform exit graph analysis to determine
            // if the function ever "escapes" without a return expression
            // This would require moving some of this logic into the function's typecheck-proper,
            // which would slow things down a fair bit, but would open up more analysis opportunities
            var allReturnsAreVoid = true;

            if (funcDecl.signature.returnType.type == null) {
                var preFindReturnExpressionTypes = function (ast: AST, parent: AST, walker: IAstWalker) {
                    var go = true;
                    switch (ast.nodeType) {
                        case NodeType.FuncDecl:
                            // don't recurse into a function decl - we don't want to confuse a nested
                            // return type with the top-level function's return type
                            go = false;
                            break;
                        case NodeType.Return:
                            var returnStmt: ReturnStatement = <ReturnStatement>ast;

                            if (returnStmt.returnExpression) {
                                allReturnsAreVoid = false;
                                go = false;
                            }

                        default:
                            break;
                    }
                    walker.options.goChildren = go;
                    walker.options.goNextSibling = go;
                    return ast;
                }

                getAstWalkerFactory().walk(funcDecl.bod, preFindReturnExpressionTypes);
            }

            return allReturnsAreVoid;
        }

        public classConstructorHasSuperCall(funcDecl: FuncDecl) {
            var foundSuper = false;

            var preFindSuperCall = function (ast: AST, parent: AST, walker: IAstWalker) {

                var go = true;

                switch (ast.nodeType) {
                    case NodeType.FuncDecl:
                        go = false;
                        break;
                    case NodeType.Call:
                        var call = <CallExpression>ast;

                        if (call.target.nodeType == NodeType.Super) {
                            go = false;
                            foundSuper = true;
                            break;
                        }
                        break;
                    default:
                        break;
                }
                walker.options.goChildren = go;
                return ast;
            }

            getAstWalkerFactory().walk(funcDecl.bod, preFindSuperCall);

            return foundSuper;
        }

        private baseListPrivacyErrorReporter(bases: ASTList, i: number, declSymbol: Symbol, extendsList: bool, typeName: string, isModuleName: bool) {
            var baseSymbol = bases.members[i].type.symbol;
            var declTypeString = (declSymbol.declAST.nodeType == NodeType.InterfaceDeclaration) ? "interface" : "class";
            var baseListTypeString = extendsList ? "extends" : "implements";
            var baseTypeString = (baseSymbol.declAST.nodeType == NodeType.InterfaceDeclaration) ? "interface" : "class";
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module ";
                baseTypeString = " " + baseTypeString + " from private module " + quotestring + typeName + quotestring;
            } else {
                baseTypeString = " private " + baseTypeString + " '" + typeName + "'";
            }
            this.checker.errorReporter.simpleError(bases.members[i], "exported " + declTypeString + " '" + declSymbol.name + "' " + baseListTypeString + baseTypeString);
        }

        // Check if declSymbol can satisfy baselist privacy
        private typeCheckBaseListPrivacy(bases: ASTList, declSymbol: Symbol, extendsList: bool) {
            if (bases) {
                var basesLen = bases.members.length;
                for (var i = 0; i < basesLen; i++) {
                    if (!bases.members[i].type || bases.members[i].type == this.checker.anyType) {
                        // This type is coming from external module so it has to be exported, or we're recovering from an
                        // error condition
                        continue;
                    }

                    this.checkSymbolPrivacy(bases.members[i].type.symbol, declSymbol, (typeName: string, isModuleName: bool) => this.baseListPrivacyErrorReporter(bases, i, declSymbol, extendsList, typeName, isModuleName));
                }
            }
        }

        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container
        private checkSymbolPrivacy(typeSymbol: TypeSymbol, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName: bool) => void ) {
            var externalModuleSymbol: TypeSymbol = null;
            var declSymbolPath: Symbol[] = null;

            // Type is visible type, so this can be used by anyone.
            if (typeSymbol.isExternallyVisible(this.checker)) {
                // Symbol could be from external module, go ahead and find the external module
                var typeSymbolPath = typeSymbol.pathToRoot();
                declSymbolPath = declSymbol.pathToRoot();
                var typeSymbolLength = typeSymbolPath.length;
                var declSymbolPathLength = declSymbolPath.length;

                if (typeSymbolLength > 0) {
                    if (typeSymbolPath[typeSymbolLength - 1].getType().isModuleType() &&
                        (<TypeSymbol>typeSymbolPath[typeSymbolLength - 1]).isDynamic &&
                        typeSymbolPath[typeSymbolLength - 1] != declSymbolPath[declSymbolPathLength - 1]) {
                        // Symbol from external module that was imported using one of the import statement
                        externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 1];
                    } else if (typeSymbolLength > 1) {
                        // Is symbol from declared quoted module
                        if (typeSymbolPath[typeSymbolLength - 2].getType().isModuleType() &&
                            (<TypeSymbol>typeSymbolPath[typeSymbolLength - 2]).isDynamic &&
                            (declSymbolPathLength == 1 || typeSymbolPath[typeSymbolLength - 2] != declSymbolPath[declSymbolPathLength - 2])) {
                            // From quoted module name
                            externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 2];
                        }
                    }
                }

                if (externalModuleSymbol == null) {
                    return;
                }
            }

            // Interface symbol doesn't reflect correct Exported state so use AST instead
            var interfaceDecl: InterfaceDeclaration = declSymbol.getInterfaceDeclFromSymbol(this.checker);
            if (interfaceDecl && !hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {
                return;
            }

            var checkVisibilitySymbol = declSymbol;
            // Var decl symbol doesnt reflect correct exported state so use AST instead
            var varDecl = declSymbol.getVarDeclFromSymbol();
            if (varDecl) {
                if (hasFlag(varDecl.varFlags, VarFlags.Private)) {
                    return;
                } else if (hasFlag(varDecl.varFlags, VarFlags.Public)) {
                    // Its a member from class so check visibility of its container
                    checkVisibilitySymbol = declSymbol.container;
                }
            }

            // If the container is visible from global scrope it is error
            if (checkVisibilitySymbol.isExternallyVisible(this.checker)) {
                var privateSymbolName = typeSymbol.name;

                // If imported typeSymbol mark it as visible externally and verify that the symbol it imports is visible externally
                if (externalModuleSymbol != null) {
                    var prettyName = externalModuleSymbol.getPrettyNameOfDynamicModule(declSymbolPath);
                    if (prettyName != null) {
                        this.currentScript.AddExternallyVisibleImportedSymbol(prettyName.symbol, this.checker);
                        return;
                    } else {
                        privateSymbolName = externalModuleSymbol.prettyName;
                    }
                }

                // Visible declaration using non visible type.
                errorCallback(privateSymbolName, typeSymbol.name != privateSymbolName);
            }
        }

        // Checks if the privacy is satisfied by type that is used in the declaration inside container
        private checkTypePrivacy(type: Type, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName : bool) =>void ) {
            // Primitive types
            if (!(type && type.primitiveTypeClass == Primitive.None)) {
                return;
            }


            // If type is array, check element type
            if (type.isArray()) {
                return this.checkTypePrivacy(type.elementType, declSymbol, errorCallback);
            }

            // Going to be printing symbol name, verify if symbol can be emitted
            if (type.symbol && type.symbol.name && type.symbol.name != "_anonymous" &&
                        (((type.call == null) && (type.construct == null) && (type.index == null)) ||
                        (type.members && (!type.isClass())))) {
                return this.checkSymbolPrivacy(<TypeSymbol>type.symbol, declSymbol, errorCallback);
            }

            if (type.members) {
                // Verify symbols for members
                type.members.allMembers.map((key, s, unused) => {
                    var sym = <Symbol>s;
                    if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {
                        this.checkTypePrivacy(sym.getType(), declSymbol, errorCallback);
                    }
                }, null);
            }

            this.checkSignatureGroupPrivacy(type.call, declSymbol, errorCallback);
            this.checkSignatureGroupPrivacy(type.construct, declSymbol, errorCallback);
            this.checkSignatureGroupPrivacy(type.index, declSymbol, errorCallback);
        }

        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container
        private checkSignatureGroupPrivacy(sgroup: SignatureGroup, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName : bool) =>void ) {
            if (sgroup) {
                var len = sgroup.signatures.length;
                for (var i = 0; i < sgroup.signatures.length; i++) {
                    var signature = sgroup.signatures[i];
                    if (len > 1 && signature == sgroup.definitionSignature) {
                        // In case of overloads don't look up for overload defintion types.
                        continue;
                    }

                    if (signature.returnType) {
                        this.checkTypePrivacy(signature.returnType.type, declSymbol, errorCallback);
                    }

                    var paramLen = signature.parameters.length;
                    for (var j = 0; j < paramLen; j++) {
                        var param = signature.parameters[j];
                        this.checkTypePrivacy(param.getType(), declSymbol, errorCallback);
                    }
                }
            }
        }

        private functionArgumentPrivacyErrorReporter(funcDecl: FuncDecl, p: number, paramSymbol: Symbol, typeName: string, isModuleName: bool) {
            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);
            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);
            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);
            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }

            if (!isContainerInterface) {
                if (funcDecl.isConstructor) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported class's constructor parameter '" + paramSymbol.name + "'" + typestring);
                } else if (isSetter) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " setter parameter '" + paramSymbol.name + "'" + typestring);
                } else if (!isGetter) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " function parameter '" + paramSymbol.name + "'" + typestring);
                }
            } else {
                if (funcDecl.isConstructMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's constructor parameter '" + paramSymbol.name + "'" + typestring);
                } else if (funcDecl.isCallMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's call parameter '" + paramSymbol.name + "'" + typestring);
                } else if (!funcDecl.isIndexerMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's function parameter '" + paramSymbol.name + "'" + typestring);
                }
            }
        }

        private returnTypePrivacyError(astError: AST, funcDecl: FuncDecl, typeName: string, isModuleName: bool) {
            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);
            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);
            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);
            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) != null;
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }
            if (!isContainerInterface) {
                if (isGetter) {
                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " getter return type" + typestring);
                } else if (!isSetter) {
                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " function return type" + typestring);
                }
            } else {
                if (funcDecl.isConstructMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's constructor return type" + typestring);
                } else if (funcDecl.isCallMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's call return type" + typestring);
                } else if (funcDecl.isIndexerMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's indexer return type" + typestring);
                } else {
                    this.checker.errorReporter.simpleError(astError, "exported interface's function return type" + typestring);
                }
            }
        }

        private functionReturnTypePrivacyErrorReporter(funcDecl: FuncDecl, signature: Signature, typeName: string, isModuleName: bool) {
            var reportOnFuncDecl = false;

            // Error coming from return annotation
            if (funcDecl.returnTypeAnnotation != null &&
                funcDecl.returnTypeAnnotation.type == signature.returnType.type) {
                this.returnTypePrivacyError(funcDecl.returnTypeAnnotation, funcDecl, typeName, isModuleName);
            }

            // Check if return statement's type matches the one that we concluded
            for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {
                if (funcDecl.returnStatementsWithExpressions[i].type == signature.returnType.type) {
                    this.returnTypePrivacyError(funcDecl.returnStatementsWithExpressions[i], funcDecl, typeName, isModuleName);
                } else {
                    reportOnFuncDecl = true;
                }
            }

            if (reportOnFuncDecl) {
                // Show on function decl
                this.returnTypePrivacyError(funcDecl, funcDecl, typeName, isModuleName);
            }
        }

        public typeCheckFunction(funcDecl: FuncDecl): FuncDecl {
            this.nestingLevel = 0;
            var fnType = funcDecl.type;

            var fgSym = fnType.symbol;
            var signature = funcDecl.signature;

            if (this.checker.typeStatusIsFinished(signature.typeCheckStatus)) {
                return funcDecl;
            }
            else if (signature.typeCheckStatus == TypeCheckStatus.Started) {
                if (!funcDecl.returnTypeAnnotation &&
                    funcDecl.bod &&
                       !funcDecl.isSignature() &&
                       !(funcDecl.isConstructor) &&
                       this.allReturnsAreVoid(funcDecl)) {

                    signature.returnType.type = this.voidType;
                    return funcDecl;
                }
                else {
                    if (funcDecl.returnTypeAnnotation == null) {
                        if (this.checker.styleSettings.implicitAny) {
                            this.checker.errorReporter.styleError(funcDecl, "type implicitly set to 'any'");
                        }
                        signature.returnType.type = this.anyType;
                        fgSym.flags |= SymbolFlags.RecursivelyReferenced;
                    }
                    return funcDecl;
                }
            }

            signature.typeCheckStatus = TypeCheckStatus.Started;
            this.checker.addStartedPTO(signature);
            var prevScope = this.scope;
            var prevFnc = this.thisFnc;
            var prevMethodStatus = this.enclosingFncIsMethod;
            var prevClassNode = this.thisClassNode;
            this.enclosingFncIsMethod = funcDecl.isMethod() || funcDecl.isConstructor;
            this.thisFnc = funcDecl;
            var container = funcDecl.type.symbol;
            var prevThisType = this.thisType;
            var prevLocationInfo = this.checker.locationInfo;
            var funcTable: IHashTable = null;
            var acceptedContextualType = false;
            var targetParams: ParameterSymbol[] = null;
            var targetReturnType: Type = null;
            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);
            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);
            var accessorType: Type = (isGetter || isSetter) && funcDecl.accessorSymbol ? funcDecl.accessorSymbol.getType() : null;
            var prevModDecl = this.checker.currentModDecl;

            if (funcDecl.isConstructor && !funcDecl.isOverload) {
                if (fnType.instanceType == null) {
                    this.checker.errorReporter.simpleError(funcDecl, "Malformed function body (is this a class named the same as an existing interface?)");
                    return funcDecl;
                }

                this.scope = fnType.instanceType.constructorScope;
                var ssb = <SymbolScopeBuilder>this.scope;
                funcTable = ssb.valueMembers.allMembers;
            }
            else if ((funcDecl.isSpecialFn() && !(funcDecl.fncFlags & FncFlags.Signature)) || funcDecl.isOverload) {
                funcTable = funcDecl.symbols;
                // if the function is static, we just want to use the 
                // current scope
                if (!hasFlag(funcDecl.fncFlags, FncFlags.Static) && fnType.containedScope) {
                    this.scope = fnType.containedScope;
                }
            }
            else {
                if (funcDecl.bod) {
                    this.scope = fnType.containedScope;
                }
                var ssb = <SymbolScopeBuilder>this.scope;

                // If it is null, it's an ambient declaration with no body, so it doesn't strictly matter
                // if funcTable is not set
                if (ssb && ssb.valueMembers) {
                    funcTable = ssb.valueMembers.allMembers;
                }
            }

            // If it's a class constructor, we need to check for the presence (or absense) of calls
            // to the 'super' constructor
            //
            // A super constructor call must exist if:
            //  - the class has a base class
            //
            // A super constructor call must be the first statement in the function body if:
            //  - the constructor has parameter properties or
            //  - the class body has initialized property decls
            //
            // A super constructor call may not exist if:
            //  - The class has no base type, or inherits directly from 'Object'
            if (funcDecl.isConstructor && funcDecl.bod && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {

                var hasBaseType = hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseType);
                var noSuperCallAllowed = !hasBaseType || hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);
                var superCallMustBeFirst = hasFlag((<ClassDeclaration>funcDecl.classDecl).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);

                if (noSuperCallAllowed && this.classConstructorHasSuperCall(funcDecl)) {
                    this.checker.errorReporter.simpleError(funcDecl, "Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class");
                }
                else if (hasBaseType) {
                    if (superCallMustBeFirst) {
                        if (!funcDecl.bod ||
                            !funcDecl.bod.members.length ||
                            !((funcDecl.bod.members[0].nodeType == NodeType.Call && (<CallExpression>funcDecl.bod.members[0]).target.nodeType == NodeType.Super) ||
                            (hasFlag(funcDecl.bod.flags, ASTFlags.StrictMode) && funcDecl.bod.members.length > 1 &&
                             funcDecl.bod.members[1].nodeType == NodeType.Call && (<CallExpression>funcDecl.bod.members[1]).target.nodeType == NodeType.Super))) {
                            this.checker.errorReporter.simpleError(funcDecl, "If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor");
                        }
                    }
                    else if (!this.classConstructorHasSuperCall(funcDecl)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Constructors for derived classes must contain a call to the class's 'super' constructor");
                    }
                }
            }

            // If we've typechecked this method "out of order" (not by walking the class, but through a method call somewhere else),
            // we need to reset the current class node in question, so that visibility checks on class members don't fail
            if (funcDecl.isMethod() && funcDecl.type.enclosingType) {

                var enclosingClassNode: TypeDeclaration = null;

                if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.FuncDecl) {
                    enclosingClassNode = <TypeDeclaration>(<FuncDecl>funcDecl.type.enclosingType.symbol.declAST).classDecl;
                }
                else if (funcDecl.type.enclosingType.symbol.declAST.nodeType == NodeType.ClassDeclaration) {
                    enclosingClassNode = <TypeDeclaration>funcDecl.type.enclosingType.symbol.declAST;
                }

                if (enclosingClassNode) {
                    this.thisClassNode = enclosingClassNode;
                }
            }

            // if this function is contained in a module, we may be in the midst of a recursive typecheck operation
            // should that be the case, we need to properly set the current module (for visibility tests)
            if (fnType.enclosingType) {;
                var enclosingSym = fnType.symbol.container;

                // if the enclosing type is a class, grab the parent module
                if (enclosingSym && enclosingSym.isType() && enclosingSym.getType().isClass()) {
                    enclosingSym = enclosingSym.container;
                }

                if (enclosingSym && enclosingSym.declAST && enclosingSym.declAST.nodeType == NodeType.ModuleDeclaration) {
                    this.checker.currentModDecl = <ModuleDeclaration>enclosingSym.declAST;
                }
            }

            if (funcDecl.unitIndex > 0) {
                if (this.checker.units &&
                    (funcDecl.unitIndex < this.checker.units.length)) {
                    this.checker.locationInfo = this.checker.units[funcDecl.unitIndex];
                }
                else {
                    this.checker.locationInfo = unknownLocationInfo;
                }
            }

            if (fnType.enclosingType) {
                this.thisType = fnType.enclosingType;
            }
            else {
                this.thisType = prevThisType;
            }

            var paramLen = signature.parameters.length;

            if (!funcDecl.isConstructor && funcDecl.bod && !funcDecl.isSignature()) {
                var tmpParamScope = this.scope;
                var ssb = <SymbolScopeBuilder>this.scope;

                // Attempt to contextually type the function declaration             
                if (!funcDecl.isMethod() && funcDecl.returnTypeAnnotation == null) {

                    // the funcDecl may be a candidate for contextual typing                 
                    // REVIEW: prevScope will only be null in the case of an upstream error
                    if (prevScope && funcDecl.name && !funcDecl.name.isMissing()) {
                        // Go ahead and check for an ambient symbol
                        var considerSym: Symbol = prevScope.findAmbient(funcDecl.name.text, false, false);

                        if (considerSym && considerSym.declAST && considerSym.declAST.type) {
                            // REVIEW: Ambients beget signatures, and signatures don't need to be typechecked
                            //typeCheck(considerSym.declAST);
                            this.checker.setContextualType(considerSym.declAST.type, false);
                        }
                    }

                    if (this.checker.hasTargetType()) {
                        var candidateTypeContext = this.checker.getTargetTypeContext();
                        var candidateType = candidateTypeContext.contextualType;

                        if (this.checker.canContextuallyTypeFunction(candidateType, funcDecl, true)) {

                            // Safe to do this, since the indices and fields are guaranteed to be
                            // non-null and valid by the above call to canContextuallyTypeFunction
                            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;
                            candidateTypeContext.targetSig = candidateSigs.signatures[0];
                            var candidateParams = candidateTypeContext.targetSig.parameters;

                            // the target type has been accepted
                            targetParams = candidateParams;
                            targetReturnType = candidateTypeContext.targetSig.returnType.type;

                            // Set "this" if applicable
                            if (candidateTypeContext.targetSig.declAST) {
                                if (candidateTypeContext.targetSig.declAST.isConstructor) {
                                    //candidateTypeContext.targetThis=candidateType.instanceType;
                                    //this.thisType = candidateType.instanceType;
                                    funcDecl.isTargetTypedAsMethod = true;
                                }
                                else if (candidateTypeContext.targetSig.declAST.isMethod()) {
                                    //candidateTypeContext.targetThis=candidateTypeContext.targetSig.declAST.type.enclosingType;
                                    //this.thisType = candidateTypeContext.targetSig.declAST.type.enclosingType;
                                    funcDecl.isTargetTypedAsMethod = true;
                                }
                            }
                            fgSym.type = candidateTypeContext.contextualType;
                            acceptedContextualType = true;
                        }
                        else if (candidateType && funcDecl.isAccessor()) {
                            accessorType = candidateType;
                            candidateTypeContext.targetAccessorType = accessorType;
                        }
                        else {
                            this.checker.killCurrentContextualType();
                        }
                    }
                }

                // typecheck parameters
                // Add parameter symbols to current scope for typechecking (in case default params reference each other)
                // Order matters here - default parameters can reference previously defined parameters
                var paramTable = ssb.valueMembers;
                this.scope = new SymbolScopeBuilder(paramTable, null, null, null, prevScope, container);

                for (var p = 0; p < paramLen; p++) {
                    var symbol = signature.parameters[p];
                    var ast = <ArgDecl>symbol.declAST

                    if (this.checker.hasTargetType() && (targetParams && (this.checker.getTargetTypeContext().targetSig.hasVariableArgList || p < targetParams.length))) {
                        var candidateTypeContext = this.checker.getTargetTypeContext();
                        var hasVarArgList = candidateTypeContext.targetSig.hasVariableArgList;
                        ast.type = hasVarArgList && p >= targetParams.length - 1 ? targetParams[targetParams.length - 1].getType().elementType : targetParams[p].getType();
                        ast.sym.setType(ast.type);
                        (<InferenceSymbol>ast.sym).typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                    }
                    else {
                        this.typeCheck(ast);
                    }

                    // infer the setter type, if necessary
                    if (isSetter && accessorType) {
                        ast = <ArgDecl>this.cast(ast, accessorType);
                    }

                    symbol.container = container;
                    // Verify the parameter for the privacy
                    this.checkTypePrivacy(symbol.getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, symbol, typeName, isModuleName));
                    paramTable.publicMembers.add(symbol.name, symbol);
                }
                this.scope = tmpParamScope;
            }
            else {
                this.typeCheck(funcDecl.arguments)

                // Because some terms were not yet type-checkable during binding, ensure that
                // param symbols are updated with the proper argument types
                for (var p = 0; p < paramLen; p++) {
                    signature.parameters[p].parameter.typeLink.type = funcDecl.arguments.members[p].type;
                    // Verify the parameter for the privacy
                    this.checkTypePrivacy(signature.parameters[p].getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, signature.parameters[p], typeName, isModuleName));
                    if ((<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym) {
                        (<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym.setType(funcDecl.arguments.members[p].type);
                    }
                }

                if ((funcDecl.fncFlags & FncFlags.IndexerMember)) {
                    if (!paramLen || paramLen > 1) {
                        this.checker.errorReporter.simpleError(funcDecl, "Index signatures may take one and only one parameter");
                    }
                    else if (funcDecl.arguments.members[0].type == this.checker.numberType) {
                        fnType.index.flags |= SignatureFlags.IsNumberIndexer;
                    }
                    else if (funcDecl.arguments.members[0].type == this.checker.stringType) {
                        fnType.index.flags |= SignatureFlags.IsStringIndexer;
                    }
                    else {
                        this.checker.errorReporter.simpleError(funcDecl.arguments.members[0], "Index signatures may only take 'string' or 'number' as their parameter");
                    }

                }
            }

            // typecheck body
            if (funcDecl.bod && (!funcDecl.isSignature())) {
                if (!(funcDecl.isConstructor)) {
                    this.addFormals(container, signature, funcTable);
                }
                else {
                    this.addConstructorLocalArgs(funcDecl, funcTable, hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod));

                    if (this.thisClassNode && this.thisClassNode.extendsList) {
                        var tmpScope = this.scope;
                        var funcMembers = new ScopedMembers(<DualStringHashTable>funcTable);
                        this.scope = new FilteredSymbolScopeBuilder(funcMembers, prevScope, funcDecl.type.symbol,
                                                             function (sym) {
                                                                 return sym.kind() == SymbolKind.Parameter;
                                                             });
                        this.typeCheckBaseCalls(this.thisClassNode.extendsList);
                        this.scope = tmpScope;
                    }
                }

                // Because this function may have been typechecked in a different visiblity context as its caller (e.g., this
                // function is being typechecked as a result of a call, before the declaration could be typechecked), we need
                // to set the enclosing module
                var prevMod = this.checker.currentModDecl;
                if (funcDecl.type &&
                    funcDecl.type.symbol &&
                    !funcDecl.isMethod() &&
                    funcDecl.type.symbol.declModule) {
                    this.checker.currentModDecl = funcDecl.type.symbol.declModule;
                }


                // unset the contextual type before typechecking the function body
                if (acceptedContextualType) {
                    this.checker.setContextualType(null, this.checker.inProvisionalTypecheckMode());
                }

                this.typeCheck(funcDecl.bod);

                if (acceptedContextualType) {
                    this.checker.unsetContextualType();
                }

                this.checker.currentModDecl = prevMod;

                if (this.checker.checkControlFlow) {
                    var cfg = funcDecl.buildControlFlow();
                    if (this.checker.printControlFlowGraph) {
                        cfg.print(this.checker.errorReporter.outfile);
                    }
                    cfg.reportUnreachable(this.checker.errorReporter);
                    if (this.checker.checkControlFlowUseDef) {
                        cfg.useDef(this.checker.errorReporter, funcDecl.type.symbol);
                    }
                }

                if (funcDecl.isConstructor) {
                    var fns: ASTList = funcDecl.scopes;
                    var fnsLen = fns.members.length;
                    var freeVars: Symbol[];
                    var sym: Symbol;
                    var j = 0;
                    for (; j < fnsLen; j++) {
                        var fn = <FuncDecl>fns.members[j];
                        if (!fn.isSignature()) {
                            if (hasFlag(fn.fncFlags, FncFlags.Method) && (!hasFlag(fn.fncFlags, FncFlags.Static))) {
                                this.checkPromoteFreeVars(fn, funcDecl.type.symbol);
                            }
                        }
                    }
                }
            }

            this.scope = prevScope;
            this.thisFnc = prevFnc;
            this.thisClassNode = prevClassNode;
            this.enclosingFncIsMethod = prevMethodStatus;
            this.thisType = prevThisType;
            this.checker.locationInfo = prevLocationInfo;
            this.checker.currentModDecl = prevModDecl;

            signature.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();

            // set the return type
            if (funcDecl.returnTypeAnnotation) {
                this.checkForVoidConstructor(funcDecl.returnTypeAnnotation.type, funcDecl.returnTypeAnnotation);

                if (signature.returnType.type == null) {
                    this.checker.resolveTypeLink(this.scope, signature.returnType, false);
                }
            }
            else if (targetReturnType) {
                signature.returnType.type = targetReturnType;
            }

            // If no return type annotation has been applied to the function declaration
            // unify the return types from the given return statements

            if (!(fgSym.flags & SymbolFlags.RecursivelyReferenced) && funcDecl.returnStatementsWithExpressions.length > 0) {
                var collection: ITypeCollection = {
                    getLength: () => { return funcDecl.returnStatementsWithExpressions.length; },
                    setTypeAtIndex: (index: number, type: Type) => { funcDecl.returnStatementsWithExpressions[index].type = type; },
                    getTypeAtIndex: (index: number) => { return funcDecl.returnStatementsWithExpressions[index].type; }
                }

                var bestCommonReturnType = funcDecl.returnStatementsWithExpressions[0].type;
                bestCommonReturnType = this.checker.findBestCommonType(bestCommonReturnType, null, collection, true);

                if (bestCommonReturnType) {
                    signature.returnType.type = this.checker.widenType(bestCommonReturnType);
                }
                else {
                    for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {
                        this.checker.errorReporter.simpleError(funcDecl.returnStatementsWithExpressions[i], "Incompatible return type");
                    }
                    signature.returnType.type = this.anyType;
                }
            }

            var onlyHasThrow = false;

            if (signature.returnType.type == null) {
                if (hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {
                    if (this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(funcDecl, "type implicitly set to 'any'");
                    }
                    signature.returnType.type = this.anyType;
                }
                else {
                    signature.returnType.type = this.voidType;
                }
            }
            else if (signature.returnType.type == this.nullType || signature.returnType.type == this.checker.undefinedType) {
                signature.returnType.type = this.anyType;
            }
            else if ((signature.returnType.type != this.voidType && signature.returnType.type != this.checker.undefinedType && signature.returnType.type != this.anyType)) {
                // the signature declared a non-void type, but there's no return statement
                if (!funcDecl.isSignature() &&
                    !funcDecl.isConstructor &&
                    !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression) &&
                    !hasFlag(funcDecl.fncFlags, FncFlags.IsFatArrowFunction)) {
                        // relax the restriction if the method only contains a single "throw" statement
                    onlyHasThrow = (funcDecl.bod.members.length > 0) && (funcDecl.bod.members[0].nodeType == NodeType.Throw)

                    if (!onlyHasThrow) {
                        this.checker.errorReporter.simpleError(funcDecl.returnTypeAnnotation || funcDecl,
                             "Function declared a non-void return type, but has no return expression");
                    }
                }

                // Type check for return type Privacy
                this.checkTypePrivacy(signature.returnType.type, container, (typeName: string, isModuleName: bool) => this.functionReturnTypePrivacyErrorReporter(funcDecl, signature, typeName, isModuleName));
            }

            // if the function declaration is a getter or a setter, set the type of the associated getter/setter symbol
            if (funcDecl.accessorSymbol) {
                var accessorType = funcDecl.accessorSymbol.getType();
                if (!onlyHasThrow && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {
                    this.checker.errorReporter.simpleError(funcDecl, "Getters must return a value");
                }
                if (accessorType) {
                    if ((hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && accessorType != signature.returnType.type) ||
                        (funcDecl.arguments.members.length > 0 && accessorType != funcDecl.arguments.members[0].type)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Getter and setter types do not agree");
                    }
                }
                else {
                    if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                        funcDecl.accessorSymbol.setType(signature.returnType.type);
                    }
                    else {
                        if (funcDecl.arguments.members.length != 1) {
                            this.checker.errorReporter.simpleError(funcDecl, "Setters may have one and only one argument");
                        }
                        else {
                            funcDecl.accessorSymbol.setType(funcDecl.arguments.members[0].type);
                        }
                    }
                }
            }

            this.typeCheckOverloadSignatures(fnType, funcDecl);
            return funcDecl;
        }

        public typeCheckBases(type: Type) {
            var seenInterface = false;
            var bases = type.extendsList;
            var baseLinks = type.extendsTypeLinks;
            if (bases) {
                var len = bases.length;

                if (len > 0) {
                    type.typeFlags |= TypeFlags.HasBaseType;
                }

                for (var i = 0; i < len; i++) {
                    if (bases[i] == this.checker.anyType) {
                        // This may be the type from imported module and hence the type was not really resolved to the correct one.
                        // Try resolving it again
                        baseLinks[i].type = null;
                        // There are no contextual errors when trying to verify the base class
                        var oldErrors = this.checker.errorReporter.getCapturedErrors();
                        CompilerDiagnostics.assert(oldErrors.length == 0, "There shouldnt be any contextual errors when typechecking base type names");
                        this.checker.errorReporter.pushToErrorSink = true;
                        bases[i] = this.checker.resolveBaseTypeLink(baseLinks[i], type.containedScope);
                        this.checker.errorReporter.pushToErrorSink = false;
                        this.checker.errorReporter.freeCapturedErrors();
                    }

                    var base = bases[i];
                    var baseRef = baseLinks[i].ast;

                    // make sure it's the global 'Object' and not some alias
                    var baseTypeOfObject = base.symbol && base.symbol.name == "Object" && base.symbol.container == this.checker.gloMod;

                    if (baseTypeOfObject) {
                        type.typeFlags |= TypeFlags.HasBaseTypeOfObject;
                    }

                    if (base.isClassInstance()) {
                        if (!(type.isClassInstance())) {
                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");
                        }
                        else {
                            if (seenInterface) {
                                this.checker.errorReporter.simpleError(baseRef, "Class may not follow interface as base type");
                            }
                        }
                    }
                    else if (base.isModuleType()) {
                        this.checker.errorReporter.simpleError(baseRef, "Types may not be derived from module types");
                    }
                    else if (base.members) {
                        if (!seenInterface) {
                            seenInterface = true;
                        }
                    }
                    else {
                        if (!(type.isClassInstance())) {
                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");
                        }
                        else {
                            this.checker.errorReporter.simpleError(baseRef, "Base type must be interface or class");
                        }
                        break;
                    }
                }
            }
        }

        public checkMembersImplementInterfaces(implementingType: Type) {
            var instanceType = implementingType.getInstanceType();
            if (instanceType.implementsList) {
                var len = instanceType.implementsList.length;

                for (var i = 0; i < len; i++) {
                    var interfaceType = instanceType.implementsList[i];
                    var comparisonInfo = new TypeComparisonInfo();
                    if (!this.checker.sourceIsSubtypeOfTarget(instanceType, interfaceType, comparisonInfo)) {
                        var emsg = "Class '" + instanceType.getTypeName() +
                              "' declares interface '" + interfaceType.getTypeName() +
                              "' but does not implement it";
                        if (!comparisonInfo.message) {
                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg);
                        }
                        else {
                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg + ": " + comparisonInfo.message);
                        }
                    }
                }
            }
        }

        public typeCheckBaseCalls(bases: ASTList) {
            if (bases == null) {
                return;
            }
            var basesLen = bases.members.length;
            for (var i = 0; i < basesLen; i++) {
                var baseExpr = bases.members[i];
                var baseSymbol: Symbol = null;
                if (baseExpr.nodeType == NodeType.Call) {
                    this.typeCheckNew(baseExpr);
                }
            }
        }

        public assertUniqueNamesInBaseTypes(names: IHashTable, type: Type, classDecl: InterfaceDeclaration, checkUnique: bool): void {
            if (type) {
                if (type.members) {
                    type.members.publicMembers.map((key, s, c) => {
                        var sym = <Symbol>s;
                        var dup = names.lookup(sym.name);
                        if (dup) {
                            if (checkUnique) {
                                this.checker.errorReporter.simpleError(classDecl,
                                                                  "duplicate member name in bases for " + classDecl.name.actualText + ": " + type.symbol.name + " and " + dup.container.name + " both contain member with name " + sym.name);
                            }
                        }
                        else {
                            names.add(sym.name, sym);
                        }
                    }, null);
                }
                if (type.extendsList) {
                    var len = type.extendsList.length;
                    for (var i = 0; i < len; i++) {
                        if (!(type.extendsList[i].symbol.flags & SymbolFlags.RecursivelyReferenced)) {
                            this.assertUniqueNamesInBaseTypes(names, type.extendsList[i], classDecl, checkUnique);
                        }
                    }
                }
            }
        }

        public checkBaseTypeMemberInheritance(derivedType: Type, derivedTypeDecl: AST): void {
            var instanceType = derivedType.getInstanceType();
            if (instanceType.extendsList == null) {
                return;
            }

            var len = instanceType.extendsList.length;
            if (len > 0) {
                var names = new StringHashTable();
                if (instanceType.isClassInstance()) {
                    for (var i = 0; i < len; i++) {
                        this.assertUniqueNamesInBaseTypes(names, instanceType.extendsList[i], <InterfaceDeclaration>derivedTypeDecl, i > 0);
                    }
                }

                if (instanceType.members) {
                    instanceType.members.publicMembers.map((key, s, c) => {
                        var sym = <Symbol>s;
                        for (var j = 0; j < len; j++) {
                            var base = instanceType.extendsList[j];
                            if (base.memberScope == null) {
                                this.checker.errorReporter.simpleError(derivedTypeDecl, "Base type '" + base.symbol.name + "' lacks an implementation.")
                            }
                            else {
                                var bSym = base.memberScope.find(sym.name, false, false);
                                if (bSym) {
                                    var aType = sym.getType();
                                    var bType = bSym.getType();
                                    if (!(this.checker.sourceIsSubtypeOfTarget(aType, bType))) {
                                        this.checker.errorReporter.simpleErrorFromSym(sym,
                                                                          "Type of overridden member '" + sym.name + "' is not subtype of original member defined by type '" + bSym.container.name + "'");
                                    }
                                    else if ((sym.kind() == SymbolKind.Type) &&
                                             (bSym.kind() == SymbolKind.Field)) {
                                        this.checker.errorReporter.simpleErrorFromSym(sym,
                                                                          "Cannot override field '" + sym.name + "' with method");
                                    }
                                }
                            }
                        }
                    }, null);
                }
            }
        }

        public typeCheckClass(classDecl: ClassDeclaration): ClassDeclaration {
            var typeSymbol = <TypeSymbol>classDecl.type.symbol;

            if (typeSymbol.typeCheckStatus == TypeCheckStatus.Finished) {
                return classDecl;
            }
            else if (typeSymbol.typeCheckStatus == TypeCheckStatus.Started) {
                // REVIEW: report this recursion
                //checker.errorReporter.recursionRequiresTypeAnnotation(classDecl);
                return classDecl;
            }
            else {
                typeSymbol.typeCheckStatus = TypeCheckStatus.Started;
                this.checker.addStartedPTO(typeSymbol);
            }

            var prevScope = this.scope;
            var svClassNode = this.thisClassNode;
            this.thisClassNode = classDecl;
            var classType = classDecl.type;
            this.typeCheckBases(classType.instanceType);

            this.typeCheckBaseListPrivacy(classDecl.extendsList, typeSymbol, true);
            this.typeCheckBaseListPrivacy(classDecl.implementsList, typeSymbol, false);

            var prevThisType = this.thisType;
            this.thisType = classType.instanceType;
            this.scope = classType.instanceType.containedScope;

            // Add the constructor locals, if necessary
            if (classDecl.constructorDecl) {
                this.scope = classType.instanceType.constructorScope;
                var ssb = <SymbolScopeBuilder>this.scope;
                var funcTable = ssb.valueMembers.allMembers;

                this.addConstructorLocalArgs(classDecl.constructorDecl, funcTable, true);
            }

            this.typeCheck(classDecl.members);
            typeSymbol.typeCheckStatus = TypeCheckStatus.Finished;
            this.checkBaseTypeMemberInheritance(classType, classDecl);
            this.checkMembersImplementInterfaces(classType);

            this.typeCheckOverloadSignatures(classType, classDecl);
            this.typeCheckOverloadSignatures(classType.instanceType, classDecl);

            // if the class has no declared constructor, adapt its base class's signature group, if necessary
            if (!classDecl.constructorDecl) {
                if (classDecl.extendsList &&
                    classDecl.extendsList.members.length &&
                    classDecl.extendsList.members[0].type &&
                    classDecl.extendsList.members[0].type.symbol.type.isClass()) {
                    cloneParentConstructGroupForChildType(classDecl.type, classDecl.extendsList.members[0].type.symbol.type);
                }
            }

            this.thisType = prevThisType;
            this.thisClassNode = svClassNode;
            this.scope = prevScope;
            return classDecl;
        }

        public typeCheckOverloadSignatures(type: Type, ast: AST) {
            if (type.call) {
                type.call.typeCheck(this.checker, ast, type.construct != null);
            }
            if (type.construct) {
                type.construct.typeCheck(this.checker, ast, false);
            }
            if (type.index) {
                type.index.typeCheck(this.checker, ast, false);
            }
        }

        public typeCheckInterface(interfaceDecl: InterfaceDeclaration): InterfaceDeclaration {
            // overloads will be typechecked inline by the members
            //this.typeCheckOverloadSignatures(interfaceDecl.type, interfaceDecl);
            this.typeCheckBases(interfaceDecl.type);
            this.typeCheckBaseListPrivacy(interfaceDecl.extendsList, interfaceDecl.type.symbol, true);
            this.typeCheck(interfaceDecl.members);
            this.checkBaseTypeMemberInheritance(interfaceDecl.type, interfaceDecl);

            // propagate base type signatures
            if (interfaceDecl.extendsList) {
                for (var i = 0; i < interfaceDecl.extendsList.members.length; i++) {
                    if (interfaceDecl.extendsList.members[i].type.call) {
                        if (interfaceDecl.type.call) {
                            interfaceDecl.type.call.signatures = interfaceDecl.type.call.signatures.concat(interfaceDecl.extendsList.members[i].type.call.signatures);
                        }
                        else {
                            interfaceDecl.type.call = interfaceDecl.extendsList.members[i].type.call;
                        }
                    }
                    if (interfaceDecl.extendsList.members[i].type.construct) {
                        if (interfaceDecl.type.construct) {
                            interfaceDecl.type.construct.signatures = interfaceDecl.type.construct.signatures.concat(interfaceDecl.extendsList.members[i].type.construct.signatures);
                        }
                        else {
                            interfaceDecl.type.construct = interfaceDecl.extendsList.members[i].type.construct;
                        }
                    }
                    if (interfaceDecl.extendsList.members[i].type.index) {
                        if (interfaceDecl.type.index) {
                            interfaceDecl.type.index.signatures = interfaceDecl.type.index.signatures.concat(interfaceDecl.extendsList.members[i].type.index.signatures);
                        }
                        else {
                            interfaceDecl.type.index = interfaceDecl.extendsList.members[i].type.index;
                        }
                    }
                }
            }

            return interfaceDecl;
        }

        public typeCheckImportDecl(importDecl: ImportDeclaration) {
            var mod: ModuleType = <ModuleType>importDecl.alias.type;
            var sym: TypeSymbol = null;
            var prevInImportTC = this.inImportTypeCheck;
            this.inImportTypeCheck = true;

            this.typeCheck(importDecl.alias);
            mod = <ModuleType>importDecl.alias.type;

            if (mod == null) {
                this.checker.errorReporter.simpleError(importDecl.alias, "Could not resolve module alias '" + importDecl.id.actualText + "'");
                mod = <ModuleType>this.checker.anyType;
                (<TypeSymbol>importDecl.id.sym).type = mod;
            }

            importDecl.id.type = mod;
            sym = mod.symbol;

            if (!mod.isModuleType()) {
                this.checker.errorReporter.simpleError(importDecl.alias, "A module cannot be aliased to a non-module type");
            }
            else {
                sym.type = mod;
                
                // Add the imported module to the AMD dependency list
                if (this.checker.typeFlow.currentScript && 
                    this.checker.typeFlow.currentScript.topLevelMod && 
                    this.checker.typeFlow.currentScript.topLevelMod.mod) 
                {
                    this.checker.typeFlow.currentScript.topLevelMod.mod.importedModules.push(importDecl);
                }

                (<TypeSymbol>importDecl.id.sym).type = mod;

                if (mod.symbol && mod.symbol.declAST) {
                    (<ModuleDeclaration>mod.symbol.declAST).modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;
                }

                //importDecl.id.sym = sym;
                // REVIEW: Uncomment when you can toggle module codegen targets from the language service
                //else if (typeFlow.checker.currentModDecl == null && 
                //            hasFlag((<ModuleDecl>sym.declAST).modFlags,ModuleFlags.IsDynamic) &&
                //            moduleGenTarget == ModuleGenTarget.Asynchronous) 
                //{
                //    typeFlow.checker.errorReporter.simpleError(alias, "In AMD codegen mode, dynamic modules may not be referenced from global scope.  (Wrap the file in a module declaration.)");
                //}
            }
            this.inImportTypeCheck = prevInImportTC;
            return importDecl;
        }

        public typeCheckModule(moduleDecl: ModuleDeclaration): ModuleDeclaration {

            // In some really nasty cases of error recovery, we may not have a type
            if (!moduleDecl.mod) {
                return moduleDecl;
            }

            if (this.currentScript) {
                this.currentScript.requiresGlobal = true;
            }
            var mod = moduleDecl.mod;
            var sym: TypeSymbol = null;

            var prevScope = this.scope;
            var prevThisType = this.thisType;
            var prevCurrentModDecl = this.checker.currentModDecl;
            this.checker.currentModDecl = moduleDecl;

            this.thisType = null;
            this.scope = mod.containedScope;
            this.typeCheck(moduleDecl.members);
            sym = mod.symbol;

            this.checker.currentModDecl = prevCurrentModDecl;
            this.thisType = prevThisType;
            this.scope = prevScope;

            moduleDecl.type = mod;

            if (sym) {
                sym.typeCheckStatus = TypeCheckStatus.Finished;
            }
            return moduleDecl;
        }

        public typeCheckFor(forStmt: ForStatement): ForStatement {
            forStmt.init = this.typeCheck(forStmt.init);
            this.nestingLevel++;
            forStmt.cond = this.typeCheck(forStmt.cond);
            this.typeCheckCondExpr(forStmt.cond);
            forStmt.incr = this.typeCheck(forStmt.incr);
            this.nestingLevel--;
            forStmt.body = this.typeCheck(forStmt.body);
            this.typeCheckCompoundStmtBlock(forStmt.body, "for statement");
            forStmt.type = this.voidType;
            return forStmt;
        }

        public typeCheckWith(withStmt: WithStatement): WithStatement {
            if (this.checker.errorsOnWith) {
                this.checker.errorReporter.simpleError(withStmt.expr, "All symbols within a 'with' block will be typed as 'any'");
            }
            withStmt.expr = this.typeCheck(withStmt.expr);
            this.checker.inWith = true;
            withStmt.body = this.typeCheck(withStmt.body);
            this.typeCheckCompoundStmtBlock(withStmt.body, "with statement");
            this.checker.inWith = false;
            return withStmt;
        }

        public typeCheckForIn(forInStmt: ForInStatement): ForInStatement {
            forInStmt.obj = this.typeCheck(forInStmt.obj);
            forInStmt.lval = this.cast(this.typeCheck(forInStmt.lval), this.checker.stringType);
            if (forInStmt.lval.nodeType == NodeType.VarDecl) {

                var varDecl = <VarDecl>forInStmt.lval;
                if (varDecl.typeExpr) {
                    this.checker.errorReporter.simpleError(varDecl, "Variable declarations for for/in expressions may not contain a type annotation");
                }

                if (varDecl.sym) {
                    varDecl.sym.setType(this.checker.stringType);
                }
            }
            forInStmt.body = this.typeCheck(forInStmt.body);
            this.typeCheckCompoundStmtBlock(forInStmt.body, "for in statement");
            return forInStmt;
        }

        public typeCheckWhile(whileStmt: WhileStatement): WhileStatement {
            whileStmt.cond = this.typeCheck(whileStmt.cond);
            this.typeCheckCondExpr(whileStmt.cond);
            whileStmt.body = this.typeCheck(whileStmt.body);
            this.typeCheckCompoundStmtBlock(whileStmt.body, "while statement");
            whileStmt.type = this.voidType;
            return whileStmt;
        }

        public typeCheckDoWhile(doWhileStmt: DoWhileStatement): DoWhileStatement {
            doWhileStmt.cond = this.typeCheck(doWhileStmt.cond);
            this.typeCheckCondExpr(doWhileStmt.cond);
            doWhileStmt.body = this.typeCheck(doWhileStmt.body);
            this.typeCheckCompoundStmtBlock(doWhileStmt.body, "do while statement");
            doWhileStmt.type = this.voidType;
            return doWhileStmt;
        }

        public typeCheckCondExpr(cond: AST) {
            if (this.checker.styleSettings.assignmentInCond) {
                if ((cond !== null) &&
                    (cond.nodeType >= NodeType.Asg) &&
                    (cond.nodeType <= NodeType.LastAsg)) {
                    this.checker.errorReporter.simpleError(cond, "top-level assignment statement in conditional expression");
                }
            }
        }

        public typeCheckCompoundStmtBlock(stmts: AST, stmtType: string) {
            if (this.checker.styleSettings.blockInCompoundStmt && stmts) {
                if (stmts.nodeType != NodeType.Block) {
                    this.checker.errorReporter.styleError(stmts, stmtType + " requires a block");
                }
            }
        }
        public typeCheckIf(ifStmt: IfStatement): IfStatement {
            ifStmt.cond = this.typeCheck(ifStmt.cond);
            this.typeCheckCondExpr(ifStmt.cond);
            ifStmt.thenBod = this.typeCheck(ifStmt.thenBod);
            ifStmt.elseBod = this.typeCheck(ifStmt.elseBod);
            this.typeCheckCompoundStmtBlock(ifStmt.thenBod, "if statement");
            this.typeCheckCompoundStmtBlock(ifStmt.elseBod, "if statement");
            ifStmt.type = this.voidType;
            return ifStmt;
        }

        public typeFromAccessorFuncDecl(funcDecl: FuncDecl) {
            if (!funcDecl.isAccessor()) {
                return null;
            }

            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                return funcDecl.type.call.signatures[0].returnType.type;
            }
            else {
                return funcDecl.type.call.signatures[0].parameters[0].getType();
            }
        }

        public typeCheckObjectLit(objectLit: UnaryExpression): void {

            var resultType = new Type();
            resultType.symbol = new TypeSymbol(this.checker.anon, objectLit.minChar,
                                             objectLit.limChar - objectLit.minChar,
                                             this.checker.locationInfo.unitIndex,
                                             resultType);

            resultType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            resultType.memberScope = new SymbolTableScope(resultType.members, null, null, null, null);

            var aggScope = new SymbolAggregateScope(resultType.symbol);
            aggScope.addParentScope(resultType.memberScope);
            aggScope.addParentScope(this.scope);
            resultType.containedScope = aggScope;
            var memberDecls = <ASTList>objectLit.operand;
            var prevThisType = this.thisType;
            var acceptTargetType = false;
            var targetType: Type = null;

            if (this.checker.hasTargetType()) {
                targetType = this.checker.getTargetTypeContext().contextualType;

                if (targetType && targetType.symbol && !this.checker.typeStatusIsFinished(targetType.symbol.typeCheckStatus)) {
                    if (targetType.symbol.declAST) {
                        this.typeCheck(targetType.symbol.declAST);
                    }
                }
                acceptTargetType = true;
            }

            if (memberDecls) {
                for (var i = 0, len = memberDecls.members.length; i < len; i++) {

                    var binex = <BinaryExpression>memberDecls.members[i];

                    var id = binex.operand1;
                    var text: string;
                    var targetMember: Symbol = null;
                    var fieldSymbol: FieldSymbol = null;

                    if (id.nodeType == NodeType.Name) {
                        text = (<Identifier>id).text;
                    }
                    else if (id.nodeType == NodeType.QString) {
                        // TODO: set text to unescaped string
                        var idText = (<StringLiteral>id).text;
                        text = idText.substring(1, idText.length - 1);
                    }
                    else {
                        this.checker.errorReporter.simpleError(objectLit,
                                                          "malformed object literal");
                        resultType = this.anyType;
                        break;
                    }

                    if (acceptTargetType && targetType.memberScope) {
                        targetMember = targetType.memberScope.find(text, false, false);
                    }

                    // before typechecking an accessor function member, we need to initialize its accessor symbol
                    if (binex.operand2.nodeType == NodeType.FuncDecl && (<FuncDecl>binex.operand2).isAccessor()) {

                        var funcDecl = <FuncDecl>binex.operand2;
                        var accessorSym: FieldSymbol = resultType.members.publicMembers.lookup(text);

                        accessorSym = this.checker.createAccessorSymbol(funcDecl, accessorSym, resultType, true, false, resultType.memberScope, null);
                        funcDecl.accessorSymbol = accessorSym;
                        fieldSymbol = accessorSym;
                        if (id.nodeType == NodeType.Name) {
                            (<Identifier>id).sym = accessorSym;
                        }
                    }

                    this.checker.typeCheckWithContextualType(acceptTargetType && targetMember ? targetMember.getType() : null, false, acceptTargetType, binex.operand2);

                    if (acceptTargetType && targetMember) {
                        // Note that we accept 'any' in place of a valid subtype                     
                        if ((binex.operand2.type == this.anyType || this.checker.sourceIsAssignableToTarget(binex.operand2.type, targetMember.getType())) ||
                            (binex.operand2.nodeType == NodeType.FuncDecl &&
                            (<FuncDecl>binex.operand2).isAccessor() &&
                                this.typeFromAccessorFuncDecl(<FuncDecl>binex.operand2) == targetMember.getType())) {
                                    // set the field type to the proper contextual type
                                    // this is especially important in the 'any' case, so that
                                    // fields typed to 'any' aren't accepted for contextual typing,
                                    // but never properly set to the target type
                            binex.operand1.type = targetMember.getType();
                        }
                    }
                    else {
                        // here we sub in 'any' for 'undefined' to account for field initialization to
                        // 'undefined'  
                        binex.operand2.type = binex.operand2.type == this.checker.undefinedType ? this.anyType : binex.operand2.type;
                    }

                    // the field symbol hasn't been set by a getter or setter
                    if (fieldSymbol == null) {
                        var memberType = binex.operand2.type;
                        var field = new ValueLocation();
                        fieldSymbol =
                            new FieldSymbol(text, id.minChar,
                                            this.checker.locationInfo.unitIndex,
                                            true, field);
                        fieldSymbol.flags |= SymbolFlags.Property;
                        field.symbol = fieldSymbol;
                        fieldSymbol.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                        field.typeLink = new TypeLink();
                        field.typeLink.type = memberType;
                        resultType.members.publicMembers.add(text, fieldSymbol);
                    }
                    fieldSymbol.isObjectLitField = true;
                }
            }

            this.thisType = prevThisType;
            objectLit.type = resultType;
            if (targetType) {
                objectLit.targetType = targetType;
            }
        }

        public typeCheckArrayLit(arrayLit: UnaryExpression): void {
            var elements = <ASTList>arrayLit.operand;
            var elementType = this.anyType;
            var targetElementType: Type = null;
            var comparisonInfo = new TypeComparisonInfo();
            comparisonInfo.onlyCaptureFirstError = true;

            // if the target type is an array type, extract the element type
            if (this.checker.hasTargetType()) {
                var targetType = this.checker.getTargetTypeContext().contextualType;
                if (targetType.elementType) {
                    targetElementType = targetType.elementType;
                }
            }

            if (elements) {

                var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;

                this.inArrayElementTypeCheck = true;
                this.checker.typeCheckWithContextualType(targetElementType, this.checker.inProvisionalTypecheckMode(), targetElementType != null, elements);
                this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;

                elementType = elements.members[0].type;

                var collection: ITypeCollection = {
                    getLength: () => { return elements.members.length; },
                    setTypeAtIndex: (index: number, type: Type) => { elements.members[index].type = type; },
                    getTypeAtIndex: (index: number) => { return elements.members[index].type; }
                }

                elementType = this.checker.findBestCommonType(elementType, targetElementType, collection, false, comparisonInfo);

                // if the array type is the undefined type, we should widen it to any
                // if it's of the null type, only widen it if it's not in a nested array element, so as not to 
                // short-circuit any checks for the best common type
                if (elementType == this.checker.undefinedType || (!prevInArrayElemTypeCheck && elementType == this.nullType)) {
                    elementType = this.anyType;
                }
            }
            if (!elementType) {
                var emsg = "Incompatible types in array literal expression";
                if (!comparisonInfo.message) {
                    this.checker.errorReporter.simpleError(arrayLit, emsg);
                }
                else {
                    this.checker.errorReporter.simpleError(arrayLit, emsg + ": " + comparisonInfo.message);
                }
                elementType = this.anyType;
            }
            else if (targetElementType) {
                // for the case of zero-length 'any' arrays, we still want to set the contextual type, if
                // need be
                if (this.checker.sourceIsAssignableToTarget(elementType, targetElementType)) {
                    elementType = targetElementType;
                }
            }

            arrayLit.type = this.checker.makeArrayType(elementType);

        }

        public checkForVoidConstructor(type: Type, ast: AST) {
            if (type &&
                type.construct &&
                type.construct.signatures.length > 0) {

                for (var i = 0; i < type.construct.signatures.length; i++) {
                    if (type.construct.signatures[i].returnType.type == this.checker.voidType) {
                        this.checker.errorReporter.simpleError(ast, "Constructors may not have a return type of 'void'");
                        break;
                    }
                }
            }
        }

        // REVIEW: the code below could set the signature type of the function to the current return
        // type, which would have a benefit of reducing the risk of a recursive typecheck scenario, but is
        // is technically wrong - mergeOrdered will only work properly if the best common supertype
        // comes before any sibling types.  This would mean that if a function, "color()", returned
        // three types (in order) - "Red", "Blue", and "IColor", an "Incompatible return type" error 
        // would be triggered.  However, if "color()" returned (in order) "Red", "IColor" and "Blue"
        // no error would be triggered, and the return type of the function would be "IColor"
        public typeCheckReturn(returnStmt: ReturnStatement): ReturnStatement {

            if (this.thisFnc) {
                var targetType: Type = null;

                // determine the target type
                if (this.checker.hasTargetType()) {
                    var tcContext = this.checker.getTargetTypeContext();
                    var accessorType = tcContext.targetAccessorType;

                    if (accessorType) {
                        targetType = accessorType;
                    }
                    else {
                        var targetSig = this.checker.getTargetTypeContext().targetSig;
                        if (targetSig && targetSig.returnType.type != this.voidType) {
                            targetType = targetSig.returnType.type;
                        }
                    }
                }

                if (returnStmt.returnExpression) {
                    this.thisFnc.fncFlags |= FncFlags.HasReturnExpression;

                    if (targetType == null && this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type && this.thisFnc.returnTypeAnnotation.type != this.voidType) {
                        targetType = this.thisFnc.returnTypeAnnotation.type;
                    }

                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), targetType != null, returnStmt.returnExpression);

                    var expectedReturnType: Type =
                        (this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ?
                            this.thisFnc.returnTypeAnnotation.type :
                            targetType;
                    if (expectedReturnType) {
                        if (expectedReturnType == this.voidType && returnStmt.returnExpression.type != this.voidType) {
                            this.checker.errorReporter.simpleError(returnStmt,
                                                              "Return with value expression in void function");

                            // even though we've raised an error, use the more specific type
                            returnStmt.type = returnStmt.returnExpression.type;
                        }
                        else {
                            returnStmt.returnExpression = this.cast(returnStmt.returnExpression, expectedReturnType);
                            returnStmt.type = expectedReturnType;
                        }
                    }
                    else {
                        if (targetType) {
                            if (returnStmt.returnExpression.type != this.voidType) {
                                returnStmt.returnExpression = this.cast(returnStmt.returnExpression, targetType);
                            }
                            else {
                                returnStmt.returnExpression.type = targetType;
                            }
                        }
                        returnStmt.type = returnStmt.returnExpression.type;
                    }
                    this.thisFnc.returnStatementsWithExpressions[this.thisFnc.returnStatementsWithExpressions.length] = returnStmt;
                }
                else {
                    returnStmt.type = targetType == null ? this.checker.voidType : targetType; //((this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ? this.thisFnc.returnTypeAnnotation.type : this.checker.voidType) : targetType;
                }
            }

            return returnStmt;
        }

        public typeCheckInstOf(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);

            if (!((binex.operand1.type == this.checker.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand1.type, this.objectInterfaceType)) &&
                    (binex.operand2.type == this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.functionInterfaceType)))) {
                this.checker.errorReporter.simpleError(ast, "The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type");
            }
            binex.type = this.booleanType;
            return binex;
        }

        public typeCheckCommaOperator(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            binex.type = binex.operand2.type;
            return binex;
        }

        public typeCheckLogOr(binex: BinaryExpression): BinaryExpression {
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;

            if (leftType == this.checker.anyType || rightType == this.checker.anyType) {
                binex.type = this.checker.anyType;
            }
            else if (leftType == this.checker.booleanType) {
                if (rightType == this.checker.booleanType) {
                    binex.type = this.checker.booleanType;
                }
                else {
                    binex.type = this.checker.anyType;
                }
            }
            else if (leftType == this.checker.numberType) {
                if (rightType == this.checker.numberType) {
                    binex.type = this.checker.numberType;
                }
                else {
                    binex.type = this.checker.anyType;
                }
            }
            else if (leftType == this.checker.stringType) {
                if (rightType == this.checker.stringType) {
                    binex.type = this.checker.stringType;
                }
                else {
                    binex.type = this.checker.anyType;
                }
            }
            else {
                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {
                    binex.type = rightType;
                }
                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {
                    binex.type = leftType;
                }
                else {
                    binex.type = this.checker.anyType;
                }
            }
            return binex;
        }

        public typeCheckLogAnd(binex: BinaryExpression): BinaryExpression {
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            binex.type = binex.operand2.type;
            return binex;
        }

        public tryAddCandidates(signature: Signature, actuals: Type[], exactCandidates: Signature[], conversionCandidates: Signature[], comparisonInfo: TypeComparisonInfo): void {
            var lowerBound = signature.nonOptionalParameterCount; // required parameters
            var upperBound = signature.parameters.length; // required and optional parameters
            var formalLen = lowerBound;
            var acceptable = false;

            if ((actuals.length >= lowerBound) && (signature.hasVariableArgList || actuals.length <= upperBound)) {
                formalLen = (signature.hasVariableArgList ? signature.parameters.length : actuals.length);
                acceptable = true;
            }

            var repeatType: Type = null;

            if (acceptable || signature.hasVariableArgList) {
                // assumed structure here is checked when signature is formed
                if (signature.hasVariableArgList) {
                    formalLen -= 1;
                    repeatType = (<ParameterSymbol>signature.parameters[formalLen]).parameter.typeLink.type;
                    repeatType = repeatType.elementType;
                    acceptable = actuals.length >= formalLen;
                }
                var len = actuals.length;

                var exact = acceptable;
                var convert = acceptable;
                for (var i = 0; i < len; i++) {
                    var typeA: Type;
                    if (i < formalLen) {
                        typeA =
                            (<ParameterSymbol>signature.parameters[i]).parameter.typeLink.type;
                    }
                    else {
                        typeA = repeatType;
                    }

                    var typeB = actuals[i];
                    if (!typeA || !typeB || !(this.checker.typesAreIdentical(typeA, typeB))) {
                        exact = false;
                    }
                    // is the argument assignable to the parameter?
                    if (!this.checker.sourceIsAssignableToTarget(typeB, typeA, comparisonInfo)) {
                        convert = false;
                    }
                    if (!(exact || convert)) {
                        break;
                    }
                }
                if (exact) {
                    exactCandidates[exactCandidates.length] = signature;
                }
                else if (convert && (exactCandidates.length == 0)) {
                    conversionCandidates[conversionCandidates.length] = signature;
                }

            }
        }

        public resolveOverload(application: AST, group: SignatureGroup): Signature {
            var rd = this.resolutionDataCache.getResolutionData();
            var actuals = rd.actuals;
            var exactCandidates = rd.exactCandidates;
            var conversionCandidates = rd.conversionCandidates;
            var candidate: Signature = null;
            var hasOverloads = group.signatures.length > 1;
            var comparisonInfo = new TypeComparisonInfo();
            var args: ASTList = null;
            var target: AST = null;

            if (application.nodeType == NodeType.Call || application.nodeType == NodeType.New) {
                var callEx = <CallExpression>application;
                args = callEx.arguments;
                target = callEx.target;
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    for (var i = 0; i < len; i++) {
                        actuals[i] = callEx.arguments.members[i].type;
                    }
                }
            }
            else if (application.nodeType == NodeType.Index) {
                var binExp = <BinaryExpression>application;
                target = binExp.operand1;
                args = new ASTList();
                args.members[0] = binExp.operand2;
                actuals[0] = binExp.operand2.type;
            }

            for (var j = 0, groupLen = group.signatures.length; j < groupLen; j++) {
                var signature = group.signatures[j];
                if (hasOverloads && signature == group.definitionSignature && !this.checker.canCallDefinitionSignature) {
                    continue;
                }
                if (!signature.returnType.type && signature.declAST &&
                    (signature.typeCheckStatus != TypeCheckStatus.Finished)) {
                    this.typeCheckFunction(signature.declAST);
                }
                this.tryAddCandidates(signature, actuals, exactCandidates, conversionCandidates, comparisonInfo);
            }
            if (exactCandidates.length == 0) {

                var applicableCandidates = this.checker.getApplicableSignatures(conversionCandidates, args, comparisonInfo);
                if (applicableCandidates.length > 0) {
                    var candidateInfo = this.checker.findMostApplicableSignature(applicableCandidates, args);
                    if (candidateInfo.ambiguous) {
                        this.checker.errorReporter.simpleError(target, "Ambiguous call expression - could not choose overload");
                    }
                    candidate = candidateInfo.sig;
                }
                else {
                    var emsg = "Supplied parameters do not match any signature of call target";
                    if (comparisonInfo.message) {
                        this.checker.errorReporter.simpleError(target, emsg + ":\n\t" + comparisonInfo.message);
                    }
                    else {
                        this.checker.errorReporter.simpleError(target, emsg);
                    }
                }
            }
            else {
                if (exactCandidates.length > 1) {
                    var applicableSigs: ApplicableSignature[] = [];
                    for (var i = 0; i < exactCandidates.length; i++) {
                        applicableSigs[i] = { signature: exactCandidates[i], hadProvisionalErrors: false };
                    }
                    var candidateInfo = this.checker.findMostApplicableSignature(applicableSigs, args);
                    if (candidateInfo.ambiguous) {
                        this.checker.errorReporter.simpleError(target, "Ambiguous call expression - could not choose overload");
                    }
                    candidate = candidateInfo.sig;
                }
                else {
                    candidate = exactCandidates[0];
                }
            }

            this.resolutionDataCache.returnResolutionData(rd);
            return candidate;
        }

        public typeCheckNew(ast: AST): AST {
            var callEx = <CallExpression>ast;

            callEx.target = this.typeCheck(callEx.target);
            var target = callEx.target;
            if (target.type.construct || target.type.call) {
                this.preTypeCheckCallArgs(callEx.arguments);
            }
            else {
                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);
            }

            if (target.type == this.anyType) {
                callEx.type = this.anyType;
                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);
            }
            else {
                if (target.type.construct) {
                    var signature = this.resolveOverload(callEx, target.type.construct);
                    if (signature == null) {
                        callEx.type = this.anyType;
                    }
                    else if (signature.returnType.type == this.voidType) {
                        callEx.type = this.anyType;
                        callEx.signature = signature;
                    }
                    else {
                        callEx.type = signature.returnType.type;
                        callEx.signature = signature;
                    }
                }
                else if (target.type.call) {
                    var signature = this.resolveOverload(callEx, target.type.call);
                    if (signature == null) {
                        callEx.type = this.anyType;
                    }
                    else if ((signature.returnType.type == this.voidType) || (signature.returnType.type == this.anyType)) {
                        callEx.type = this.anyType;
                        callEx.signature = signature;
                    }
                    else {
                        this.checker.errorReporter.simpleError(callEx.target,
                           "new expression only valid on constructors");
                    }
                }
                else if (target.type.elementType) {
                    callEx.type = target.type;
                }
                else {
                    this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);
                    callEx.type = this.anyType;
                }
            }

            this.postTypeCheckCallArgs(callEx);

            return callEx;
        }

        // Typecheck all args that cannot be affected by contextual typing of overloads
        public preTypeCheckCallArgs(args: ASTList) {

            if (!args) {
                return;
            }

            for (var i = 0; i < args.members.length; i++) {
                switch (args.members[i].nodeType) {
                    case NodeType.FuncDecl:
                    case NodeType.ObjectLit:
                    case NodeType.ArrayLit:
                        continue;
                    default:
                        this.typeCheck(args.members[i]);
                        break;
                }
            }
        }

        public postTypeCheckCallArgs(callEx: CallExpression) {

            var acceptedTargetType = false;
            var i = 0;

            if (callEx.target &&
                callEx.target.type &&
                callEx.signature &&
                callEx.arguments) {
                var sig = callEx.signature;

                if (sig && callEx.arguments.members.length >= sig.nonOptionalParameterCount) {
                    acceptedTargetType = true;
                    var targetType: Type = null;
                    var nonVarArgFormalParamLength = sig.hasVariableArgList ? sig.parameters.length - 1 : sig.parameters.length;
                    var nonVarArgActualParamLength = callEx.arguments.members.length < nonVarArgFormalParamLength ? callEx.arguments.members.length : nonVarArgFormalParamLength

                    for (i = 0; i < nonVarArgActualParamLength; i++) {
                        targetType = sig.parameters[i].getType();
                        switch (callEx.arguments.members[i].nodeType) {
                            case NodeType.FuncDecl:
                            case NodeType.ObjectLit:
                            case NodeType.ArrayLit:
                                this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), !sig.parameters[i].declAST.isParenthesized, callEx.arguments.members[i]);
                                break;
                        }
                    }

                    if (sig.hasVariableArgList) {
                        var varArgParamIndex = sig.nonOptionalParameterCount - 1;
                        targetType = sig.parameters[varArgParamIndex].getType();
                        if (targetType) {
                            targetType = targetType.elementType;
                        }
                        var isParenthesized = !sig.parameters[varArgParamIndex].declAST.isParenthesized;
                        for (i = nonVarArgActualParamLength; i < callEx.arguments.members.length; i++) {
                            switch (callEx.arguments.members[i].nodeType) {
                                case NodeType.FuncDecl:
                                case NodeType.ObjectLit:
                                case NodeType.ArrayLit:
                                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), isParenthesized, callEx.arguments.members[i]);
                                    break;
                            }
                        }
                    }
                }
            }

            if (!acceptedTargetType && callEx.arguments) {
                this.checker.killCurrentContextualType();

                for (i = 0; i < callEx.arguments.members.length; i++) {
                    switch (callEx.arguments.members[i].nodeType) {
                        case NodeType.FuncDecl:
                        case NodeType.ObjectLit:
                        case NodeType.ArrayLit:
                            this.typeCheck(callEx.arguments.members[i]);
                            break;
                        default:
                            continue;
                    }
                }
            }
        }

        public typeCheckCall(ast: AST): AST {
            var callEx = <CallExpression>ast;
            if (this.checker.styleSettings.newMustBeUsed && (ast.nodeType == NodeType.New)) {
                if (hasFlag(ast.flags, ASTFlags.IsStatement)) {
                    this.checker.errorReporter.styleError(ast, "use of new expression as a statement");
                }
            }
            else if ((!this.checker.styleSettings.evalOK) && (ast.nodeType == NodeType.Call)) {
                if ((callEx.target.nodeType == NodeType.Name) && ((<Identifier>callEx.target).text == "eval")) {
                    this.checker.errorReporter.styleError(callEx, "eval not permitted");
                }
            }

            if (callEx.target.nodeType == NodeType.FuncDecl) {
                (<FuncDecl>callEx.target).isInlineCallLiteral = true;
            }

            var prevInSuperCall = this.inSuperCall;

            if (callEx.target.nodeType == NodeType.Super) {
                this.inSuperCall = true;
            }

            callEx.target = this.typeCheck(callEx.target);
            this.preTypeCheckCallArgs(callEx.arguments);

            var target = callEx.target;

            if ((target.type == null) || (target.type == this.anyType) || (this.functionInterfaceType && target.type == this.functionInterfaceType)) {
                callEx.type = this.anyType;
            }
            else {
                var fnType = target.type;
                if (fnType.call) {
                    var signature = this.resolveOverload(callEx, fnType.call);
                    if (signature == null) {
                        callEx.type = this.anyType;
                    }
                    else {
                        callEx.type = signature.returnType.type;
                        callEx.signature = signature;
                    }
                }
                else {
                    // track calls to class base class
                    if (callEx.target.nodeType == NodeType.Super &&
                        this.thisFnc &&
                        this.thisFnc.isConstructor &&
                        hasFlag(this.thisFnc.fncFlags, FncFlags.ClassMethod)) {

                            // Need to use the class type for the construct signature, not the instance type
                        var signature = fnType.symbol.type.construct ? this.resolveOverload(callEx, fnType.symbol.type.construct) : null;

                        if (signature == null) {
                            callEx.type = this.anyType;
                        }
                        else {
                            callEx.flags |= ASTFlags.ClassBaseConstructorCall;
                            callEx.type = signature.returnType.type;
                            callEx.signature = signature;
                        }
                    }
                    else {
                        callEx.type = this.anyType;
                        this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);
                    }
                }
            }
            this.postTypeCheckCallArgs(callEx);

            this.inSuperCall = prevInSuperCall;

            return callEx;
        }

        public assignScopes(ast: AST) {
            var script = <Script>ast;
            this.checker.locationInfo = script.locationInfo;
            var globalChain = new ScopeChain(this.checker.gloMod, null, this.globalScope);
            var context = new AssignScopeContext(globalChain, this, [this.checker.currentModDecl]);
            getAstWalkerFactory().walk(ast, preAssignScopes, postAssignScopes, null, context);
        }

        public findMemberScope(enclosingScopeContext: EnclosingScopeContext, matchFlag: ASTFlags) {
            var enclosingScope = enclosingScopeContext.getScope();
            var pos = enclosingScopeContext.pos - enclosingScopeContext.getScriptFragmentPosition();
            var scriptFragment = enclosingScopeContext.getScriptFragment();

            var memContext = new MemberScopeContext(this, pos, matchFlag);
            memContext.scope = enclosingScope;
            if (scriptFragment.nodeType == NodeType.Name) {
                return scriptFragment.type.getMemberScope(this);
            }
            else {
                getAstWalkerFactory().walk(scriptFragment, preFindMemberScope, null, null, memContext);
                if (memContext.ast && enclosingScopeContext.enclosingClassDecl && memContext.ast.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {
                    enclosingScopeContext.publicsOnly = false;
                }
                if (memContext.type) {
                    return memContext.type.getMemberScope(this);
                }
                else {
                    return null;
                }
            }
        }

        public findMemberScopeAt(enclosingScopeContext: EnclosingScopeContext) {
            return this.findMemberScope(enclosingScopeContext, ASTFlags.DotLHS);
        }

        public findMemberScopeAtFullAst(enclosingScopeContext: EnclosingScopeContext) {
            var matchFlag = ASTFlags.DotLHS;
            var pos = enclosingScopeContext.pos;
            var astResult: AST = null;

            var preFindMemberScopeFullAst = function (ast: AST, parent: AST, walker: IAstWalker) {
                if (isValidAstNode(ast)) {
                    // Note: pos == ast.limChar       in case of incomplete code (e.g. "foo.")
                    // Note: (pos - 1) == ast.limChar in case of complete code (e.g. "foo.bar")
                    if (hasFlag(ast.flags, matchFlag) && (pos == ast.limChar || (pos - 1) == ast.limChar)) {
                        astResult = ast;
                        walker.options.stopWalk();
                    }

                    // Stop traversal if range does not contain position
                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);
                }
                return ast;
            }

            var preFindMemberScopeFullAstFuzy = function (ast: AST, parent: AST, walker: IAstWalker) {
                if (isValidAstNode(ast)) {
                    if (hasFlag(ast.flags, matchFlag) && ((ast.minChar < pos) && (pos <= ast.limChar))) {
                        astResult = ast;
                    }

                    // Stop traversal if range does not contain position
                    walker.options.goChildren = (ast.minChar <= pos) && (pos <= ast.limChar);
                }
                return ast;
            }

            getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAst);

            if (astResult == null) {
                // Perform a more "fusy" match. This is because the limChar of AST nodes is sometimes
                // not what we expect, for example:
                //   foo./*comment*/;
                // In this case, limChar points to ";" instead of "." (because of the trailing comment).
                getAstWalkerFactory().walk(enclosingScopeContext.script, preFindMemberScopeFullAstFuzy);
            }

            if (astResult &&
                enclosingScopeContext.enclosingClassDecl &&
                astResult.type == enclosingScopeContext.enclosingClassDecl.type.instanceType) {
                enclosingScopeContext.publicsOnly = false;
            }

            if (astResult && astResult.type) {
                return astResult.type.getMemberScope(this);
            }
            else {
                return null;
            }
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export enum Primitive {
        None = 0,
        Void = 1,
        Double = 2,
        String = 4,
        Boolean = 8,
        Any = 16,
        Null = 32,
        Undefined = 64,
    }

    export class MemberName {
        public prefix: string = "";
        public suffix: string = "";

        public isString() { return false; }
        public isArray() { return false; }

        public toString(): string {
            return MemberName.memberNameToString(this);
        }

        static memberNameToString(memberName: MemberName): string {
            var result = memberName.prefix;

            if (memberName.isString()) {
                result += (<MemberNameString>memberName).text;
            }
            else {
                var ar = <MemberNameArray>memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    result += memberNameToString(ar.entries[index]);
                    result += ar.delim;
                }
            }

            result += memberName.suffix;
            return result;
        }

        static create(text: string): MemberName;
        static create(entry: MemberName, prefix: string, suffix: string): MemberName;
        static create(arg1: any, arg2?: any, arg3?: any): MemberName {
            if (typeof arg1 == "string") {
                return new MemberNameString(arg1);
            }
            else {
                var result = new MemberNameArray();
                if (arg2)
                    result.prefix = arg2;
                if (arg3)
                    result.suffix = arg3;
                result.entries.push(arg1);
                return result;
            }
        }
    }

    export class MemberNameString extends MemberName {
        constructor (public text: string) {
            super()
        }

        public isString() { return true; }
    }

    export class MemberNameArray extends MemberName {
        public delim: string = "";
        public entries: MemberName[] = [];

        public isArray() { return true; }

        public add(entry: MemberName) {
            this.entries.push(entry);
        }

        public addAll(entries: MemberName[]) {
            for (var i = 0 ; i < entries.length; i++) {
                this.entries.push(entries[i]);
            }
        }
    }

    var currentTypeID = -1;

    export class Type {
        public typeID = currentTypeID++;

        public members: ScopedMembers;
        public ambientMembers: ScopedMembers;

        public construct: SignatureGroup = null;
        public call: SignatureGroup = null;
        public index: SignatureGroup = null;

        // REVIEW: for either of the below, why do we have lists of types and lists of type links?
        // interface can only extend
        public extendsList: Type[];
        public extendsTypeLinks: TypeLink[];

        // class can also implement
        public implementsList: Type[];
        public implementsTypeLinks: TypeLink[];

        public passTypeCreated: number = CompilerDiagnostics.analysisPass;

        public baseClass(): Type {
            if (this.extendsList && (this.extendsList.length > 0)) {
                return this.extendsList[0];
            }
            else {
                return null;
            }
        }

        public elementType: Type;

        public getArrayBase(arrInstType: Type, checker: TypeChecker): Type {
            return this.arrayCache.specialize(arrInstType, checker);
        }

        public primitiveTypeClass: number = Primitive.None;

        // REVIEW: Prune constructorScope
        public constructorScope: SymbolScope;
        public containedScope: SymbolScope;
        public memberScope: SymbolScope;

        public arrayCache: ArrayCache;

        public typeFlags = TypeFlags.None;

        public symbol: TypeSymbol;

        public enclosingType: Type;
        public instanceType: Type;

        // REVIEW: Prune
        public isClass() { return this.instanceType != null; }
        public isArray() { return this.elementType != null; }
        public isClassInstance() {
            return this.symbol && !this.elementType && (<TypeSymbol>this.symbol).type.isClass();
        }

        public getInstanceType() {
            if (this.isClass()) {
                return this.instanceType;
            }
            else {
                return this;
            }
        }

        public hasImplementation() { return hasFlag(this.typeFlags, TypeFlags.HasImplementation); }
        public setHasImplementation() { this.typeFlags |= TypeFlags.HasImplementation; }

        public isDouble() { return hasFlag(this.primitiveTypeClass, Primitive.Double); }
        public isString() { return hasFlag(this.primitiveTypeClass, Primitive.String); }
        public isBoolean() { return hasFlag(this.primitiveTypeClass, Primitive.Boolean); }
        public isNull() { return hasFlag(this.primitiveTypeClass, Primitive.Null); }

        // REVIEW: No need for this to be a method
        public getTypeName(): string {
            return this.getMemberTypeName("", true, false, null);
        }

        public getScopedTypeName(scope: SymbolScope, getPrettyTypeName?: bool) {
            return this.getMemberTypeName("", true, false, scope, getPrettyTypeName);
        }

        public getScopedTypeNameEx(scope: SymbolScope, getPrettyTypeName?: bool) {
            return this.getMemberTypeNameEx("", true, false, scope, getPrettyTypeName);
        }

        // REVIEW: No need for this to be a method
        public callCount() {
            var total = 0;
            if (this.call) {
                total += this.call.signatures.length;
            }
            if (this.construct) {
                total += this.construct.signatures.length;
            }
            if (this.index) {
                total += this.index.signatures.length;
            }
            return total;
        }

        // REVIEW: No need for this to be a method
        public getMemberTypeName(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope, getPrettyTypeName?: bool): string {
            var memberName = this.getMemberTypeNameEx(prefix, topLevel, isElementType, scope, getPrettyTypeName);
            return memberName.toString();
        }

        // REVIEW: No need for this to be a method
        public getMemberTypeNameEx(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope, getPrettyTypeName?: bool): MemberName {
            if (this.elementType) {
                return MemberName.create(this.elementType.getMemberTypeNameEx(prefix, false, true, scope), "", "[]");
            }
            else if (this.symbol && this.symbol.name && this.symbol.name != "_anonymous" &&
                     (((this.call == null) && (this.construct == null) && (this.index == null)) ||
                      (hasFlag(this.typeFlags, TypeFlags.BuildingName)) ||
                      (this.members && (!this.isClass())))) {
                var tn = this.symbol.scopeRelativeName(scope);
                return MemberName.create(tn == "null" ? "any" : tn); // REVIEW: GROSS!!!
            }
            else {
                if (this.members || this.call || this.construct) {
                    if (hasFlag(this.typeFlags, TypeFlags.BuildingName)) {
                        return MemberName.create("this");
                    }
                    this.typeFlags |= TypeFlags.BuildingName;
                    var builder = "";
                    var allMemberNames = new MemberNameArray();
                    var curlies = isElementType || this.index != null;
                    var memCount = 0;
                    var delim = "; ";
                    if (this.members) {
                        this.members.allMembers.map((key, s, unused) => {
                            var sym = <Symbol>s;
                            if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {
                                // Remove the delimiter character from the generated type name, since
                                // our "allMemberNames" array takes care of storing delimiters
                                var typeNameMember = sym.getTypeNameEx(scope);
                                if (typeNameMember.isArray() && (<MemberNameArray>typeNameMember).delim == delim) {
                                    allMemberNames.addAll((<MemberNameArray>typeNameMember).entries);
                                } else {
                                    allMemberNames.add(typeNameMember);
                                }
                                memCount++;
                                curlies = true;
                            }
                        }, null);
                    }

                    var signatureCount = this.callCount();
                    var j: number;
                    var len = 0;
                    var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.call && this.call.signatures.length > 1 && !this.members && !this.construct;
                    var shortform = !curlies && (signatureCount == 1 || getPrettyFunctionOverload) && topLevel;
                    if (this.call) {
                        allMemberNames.addAll(this.call.toStrings(prefix, shortform, scope, getPrettyFunctionOverload));
                    }

                    if (this.construct) {
                        allMemberNames.addAll(this.construct.toStrings("new", shortform, scope));
                    }

                    if (this.index) {
                        allMemberNames.addAll(this.index.toStrings("", shortform, scope));
                    }

                    if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                        allMemberNames.prefix = "{ ";
                        allMemberNames.suffix = "}";
                        allMemberNames.delim = delim;
                    } else if (allMemberNames.entries.length > 1) {
                        allMemberNames.delim = delim;
                    }

                    this.typeFlags &= (~TypeFlags.BuildingName);
                    if ((signatureCount == 0) && (memCount == 0)) {
                        return MemberName.create("{}");
                    }
                    else {
                        return allMemberNames;
                    }
                }
                else {
                    return MemberName.create("{}");
                }
            }
        }

        public checkDecl(checker: TypeChecker) {
            if (this.isClassInstance() || this.isClass()) {
                if (this.symbol.declAST) {
                    checker.typeFlow.inScopeTypeCheckDecl(this.symbol.declAST);
                }
            }
        }

        public getMemberScope(flow: TypeFlow) {
            if (this == flow.anyType) {
                return null;
            }
            else if (this.isDouble()) {
                if (flow.numberInterfaceType) {
                    return flow.numberInterfaceType.memberScope;
                }
                else {
                    return null;
                }
            }
            else if (this.isBoolean()) {
                if (flow.booleanInterfaceType) {
                    return flow.booleanInterfaceType.memberScope;
                }
                else {
                    return null;
                }
            }
            else if (this == flow.stringType) {
                if (flow.stringInterfaceType) {
                    return flow.stringInterfaceType.memberScope;
                }
                else {
                    return null;
                }
            }
            else if (this.elementType) {
                if (flow.arrayInterfaceType) {
                    var arrInstType = this.elementType.getArrayBase(flow.arrayInterfaceType, flow.checker);
                    return arrInstType.memberScope;
                }
                else {
                    return null;
                }
            }
            else {
                return this.memberScope;
            }
        }

        public isReferenceType() {
            return this.members || this.extendsList ||
                this.construct || this.call || this.index ||
                this.elementType;
        }

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker, membersOnly: bool): Type {
            if (pattern == this) {
                return replacement;
            }
            var result = this;
            if (membersOnly) {
                // assume interface type without bases
                if (this.isReferenceType()) {
                    result = new Type();
                    if (this.members) {
                        result.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));

                        this.members.publicMembers.map((key, s, unused) => {
                            var sym = <Symbol>s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.members.addPublicMember(bSym.name, bSym);
                        }, null);

                        this.members.privateMembers.map((key, s, unused) => {
                            var sym = <Symbol>s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.members.addPrivateMember(bSym.name, bSym);
                        }, null);
                    }
                    if (this.ambientMembers) {
                        result.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                        this.ambientMembers.publicMembers.map((key, s, unused) => {
                            var sym = <Symbol>s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.ambientMembers.addPublicMember(bSym.name, bSym);
                        }, null);

                        this.ambientMembers.privateMembers.map((key, s, unused) => {
                            var sym = <Symbol>s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.ambientMembers.addPrivateMember(bSym.name, bSym);
                        }, null);
                    }
                    result.containedScope = checker.scopeOf(result);
                    result.memberScope = result.containedScope;
                }
            }
            else {
                if (this.elementType) {
                    if (this.elementType == pattern) {
                        result = checker.makeArrayType(replacement);
                    }
                    else {
                        if (this.elementType.elementType == pattern) {
                            result = checker.makeArrayType(checker.makeArrayType(replacement));
                        }
                    }
                }
                else if (this.call) {
                    result = new Type();
                    result.call = this.call.specializeType(pattern, replacement, checker);
                }
            }
            return result;
        }

        public hasBase(baseType: Type): bool {
            if (baseType == this) {
                return true;
            }
            else {
                if (this.extendsList) {
                    for (var i = 0, len = this.extendsList.length; i < len; i++) {
                        if (this.extendsList[i].hasBase(baseType)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        public mergeOrdered(b: Type, checker: TypeChecker, acceptVoid: bool, comparisonInfo?: TypeComparisonInfo): Type {
            if ((this == checker.anyType) || (b == checker.anyType)) {
                return checker.anyType;
            }
            else if (this == b) {
                return this;
            }
            else if ((b == checker.nullType) && this != checker.nullType) {
                return this;
            }
            else if ((this == checker.nullType) && (b != checker.nullType)) {
                return b;
            }
            else if (acceptVoid && (b == checker.voidType) && this != checker.voidType) {
                return this;
            }
            else if (acceptVoid && (this == checker.voidType) && (b != checker.voidType)) {
                return b;
            }
            else if ((b == checker.undefinedType) && this != checker.undefinedType) {
                return this;
            }
            else if ((this == checker.undefinedType) && (b != checker.undefinedType)) {
                return b;
            }
            else if (this.elementType && b.elementType) {
                if (this.elementType == b.elementType) {
                    return this;
                }
                else {
                    var mergedET = this.elementType.mergeOrdered(b.elementType, checker, acceptVoid, comparisonInfo);
                    if (mergedET == null) {
                        return checker.makeArrayType(checker.anyType);
                    }
                    else {
                        return checker.makeArrayType(mergedET);
                    }
                }
            }
            else if (checker.sourceIsSubtypeOfTarget(this, b, comparisonInfo)) {
                return b;
            }
            else if (checker.sourceIsSubtypeOfTarget(b, this, comparisonInfo)) {
                return this;
            }
            else {
                return null;
            }
        }

        public isModuleType() { return false; }
        public hasMembers() { return this.members != null; }
        public getAllEnclosedTypes(): ScopedMembers { return null; }
        public getAllAmbientEnclosedTypes(): ScopedMembers { return null; }
        public getPublicEnclosedTypes(): ScopedMembers { return null; }
        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }

        public getDocComments(): Comment[]{
            if (this.elementType || !this.symbol) {
                return [];
            }

            if (this.isClassInstance() || this.isClass()) {
                if (this.symbol.declAST.nodeType == NodeType.FuncDecl) {
                    // Its a constructor - use the class declaration instead
                    return (<FuncDecl>this.symbol.declAST).classDecl.getDocComments();
                } else {
                    // Its a class without constructor
                    return this.symbol.getDocComments();
                }
            }

            if (this.symbol.name && this.symbol.name != "_anonymous" &&
                (((this.call == null) && (this.construct == null) && (this.index == null))
                  || this.members)) {
                return this.symbol.getDocComments();
            }

            return [];
        }
    }

    export interface ITypeCollection {
        // returns null when types are exhausted
        getLength(): number;
        setTypeAtIndex(index: number, type: Type): void;
        getTypeAtIndex(index: number): Type;
    }

    export class ModuleType extends Type {

        constructor (public enclosedTypes: ScopedMembers, public ambientEnclosedTypes: ScopedMembers) {
            super();
        }

        public isModuleType() { return true; }
        public hasMembers() { return this.members != null || this.enclosedTypes != null; }
        public getAllEnclosedTypes() { return this.enclosedTypes; }
        public getAllAmbientEnclosedTypes() { return this.ambientEnclosedTypes; }
        public getPublicEnclosedTypes(): ScopedMembers { return null; }
        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }
        public importedModules: ImportDeclaration[] = [];

        // Finds the dynamic module name of moduleType in the members
        // ignoreSymbols define list of symbols already visited - to avoid recursion
        static findDynamicModuleNameInHashTable(moduleType: Type, members: IHashTable) {
            var moduleName: { name: string; symbol: Symbol; } = null;
            members.map((key, s, c) => {
                if (moduleName == null && !isQuoted(key)) {
                    var symbol = <Symbol>s;
                    var type = symbol.getType();
                    if (type == moduleType) {
                        // If this is the module type we were looking for
                        moduleName = { name: key, symbol: symbol };
                    }
                }
            }, null);

            return moduleName;
        }

        // Finds the Dynamic module name of the moduleType in this moduleType
        // onlyPublic tells if we are looking for module name in public members only
        public findDynamicModuleName(moduleType: Type): { name: string; symbol: Symbol; } {
            var moduleName: { name: string; symbol: Symbol; } = null;
            // Not cached, so seach and add to the cache
            moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.members.allMembers);
            if (moduleName == null) {
                moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.ambientMembers.allMembers);
            }
            return moduleName;
        }
    }

    export class TypeLink {
        public type: Type = null;
        public ast: AST = null;
    }

    export function getTypeLink(ast: AST, checker: TypeChecker, autoVar: bool): TypeLink {
        var result = new TypeLink();

        result.ast = ast;

        if ((ast == null) && (autoVar)) {
            result.type = checker.anyType;
        }
        else {
            result.type = null;
        }

        return result;
    }

}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    // We need to catch both left and right quotes
    // (depending on your editor's font, this may not be clear...)    
    export function stripQuotes(str: string) {
        return str.replace("\"", "").replace("'", "").replace("'", "").replace("\"", "")
    }

    export function isQuoted(str: string) {
        return str.indexOf("\"") != -1 || str.indexOf("'") != -1 || str.indexOf("'") != -1 || str.indexOf("\"") != -1;
    }

    export function quoteStr(str: string) {
        return "\"" + str + "\"";
    }

    export function swapQuotes(str: string) {

        if (str.indexOf("\"") != -1) {
            str = str.replace("\"", "'");
            str = str.replace("\"", "'");
        }
        else {
            str = str.replace("'", "\"");
            str = str.replace("'", "\"");
        }

        return str;
    }

    export function switchToForwardSlashes(path: string) {
        return path.replace(/\\/g, "/");
    }

    export function trimModName(modName: string) {
        // in case's it's a declare file...
        if (modName.length > 6 && modName.substring(modName.length - 6, modName.length) == ".d.str") {
            return modName.substring(0, modName.length - 6);
        }
        if (modName.length > 4 && modName.substring(modName.length - 4, modName.length) == ".str") {
            return modName.substring(0, modName.length - 4);
        }
        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) == ".d.ts") {
            return modName.substring(0, modName.length - 5);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".ts") {
            return modName.substring(0, modName.length - 3);
        }
        // in case's it's a .js file
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".js") {
            return modName.substring(0, modName.length - 3);
        }

        return modName;
    }

    export function getDeclareFilePath(fname: string) {
        return isSTRFile(fname) ? changePathToDSTR(fname) : isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);
    }

    function isFileOfExtension(fname: string, ext: string) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) == invariantExt;
    }

    export function isJSFile(fname: string) {
        return isFileOfExtension(fname, ".js");
    }

    export function isSTRFile(fname: string) {
        return isFileOfExtension(fname, ".str");
    }

    export function isTSFile(fname: string) {
        return isFileOfExtension(fname, ".ts");
    }

    export function isDSTRFile(fname: string) {
        return isFileOfExtension(fname, ".d.str");
    }

    export function isDTSFile(fname: string) {
        return isFileOfExtension(fname, ".d.ts");
    }

    export function getPrettyName(modPath: string, quote?=true, treatAsFileName?=false) { 
        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripQuotes(modPath));
        var components = this.getPathComponents(modName);
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;
    }

    export function getPathComponents(path: string) {
        return path.split("/");
    }

    export function getRelativePathToFixedPath(fixedModFilePath: string, absoluteModPath: string) {
        absoluteModPath = switchToForwardSlashes(absoluteModPath);

        var modComponents = this.getPathComponents(absoluteModPath);
        var fixedModComponents = this.getPathComponents(fixedModFilePath);

        // Find the component that differs
        var joinStartIndex = 0;
        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length ; joinStartIndex++) {
            if (fixedModComponents[joinStartIndex] != modComponents[joinStartIndex]) {
                break;
            }
        }

        // Get the relative path
        if (joinStartIndex != 0) {
            var relativePath = "";
            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {
                if (fixedModComponents[joinStartIndex] != "") {
                    relativePath = relativePath + "../";
                }
            }

            return relativePath + relativePathComponents.join("/");
        }

        return absoluteModPath;
    }

    export function quoteBaseName(modPath: string) {
        var modName = trimModName(stripQuotes(modPath));
        var path = getRootFilePath(modName);
        if (path == "") {
            return modPath;
        }
        else {
            var components = modName.split(path);
            var fileIndex = components.length > 1 ? 1 : 0;
            return quoteStr(components[fileIndex]);
        }
    }

    export function changePathToSTR(modPath: string) {
        return trimModName(stripQuotes(modPath)) + ".str";
    }

    export function changePathToDSTR(modPath: string) {
        return trimModName(stripQuotes(modPath)) + ".d.str";
    }

    export function changePathToTS(modPath: string) {
        return trimModName(stripQuotes(modPath)) + ".ts";
    }

    export function changePathToDTS(modPath: string) {
        return trimModName(stripQuotes(modPath)) + ".d.ts";
    }

    export function isRelative(path: string) {
        return path.charAt(0) == ".";
    }
    export function isRooted(path: string) {
        return path.charAt(0) == "\\" || path.charAt(0) == "/" || (path.indexOf(":\\") != -1) || (path.indexOf(":/") != -1);
    }

    export function getRootFilePath(outFname: string) {
        if (outFname == "") {
            return outFname;
        }
        else {
            var isPath = outFname.indexOf("/") != -1;
            return isPath ? filePath(outFname) : "";
        }
    }

    export function filePathComponents(fullPath: string) {
        fullPath = switchToForwardSlashes(fullPath);
        var components = getPathComponents(fullPath);
        return components.slice(0, components.length - 1);
    }

    export function filePath(fullPath: string) {
        var path = filePathComponents(fullPath);
        return path.join("/") + "/";
    }

    export function normalizeURL(url: string): string {
        var hostDomainAndPortRegex = /^(https?:\/\/[\-\w\.]+(:\d+)?\/)(.*)$/i;
        var matches = hostDomainAndPortRegex.exec(url);
        if (matches) {
            var hostDomainAndPort = matches[1];
            var actualPath = matches[3];
            return hostDomainAndPort + normalizePath(actualPath);
        }
        return normalizePath(url);
    }

    export var pathNormalizeRegExp = /\//g;

    export function normalizePath(path: string): string {
        path = switchToForwardSlashes(path);
        var startedWithSep = path.charAt(0) === "/";
        var parts = this.getPathComponents(path);
        for (var i = 0; i < parts.length; i++) {
            if (parts[i] === "." || parts[i] === "") {
                parts.splice(i, 1);
                i--;
            }
            if (i > 0 && parts[i] === ".." && parts[i - 1] !== "..") {
                parts.splice(i - 1, 2);
                i -= 2;
            }
        }
        return (startedWithSep ? "/" : "") + parts.join("/");
    }

    export function normalizeImportPath(path: string): string {
        return normalizePath(path);
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export interface IResolvedFile {
        content: string;
        path: string;
    }

    /// This class acts as a convenience class to store path and content information in places
    /// where we need an ISourceText object
    export class SourceUnit implements ISourceText, IResolvedFile {
        public referencedFiles: IFileReference[] = null;

        constructor(public path: string,
                    public content: string) {
        }

        public getText(start: number, end: number): string {
            return this.content.substring(start, end);
        }

        public getLength(): number {
            return this.content.length;
        }
    }

    export interface IFileReference {
        minChar: number;
        limChar: number;
        startLine: number;
        startCol: number;
        path: string;
        isResident: bool;
    }

    /// Limited API for file system manipulation
    export interface IFileSystemObject {
        resolvePath(path: string): string;
        readFile(path: string): string;
        findFile(rootPath: string, partialFilePath: string): IResolvedFile;
        dirName(path: string): string;
    }

    export class CompilationEnvironment {
        constructor (public compilationSettings: CompilationSettings, public ioHost: IFileSystemObject) { }
        public residentCode: SourceUnit[] = [];
        public code: SourceUnit[] = [];
    }

    export interface IResolutionDispatcher {
        postResolutionError(errorFile: string, line: number, col: number, errorMessage: string): void;
        postResolution(path: string, source: ISourceText): void;
    }

    export interface ICodeResolver {
        resolveCode(referencePath: string, rootPath: string, performSearch:bool, state: IResolutionDispatcher): void;
    }

    export interface IResolverHost {
        resolveCompilationEnvironment(preEnvironment: CompilationEnvironment, resolver: ICodeResolver, traceDependencies: bool): CompilationEnvironment;
    }

    export class CodeResolver implements TypeScript.ICodeResolver {
        public visited: any = { };

        constructor (public environment: CompilationEnvironment) { }

        public resolveCode(referencePath: string, parentPath: string, performSearch: bool, resolutionDispatcher: TypeScript.IResolutionDispatcher): bool {
            
            var resolvedFile: IResolvedFile = { content: null, path: referencePath };
            
            var ioHost = this.environment.ioHost;
            
            // If the path is relative, normalize it, based on the root
            var isRelativePath = TypeScript.isRelative(referencePath);
            var isRootedPath = isRelativePath ? false : isRooted(referencePath);
            var normalizedPath: string = 
                isRelativePath ? ioHost.resolvePath(parentPath + "/" + referencePath) : 
                // we only follow the second clause if the path is a non-rooted triple-slash reference path
                (isRootedPath || !parentPath || performSearch ? referencePath : parentPath + "/" + referencePath);

            // We use +=.ts to make sure we don't accidentally pick up ".js" files or the like
            if (!isSTRFile(normalizedPath) && !isTSFile(normalizedPath)) {
                normalizedPath += ".ts";  //changePathToSTR(normalizedPath);
            }

            normalizedPath = switchToForwardSlashes(stripQuotes(normalizedPath));
            var absoluteModuleID = this.environment.compilationSettings.useCaseSensitiveFileResolution ? normalizedPath : normalizedPath.toLocaleUpperCase();
            // read the file contents - if it doesn't exist, trigger a resolution error
            if (!this.visited[absoluteModuleID]) {

                // if the path is relative, or came from a reference tag, we don't perform a search
                if (isRelativePath || isRootedPath || !performSearch) {
                    try {
                        CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                            
                        // Look for the .ts file first - if not present, use the .ts, the .d.str and the .d.ts
                        try {
                            resolvedFile.content = ioHost.readFile(normalizedPath);
                        }
                        catch (err) {
                            try {
                                if (isSTRFile(normalizedPath)) {
                                    normalizedPath = changePathToTS(normalizedPath);
                                }
                                else if (isTSFile(normalizedPath)) {
                                    normalizedPath = changePathToSTR(normalizedPath);
                                }
                                CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                                resolvedFile.content = ioHost.readFile(normalizedPath);
                            }
                            catch (err) {
                                normalizedPath = changePathToDSTR(normalizedPath);
                                CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);

                                try {
                                    resolvedFile.content = ioHost.readFile(normalizedPath);
                                }
                                catch (err) {
                                    normalizedPath = changePathToDTS(normalizedPath);
                                    CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                                    resolvedFile.content = ioHost.readFile(normalizedPath);
                                }
                            }
                        }
                        CompilerDiagnostics.debugPrint("   Found code at " + normalizedPath);

                        resolvedFile.path = normalizedPath;
                        this.visited[absoluteModuleID] = true;
                    }
                    catch (err) {
                        CompilerDiagnostics.debugPrint("   Did not find code for " + referencePath);
                        // Resolution failed
                        return false;
                    }
                }
                else {

                    // if the path is non-relative, we should attempt to search on the relative path
                    resolvedFile = ioHost.findFile(parentPath, normalizedPath);

                    if (!resolvedFile) {
                        if (isSTRFile(normalizedPath)) {
                            normalizedPath = changePathToTS(normalizedPath);
                        }
                        else if (isTSFile(normalizedPath)) {
                            normalizedPath = changePathToSTR(normalizedPath);
                        }
                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);
                    }

                    if (!resolvedFile) {
                        normalizedPath = changePathToDTS(normalizedPath);
                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);
                        if (!resolvedFile) {
                            normalizedPath = changePathToDSTR(normalizedPath);
                            resolvedFile = ioHost.findFile(parentPath, normalizedPath);
                        }
                    }

                    if (resolvedFile) {
                        resolvedFile.path = switchToForwardSlashes(TypeScript.stripQuotes(resolvedFile.path));
                        CompilerDiagnostics.debugPrint(referencePath + " resolved to: " + resolvedFile.path);
                        resolvedFile.content = resolvedFile.content;
                        this.visited[absoluteModuleID] = true;
                    }
                    else {
                        CompilerDiagnostics.debugPrint("Could not find " + referencePath);
                    }
                }

                if (resolvedFile && resolvedFile.content != null) {
                    // preprocess the file, to gather dependencies
                    var rootDir = ioHost.dirName(resolvedFile.path);
                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.content);
                    var preProcessedFileInfo = preProcessFile(sourceUnit, this.environment.compilationSettings);
                    var resolvedFilePath = ioHost.resolvePath(resolvedFile.path);
                    sourceUnit.referencedFiles = preProcessedFileInfo.referencedFiles;

                    // resolve explicit references
                    for (var i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {
                        var fileReference = preProcessedFileInfo.referencedFiles[i];
                        var normalizedPath = isRooted(fileReference.path) ? fileReference.path : rootDir + "/" + fileReference.path;
                        normalizedPath = ioHost.resolvePath(normalizedPath);
                        if (resolvedFilePath == normalizedPath) {
                            resolutionDispatcher.postResolutionError(normalizedPath, fileReference.startLine, fileReference.startCol, "Incorrect reference: File contains reference to itself.");
                            continue;
                        }
                        var resolutionResult = this.resolveCode(fileReference.path, rootDir, false, resolutionDispatcher);
                        if (!resolutionResult) {
                            resolutionDispatcher.postResolutionError(resolvedFilePath, fileReference.startLine, fileReference.startCol, "Incorrect reference: referenced file: \"" + fileReference.path + "\" cannot be resolved.");
                        }
                    }
                    
                    // resolve imports
                    for (var i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {
                        var fileImport = preProcessedFileInfo.importedFiles[i];
                        var resolutionResult = this.resolveCode(fileImport.path, rootDir, true, resolutionDispatcher);
                        if (!resolutionResult) {
                            resolutionDispatcher.postResolutionError(resolvedFilePath, fileImport.startLine, fileImport.startCol, "Incorrect reference: imported file: \"" + fileImport.path + "\" cannot be resolved.");
                        }
                    }

                    // add the file to the appropriate code list
                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit);
                }
            }
            return true;
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    /// Compiler settings

    export class StyleSettings {
        // bitwise operations not permitted
        public bitwise = false;  
        // disallow non-block statements as bodies of compound statements
        public blockInCompoundStmt = false;
        // disallow == and !=
        public eqeqeq = false;
        // require body of for in loop to start with a filter
        public forin = false;
        // empty blocks permitted
        public emptyBlocks = true;
        // require result of new expression to be used (no new just for side-effects)
        public newMustBeUsed = false;
        // require semicolons to terminate statements
        public requireSemi = false;
        // no top-level assignment in conditionals if (a=b) { ...
        public assignmentInCond = false;
        // no == null or != null
        public eqnull = false;
        // permit eval
        public evalOK = true;
        // permit var use if decl in inner scope as in if (c) { var v=10; } v=11;
        public innerScopeDeclEscape = true;
        // permit functions in loops
        public funcInLoop = true;
        // permit re-declaration of local variable 
        public reDeclareLocal = true;
        // permit obj['x'] in addition to obj.x
        public literalSubscript = true;
        // flag implicit 'any'
        public implicitAny = false;

        public setOption(opt: string, val: bool): bool {
            var optExists = this[opt];
            if (optExists !== undefined) {
                this[opt] = val;
                return true;
            }
            else {
                return false;
            }
        }
        
        public parseOptions(str: string) {
            var opts=str.split(";");
            for (var i = 0, len = opts.length; i < len; i++) {
                var opt = opts[i];
                var val = true;
                var colonIndex=opt.lastIndexOf(":");
                if (colonIndex >= 0) {
                    var valStr = opt.substring(colonIndex+1);
                    opt = opt.substring(0, colonIndex);
                    if (valStr == "off") {
                        val = false;
                    }
                }
                if (!this.setOption(opt, val)) {
                    return false;
                }
            }
            return true;
        }
    }
    
    export class CompilationSettings {
        public styleSettings = new StyleSettings();
        public propagateConstants = false;
        public minWhitespace = false;
        public errorRecovery = false;
        public emitComments = false;
        public watch = false;
        public exec = false;
        public resolve = true;
        public controlFlow = false;
        public printControlFlow = false;
        public controlFlowUseDef = false;
        public errorOnWith = true;
        public preprocess = true;
        public canCallDefinitionSignature = false;

        public inferPropertiesFromThisAssignment = false;
        public useDefaultLib = true;

        public codeGenTarget = CodeGenTarget.ES3;
        public moduleGenTarget = ModuleGenTarget.Synchronous;
        // --out option passed. 
        // Default is the "" which leads to multiple files generated next to the.ts files
        public outputOption: string = "";
        public mapSourceFiles = false;
        public emitFullSourceMapPath = false; // By default emit relative path of the soucemap
        public generateDeclarationFiles = false;

        public useCaseSensitiveFileResolution = false;
        public useFidelity = false;
        public usePull = false;

        public gatherDiagnostics = false;

        public setStyleOptions(str: string) {
            this.styleSettings.parseOptions(str);
        }
    }

    export interface IHostSettings {
        usePullLanguageService: bool;
    }
    
    ///
    /// Preprocessing
    ///
    export interface IPreProcessedFileInfo {
        settings: CompilationSettings;
        referencedFiles: IFileReference[];
        importedFiles: IFileReference[];
        isLibFile: bool;
    }

    function getFileReferenceFromReferencePath(comment: string): IFileReference {
        var referencesRegEx = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/gim;
        var match = referencesRegEx.exec(comment);

        if (match) {
            var path: string = normalizePath(match[3]);
            var adjustedPath = normalizePath(path);
    
            var isResident = match.length >= 7 && match[6] == "true";
            if (isResident) {
                CompilerDiagnostics.debugPrint(path + " is resident");
            }
            return {
                minChar: 0,
                limChar: 0,
                startLine: 0,
                startCol: 0,
                path: switchToForwardSlashes(adjustedPath),
                isResident: isResident
            };
        }
        else {
            return null;
        }
    }

    // used in the parser, but kept here in case we want to reintegrate it with preprocessing
    export function getAdditionalDependencyPath(comment: string): string {
        var amdDependencyRegEx = /^(\/\/\/\s*<amd-dependency\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/gim;
        var match = amdDependencyRegEx.exec(comment);

        if (match) {
            var path: string = match[3];
            return path;
        }
        else {
            return null;
        }
    }

    export function getImplicitImport(comment: string): bool {
        var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
        var match = implicitImportRegEx.exec(comment);

        if (match) {
            return true;
        }
        
        return false;
    }

    export function getStyleSettings(comment: string, styleSettings: StyleSettings) {
        var styleRegEx = /^(\/\/\/\s*<style\s+)(([a-zA-Z])+=('|").+('|"))\s*\/>/gim;

        var settings = styleRegEx.exec(comment);

        if (settings) {
            var settingsRegEx = /^([a-zA-Z]+=['"]on['|"])/gim;
            settings = settingsRegEx.exec(settings[2]);
                
            if (settings) {
                for (var i = 0; i < settings.length; i++) {
                    var setting = (<string>settings[i]).split("=");
                    var on = "\"on\"";

                    switch (setting[0]) {
                        case "blockInCompoundStmt": styleSettings.blockInCompoundStmt = setting[1] == on; break;
                        case "eqeqeq": styleSettings.eqeqeq = setting[1] == on; break;
                        case "forin": styleSettings.forin = setting[1] == on; break;
                        case "emptyBlocks": styleSettings.emptyBlocks = setting[1] == on; break;
                        case "newMustBeUsed": styleSettings.newMustBeUsed = setting[1] == on; break;
                        case "requireSemi": styleSettings.requireSemi = setting[1] == on; break;
                        case "assignmentInCond": styleSettings.assignmentInCond = setting[1] == on; break;
                        case "eqnull": styleSettings.eqnull = setting[1] == on; break;
                        case "evalOK": styleSettings.evalOK = setting[1] == on; break;
                        case "innerScopeDeclEscape": styleSettings.innerScopeDeclEscape = setting[1] == on; break;
                        case "funcInLoop": styleSettings.funcInLoop = setting[1] == on; break;
                        case "reDeclareLocal": styleSettings.reDeclareLocal = setting[1] == on; break;
                        case "literalSubscript": styleSettings.literalSubscript = setting[1] == on; break;
                        case "implicitAny": styleSettings.implicitAny = setting[1] == on; break;                               
                    }
                }
            }
        }
    }

    export function getReferencedFiles(sourceText: ISourceText): IFileReference[] {
        var preProcessInfo = preProcessFile(sourceText, null, false);
        return preProcessInfo.referencedFiles;
    }

    export function preProcessFile(sourceText: ISourceText, options=new CompilationSettings(), readImportFiles? = true): IPreProcessedFileInfo {
        var scanner = new Scanner();
        scanner.resetComments();
        scanner.setSourceText(sourceText, LexMode.File);

        var tok: Token = scanner.scan();
        var comments: CommentToken[] = [];
        var comment: CommentToken = null;
        var leftCurlies: Token[] = [];

        var settings: CompilationSettings = options;
        var referencedFiles: IFileReference[] = [];
        var importedFiles: IFileReference[] = [];
        var isLibFile: bool = false;

        // only search out dynamic mods
        // if you find a dynamic mod, ignore every other mod inside, until you balance rcurlies

        while (tok.tokenId != TokenID.EndOfFile) {

            if (readImportFiles && tok.tokenId == TokenID.Import) {

                tok = scanner.scan();

                if (tok.tokenId == TokenID.Identifier || convertTokToID(tok, false)) {
                    tok = scanner.scan();

                    if (tok.tokenId == TokenID.Equals) {
                        tok = scanner.scan();

                        if (tok.tokenId == TokenID.Module) {
                            tok = scanner.scan();
                            if (tok.tokenId == TokenID.OpenParen) {
                                tok = scanner.scan();

                                // import foo = module("foo")
                                if (tok.tokenId == TokenID.StringLiteral) {
                                    var ref = {
                                        minChar: scanner.startPos,
                                        limChar: scanner.pos,
                                        startLine: scanner.line,
                                        startCol: scanner.col,
                                        path: stripQuotes(switchToForwardSlashes(tok.getText())),
                                        isResident: false
                                    };
                                    importedFiles.push(ref);
                                }
                            }
                        }
                    }
                }
            }

            if (tok.tokenId == TokenID.OpenBrace) {
                leftCurlies.push(tok);
            }

            if (tok.tokenId == TokenID.CloseBrace) {
                leftCurlies.pop();
            }

            tok = scanner.scan();
        }

        // deal with comment references, amd dependencies and style settings
        // REVIEW: We could potentially do this inline with the above, if we
        // set Scanner::scanComments to 'true'
        comments = scanner.getComments();

        for (var iComment = 0; iComment < comments.length; iComment++) {
            comment = comments[iComment];
            
            if (!comment.isBlock) {
                var referencedCode = getFileReferenceFromReferencePath(comment.getText());
                if (referencedCode) {
                    referencedCode.minChar = comment.startPos;
                    referencedCode.limChar = referencedCode.minChar + comment.value.length;
                    // Get the startLine and startCol
                    var result = { line: -1, col: -1 };
                    getSourceLineColFromMap(result, comment.startPos, scanner.lineMap);
                    if (result.col >= 0) {
                        result.col++;   // Make it 1-based
                    }
                    referencedCode.startLine = result.line;
                    referencedCode.startCol = result.col;
                    referencedFiles.push(referencedCode);
                }

                if (settings) {
                    getStyleSettings(comment.getText(), settings.styleSettings);

                    // is it a lib file?
                    var isNoLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
                    var isNoLibMatch: any = isNoLibRegex.exec(comment.getText());
                    if (isNoLibMatch) {
                        isLibFile = (isNoLibMatch[3] == "true");
                    }
                }
            }
        }

        return { settings: settings, referencedFiles: referencedFiles, importedFiles: importedFiles, isLibFile: isLibFile };
    }

} // Tools
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export class IncrementalParser {
        
        private astLogger: AstLogger;

        constructor (private logger: TypeScript.ILogger) {
            this.astLogger = new AstLogger(this.logger);
        }

        //
        // Return "null" if "editRange" cannot be safely determined to be inside a single scope.
        //
        public getEnclosingScopeContextIfSingleScopeEdit(previousScript: Script, scriptId: string, newSourceText: ISourceText, editRange: ScriptEditRange): EnclosingScopeContext {
            this.logger.log("checkEditsInsideSingleScope(\"" + scriptId + "\")");

            if (editRange === null) {
                throw new Error("editRange should be valid");
            }

            if (editRange.isUnknown()) {
                this.logger.log("  Bailing out because edit range is unknown");
                return null;
            }

            var scope1 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.minChar, false/*isMemberCompletion*/);
            var scope2 = TypeScript.findEnclosingScopeAt(this.logger, previousScript, newSourceText, editRange.limChar, false/*isMemberCompletion*/);
            if (scope1 == null || scope2 == null) {
                this.logger.log("  Bailing out because containing scopes cannot be determined");
                return null;
            }

            // We only support changes within a single containing scope
            if (scope1.scopeStartAST !== scope2.scopeStartAST) {
                this.logger.log("  Bailing out because edit overlaps 2 disctint scopes");
                return null;
            }

            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;
            if (newScopeLength <= 0) {
                this.logger.log("  Bailing out because scope has been entirely removed from new source text");
                return null;
            }

            return scope1;
        }

        public attemptIncrementalUpdateUnit(previousScript: Script, scriptId: string, newSourceText: ISourceText, editRange: ScriptEditRange): UpdateUnitResult {
            this.logger.log("attemptIncrementalUpdateUnit(\"" + scriptId + "\")");

            if (editRange === null) {
                throw new Error("editRange should be valid");
            }

            var scope1 = this.getEnclosingScopeContextIfSingleScopeEdit(previousScript, scriptId, newSourceText, editRange);
            if (scope1 === null) {
                return null;
            }

            var newScopeLength = scope1.scopeStartAST.limChar - scope1.scopeStartAST.minChar + editRange.delta;

            // Heuristic: if the range to reparse is too big, bail out. 
            // This is because a full parse will be faster than an incremental parse followed by all the necessary fix-ups 
            if (newScopeLength >= newSourceText.getLength() / 2) {
                this.logger.log("  Bailing out because range of scope to reparse (" + newScopeLength + " characters) is greater than half the size of the source text");
                return null;
            }

            // Capture parsing errors so that they are part of "updateResult"
            var parseErrors: TypeScript.ErrorEntry[] = [];
            var errorCapture = function(minChar: number, charLen: number, message: string, unitIndex: number): void {
                parseErrors.push(new TypeScript.ErrorEntry(unitIndex, minChar, minChar + charLen, message));
            };

            var quickParseResult = TypeScript.quickParse(this.logger, scope1.scopeStartAST, newSourceText, scope1.scopeStartAST.minChar, scope1.scopeStartAST.minChar + newScopeLength, errorCapture);
            if (quickParseResult.endLexState != TypeScript.LexState.Start) {
                this.logger.log("  Bailing out because scope contains unterminated comment");
                return null;
            }

            var scriptFragment = quickParseResult.Script;
            if (scriptFragment.vars.members.length !== 0) {
                this.logger.log("  Bailing out because new source text defines variables");
                return null;
            }

            //if (scriptFragment.scopes.members.length !== 1) {
            //    logger.log("  Bailing out because new source text defines more than one scope (or none)");
            //    return null;
            //}

            // This detects adding close curlies, since they have the side effect of having the parser 
            // parse more members in the scope range.
            if (scriptFragment.bod.members.length !== 1) {
                this.logger.log("  Bailing out because new source text defines more than one scope (or none)");
                return null;
            }

            var oldScope = scope1.scopeStartAST;
            var newScope = scriptFragment.bod.members[0];

            if (oldScope.nodeType != newScope.nodeType) {
                this.logger.log("  Bailing out because new source text does not define the same scope type as the existing scope");
                return null;
            }

            if (!(<any>oldScope).leftCurlyCount || !(<any>oldScope).rightCurlyCount) {
                this.logger.log("  Bailing out because sopce doesn't have left/right curly count");
                return null;
            }

            if ((<any>oldScope).leftCurlyCount !== (<any>newScope).leftCurlyCount) {
                this.logger.log("  Bailing out because new source text contains more (or fewer) left curly braces");
                return null;
            }

            if ((<any>oldScope).rightCurlyCount !== (<any>newScope).rightCurlyCount) {
                this.logger.log("  Bailing out because new source text contains more (or fewer) right curly braces");
                return null;
            }

            if (newScope.minChar !== 0) {
                this.logger.log("  Bailing out because new function declaration does not start at position 0");
                return null;
            }

            if (newScope.limChar !== newScopeLength) {
                this.logger.log("  Bailing out because new function declaration does not end at the new end position");
                return null;
            }

            return TypeScript.UpdateUnitResult.singleScopeEdits(previousScript, scriptFragment, oldScope, newScope, editRange, parseErrors);
        }

        public mergeTrees(updateResult: UpdateUnitResult): void {
            TypeScript.timeFunction(this.logger, "mergeTrees()", () => {
                var editRange = new ScriptEditRange(updateResult.scope1.minChar, updateResult.scope1.limChar, updateResult.editRange.delta);
                // Update positions in current ast
                this.applyDeltaPosition(updateResult.script1, editRange.limChar, editRange.delta);
                // Update positions in new (partial) ast
                this.applyDeltaPosition(updateResult.script2, 0, editRange.minChar);
                // Merge linemaps
                this.mergeLocationInfo(updateResult.script1, updateResult.script2, editRange);
                //  Replace old AST for scope with new one
                this.replaceAST(updateResult.script1, updateResult.scope1, updateResult.scope2);
            });
        }

        private replaceAST(script: TypeScript.AST, oldAst: TypeScript.AST, newAst: TypeScript.AST) {
            var pre = (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) => {
                if (cur === oldAst) {
                    // Transfer comments ownership to new AST. We need this because when "quick parsing" the
                    // new AST, we don't take into account the text before and after the "minChar/limChar" pair
                    // of the scope, which don't include pre/post-comments.
                    newAst.preComments = cur.preComments;
                    newAst.postComments = cur.postComments;

                    this.logger.log("replaced old AST node with new one in script AST");
                    walker.options.stopWalk();
                    return newAst;
                }

                // Avoid visiting sub-trees outside of the edit range
                if (TypeScript.isValidAstNode(cur)) {
                    if (cur.limChar < oldAst.minChar || cur.minChar > oldAst.limChar) {
                        walker.options.goChildren = false;
                    }
                }
                return cur;
            }

            TypeScript.getAstWalkerFactory().walk(script, pre);
        }

        private mergeLocationInfo(script: TypeScript.Script, partial: TypeScript.Script, editRange: ScriptEditRange) {
            // Don't merger these fields, as the original script has the right values
            //script.locationInfo.unitIndex = partial.locationInfo.unitIndex;
            //script.locationInfo.filename = partial.locationInfo.filename;

            var lineMap1 = script.locationInfo.lineMap;
            var lineMap2 = partial.locationInfo.lineMap;

            if (this.logger.information()) {
                this.logger.log("lineMap1 (before):");
                this.astLogger.logLinemap(lineMap1);
                this.logger.log("lineMap2 (quick parse):");
                this.astLogger.logLinemap(lineMap2);
                this.logger.log("EditRange=" + editRange);
            }

            // Skip entries < minChar
            var i1 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.
            var i2 = 2; // lineMap[0] is always undefined, lineMap[1] is always 0.
            var len1 = lineMap1.length;
            var len2 = lineMap2.length;
            while (i1 < len1) {
                if (lineMap1[i1] <= editRange.minChar) {
                    // Nothing to do for this entry, since it's before the range of the change
                    i1++;
                } else if (lineMap1[i1] >= editRange.limChar) {
                    // Apply delta to this entry, since it's outside the range of the change
                    lineMap1[i1] += editRange.delta;
                    i1++;
                }
                else {
                    if (i2 < len2) {
                        // Add a new entry to lineMap1 corresponding to lineMap2 in new range
                        lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);
                        i1++;
                        len1++;
                        i2++;
                    }
                    else { /* i2 >= len 2 */
                        // Remove this entry, since there is no corresponding entry in the new map
                        lineMap1.splice(i1, 1);
                        len1--;
                    }
                }
            }
            // Merge the remaining entries in lineMap2 while maintaing the constraint that a lineMap is sorted
            if (i2 < len2) {
                // i1 >= len1 && i2 < len2 
                if (lineMap1[len1 - 1] >= (lineMap2[i2] + editRange.minChar)) {
                    // lineMap2 needs to be merged within lineMap1
                    i1 = 2;
                    while (i1 < len1 && i2 < len2) {
                        if (lineMap1[i1] < (lineMap2[i2] + editRange.minChar)) {
                            i1++;
                        }
                        else {
                            lineMap1.splice(i1, 0, lineMap2[i2] + editRange.minChar);
                            i1++;
                            len1++;
                            i2++;
                        }
                    }
                }

                // Append all the remaining entries in lineMap2 to the end of lineMap1
                for (; i2 < len2; i2++) {
                    lineMap1.push(lineMap2[i2] + editRange.minChar);
                }
            }

            if (this.logger.information()) {
                this.logger.log("lineMap1 (after merge):");
                this.astLogger.logLinemap(lineMap1);
            }
        }

        private applyDeltaPosition(ast: TypeScript.AST, start: number, delta: number) {
            var applyDelta = (ast: TypeScript.AST) => {
                if (ast.minChar !== -1 && ast.minChar >= start) {
                    ast.minChar += delta;
                }
                if (ast.limChar !== -1 && ast.limChar >= start) {
                    ast.limChar += delta;
                }
            }

            var applyDeltaToComments = (comments: TypeScript.Comment[]) => {
                if (comments && comments.length > 0) {
                    for (var i = 0; i < comments.length; i++) {
                        applyDelta(comments[i]);
                    }
                }
            }

            var pre = function(cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {
                // *Before* applying delta to this, check if we need to go to children
                if (cur.limChar !== -1 && cur.limChar < start) {
                    walker.options.goChildren = false; // Done with applying Delta for this sub-tree
                }

                // Apply delta to this node
                applyDelta(cur);
                applyDeltaToComments(cur.preComments);
                applyDeltaToComments(cur.postComments);

                return cur;
            }

            TypeScript.getAstWalkerFactory().walk(ast, pre);
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class DeclFileWriter {
        public onNewLine = true;
        constructor(private declFile: ITextWriter) {
        }

        public Write(s: string) {
            this.declFile.Write(s);
            this.onNewLine = false;
        }

        public WriteLine(s: string) {
            this.declFile.WriteLine(s);
            this.onNewLine = true;
        }

        public Close() {
            this.declFile.Close();
        }
    }

    export class DeclarationEmitter implements AstWalkerWithDetailCallback.AstWalkerDetailCallback {
        private declFile: DeclFileWriter = null;
        private indenter = new Indenter();
        private declarationContainerStack: AST[] = [];
        private isDottedModuleName: bool[] = [];
        private dottedModuleEmit: string;
        private ignoreCallbackAst: AST = null;
        private singleDeclFile: DeclFileWriter = null;
        private varListCount: number = 0;

        private getAstDeclarationContainer() {
            return this.declarationContainerStack[this.declarationContainerStack.length - 1];
        }

        private emitDottedModuleName() {
            return (this.isDottedModuleName.length == 0) ? false : this.isDottedModuleName[this.isDottedModuleName.length - 1];
        }

        constructor (public checker: TypeChecker, public emitOptions: EmitOptions, public errorReporter: ErrorReporter) {
        }

        public setDeclarationFile(file: ITextWriter) {
            this.declFile = new DeclFileWriter(file);
        }

        public Close() {
            try {
                // Closing files could result in exceptions, report them if they occur
                this.declFile.Close();
            } catch (ex) {
                this.errorReporter.emitterError(null, ex.message);
            }
        }

        public emitDeclarations(script: TypeScript.Script): void {
            AstWalkerWithDetailCallback.walk(script, this);
        }

        private getIndentString(declIndent? = false) {
            if (this.emitOptions.minWhitespace) {
                return "";
            }
            else {
                return this.indenter.getIndent();
            }
        }

        private emitIndent() {
            this.declFile.Write(this.getIndentString());
        }

        private canEmitSignature(declFlags: DeclFlags, canEmitGlobalAmbientDecl?: bool = true, useDeclarationContainerTop?: bool = true) {
            var container: AST;
            if (useDeclarationContainerTop) {
                container = this.getAstDeclarationContainer();
            } else {
                container = this.declarationContainerStack[this.declarationContainerStack.length - 2];
            }

            if (container.nodeType == NodeType.ModuleDeclaration && !hasFlag(declFlags, DeclFlags.Exported)) {
                return false;
            }

            if (!canEmitGlobalAmbientDecl && container.nodeType == NodeType.Script && hasFlag(declFlags, DeclFlags.Ambient)) {
                return false;
            }

            return true;
        }

        private canEmitPrePostAstSignature(declFlags: DeclFlags, astWithPrePostCallback: AST, preCallback: bool) {
            if (this.ignoreCallbackAst) {
                CompilerDiagnostics.assert(this.ignoreCallbackAst != astWithPrePostCallback, "Ignore Callback AST mismatch");
                this.ignoreCallbackAst = null;
                return false;
            } else if (preCallback &&
                !this.canEmitSignature(declFlags, true, preCallback)) {
                this.ignoreCallbackAst = astWithPrePostCallback;
                return false;
            }

            return true;
        }

        private getDeclFlagsString(declFlags: DeclFlags, typeString: string) {
            var result = this.getIndentString();

            // Accessor strings
            var accessorString = "";
            if (hasFlag(declFlags, DeclFlags.GetAccessor)) {
                accessorString = "get ";
            }
            else if (hasFlag(declFlags, DeclFlags.SetAccessor)) {
                accessorString = "set ";
            }

            // Emit export only for global export statements. The container for this would be dynamic module which is whole file
            var container = this.getAstDeclarationContainer();
            if (container.nodeType == NodeType.ModuleDeclaration &&
                hasFlag((<ModuleDeclaration>container).modFlags, ModuleFlags.IsWholeFile) &&
                hasFlag(declFlags, DeclFlags.Exported)) {
                result += "export ";
            }

            // Static/public/private/global declare
            if (hasFlag(declFlags, DeclFlags.LocalStatic) || hasFlag(declFlags, DeclFlags.Static)) {
                if (hasFlag(declFlags, DeclFlags.Private)) {
                    result += "private ";
                }
                result += "static " + accessorString;
            }
            else {
                if (hasFlag(declFlags, DeclFlags.Private)) {
                    result += "private " + accessorString;
                }
                else if (hasFlag(declFlags, DeclFlags.Public)) {
                    result += "public " + accessorString;
                }
                else {
                    if (accessorString == "") {
                        result += typeString + " ";
                    } else {
                        result += accessorString;
                    }
                }
            }

            return result;
        }

        private emitDeclFlags(declFlags: DeclFlags, typeString: string) {
            this.declFile.Write(this.getDeclFlagsString(declFlags, typeString));
        }

        private canEmitTypeAnnotationSignature(declFlag: DeclFlags = DeclFlags.None) {
            // Private declaration, shouldnt emit type any time.
            return !hasFlag(declFlag, DeclFlags.Private);
        }

        private pushDeclarationContainer(ast: AST) {
            this.declarationContainerStack.push(ast);
        }

        private popDeclarationContainer(ast: AST) {
            CompilerDiagnostics.assert(ast != this.getAstDeclarationContainer(), 'Declaration container mismatch');
            this.declarationContainerStack.pop();
        }

        private emitTypeNamesMember(memberName: MemberName, emitIndent? : bool = false) {
            if (memberName.prefix == "{ ") {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.WriteLine("{");
                this.indenter.increaseIndent();
                emitIndent = true;
            } else if (memberName.prefix != "") {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.Write(memberName.prefix);
                emitIndent = false;
            }

            if (memberName.isString()) {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.Write((<MemberNameString>memberName).text);
            } else {
                var ar = <MemberNameArray>memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    this.emitTypeNamesMember(ar.entries[index], emitIndent);
                    if (ar.delim == "; ") {
                        this.declFile.WriteLine(";");
                    }
                }
            }

            if (memberName.suffix == "}") {
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.declFile.Write(memberName.suffix);
            } else {
                this.declFile.Write(memberName.suffix);
            }
        }

        private emitTypeSignature(type: Type) {
            var containingScope: SymbolScope = null;
            var declarationContainerAst = this.getAstDeclarationContainer();
            switch (declarationContainerAst.nodeType) {
                case NodeType.ModuleDeclaration:
                case NodeType.InterfaceDeclaration:
                case NodeType.FuncDecl:
                    if (declarationContainerAst.type) {
                        containingScope = declarationContainerAst.type.containedScope;
                    }
                    break;

                case NodeType.Script:
                    var script = <Script>declarationContainerAst;
                    if (script.bod) {
                        containingScope = script.bod.enclosingScope;
                    }
                    break;

                case NodeType.ClassDeclaration:
                    if (declarationContainerAst.type) {
                        containingScope = declarationContainerAst.type.instanceType.containedScope;
                    }
                    break;

                default:
                    CompilerDiagnostics.debugPrint("Unknown containing scope");
            }

            var typeNameMembers = type.getScopedTypeNameEx(containingScope);
            this.emitTypeNamesMember(typeNameMembers);
        }

        private emitComment(comment: Comment) {
            var text = comment.getText();
            if (this.declFile.onNewLine) {
                this.emitIndent();
            } else if (!comment.isBlockComment) {
                this.declFile.WriteLine("");
                this.emitIndent();
            }
            
            this.declFile.Write(text[0]);

            for (var i = 1; i < text.length; i++) {
                this.declFile.WriteLine("");
                this.emitIndent();
                this.declFile.Write(text[i]);
            }

            if (comment.endsLine || !comment.isBlockComment) {
                this.declFile.WriteLine("");
            } else {
                this.declFile.Write(" ");
            }
        }

        private emitDeclarationComments(ast: AST, endLine?: bool);
        private emitDeclarationComments(symbol: Symbol, endLine?: bool);
        private emitDeclarationComments(astOrSymbol, endLine = true) {
            if (!this.emitOptions.emitComments) {
                return;
            }

            var declComments = <Comment[]>astOrSymbol.getDocComments();
            if (declComments.length > 0) {
                for (var i = 0; i < declComments.length; i++) {
                    this.emitComment(declComments[i]);
                }

                if (endLine) {
                    if (!this.declFile.onNewLine) {
                        this.declFile.WriteLine("");
                    }
                } else {
                    if (this.declFile.onNewLine) {
                        this.emitIndent();
                    }
                }
            }
        }

        public VarDeclCallback(pre: bool, varDecl: VarDecl): bool {
            if (pre && this.canEmitSignature(ToDeclFlags(varDecl.varFlags), false)) {
                var interfaceMember = (this.getAstDeclarationContainer().nodeType == NodeType.InterfaceDeclaration);
                this.emitDeclarationComments(varDecl);
                if (!interfaceMember) {
                    // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var
                    // If it is var list of form  var a = varList count will be 0
                    if (this.varListCount >= 0) {
                        this.emitDeclFlags(ToDeclFlags(varDecl.varFlags), "var");
                        this.varListCount = -this.varListCount;
                    }
                    this.declFile.Write(varDecl.id.text);
                } else {
                    this.emitIndent();
                    this.declFile.Write(varDecl.id.text);
                    if (hasFlag(varDecl.id.flags, ASTFlags.OptionalName)) {
                        this.declFile.Write("?");
                    }
                }

                var type: Type = null;
                if (varDecl.typeExpr && varDecl.typeExpr.type) {
                    type = varDecl.typeExpr.type;
                }
                else if (varDecl.sym) {
                    type = (<FieldSymbol>varDecl.sym).getType();
                    // Dont emit inferred any
                    if (type == this.checker.anyType) {
                        type = null;
                    }
                }

                if (type && this.canEmitTypeAnnotationSignature(ToDeclFlags(varDecl.varFlags))) {
                    this.declFile.Write(": ");
                    this.emitTypeSignature(type);
                }
               
                // emitted one var decl
                if (this.varListCount > 0) { this.varListCount--; } else if (this.varListCount < 0) { this.varListCount++; }

                // Write ; or ,
                if (this.varListCount < 0) {
                    this.declFile.Write(", ");
                } else {
                    this.declFile.WriteLine(";");
                }
            }
            return false;
        }

        public BlockCallback(pre: bool, block: Block): bool {
            if (!block.isStatementBlock) {
                if (pre) {
                    this.varListCount = block.statements.members.length;
                } else {
                    this.varListCount = 0;
                }
                return true;
            }
            return false;
        }

        private emitArgDecl(argDecl: ArgDecl, funcDecl: FuncDecl) {
            this.emitDeclarationComments(argDecl, false);
            this.declFile.Write(argDecl.id.text);
            if (argDecl.isOptionalArg()) {
                this.declFile.Write("?");
            }
            if ((argDecl.typeExpr || argDecl.type != this.checker.anyType) &&
                this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {
                this.declFile.Write(": ");
                this.emitTypeSignature(argDecl.type);
            }
        }

        public FuncDeclCallback(pre: bool, funcDecl: FuncDecl): bool {
            if (!pre) {
                return false;
            }

            if (funcDecl.isAccessor()) {
                return this.emitPropertyAccessorSignature(funcDecl);
            }

            var isInterfaceMember = (this.getAstDeclarationContainer().nodeType == NodeType.InterfaceDeclaration);
            if (funcDecl.bod) {
                if (funcDecl.isConstructor) {
                    if (funcDecl.type.construct && funcDecl.type.construct.signatures.length > 1) {
                        return false;
                    }
                } else {
                    if (funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {
                        // This means its implementation of overload signature. do not emit
                        return false;
                    }
                }
            } else if (!isInterfaceMember && hasFlag(funcDecl.fncFlags, FncFlags.Private) && funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {
                // Print only first overload of private function
                var signatures = funcDecl.type.call.signatures;
                var firstSignature = signatures[0].declAST;
                if (firstSignature.bod) {
                    // Its a implementation, use next one
                    firstSignature = signatures[1].declAST;
                }

                if (firstSignature != funcDecl) {
                    return false;
                }
            }

            if (!this.canEmitSignature(ToDeclFlags(funcDecl.fncFlags), false)) {
                return false;
            }

            this.emitDeclarationComments(funcDecl);
            if (funcDecl.isConstructor) {
                this.emitIndent();
                this.declFile.Write("constructor");
            }
            else {
                var id = funcDecl.getNameText();
                if (!isInterfaceMember) {
                    this.emitDeclFlags(ToDeclFlags(funcDecl.fncFlags), "function");
                    this.declFile.Write(id);
                } else {
                    this.emitIndent();
                    if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                    } else if (!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {
                        this.declFile.Write(id);
                        if (hasFlag(funcDecl.name.flags, ASTFlags.OptionalName)) {
                            this.declFile.Write("? ");
                        }
                    }
                }
            }

            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write("(");
            } else {
                this.declFile.Write("[");
            }

            this.indenter.increaseIndent();

            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length;
                if (funcDecl.variableArgList) {
                    argsLen--;
                }
                for (var i = 0; i < argsLen; i++) {
                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];
                    this.emitArgDecl(argDecl, funcDecl);
                    if (i < (argsLen - 1)) {
                        this.declFile.Write(", ");
                    }
                }
            }

            if (funcDecl.variableArgList) {
                var lastArg = <ArgDecl>funcDecl.arguments.members[funcDecl.arguments.members.length - 1];
                if (funcDecl.arguments.members.length > 1) {
                    this.declFile.Write(", ...");
                }
                else {
                    this.declFile.Write("...");
                }
                this.emitArgDecl(lastArg, funcDecl);
            }

            this.indenter.decreaseIndent();

            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write(")");
            } else {
                this.declFile.Write("]");
            }

            if (!funcDecl.isConstructor &&
                (funcDecl.returnTypeAnnotation || funcDecl.signature.returnType.type != this.checker.anyType) &&
                this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {
                this.declFile.Write(": ");
                this.emitTypeSignature(funcDecl.signature.returnType.type);
            }

            this.declFile.WriteLine(";");

            return false;
        }

        private emitBaseList(bases: ASTList, qual: string) {
            if (bases && (bases.members.length > 0)) {
                this.declFile.Write(" " + qual + " ");
                var basesLen = bases.members.length;
                for (var i = 0; i < basesLen; i++) {
                    var baseExpr = bases.members[i];
                    var baseSymbol = baseExpr.type.symbol;
                    var baseType = baseExpr.type;
                    if (i > 0) {
                        this.declFile.Write(", ");
                    }
                    this.emitTypeSignature(baseType);
                }
            }
        }

        private emitPropertyAccessorSignature(funcDecl: FuncDecl) {
            var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;
            if (accessorSymbol.getter && accessorSymbol.getter.declAST != funcDecl) {
                // Setter is being used to emit the type info. 
                return false;
            }

            this.emitDeclarationComments(accessorSymbol);
            this.emitDeclFlags(ToDeclFlags(accessorSymbol.flags), "var");
            this.declFile.Write(funcDecl.name.text);
            var propertyType = accessorSymbol.getType();
            if (this.canEmitTypeAnnotationSignature(ToDeclFlags(accessorSymbol.flags))) {
                this.declFile.Write(" : ");
                this.emitTypeSignature(propertyType);
            }
            this.declFile.WriteLine(";");

            return false;
        }

        private emitClassMembersFromConstructorDefinition(funcDecl: FuncDecl) {
            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length; if (funcDecl.variableArgList) { argsLen--; }

                for (var i = 0; i < argsLen; i++) {
                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];
                    if (hasFlag(argDecl.varFlags, VarFlags.Property)) {
                        this.emitDeclarationComments(argDecl);
                        this.emitDeclFlags(ToDeclFlags(argDecl.varFlags), "var");
                        this.declFile.Write(argDecl.id.text);

                        if (argDecl.typeExpr && this.canEmitTypeAnnotationSignature(ToDeclFlags(argDecl.varFlags))) {
                            this.declFile.Write(": ");
                            this.emitTypeSignature(argDecl.type);
                        }
                        this.declFile.WriteLine(";");
                    }
                }
            }
        }

        public ClassDeclarationCallback(pre: bool, classDecl: ClassDeclaration): bool {
            if (!this.canEmitPrePostAstSignature(ToDeclFlags(classDecl.varFlags), classDecl, pre)) {
                return false;
            }

            if (pre) {
                var className = classDecl.name.text;
                this.emitDeclarationComments(classDecl);
                this.emitDeclFlags(ToDeclFlags(classDecl.varFlags), "class");
                this.declFile.Write(className);
                this.emitBaseList(classDecl.extendsList, "extends");
                this.emitBaseList(classDecl.implementsList, "implements");
                this.declFile.WriteLine(" {");

                this.pushDeclarationContainer(classDecl);
                this.indenter.increaseIndent();
                if (classDecl.constructorDecl) {
                    this.emitClassMembersFromConstructorDefinition(classDecl.constructorDecl);
                }
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(classDecl);

                this.emitIndent();
                this.declFile.WriteLine("}");
            }

            return true;
        }

        public InterfaceDeclarationCallback(pre: bool, interfaceDecl: InterfaceDeclaration): bool {
            if (!this.canEmitPrePostAstSignature(ToDeclFlags(interfaceDecl.varFlags), interfaceDecl, pre)) {
                return false;
            }

            if (pre) {
                var interfaceName = interfaceDecl.name.text;
                this.emitDeclarationComments(interfaceDecl);
                this.emitDeclFlags(ToDeclFlags(interfaceDecl.varFlags), "interface");
                this.declFile.Write(interfaceName);
                this.emitBaseList(interfaceDecl.extendsList, "extends");
                this.declFile.WriteLine(" {");

                this.indenter.increaseIndent();
                this.pushDeclarationContainer(interfaceDecl);
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(interfaceDecl);

                this.emitIndent();
                this.declFile.WriteLine("}");
            }

            return true;
        }

        public ImportDeclarationCallback(pre: bool, importDecl: ImportDeclaration): bool {
            if (pre) {
                if ((<Script>this.declarationContainerStack[0]).isExternallyVisibleSymbol(importDecl.id.sym)) {
                    this.emitDeclarationComments(importDecl);
                    this.emitIndent();
                    this.declFile.Write("import ");

                    this.declFile.Write(importDecl.id.text + " = ");
                    if (importDecl.isDynamicImport) {
                        this.declFile.WriteLine("module (" + importDecl.getAliasName() + ");");
                    } else {
                        this.declFile.WriteLine(importDecl.getAliasName() + ";");
                    }
                }
            }

            return false;
        }

        private emitEnumSignature(moduleDecl: ModuleDeclaration) {
            if (!this.canEmitSignature(ToDeclFlags(moduleDecl.modFlags))) {
                return false;
            }

            this.emitDeclarationComments(moduleDecl);
            this.emitDeclFlags(ToDeclFlags(moduleDecl.modFlags), "enum");
            this.declFile.WriteLine(moduleDecl.name.text + " {");

            this.indenter.increaseIndent();
            var membersLen = moduleDecl.members.members.length;
            for (var j = 1; j < membersLen; j++) {
                var memberDecl: AST = moduleDecl.members.members[j];
                if (memberDecl.nodeType == NodeType.VarDecl) {
                    this.emitDeclarationComments(memberDecl);
                    this.emitIndent();
                    this.declFile.WriteLine((<VarDecl>memberDecl).id.text + ",");
                } else {
                    CompilerDiagnostics.assert(memberDecl.nodeType != NodeType.Asg, "We want to catch this");
                }
            }
            this.indenter.decreaseIndent();

            this.emitIndent();
            this.declFile.WriteLine("}");

            return false;
        }

        public ModuleDeclarationCallback(pre: bool, moduleDecl: ModuleDeclaration): bool {
            if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile)) {
                // This is dynamic modules and we are going to outputing single file, 
                // we need to change the declFile because dynamic modules are always emitted to their corresponding .d.ts
                if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic)) {
                    if (pre) {
                        if (!this.emitOptions.outputMany) {
                            this.singleDeclFile = this.declFile;
                            CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");
                            // Create new file
                            var declareFileName = this.emitOptions.mapOutputFileName(stripQuotes(moduleDecl.name.sym.name), TypeScriptCompiler.mapToDTSFileName);
                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);
                            try {
                                // Creating files can cause exceptions, report them.   
                                this.declFile = new DeclFileWriter(this.emitOptions.ioHost.createFile(declareFileName, useUTF8InOutputfile));
                            } catch (ex) {
                                this.errorReporter.emitterError(null, ex.message);
                            }
                        }
                        this.pushDeclarationContainer(moduleDecl);
                    } else {
                        if (!this.emitOptions.outputMany) {
                            CompilerDiagnostics.assert(this.singleDeclFile != this.declFile, "singleDeclFile cannot be null as we are going to revert back to it");
                            CompilerDiagnostics.assert(this.indenter.indentAmt == 0, "Indent has to be 0 when outputing new file");
                            try {
                                // Closing files could result in exceptions, report them if they occur
                                this.declFile.Close();
                            } catch (ex) {
                                this.errorReporter.emitterError(null, ex.message);
                            }
                            this.declFile = this.singleDeclFile;
                        }
                        this.popDeclarationContainer(moduleDecl);
                    }
                }

                return true;
            }

            if (moduleDecl.isEnum()) {
                if (pre) {
                    this.emitEnumSignature(moduleDecl);
                }
                return false;
            }

            if (!this.canEmitPrePostAstSignature(ToDeclFlags(moduleDecl.modFlags), moduleDecl, pre)) {
                return false;
            }

            if (pre) {
                if (this.emitDottedModuleName()) {
                    this.dottedModuleEmit += ".";
                } else {
                    this.dottedModuleEmit = this.getDeclFlagsString(ToDeclFlags(moduleDecl.modFlags), "module");
                }
                this.dottedModuleEmit += moduleDecl.name.text;

                var isCurrentModuleDotted = (moduleDecl.members.members.length == 1 &&
                    moduleDecl.members.members[0].nodeType == NodeType.ModuleDeclaration &&
                    !(<ModuleDeclaration>moduleDecl.members.members[0]).isEnum() &&
                    hasFlag((<ModuleDeclaration>moduleDecl.members.members[0]).modFlags, ModuleFlags.Exported));

                // Module is dotted only if it does not have doc comments for it
                var moduleDeclComments = moduleDecl.getDocComments();
                isCurrentModuleDotted = isCurrentModuleDotted && (moduleDeclComments == null || moduleDeclComments.length == 0);

                this.isDottedModuleName.push(isCurrentModuleDotted);
                this.pushDeclarationContainer(moduleDecl);

                if (!isCurrentModuleDotted) {
                    this.emitDeclarationComments(moduleDecl);
                    this.declFile.Write(this.dottedModuleEmit);
                    this.declFile.WriteLine(" {");
                    this.indenter.increaseIndent();
                }
            } else {
                if (!this.emitDottedModuleName()) {
                    this.indenter.decreaseIndent();
                    this.emitIndent();
                    this.declFile.WriteLine("}");
                }
                this.popDeclarationContainer(moduleDecl);
                this.isDottedModuleName.pop();
            }

            return true;
        }

        public ScriptCallback(pre: bool, script: Script): bool {
            if (pre) {
                if (this.emitOptions.outputMany) {
                    for (var i = 0; i < script.referencedFiles.length; i++) {
                        var referencePath = script.referencedFiles[i].path;
                        var declareFileName: string;
                        if (isRooted(referencePath)) {
                            declareFileName = this.emitOptions.mapOutputFileName(referencePath, TypeScriptCompiler.mapToDTSFileName)
                        } else {
                            declareFileName = getDeclareFilePath(script.referencedFiles[i].path);
                        }
                        this.declFile.WriteLine('/// <reference path="' + declareFileName + '" />');
                    }
                }
                this.pushDeclarationContainer(script);
            }
            else {
                this.popDeclarationContainer(script);
            }
            return true;
        }

        public DefaultCallback(pre: bool, ast: AST): bool {
            return !hasFlag(ast.flags, ASTFlags.IsStatement);
        }
    }
}
// If you change anything in this enum, make sure you run SyntaxGenerator again!

enum SyntaxKind {
    // Variable width tokens, trivia and lists.
    None,
    List,
    SeparatedList,
    TriviaList,

    // Trivia
    WhitespaceTrivia,
    NewLineTrivia,
    MultiLineCommentTrivia,
    SingleLineCommentTrivia,
    SkippedTextTrivia,

    // Note: all variable width tokens must come before all fixed width tokens.

    ErrorToken,
    EndOfFileToken,

    // Tokens
    IdentifierName,

    // LiteralTokens
    RegularExpressionLiteral,
    NumericLiteral,
    StringLiteral,

    // All fixed width tokens follow.

    // Keywords
    BreakKeyword,
    CaseKeyword,
    CatchKeyword,
    ContinueKeyword,
    DebuggerKeyword,
    DefaultKeyword,
    DeleteKeyword,
    DoKeyword,
    ElseKeyword,
    FalseKeyword,
    FinallyKeyword,
    ForKeyword,
    FunctionKeyword,
    IfKeyword,
    InKeyword,
    InstanceOfKeyword,
    NewKeyword,
    NullKeyword,
    ReturnKeyword,
    SwitchKeyword,
    ThisKeyword,
    ThrowKeyword,
    TrueKeyword,
    TryKeyword,
    TypeOfKeyword,
    VarKeyword,
    VoidKeyword,
    WhileKeyword,
    WithKeyword,

    // FutureReservedWords.
    ClassKeyword,
    ConstKeyword,
    EnumKeyword,
    ExportKeyword,
    ExtendsKeyword,
    ImportKeyword,
    SuperKeyword,

    // FutureReservedStrictWords.
    ImplementsKeyword,
    InterfaceKeyword,
    LetKeyword,
    PackageKeyword,
    PrivateKeyword,
    ProtectedKeyword,
    PublicKeyword,
    StaticKeyword,
    YieldKeyword,

    // TypeScript keywords.
    AnyKeyword,
    BooleanKeyword,
    BoolKeyword,
    ConstructorKeyword,
    DeclareKeyword,
    GetKeyword,
    ModuleKeyword,
    NumberKeyword,
    SetKeyword,
    StringKeyword,

    // Punctuators
    OpenBraceToken,
    CloseBraceToken,
    OpenParenToken,
    CloseParenToken,
    OpenBracketToken,
    CloseBracketToken,
    DotToken,
    DotDotDotToken,
    SemicolonToken,
    CommaToken,
    LessThanToken,
    GreaterThanToken,
    LessThanEqualsToken,
    GreaterThanEqualsToken,
    EqualsEqualsToken,
    EqualsGreaterThanToken,
    ExclamationEqualsToken,
    EqualsEqualsEqualsToken,
    ExclamationEqualsEqualsToken,
    PlusToken,
    MinusToken,
    AsteriskToken,
    PercentToken,
    PlusPlusToken,
    MinusMinusToken,
    LessThanLessThanToken,
    GreaterThanGreaterThanToken,
    GreaterThanGreaterThanGreaterThanToken,
    AmpersandToken,
    BarToken,
    CaretToken,
    ExclamationToken,
    TildeToken,
    AmpersandAmpersandToken,
    BarBarToken,
    QuestionToken,
    ColonToken,
    EqualsToken,
    PlusEqualsToken,
    MinusEqualsToken,
    AsteriskEqualsToken,
    PercentEqualsToken,
    LessThanLessThanEqualsToken,
    GreaterThanGreaterThanEqualsToken,
    GreaterThanGreaterThanGreaterThanEqualsToken,
    AmpersandEqualsToken,
    BarEqualsToken,
    CaretEqualsToken,
    SlashToken,
    SlashEqualsToken,

    // SyntaxNodes
    SourceUnit,

    // Names
    QualifiedName,

    // Types
    ObjectType,
    FunctionType,
    ArrayType,
    ConstructorType,
    GenericType,

    // Module elements.
    InterfaceDeclaration,
    FunctionDeclaration,
    ModuleDeclaration,
    ClassDeclaration,
    EnumDeclaration,
    ImportDeclaration,

    // ClassElements
    MemberFunctionDeclaration,
    MemberVariableDeclaration,
    ConstructorDeclaration,
    GetMemberAccessorDeclaration,
    SetMemberAccessorDeclaration,

    // Type members.
    PropertySignature,
    CallSignature,
    ConstructSignature,
    IndexSignature,
    FunctionSignature,

    // Statements
    Block,
    IfStatement,
    VariableStatement,
    ExpressionStatement,
    ReturnStatement,
    SwitchStatement,
    BreakStatement,
    ContinueStatement,
    ForStatement,
    ForInStatement,
    EmptyStatement,
    ThrowStatement,
    WhileStatement,
    TryStatement,
    LabeledStatement,
    DoStatement,
    DebuggerStatement,
    WithStatement,

    // Expressions
    PlusExpression,
    NegateExpression,
    BitwiseNotExpression,
    LogicalNotExpression,
    PreIncrementExpression,
    PreDecrementExpression,
    DeleteExpression,
    TypeOfExpression,
    VoidExpression,
    CommaExpression,
    AssignmentExpression,
    AddAssignmentExpression,
    SubtractAssignmentExpression,
    MultiplyAssignmentExpression,
    DivideAssignmentExpression,
    ModuloAssignmentExpression,
    AndAssignmentExpression,
    ExclusiveOrAssignmentExpression,
    OrAssignmentExpression,
    LeftShiftAssignmentExpression,
    SignedRightShiftAssignmentExpression,
    UnsignedRightShiftAssignmentExpression,
    ConditionalExpression,
    LogicalOrExpression,
    LogicalAndExpression,
    BitwiseOrExpression,
    BitwiseExclusiveOrExpression,
    BitwiseAndExpression,
    EqualsWithTypeConversionExpression,
    NotEqualsWithTypeConversionExpression,
    EqualsExpression,
    NotEqualsExpression,
    LessThanExpression,
    GreaterThanExpression,
    LessThanOrEqualExpression,
    GreaterThanOrEqualExpression,
    InstanceOfExpression,
    InExpression,
    LeftShiftExpression,
    SignedRightShiftExpression,
    UnsignedRightShiftExpression,
    MultiplyExpression,
    DivideExpression,
    ModuloExpression,
    AddExpression,
    SubtractExpression,
    PostIncrementExpression,
    PostDecrementExpression,
    MemberAccessExpression,
    InvocationExpression,
    ArrayLiteralExpression,
    ObjectLiteralExpression,
    ObjectCreationExpression,
    ParenthesizedExpression,
    ParenthesizedArrowFunctionExpression,
    SimpleArrowFunctionExpression,
    CastExpression,
    ElementAccessExpression,
    FunctionExpression,
    OmittedExpression,

    // Variable declarations
    VariableDeclaration,
    VariableDeclarator,

    // Lists
    ArgumentList,
    ParameterList,
    TypeArgumentList,
    TypeParameterList,

    // Clauses
    ImplementsClause,
    ExtendsClause,
    EqualsValueClause,
    CaseSwitchClause,
    DefaultSwitchClause,
    ElseClause,
    CatchClause,
    FinallyClause,

    // Generics
    TypeParameter,
    Constraint,

    // Misc.
    Parameter,
    TypeAnnotation,
    SimplePropertyAssignment,
    ExternalModuleReference,
    ModuleNameModuleReference,
    GetAccessorPropertyAssignment,
    SetAccessorPropertyAssignment,

    FirstStandardKeyword = BreakKeyword,
    LastStandardKeyword = WithKeyword,

    FirstFutureReservedKeyword = ClassKeyword,
    LastFutureReservedKeyword = SuperKeyword,

    FirstFutureReservedStrictKeyword = ImplementsKeyword,
    LastFutureReservedStrictKeyword = YieldKeyword,

    FirstTypeScriptKeyword = AnyKeyword,
    LastTypeScriptKeyword = StringKeyword,

    FirstKeyword = FirstStandardKeyword,
    LastKeyword = LastTypeScriptKeyword,

    FirstToken = ErrorToken,
    LastToken = SlashEqualsToken,

    FirstPunctuation = OpenBraceToken,
    LastPunctuation = SlashEqualsToken,

    FirstFixedWidth = FirstKeyword,
    LastFixedWidth = LastPunctuation,
}
///<reference path='ISyntaxElement.ts' />

interface ISyntaxTrivia {
    kind(): SyntaxKind;

    isWhitespace(): bool;
    isComment(): bool;
    isNewLine(): bool;
    isSkippedText(): bool;

    // With of this trivia.
    fullWidth(): number;

    // Text for this trivia.
    fullText(): string;
}
///<reference path='ISyntaxElement.ts' />
///<reference path='ISyntaxTrivia.ts' />

interface ISyntaxTriviaList {
    count(): number;
    syntaxTriviaAt(index: number): ISyntaxTrivia;

    // With of this trivia list.
    fullWidth(): number;

    // Text for this trivia list.
    fullText(): string;

    hasComment(): bool;
    hasNewLine(): bool;
    hasSkippedText(): bool;

    last(): ISyntaxTrivia;
    toArray(): ISyntaxTrivia[];

    concat(trivia: ISyntaxTriviaList): ISyntaxTriviaList;

    collectTextElements(elements: string[]): void;
}
﻿///<reference path='ISyntaxNodeOrToken.ts' />

class SyntaxRewriter implements ISyntaxVisitor {
    public visitToken(token: ISyntaxToken): ISyntaxToken {
        return token;
    }

    public visitNode(node: SyntaxNode): SyntaxNode {
        return node.accept(this);
    }

    public visitNodeOrToken(node: ISyntaxNodeOrToken): ISyntaxNodeOrToken {
        return node.isToken() ? <ISyntaxNodeOrToken>this.visitToken(<ISyntaxToken>node) : this.visitNode(<SyntaxNode>node);
    }

    public visitList(list: ISyntaxList): ISyntaxList {
        var newItems: ISyntaxNodeOrToken[] = null;

        for (var i = 0, n = list.childCount(); i < n; i++) {
            var item = list.childAt(i);
            var newItem = this.visitNodeOrToken(item);

            if (item !== newItem && newItems === null) {
                newItems = [];
                for (var j = 0; j < i; j++) {
                    newItems.push(list.childAt(j));
                }
            }

            if (newItems) {
                newItems.push(newItem);
            }
        }

        // Debug.assert(newItems === null || newItems.length === list.childCount());
        return newItems === null ? list : Syntax.list(newItems);
    }

    public visitSeparatedList(list: ISeparatedSyntaxList): ISeparatedSyntaxList {
        var newItems: ISyntaxNodeOrToken[] = null;

        for (var i = 0, n = list.childCount(); i < n; i++) {
            var item = list.childAt(i);
            var newItem = item.isToken() ? <ISyntaxNodeOrToken>this.visitToken(<ISyntaxToken>item) : this.visitNode(<SyntaxNode>item);

            if (item !== newItem && newItems === null) {
                newItems = [];
                for (var j = 0; j < i; j++) {
                    newItems.push(list.childAt(j));
                }
            }

            if (newItems) {
                newItems.push(newItem);
            }
        }

        // Debug.assert(newItems === null || newItems.length === list.childCount());
        return newItems === null ? list : Syntax.separatedList(newItems);
    }

    public visitSourceUnit(node: SourceUnitSyntax): any {
        return node.update(
            this.visitList(node.moduleElements),
            this.visitToken(node.endOfFileToken));
    }

    public visitExternalModuleReference(node: ExternalModuleReferenceSyntax): any {
        return node.update(
            this.visitToken(node.moduleKeyword),
            this.visitToken(node.openParenToken),
            this.visitToken(node.stringLiteral),
            this.visitToken(node.closeParenToken));
    }

    public visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): any {
        return node.update(
            <INameSyntax>this.visitNodeOrToken(node.moduleName));
    }

    public visitImportDeclaration(node: ImportDeclarationSyntax): any {
        return node.update(
            this.visitToken(node.importKeyword),
            this.visitToken(node.identifier),
            this.visitToken(node.equalsToken),
            <ModuleReferenceSyntax>this.visitNode(node.moduleReference),
            this.visitToken(node.semicolonToken));
    }

    public visitClassDeclaration(node: ClassDeclarationSyntax): any {
        return node.update(
            node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
            node.declareKeyword === null ? null : this.visitToken(node.declareKeyword),
            this.visitToken(node.classKeyword),
            this.visitToken(node.identifier),
            node.typeParameterList === null ? null : <TypeParameterListSyntax>this.visitNode(node.typeParameterList),
            node.extendsClause === null ? null : <ExtendsClauseSyntax>this.visitNode(node.extendsClause),
            node.implementsClause === null ? null : <ImplementsClauseSyntax>this.visitNode(node.implementsClause),
            this.visitToken(node.openBraceToken),
            this.visitList(node.classElements),
            this.visitToken(node.closeBraceToken));
    }

    public visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): any {
        return node.update(
            node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
            this.visitToken(node.interfaceKeyword),
            this.visitToken(node.identifier),
            node.typeParameterList === null ? null : <TypeParameterListSyntax>this.visitNode(node.typeParameterList),
            node.extendsClause === null ? null : <ExtendsClauseSyntax>this.visitNode(node.extendsClause),
            <ObjectTypeSyntax>this.visitNode(node.body));
    }

    public visitExtendsClause(node: ExtendsClauseSyntax): any {
        return node.update(
            this.visitToken(node.extendsKeyword),
            this.visitSeparatedList(node.typeNames));
    }

    public visitImplementsClause(node: ImplementsClauseSyntax): any {
        return node.update(
            this.visitToken(node.implementsKeyword),
            this.visitSeparatedList(node.typeNames));
    }

    public visitModuleDeclaration(node: ModuleDeclarationSyntax): any {
        return node.update(
            node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
            node.declareKeyword === null ? null : this.visitToken(node.declareKeyword),
            this.visitToken(node.moduleKeyword),
            node.moduleName === null ? null : <INameSyntax>this.visitNodeOrToken(node.moduleName),
            node.stringLiteral === null ? null : this.visitToken(node.stringLiteral),
            this.visitToken(node.openBraceToken),
            this.visitList(node.moduleElements),
            this.visitToken(node.closeBraceToken));
    }

    public visitFunctionDeclaration(node: FunctionDeclarationSyntax): any {
        return node.update(
            node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
            node.declareKeyword === null ? null : this.visitToken(node.declareKeyword),
            this.visitToken(node.functionKeyword),
            <FunctionSignatureSyntax>this.visitNode(node.functionSignature),
            node.block === null ? null : <BlockSyntax>this.visitNode(node.block),
            node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
    }

    public visitVariableStatement(node: VariableStatementSyntax): any {
        return node.update(
            node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
            node.declareKeyword === null ? null : this.visitToken(node.declareKeyword),
            <VariableDeclarationSyntax>this.visitNode(node.variableDeclaration),
            this.visitToken(node.semicolonToken));
    }

    public visitVariableDeclaration(node: VariableDeclarationSyntax): any {
        return node.update(
            this.visitToken(node.varKeyword),
            this.visitSeparatedList(node.variableDeclarators));
    }

    public visitVariableDeclarator(node: VariableDeclaratorSyntax): any {
        return node.update(
            this.visitToken(node.identifier),
            node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation),
            node.equalsValueClause === null ? null : <EqualsValueClauseSyntax>this.visitNode(node.equalsValueClause));
    }

    public visitEqualsValueClause(node: EqualsValueClauseSyntax): any {
        return node.update(
            this.visitToken(node.equalsToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.value));
    }

    public visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): any {
        return node.update(
            node.kind(),
            this.visitToken(node.operatorToken),
            <IUnaryExpressionSyntax>this.visitNodeOrToken(node.operand));
    }

    public visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): any {
        return node.update(
            this.visitToken(node.openBracketToken),
            this.visitSeparatedList(node.expressions),
            this.visitToken(node.closeBracketToken));
    }

    public visitOmittedExpression(node: OmittedExpressionSyntax): any {
        return node;
    }

    public visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): any {
        return node.update(
            this.visitToken(node.openParenToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.expression),
            this.visitToken(node.closeParenToken));
    }

    public visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): any {
        return node.update(
            this.visitToken(node.identifier),
            this.visitToken(node.equalsGreaterThanToken),
            <ISyntaxNodeOrToken>this.visitNodeOrToken(node.body));
    }

    public visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): any {
        return node.update(
            <CallSignatureSyntax>this.visitNode(node.callSignature),
            this.visitToken(node.equalsGreaterThanToken),
            <ISyntaxNodeOrToken>this.visitNodeOrToken(node.body));
    }

    public visitQualifiedName(node: QualifiedNameSyntax): any {
        return node.update(
            <INameSyntax>this.visitNodeOrToken(node.left),
            this.visitToken(node.dotToken),
            this.visitToken(node.right));
    }

    public visitTypeArgumentList(node: TypeArgumentListSyntax): any {
        return node.update(
            this.visitToken(node.lessThanToken),
            this.visitSeparatedList(node.typeArguments),
            this.visitToken(node.greaterThanToken));
    }

    public visitConstructorType(node: ConstructorTypeSyntax): any {
        return node.update(
            this.visitToken(node.newKeyword),
            node.typeParameterList === null ? null : <TypeParameterListSyntax>this.visitNode(node.typeParameterList),
            <ParameterListSyntax>this.visitNode(node.parameterList),
            this.visitToken(node.equalsGreaterThanToken),
            <ITypeSyntax>this.visitNodeOrToken(node.type));
    }

    public visitFunctionType(node: FunctionTypeSyntax): any {
        return node.update(
            node.typeParameterList === null ? null : <TypeParameterListSyntax>this.visitNode(node.typeParameterList),
            <ParameterListSyntax>this.visitNode(node.parameterList),
            this.visitToken(node.equalsGreaterThanToken),
            <ITypeSyntax>this.visitNodeOrToken(node.type));
    }

    public visitObjectType(node: ObjectTypeSyntax): any {
        return node.update(
            this.visitToken(node.openBraceToken),
            this.visitSeparatedList(node.typeMembers),
            this.visitToken(node.closeBraceToken));
    }

    public visitArrayType(node: ArrayTypeSyntax): any {
        return node.update(
            <ITypeSyntax>this.visitNodeOrToken(node.type),
            this.visitToken(node.openBracketToken),
            this.visitToken(node.closeBracketToken));
    }

    public visitGenericType(node: GenericTypeSyntax): any {
        return node.update(
            <INameSyntax>this.visitNodeOrToken(node.name),
            <TypeArgumentListSyntax>this.visitNode(node.typeArgumentList));
    }

    public visitTypeAnnotation(node: TypeAnnotationSyntax): any {
        return node.update(
            this.visitToken(node.colonToken),
            <ITypeSyntax>this.visitNodeOrToken(node.type));
    }

    public visitBlock(node: BlockSyntax): any {
        return node.update(
            this.visitToken(node.openBraceToken),
            this.visitList(node.statements),
            this.visitToken(node.closeBraceToken));
    }

    public visitParameter(node: ParameterSyntax): any {
        return node.update(
            node.dotDotDotToken === null ? null : this.visitToken(node.dotDotDotToken),
            node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword),
            this.visitToken(node.identifier),
            node.questionToken === null ? null : this.visitToken(node.questionToken),
            node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation),
            node.equalsValueClause === null ? null : <EqualsValueClauseSyntax>this.visitNode(node.equalsValueClause));
    }

    public visitMemberAccessExpression(node: MemberAccessExpressionSyntax): any {
        return node.update(
            <IExpressionSyntax>this.visitNodeOrToken(node.expression),
            this.visitToken(node.dotToken),
            this.visitToken(node.name));
    }

    public visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): any {
        return node.update(
            node.kind(),
            <IExpressionSyntax>this.visitNodeOrToken(node.operand),
            this.visitToken(node.operatorToken));
    }

    public visitElementAccessExpression(node: ElementAccessExpressionSyntax): any {
        return node.update(
            <IExpressionSyntax>this.visitNodeOrToken(node.expression),
            this.visitToken(node.openBracketToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.argumentExpression),
            this.visitToken(node.closeBracketToken));
    }

    public visitInvocationExpression(node: InvocationExpressionSyntax): any {
        return node.update(
            <IExpressionSyntax>this.visitNodeOrToken(node.expression),
            <ArgumentListSyntax>this.visitNode(node.argumentList));
    }

    public visitArgumentList(node: ArgumentListSyntax): any {
        return node.update(
            node.typeArgumentList === null ? null : <TypeArgumentListSyntax>this.visitNode(node.typeArgumentList),
            this.visitToken(node.openParenToken),
            this.visitSeparatedList(node.arguments),
            this.visitToken(node.closeParenToken));
    }

    public visitBinaryExpression(node: BinaryExpressionSyntax): any {
        return node.update(
            node.kind(),
            <IExpressionSyntax>this.visitNodeOrToken(node.left),
            this.visitToken(node.operatorToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.right));
    }

    public visitConditionalExpression(node: ConditionalExpressionSyntax): any {
        return node.update(
            <IExpressionSyntax>this.visitNodeOrToken(node.condition),
            this.visitToken(node.questionToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.whenTrue),
            this.visitToken(node.colonToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.whenFalse));
    }

    public visitConstructSignature(node: ConstructSignatureSyntax): any {
        return node.update(
            this.visitToken(node.newKeyword),
            <CallSignatureSyntax>this.visitNode(node.callSignature));
    }

    public visitFunctionSignature(node: FunctionSignatureSyntax): any {
        return node.update(
            this.visitToken(node.identifier),
            node.questionToken === null ? null : this.visitToken(node.questionToken),
            <CallSignatureSyntax>this.visitNode(node.callSignature));
    }

    public visitIndexSignature(node: IndexSignatureSyntax): any {
        return node.update(
            this.visitToken(node.openBracketToken),
            <ParameterSyntax>this.visitNode(node.parameter),
            this.visitToken(node.closeBracketToken),
            node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation));
    }

    public visitPropertySignature(node: PropertySignatureSyntax): any {
        return node.update(
            this.visitToken(node.identifier),
            node.questionToken === null ? null : this.visitToken(node.questionToken),
            node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation));
    }

    public visitParameterList(node: ParameterListSyntax): any {
        return node.update(
            this.visitToken(node.openParenToken),
            this.visitSeparatedList(node.parameters),
            this.visitToken(node.closeParenToken));
    }

    public visitCallSignature(node: CallSignatureSyntax): any {
        return node.update(
            node.typeParameterList === null ? null : <TypeParameterListSyntax>this.visitNode(node.typeParameterList),
            <ParameterListSyntax>this.visitNode(node.parameterList),
            node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation));
    }

    public visitTypeParameterList(node: TypeParameterListSyntax): any {
        return node.update(
            this.visitToken(node.lessThanToken),
            this.visitSeparatedList(node.typeParameters),
            this.visitToken(node.greaterThanToken));
    }

    public visitTypeParameter(node: TypeParameterSyntax): any {
        return node.update(
            this.visitToken(node.identifier),
            node.constraint === null ? null : <ConstraintSyntax>this.visitNode(node.constraint));
    }

    public visitConstraint(node: ConstraintSyntax): any {
        return node.update(
            this.visitToken(node.extendsKeyword),
            <ITypeSyntax>this.visitNodeOrToken(node.type));
    }

    public visitElseClause(node: ElseClauseSyntax): any {
        return node.update(
            this.visitToken(node.elseKeyword),
            <IStatementSyntax>this.visitNodeOrToken(node.statement));
    }

    public visitIfStatement(node: IfStatementSyntax): any {
        return node.update(
            this.visitToken(node.ifKeyword),
            this.visitToken(node.openParenToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.condition),
            this.visitToken(node.closeParenToken),
            <IStatementSyntax>this.visitNodeOrToken(node.statement),
            node.elseClause === null ? null : <ElseClauseSyntax>this.visitNode(node.elseClause));
    }

    public visitExpressionStatement(node: ExpressionStatementSyntax): any {
        return node.update(
            <IExpressionSyntax>this.visitNodeOrToken(node.expression),
            this.visitToken(node.semicolonToken));
    }

    public visitConstructorDeclaration(node: ConstructorDeclarationSyntax): any {
        return node.update(
            this.visitToken(node.constructorKeyword),
            <ParameterListSyntax>this.visitNode(node.parameterList),
            node.block === null ? null : <BlockSyntax>this.visitNode(node.block),
            node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
    }

    public visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): any {
        return node.update(
            node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword),
            node.staticKeyword === null ? null : this.visitToken(node.staticKeyword),
            <FunctionSignatureSyntax>this.visitNode(node.functionSignature),
            node.block === null ? null : <BlockSyntax>this.visitNode(node.block),
            node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
    }

    public visitGetMemberAccessorDeclaration(node: GetMemberAccessorDeclarationSyntax): any {
        return node.update(
            node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword),
            node.staticKeyword === null ? null : this.visitToken(node.staticKeyword),
            this.visitToken(node.getKeyword),
            this.visitToken(node.identifier),
            <ParameterListSyntax>this.visitNode(node.parameterList),
            node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation),
            <BlockSyntax>this.visitNode(node.block));
    }

    public visitSetMemberAccessorDeclaration(node: SetMemberAccessorDeclarationSyntax): any {
        return node.update(
            node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword),
            node.staticKeyword === null ? null : this.visitToken(node.staticKeyword),
            this.visitToken(node.setKeyword),
            this.visitToken(node.identifier),
            <ParameterListSyntax>this.visitNode(node.parameterList),
            <BlockSyntax>this.visitNode(node.block));
    }

    public visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): any {
        return node.update(
            node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword),
            node.staticKeyword === null ? null : this.visitToken(node.staticKeyword),
            <VariableDeclaratorSyntax>this.visitNode(node.variableDeclarator),
            this.visitToken(node.semicolonToken));
    }

    public visitThrowStatement(node: ThrowStatementSyntax): any {
        return node.update(
            this.visitToken(node.throwKeyword),
            <IExpressionSyntax>this.visitNodeOrToken(node.expression),
            this.visitToken(node.semicolonToken));
    }

    public visitReturnStatement(node: ReturnStatementSyntax): any {
        return node.update(
            this.visitToken(node.returnKeyword),
            node.expression === null ? null : <IExpressionSyntax>this.visitNodeOrToken(node.expression),
            this.visitToken(node.semicolonToken));
    }

    public visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): any {
        return node.update(
            this.visitToken(node.newKeyword),
            <IExpressionSyntax>this.visitNodeOrToken(node.expression),
            node.argumentList === null ? null : <ArgumentListSyntax>this.visitNode(node.argumentList));
    }

    public visitSwitchStatement(node: SwitchStatementSyntax): any {
        return node.update(
            this.visitToken(node.switchKeyword),
            this.visitToken(node.openParenToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.expression),
            this.visitToken(node.closeParenToken),
            this.visitToken(node.openBraceToken),
            this.visitList(node.switchClauses),
            this.visitToken(node.closeBraceToken));
    }

    public visitCaseSwitchClause(node: CaseSwitchClauseSyntax): any {
        return node.update(
            this.visitToken(node.caseKeyword),
            <IExpressionSyntax>this.visitNodeOrToken(node.expression),
            this.visitToken(node.colonToken),
            this.visitList(node.statements));
    }

    public visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): any {
        return node.update(
            this.visitToken(node.defaultKeyword),
            this.visitToken(node.colonToken),
            this.visitList(node.statements));
    }

    public visitBreakStatement(node: BreakStatementSyntax): any {
        return node.update(
            this.visitToken(node.breakKeyword),
            node.identifier === null ? null : this.visitToken(node.identifier),
            this.visitToken(node.semicolonToken));
    }

    public visitContinueStatement(node: ContinueStatementSyntax): any {
        return node.update(
            this.visitToken(node.continueKeyword),
            node.identifier === null ? null : this.visitToken(node.identifier),
            this.visitToken(node.semicolonToken));
    }

    public visitForStatement(node: ForStatementSyntax): any {
        return node.update(
            this.visitToken(node.forKeyword),
            this.visitToken(node.openParenToken),
            node.variableDeclaration === null ? null : <VariableDeclarationSyntax>this.visitNode(node.variableDeclaration),
            node.initializer === null ? null : <IExpressionSyntax>this.visitNodeOrToken(node.initializer),
            this.visitToken(node.firstSemicolonToken),
            node.condition === null ? null : <IExpressionSyntax>this.visitNodeOrToken(node.condition),
            this.visitToken(node.secondSemicolonToken),
            node.incrementor === null ? null : <IExpressionSyntax>this.visitNodeOrToken(node.incrementor),
            this.visitToken(node.closeParenToken),
            <IStatementSyntax>this.visitNodeOrToken(node.statement));
    }

    public visitForInStatement(node: ForInStatementSyntax): any {
        return node.update(
            this.visitToken(node.forKeyword),
            this.visitToken(node.openParenToken),
            node.variableDeclaration === null ? null : <VariableDeclarationSyntax>this.visitNode(node.variableDeclaration),
            node.left === null ? null : <IExpressionSyntax>this.visitNodeOrToken(node.left),
            this.visitToken(node.inKeyword),
            <IExpressionSyntax>this.visitNodeOrToken(node.expression),
            this.visitToken(node.closeParenToken),
            <IStatementSyntax>this.visitNodeOrToken(node.statement));
    }

    public visitWhileStatement(node: WhileStatementSyntax): any {
        return node.update(
            this.visitToken(node.whileKeyword),
            this.visitToken(node.openParenToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.condition),
            this.visitToken(node.closeParenToken),
            <IStatementSyntax>this.visitNodeOrToken(node.statement));
    }

    public visitWithStatement(node: WithStatementSyntax): any {
        return node.update(
            this.visitToken(node.withKeyword),
            this.visitToken(node.openParenToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.condition),
            this.visitToken(node.closeParenToken),
            <IStatementSyntax>this.visitNodeOrToken(node.statement));
    }

    public visitEnumDeclaration(node: EnumDeclarationSyntax): any {
        return node.update(
            node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
            this.visitToken(node.enumKeyword),
            this.visitToken(node.identifier),
            this.visitToken(node.openBraceToken),
            this.visitSeparatedList(node.variableDeclarators),
            this.visitToken(node.closeBraceToken));
    }

    public visitCastExpression(node: CastExpressionSyntax): any {
        return node.update(
            this.visitToken(node.lessThanToken),
            <ITypeSyntax>this.visitNodeOrToken(node.type),
            this.visitToken(node.greaterThanToken),
            <IUnaryExpressionSyntax>this.visitNodeOrToken(node.expression));
    }

    public visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): any {
        return node.update(
            this.visitToken(node.openBraceToken),
            this.visitSeparatedList(node.propertyAssignments),
            this.visitToken(node.closeBraceToken));
    }

    public visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): any {
        return node.update(
            this.visitToken(node.propertyName),
            this.visitToken(node.colonToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.expression));
    }

    public visitGetAccessorPropertyAssignment(node: GetAccessorPropertyAssignmentSyntax): any {
        return node.update(
            this.visitToken(node.getKeyword),
            this.visitToken(node.propertyName),
            this.visitToken(node.openParenToken),
            this.visitToken(node.closeParenToken),
            <BlockSyntax>this.visitNode(node.block));
    }

    public visitSetAccessorPropertyAssignment(node: SetAccessorPropertyAssignmentSyntax): any {
        return node.update(
            this.visitToken(node.setKeyword),
            this.visitToken(node.propertyName),
            this.visitToken(node.openParenToken),
            this.visitToken(node.parameterName),
            this.visitToken(node.closeParenToken),
            <BlockSyntax>this.visitNode(node.block));
    }

    public visitFunctionExpression(node: FunctionExpressionSyntax): any {
        return node.update(
            this.visitToken(node.functionKeyword),
            node.identifier === null ? null : this.visitToken(node.identifier),
            <CallSignatureSyntax>this.visitNode(node.callSignature),
            <BlockSyntax>this.visitNode(node.block));
    }

    public visitEmptyStatement(node: EmptyStatementSyntax): any {
        return node.update(
            this.visitToken(node.semicolonToken));
    }

    public visitTryStatement(node: TryStatementSyntax): any {
        return node.update(
            this.visitToken(node.tryKeyword),
            <BlockSyntax>this.visitNode(node.block),
            node.catchClause === null ? null : <CatchClauseSyntax>this.visitNode(node.catchClause),
            node.finallyClause === null ? null : <FinallyClauseSyntax>this.visitNode(node.finallyClause));
    }

    public visitCatchClause(node: CatchClauseSyntax): any {
        return node.update(
            this.visitToken(node.catchKeyword),
            this.visitToken(node.openParenToken),
            this.visitToken(node.identifier),
            this.visitToken(node.closeParenToken),
            <BlockSyntax>this.visitNode(node.block));
    }

    public visitFinallyClause(node: FinallyClauseSyntax): any {
        return node.update(
            this.visitToken(node.finallyKeyword),
            <BlockSyntax>this.visitNode(node.block));
    }

    public visitLabeledStatement(node: LabeledStatementSyntax): any {
        return node.update(
            this.visitToken(node.identifier),
            this.visitToken(node.colonToken),
            <IStatementSyntax>this.visitNodeOrToken(node.statement));
    }

    public visitDoStatement(node: DoStatementSyntax): any {
        return node.update(
            this.visitToken(node.doKeyword),
            <IStatementSyntax>this.visitNodeOrToken(node.statement),
            this.visitToken(node.whileKeyword),
            this.visitToken(node.openParenToken),
            <IExpressionSyntax>this.visitNodeOrToken(node.condition),
            this.visitToken(node.closeParenToken),
            this.visitToken(node.semicolonToken));
    }

    public visitTypeOfExpression(node: TypeOfExpressionSyntax): any {
        return node.update(
            this.visitToken(node.typeOfKeyword),
            <IExpressionSyntax>this.visitNodeOrToken(node.expression));
    }

    public visitDeleteExpression(node: DeleteExpressionSyntax): any {
        return node.update(
            this.visitToken(node.deleteKeyword),
            <IExpressionSyntax>this.visitNodeOrToken(node.expression));
    }

    public visitVoidExpression(node: VoidExpressionSyntax): any {
        return node.update(
            this.visitToken(node.voidKeyword),
            <IExpressionSyntax>this.visitNodeOrToken(node.expression));
    }

    public visitDebuggerStatement(node: DebuggerStatementSyntax): any {
        return node.update(
            this.visitToken(node.debuggerKeyword),
            this.visitToken(node.semicolonToken));
    }
}
class Errors {
    public static argument(argument: string, message?: string): Error {
        return new Error("Invalid argument: " + argument + "."  + (message ? (" " + message) : ""));
    }

    public static argumentOutOfRange(argument: string): Error {
        return new Error("Argument out of range: " + argument + ".");
    }

    public static argumentNull(argument: string): Error {
        return new Error("Argument null: " + argument + ".");
    }

    public static abstract(): Error {
        return new Error("Operation not implemented properly by subclass.");
    }

    public static notYetImplemented(): Error {
        return new Error("Not yet implemented.");
    }

    public static invalidOperation(message?: string): Error {
        return new Error(message ? ("Invalid operation: " + message) :"Invalid operation.");
    }
}
///<reference path='SyntaxRewriter.generated.ts' />

class SyntaxTokenReplacer extends SyntaxRewriter {
    constructor(private token1: ISyntaxToken,
                private token2: ISyntaxToken) {
        super();
    }

    private visitToken(token: ISyntaxToken): ISyntaxToken {
        if (token === this.token1) {
            // Found the token to replace.  Return the new token and null out our state.  This will 
            // let the later visit methods bail out earlier.
            var result = this.token2;
            this.token1 = null;
            this.token2 = null;

            return result;
        }

        return token;
    }

    private visitNode(node: SyntaxNode): SyntaxNode {
        if (this.token1 === null) {
            return node;
        }

        return super.visitNode(node);
    }

    private visitList(list: ISyntaxList): ISyntaxList {
        if (this.token1 === null) {
            return list;
        }

        return super.visitList(list);
    }

    private visitSeparatedList(list: ISeparatedSyntaxList): ISeparatedSyntaxList {
        if (this.token1 === null) {
            return list;
        }

        return super.visitSeparatedList(list);
    }
}
///<reference path='SyntaxRewriter.generated.ts' />
///<reference path='..\Core\Errors.ts' />
///<reference path='ISyntaxElement.ts' />
///<reference path='ISyntaxToken.ts' />
///<reference path='SyntaxVisitor.generated.ts' />
///<reference path='SyntaxTokenReplacer.ts' />

class SyntaxNode implements ISyntaxNodeOrToken {
    private _data: number;

    constructor(parsedInStrictMode: bool) {
        this._data = parsedInStrictMode ? SyntaxConstants.NodeParsedInStrictModeMask : 0;
    }

    public isNode(): bool{ return true; }
    public isToken(): bool { return false; }
    public isList(): bool{ return false; }
    public isSeparatedList(): bool{ return false; }

    public kind(): SyntaxKind {
        throw Errors.abstract();
    }

    private childCount(): number {
        throw Errors.abstract();
    }

    private childAt(slot: number): ISyntaxElement {
        throw Errors.abstract();
    }

    // Returns the first non-missing token inside this node (or null if there are no such token).
    public firstToken(): ISyntaxToken {
        for (var i = 0, n = this.childCount(); i < n; i++) {
            var element = this.childAt(i);
            
            if (element != null) {
                if (element.fullWidth() > 0 || element.kind() === SyntaxKind.EndOfFileToken) {
                    return element.firstToken();
                }
            }
        }

        return null;
    }

    // Returns the last non-missing token inside this node (or null if there are no such token).
    public lastToken(): ISyntaxToken {
        for (var i = this.childCount() - 1; i >= 0; i--) {
            var element = this.childAt(i);

            if (element != null) {
                if (element.fullWidth() > 0 || element.kind() === SyntaxKind.EndOfFileToken) {
                    return element.lastToken();
                }
            }
        }

        return null;
    }

    public insertChildrenInto(array: ISyntaxElement[], index: number) {
        for (var i = this.childCount() - 1; i >= 0; i--) {
            var element = this.childAt(i);

            if (element !== null) {
                if (element.isNode() || element.isToken()) {
                    array.splice(index, 0, element);
                }
                else if (element.isList()) {
                    (<ISyntaxList>element).insertChildrenInto(array, index);
                }
                else if (element.isSeparatedList()) {
                    (<ISeparatedSyntaxList>element).insertChildrenInto(array, index);
                }
                else {
                    throw Errors.invalidOperation();
                }
            }
        }
    }

    public leadingTrivia(): ISyntaxTriviaList {
        return this.firstToken().leadingTrivia();
    }

    public trailingTrivia(): ISyntaxTriviaList {
        return this.lastToken().trailingTrivia();
    }

    public toJSON(key) {
        var result: any = { 
            kind: (<any>SyntaxKind)._map[this.kind()],
            fullWidth: this.fullWidth()
        };

        if (this.hasSkippedText()) {
            result.hasSkippedText = true;
        }

        if (this.hasZeroWidthToken()) {
            result.hasZeroWidthToken = true;
        }

        if (this.hasRegularExpressionToken()) {
            result.hasRegularExpressionToken = true;
        }
        
        if (this.parsedInStrictMode()) {
            result.parsedInStrictMode = true;
        }

        for (var i = 0, n = this.childCount(); i < n; i++) {
            var value = this.childAt(i);

            if (value) {
                for (var name in this) {
                    if (value === this[name]) {
                        result[name] = value;
                        break;
                    }
                }
            }
        }

        return result;
    }

    public accept(visitor: ISyntaxVisitor): any {
        throw Errors.abstract();
    }

    public fullText(): string {
        var elements: string[] = [];
        this.collectTextElements(elements);
        return elements.join("");
    }

    public collectTextElements(elements: string[]): void {
        for (var i = 0, n = this.childCount(); i < n; i++) {
            var element = this.childAt(i);

            if (element !== null) {
                element.collectTextElements(elements)
            }
        }
    }

    public replaceToken(token1: ISyntaxToken, token2: ISyntaxToken): SyntaxNode {
        if (token1 === token2) {
            return this;
        }

        return this.accept(new SyntaxTokenReplacer(token1, token2));
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SyntaxNode {
        return this.replaceToken(this.firstToken(), this.firstToken().withLeadingTrivia(trivia));
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SyntaxNode {
        return this.replaceToken(this.lastToken(), this.lastToken().withTrailingTrivia(trivia));
    }

    public hasLeadingTrivia(): bool {
        return this.lastToken().hasLeadingTrivia();
    }

    public hasTrailingTrivia(): bool {
        return this.lastToken().hasTrailingTrivia();
    }

    public isTypeScriptSpecific(): bool {
        return false;
    }

    public hasSkippedText(): bool {
        return (this.data() & SyntaxConstants.NodeSkippedTextMask) !== 0;
    }

    public hasZeroWidthToken(): bool {
        return (this.data() & SyntaxConstants.NodeZeroWidthTokenMask) !== 0;
    }

    // True if this node contains a regex token somewhere under it.  A regex token is either a 
    // regex itself (i.e. /foo/), or is a token which could start a regex (i.e. "/" or "/=").  This
    // data is used by the incremental parser to decide if a node can be reused.  Due to the 
    // lookahead nature of regex tokens, a node containing a regex token cannot be reused.  Normally,
    // changes to text only affect the tokens directly intersected.  However, because regex tokens 
    // have such unbounded lookahead (technically bounded at the end of a line, but htat's minor), 
    // we need to recheck them to see if they've changed due to the edit.  For example, if you had:
    //
    //      while (true) /3; return;
    //
    // And you changed it to:
    //
    //      while (true) /3; return/;
    //
    // Then even though only the 'return' and ';' colons were touched, we'd want to rescan the '/'
    // token which we would then realize was a regex.
    public hasRegularExpressionToken(): bool {
        return (this.data() & SyntaxConstants.NodeRegularExpressionTokenMask) !== 0;
    }

    // True if this node was parsed while the parser was in 'strict' mode.  A node parsed in strict
    // mode cannot be reused if the parser is non-strict mode (and vice versa).  This is because 
    // the parser parses things differently in strict mode and thus the tokens may be interpretted
    // differently if the mode is changed. 
    public parsedInStrictMode(): bool {
        return (this.data() & SyntaxConstants.NodeParsedInStrictModeMask) !== 0;
    }

    public fullWidth(): number {
        return this.data() >>> SyntaxConstants.NodeFullWidthShift;
    }

    private computeData(): number {
        var slotCount = this.childCount();

        var fullWidth = 0;
        var childWidth = 0;
        var hasSkippedText = false;

        // If we have no children (like an OmmittedExpressionSyntax), we automatically have a zero 
        // width token.
        var hasZeroWidthToken = slotCount === 0;
        var hasRegularExpressionToken = false;

        for (var i = 0, n = slotCount; i < n; i++) {
            var element = this.childAt(i);

            if (element !== null) {
                var childWidth = element.fullWidth();
                fullWidth += childWidth;

                if (!hasSkippedText) {
                    hasSkippedText = element.hasSkippedText();
                }

                if (!hasZeroWidthToken) {
                    hasZeroWidthToken = element.hasZeroWidthToken();
                }

                if (!hasRegularExpressionToken) {
                    hasRegularExpressionToken = element.hasRegularExpressionToken();
                }
            }
        }

        return (fullWidth << SyntaxConstants.NodeFullWidthShift)
             | (hasSkippedText ? SyntaxConstants.NodeSkippedTextMask : 0)
             | (hasZeroWidthToken ? SyntaxConstants.NodeZeroWidthTokenMask : 0)
             | (hasRegularExpressionToken ? SyntaxConstants.NodeRegularExpressionTokenMask : 0);
    }
    
    private data(): number {
        if (this._data === 0 || this._data === SyntaxConstants.NodeParsedInStrictModeMask) {
            this._data |= this.computeData();
        }

        return this._data;
    }

    /// <summary>
    /// Finds a token according to the following rules:
    /// 1) If position matches the End of the node/s FullSpan and the node is SourceUnit,
    ///    then the EOF token is returned. 
    /// 
    ///  2) If node.FullSpan.Contains(position) then the token that contains given position is
    ///     returned.
    /// 
    ///  3) Otherwise an ArgumentOutOfRangeException is thrown
    ///
    /// Note: findToken will always return a non missing token with width greater than or equal to
    /// 1 (except for EOF).  Empty tokens syntehsized by teh parser are never returned.
    /// </summary>
    public findToken(position: number): PositionedToken {
        var endOfFileToken = this.tryGetEndOfFileAt(position);
        if (endOfFileToken !== null) {
            return endOfFileToken;
        }

        if (position < 0 || position >= this.fullWidth()) {
            throw Errors.argumentOutOfRange("position");
        }

        return this.findTokenInternal(null, position, 0);
    }

    private tryGetEndOfFileAt(position: number): PositionedToken {
        if (this.kind() === SyntaxKind.SourceUnit && position === this.fullWidth()) {
            var sourceUnit = <SourceUnitSyntax>this;
            return new PositionedToken(
                new PositionedNode(null, sourceUnit, 0),
                sourceUnit.endOfFileToken, sourceUnit.moduleElements.fullWidth());
        }

        return null;
    }

    private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
        Debug.assert(position >= 0 && position < this.fullWidth());

        parent = new PositionedNode(parent, this, fullStart);
        for (var i = 0, n = this.childCount(); i < n; i++) {
            var element = this.childAt(i);

            if (element !== null) {
                var childWidth = element.fullWidth();

                if (position < childWidth) {
                    return (<any>element).findTokenInternal(parent, position, fullStart);
                }

                position -= childWidth;
                fullStart += childWidth;
            }
        }

        throw Errors.invalidOperation();
    }

    public findTokenOnLeft(position: number): PositionedToken {
        var positionedToken = this.findToken(position);
        var start = positionedToken.start();

        // Position better fall within this token.
        Debug.assert(position >= positionedToken.fullStart());
        Debug.assert(position < positionedToken.fullEnd() || positionedToken.token().tokenKind === SyntaxKind.EndOfFileToken);

        // if position is after the start of the token, then this token is the token on the left.
        if (position > start) {
            return positionedToken;
        }

        // we're in the trivia before the start of the token.  Need to return the previous token.
        if (positionedToken.fullStart() === 0) {
            // Already on the first token.  Nothing before us.
            return null;
        }

        var previousToken = this.findToken(positionedToken.fullStart() - 1);

        // Position better be after this token.
        Debug.assert(previousToken.fullEnd() <= position);

        return previousToken;
    }

    public isModuleElement(): bool {
        return false;
    }

    public isClassElement(): bool {
        return false;
    }

    public isTypeMember(): bool {
        return false
    }

    public isStatement(): bool {
        return false;
    }

    public isSwitchClause(): bool {
        return false;
    }

    public structuralEquals(node: SyntaxNode): bool {
        if (this === node) { return true; }
        if (node === null) { return false; }
        if (this.kind() !== node.kind()) { return false; }

        for (var i = 0, n = this.childCount(); i < n; i++) {
            var element1 = this.childAt(i);
            var element2 = node.childAt(i);

            if (!Syntax.elementStructuralEquals(element1, element2)) {
                return false;
            }
        }

        return true;
    }

    public width(): number {
        return this.fullWidth() - this.leadingTriviaWidth() - this.trailingTriviaWidth();
    }

    public leadingTriviaWidth() {
        var firstToken = this.firstToken();
        return firstToken === null ? 0 : firstToken.leadingTriviaWidth();
    }

    public trailingTriviaWidth() {
        var lastToken = this.lastToken();
        return lastToken === null ? 0 : lastToken.trailingTriviaWidth();
    }
}
///<reference path='ISyntaxElement.ts' />
///<reference path='SyntaxNode.ts' />

interface ISyntaxList extends ISyntaxElement {
    childAt(index: number): ISyntaxNodeOrToken;
    toArray(): ISyntaxNodeOrToken[];

    insertChildrenInto(array: ISyntaxElement[], index: number): void;
}
///<reference path='ISyntaxElement.ts' />
///<reference path='SyntaxNode.ts' />

interface ISeparatedSyntaxList extends ISyntaxElement {
    childAt(index: number): ISyntaxNodeOrToken;

    toArray(): ISyntaxNodeOrToken[];
    toNonSeparatorArray(): ISyntaxNodeOrToken[];

    separatorCount();
    separatorAt(index: number): ISyntaxToken;

    nonSeparatorCount();
    nonSeparatorAt(index: number): ISyntaxNodeOrToken;

    insertChildrenInto(array: ISyntaxElement[], index: number): void;
}
class IntegerUtilities {
    public static integerDivide(numerator: number, denominator: number): number {
        return (numerator / denominator) >> 0;
    }

    public static integerMultiplyLow32Bits(n1: number, n2: number): number {
        var n1Low16 = n1 & 0x0000ffff;
        var n1High16 = n1 >>> 16;

        var n2Low16 = n2 & 0x0000ffff;
        var n2High16 = n2 >>> 16;

        var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
        return resultLow32;
    }

    public static integerMultiplyHigh32Bits(n1: number, n2: number): number {
        var n1Low16 = n1 & 0x0000ffff;
        var n1High16 = n1 >>> 16;

        var n2Low16 = n2 & 0x0000ffff;
        var n2High16 = n2 >>> 16;

        var resultHigh32 = n1High16 * n2High16 + ((((n1Low16 * n2Low16) >>> 17) + n1Low16 * n2High16) >>> 15);
        return resultHigh32;
    }
}
///<reference path='ISyntaxToken.ts' />

class PositionedElement {
    private _parent: PositionedElement;
    private _element: ISyntaxElement;
    private _fullStart: number;

    constructor(parent: PositionedElement, element: ISyntaxElement, fullStart: number) {
        this._parent = parent;
        this._element = element;
        this._fullStart = fullStart;
    }

    public static create(parent: PositionedElement, element: ISyntaxElement, fullStart: number): PositionedElement {
        if (element === null) {
            return null;
        }

        if (element.isNode()) {
            return new PositionedNode(parent, <SyntaxNode>element, fullStart);
        }
        else if (element.isToken()) {
            return new PositionedToken(parent, <ISyntaxToken>element, fullStart);
        }
        else if (element.isList()) {
            return new PositionedList(parent, <ISyntaxList>element, fullStart);
        }
        else if (element.isSeparatedList()) {
            return new PositionedSeparatedList(parent, <ISeparatedSyntaxList>element, fullStart);
        }
        else {
            throw Errors.invalidOperation();
        }
    }

    public parent(): PositionedElement {
        return this._parent;
    }

    public parentElement(): ISyntaxElement {
        return this._parent && this._parent._element;
    }

    public element(): ISyntaxElement {
        return this._element;
    }

    public kind(): SyntaxKind {
        return this.element().kind();
    }

    public childCount(): number {
        return this.element().childCount();
    }

    public childAt(index: number): PositionedElement {
        var offset = 0;

        for (var i = 0; i < index; i++) {
            offset += this.element().childAt(i).fullWidth();
        }

        return PositionedElement.create(this, this.element().childAt(index), offset);
    }

    public getPositionedChild(child: ISyntaxElement) {
        var offset = Syntax.childOffset(this.element(), child);

        return PositionedElement.create(this, child, offset);
    }

    public fullStart(): number {
        return this._fullStart;
    }

    public fullEnd(): number {
        return this.fullStart() + this.element().fullWidth();
    }

    public fullWidth(): number {
        return this.element().fullWidth();
    }

    public start(): number {
        return this.fullStart() + this.element().leadingTriviaWidth();
    }

    public end(): number {
        return this.fullStart() + this.element().leadingTriviaWidth() + this.element().width();
    }

    public root(): PositionedNode {
        var current = this;
        while (current.parent() !== null) {
            current = current.parent();
        }

        return <PositionedNode>current;
    }

    public containingNode(): PositionedNode {
        var current = this.parent();

        while (current !== null && !current.element().isNode()) {
            current = current.parent();
        }
        
        return <PositionedNode>current;
    }
}

class PositionedNodeOrToken extends PositionedElement {
    constructor(parent: PositionedElement, nodeOrToken: ISyntaxNodeOrToken, fullStart: number) {
        super(parent, nodeOrToken, fullStart);
    }

    public nodeOrToken(): ISyntaxNodeOrToken {
        return <ISyntaxNodeOrToken>this.element();
    }
}

class PositionedNode extends PositionedNodeOrToken {
    constructor(parent: PositionedElement, node: SyntaxNode, fullStart: number) {
        super(parent, node, fullStart);
    }
    
    public node(): SyntaxNode {
        return <SyntaxNode>this.element();
    }
}

class PositionedToken extends PositionedNodeOrToken {
    constructor(parent: PositionedElement, token: ISyntaxToken, fullStart: number) {
        super(parent, token, fullStart);
    }

    public token(): ISyntaxToken {
        return <ISyntaxToken>this.element();
    }

    public previousToken(): PositionedToken {
        var fullStart = this.fullStart();
        if (fullStart === 0) {
            return null;
        }

        return this.root().node().findToken(fullStart - 1);
    }

    public nextToken(): PositionedToken {
        if (this.token().tokenKind === SyntaxKind.EndOfFileToken) {
            return null;
        }

        return this.root().node().findToken(this.fullEnd());
    }
}

class PositionedList extends PositionedElement {
    constructor(parent: PositionedElement, list: ISyntaxList, fullStart: number) {
        super(parent, list, fullStart);
    }

    public list(): ISyntaxList {
        return <ISyntaxList>this.element();
    }
}

class PositionedSeparatedList extends PositionedElement {
    constructor(parent: PositionedElement, list: ISeparatedSyntaxList, fullStart: number) {
        super(parent, list, fullStart);
    }

    public list(): ISeparatedSyntaxList {
        return <ISeparatedSyntaxList>this.element();
    }
}
class Debug {
    public static assert(expression: bool): void {
        if (!expression) {
            throw new Error("Debug Failure. False expression.");
        }
    }
}
///<reference path='..\Core\Debug.ts' />
///<reference path='SyntaxKind.ts' />

module SyntaxFacts {
    var textToKeywordKind: any = {
        "any": SyntaxKind.AnyKeyword,
        "bool": SyntaxKind.BoolKeyword,
        "boolean": SyntaxKind.BooleanKeyword,
        "break": SyntaxKind.BreakKeyword,
        "case": SyntaxKind.CaseKeyword,
        "catch": SyntaxKind.CatchKeyword,
        "class": SyntaxKind.ClassKeyword,
        "continue": SyntaxKind.ContinueKeyword,
        "const": SyntaxKind.ConstKeyword,
        "constructor": SyntaxKind.ConstructorKeyword,
        "debugger": SyntaxKind.DebuggerKeyword,
        "declare": SyntaxKind.DeclareKeyword,
        "default": SyntaxKind.DefaultKeyword,
        "delete": SyntaxKind.DeleteKeyword,
        "do": SyntaxKind.DoKeyword,
        "else": SyntaxKind.ElseKeyword,
        "enum": SyntaxKind.EnumKeyword,
        "export": SyntaxKind.ExportKeyword,
        "extends": SyntaxKind.ExtendsKeyword,
        "false": SyntaxKind.FalseKeyword,
        "finally": SyntaxKind.FinallyKeyword,
        "for": SyntaxKind.ForKeyword,
        "function": SyntaxKind.FunctionKeyword,
        "get": SyntaxKind.GetKeyword,
        "if": SyntaxKind.IfKeyword,
        "implements": SyntaxKind.ImplementsKeyword,
        "import": SyntaxKind.ImportKeyword,
        "in": SyntaxKind.InKeyword,
        "instanceof": SyntaxKind.InstanceOfKeyword,
        "interface": SyntaxKind.InterfaceKeyword,
        "let": SyntaxKind.LetKeyword,
        "module": SyntaxKind.ModuleKeyword,
        "new": SyntaxKind.NewKeyword,
        "null": SyntaxKind.NullKeyword,
        "number":SyntaxKind.NumberKeyword,
        "package": SyntaxKind.PackageKeyword,
        "private": SyntaxKind.PrivateKeyword,
        "protected": SyntaxKind.ProtectedKeyword,
        "public": SyntaxKind.PublicKeyword,
        "return": SyntaxKind.ReturnKeyword,
        "set": SyntaxKind.SetKeyword,
        "static": SyntaxKind.StaticKeyword,
        "string": SyntaxKind.StringKeyword,
        "super": SyntaxKind.SuperKeyword,
        "switch": SyntaxKind.SwitchKeyword,
        "this": SyntaxKind.ThisKeyword,
        "throw": SyntaxKind.ThrowKeyword,
        "true": SyntaxKind.TrueKeyword,
        "try": SyntaxKind.TryKeyword,
        "typeof": SyntaxKind.TypeOfKeyword,
        "var": SyntaxKind.VarKeyword,
        "void": SyntaxKind.VoidKeyword,
        "while": SyntaxKind.WhileKeyword,
        "with": SyntaxKind.WithKeyword,
        "yield": SyntaxKind.YieldKeyword,

        "{": SyntaxKind.OpenBraceToken,
        "}": SyntaxKind.CloseBraceToken,
        "(": SyntaxKind.OpenParenToken,
        ")": SyntaxKind.CloseParenToken,
        "[": SyntaxKind.OpenBracketToken,
        "]": SyntaxKind.CloseBracketToken,
        ".": SyntaxKind.DotToken,
        "...": SyntaxKind.DotDotDotToken,
        ";": SyntaxKind.SemicolonToken,
        ",": SyntaxKind.CommaToken,
        "<": SyntaxKind.LessThanToken,
        ">": SyntaxKind.GreaterThanToken,
        "<=": SyntaxKind.LessThanEqualsToken,
        ">=": SyntaxKind.GreaterThanEqualsToken,
        "==": SyntaxKind.EqualsEqualsToken,
        "=>": SyntaxKind.EqualsGreaterThanToken,
        "!=": SyntaxKind.ExclamationEqualsToken,
        "===": SyntaxKind.EqualsEqualsEqualsToken,
        "!==": SyntaxKind.ExclamationEqualsEqualsToken,
        "+": SyntaxKind.PlusToken,
        "-": SyntaxKind.MinusToken,
        "*": SyntaxKind.AsteriskToken,
        "%": SyntaxKind.PercentToken,
        "++": SyntaxKind.PlusPlusToken,
        "--": SyntaxKind.MinusMinusToken,
        "<<": SyntaxKind.LessThanLessThanToken,
        ">>": SyntaxKind.GreaterThanGreaterThanToken,
        ">>>": SyntaxKind.GreaterThanGreaterThanGreaterThanToken,
        "&": SyntaxKind.AmpersandToken,
        "|": SyntaxKind.BarToken,
        "^": SyntaxKind.CaretToken,
        "!": SyntaxKind.ExclamationToken,
        "~": SyntaxKind.TildeToken,
        "&&": SyntaxKind.AmpersandAmpersandToken,
        "||": SyntaxKind.BarBarToken,
        "?": SyntaxKind.QuestionToken,
        ":": SyntaxKind.ColonToken,
        "=": SyntaxKind.EqualsToken,
        "+=": SyntaxKind.PlusEqualsToken,
        "-=": SyntaxKind.MinusEqualsToken,
        "*=": SyntaxKind.AsteriskEqualsToken,
        "%=": SyntaxKind.PercentEqualsToken,
        "<<=": SyntaxKind.LessThanLessThanEqualsToken,
        ">>=": SyntaxKind.GreaterThanGreaterThanEqualsToken,
        ">>>=": SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
        "&=": SyntaxKind.AmpersandEqualsToken,
        "|=": SyntaxKind.BarEqualsToken,
        "^=": SyntaxKind.CaretEqualsToken,
        "/": SyntaxKind.SlashToken,
        "/=": SyntaxKind.SlashEqualsToken,
    };

    var kindToText: string[] = [];

    for (var name in textToKeywordKind) {
        if (textToKeywordKind.hasOwnProperty(name)) {
            Debug.assert(kindToText[textToKeywordKind[name]] === undefined);
            kindToText[textToKeywordKind[name]] = name;
        }
    }

    // Manually work around a bug in the CScript 5.8 runtime where 'constructor' is not
    // listed when SyntaxFacts.textToKeywordKind is enumerated because it is the name of
    // the constructor function.
    kindToText[SyntaxKind.ConstructorKeyword] = "constructor";

    export function getTokenKind(text: string): SyntaxKind {
        if (textToKeywordKind.hasOwnProperty(text)) {
            return textToKeywordKind[text];
        }

        return SyntaxKind.None;
    }

    export function getText(kind: SyntaxKind): string {
        var result = kindToText[kind];
        return result !== undefined ? result : null;
    }

    export function isTokenKind(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstToken && kind <= SyntaxKind.LastToken;
    }

    export function isAnyKeyword(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstKeyword && kind <= SyntaxKind.LastKeyword;
    }

    export function isStandardKeyword(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstStandardKeyword && kind <= SyntaxKind.LastStandardKeyword;
    }

    export function isFutureReservedKeyword(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstFutureReservedKeyword && kind <= SyntaxKind.LastFutureReservedKeyword;
    }

    export function isFutureReservedStrictKeyword(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstFutureReservedStrictKeyword && kind <= SyntaxKind.LastFutureReservedStrictKeyword;
    }

    export function isAnyPunctuation(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstPunctuation && kind <= SyntaxKind.LastPunctuation;
    }

    export function isPrefixUnaryExpressionOperatorToken(tokenKind: SyntaxKind): bool {
        return getPrefixUnaryExpressionFromOperatorToken(tokenKind) !== SyntaxKind.None;
    }

    export function isBinaryExpressionOperatorToken(tokenKind: SyntaxKind): bool {
        return getBinaryExpressionFromOperatorToken(tokenKind) !== SyntaxKind.None;
    }

    export function getPrefixUnaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind {
        switch (tokenKind) {
            case SyntaxKind.PlusToken:
                return SyntaxKind.PlusExpression;
            case SyntaxKind.MinusToken:
                return SyntaxKind.NegateExpression;
            case SyntaxKind.TildeToken:
                return SyntaxKind.BitwiseNotExpression;
            case SyntaxKind.ExclamationToken:
                return SyntaxKind.LogicalNotExpression;
            case SyntaxKind.PlusPlusToken:
                return SyntaxKind.PreIncrementExpression;
            case SyntaxKind.MinusMinusToken:
                return SyntaxKind.PreDecrementExpression;
            //case SyntaxKind.DeleteKeyword:
            //    return SyntaxKind.DeleteExpression;
            //case SyntaxKind.TypeOfKeyword:
            //    return SyntaxKind.TypeOfExpression;
            //case SyntaxKind.VoidKeyword:
            //    return SyntaxKind.VoidExpression;
            default:
                return SyntaxKind.None;
        }
    }

    export function getPostfixUnaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind {
        switch (tokenKind) {
            case SyntaxKind.PlusPlusToken:
                return SyntaxKind.PostIncrementExpression;
            case SyntaxKind.MinusMinusToken:
                return SyntaxKind.PostDecrementExpression;
            default:
                return SyntaxKind.None;
        }
    }

    export function getBinaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind {
        switch (tokenKind) {
            case SyntaxKind.AsteriskToken:
                return SyntaxKind.MultiplyExpression;

            case SyntaxKind.SlashToken:
                return SyntaxKind.DivideExpression;

            case SyntaxKind.PercentToken:
                return SyntaxKind.ModuloExpression;

            case SyntaxKind.PlusToken:
                return SyntaxKind.AddExpression;

            case SyntaxKind.MinusToken:
                return SyntaxKind.SubtractExpression;

            case SyntaxKind.LessThanLessThanToken:
                return SyntaxKind.LeftShiftExpression;

            case SyntaxKind.GreaterThanGreaterThanToken:
                return SyntaxKind.SignedRightShiftExpression;

            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                return SyntaxKind.UnsignedRightShiftExpression;

            case SyntaxKind.LessThanToken:
                return SyntaxKind.LessThanExpression;

            case SyntaxKind.GreaterThanToken:
                return SyntaxKind.GreaterThanExpression;

            case SyntaxKind.LessThanEqualsToken:
                return SyntaxKind.LessThanOrEqualExpression;

            case SyntaxKind.GreaterThanEqualsToken:
                return SyntaxKind.GreaterThanOrEqualExpression;

            case SyntaxKind.InstanceOfKeyword:
                return SyntaxKind.InstanceOfExpression;

            case SyntaxKind.InKeyword:
                return SyntaxKind.InExpression;

            case SyntaxKind.EqualsEqualsToken:
                return SyntaxKind.EqualsWithTypeConversionExpression;

            case SyntaxKind.ExclamationEqualsToken:
                return SyntaxKind.NotEqualsWithTypeConversionExpression;

            case SyntaxKind.EqualsEqualsEqualsToken:
                return SyntaxKind.EqualsExpression;

            case SyntaxKind.ExclamationEqualsEqualsToken:
                return SyntaxKind.NotEqualsExpression;

            case SyntaxKind.AmpersandToken:
                return SyntaxKind.BitwiseAndExpression;

            case SyntaxKind.CaretToken:
                return SyntaxKind.BitwiseExclusiveOrExpression;

            case SyntaxKind.BarToken:
                return SyntaxKind.BitwiseOrExpression;

            case SyntaxKind.AmpersandAmpersandToken:
                return SyntaxKind.LogicalAndExpression;

            case SyntaxKind.BarBarToken:
                return SyntaxKind.LogicalOrExpression;

            case SyntaxKind.BarEqualsToken:
                return SyntaxKind.OrAssignmentExpression;

            case SyntaxKind.AmpersandEqualsToken:
                return SyntaxKind.AndAssignmentExpression;

            case SyntaxKind.CaretEqualsToken:
                return SyntaxKind.ExclusiveOrAssignmentExpression;

            case SyntaxKind.LessThanLessThanEqualsToken:
                return SyntaxKind.LeftShiftAssignmentExpression;

            case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                return SyntaxKind.SignedRightShiftAssignmentExpression;

            case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                return SyntaxKind.UnsignedRightShiftAssignmentExpression;

            case SyntaxKind.PlusEqualsToken:
                return SyntaxKind.AddAssignmentExpression;

            case SyntaxKind.MinusEqualsToken:
                return SyntaxKind.SubtractAssignmentExpression;

            case SyntaxKind.AsteriskEqualsToken:
                return SyntaxKind.MultiplyAssignmentExpression;

            case SyntaxKind.SlashEqualsToken:
                return SyntaxKind.DivideAssignmentExpression;

            case SyntaxKind.PercentEqualsToken:
                return SyntaxKind.ModuloAssignmentExpression;

            case SyntaxKind.EqualsToken:
                return SyntaxKind.AssignmentExpression;

            case SyntaxKind.CommaToken:
                return SyntaxKind.CommaExpression;

            default:
                return SyntaxKind.None;
        }
    }

    export function isAnyDivideToken(kind: SyntaxKind): bool {
        switch (kind) {
            case SyntaxKind.SlashToken:
            case SyntaxKind.SlashEqualsToken:
                return true;
            default:
                return false;
        }
    }

    export function isAnyDivideOrRegularExpressionToken(kind: SyntaxKind): bool {
        switch (kind) {
            case SyntaxKind.SlashToken:
            case SyntaxKind.SlashEqualsToken:
            case SyntaxKind.RegularExpressionLiteral:
                return true;
            default:
                return false;
        }
    }

    export function isParserGenerated(kind: SyntaxKind): bool {
        switch (kind) {
            case SyntaxKind.GreaterThanGreaterThanToken:
            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
            case SyntaxKind.GreaterThanEqualsToken:
            case SyntaxKind.GreaterThanGreaterThanEqualsToken:
            case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                return true;
            default:
                return false;
        }
    }

    // An identifier name is basically any word, even if that work is a reserved keyword.  so 
    // both 'foo' and 'return' are identifier names.
    export function isIdentifierName(kind: SyntaxKind): bool {
        return kind === SyntaxKind.IdentifierName || isAnyKeyword(kind);
    }

    export function isAnyBinaryExpression(kind: SyntaxKind): bool {
        switch (kind) {
            case SyntaxKind.CommaExpression:
            case SyntaxKind.AssignmentExpression:
            case SyntaxKind.AddAssignmentExpression:
            case SyntaxKind.SubtractAssignmentExpression:
            case SyntaxKind.MultiplyAssignmentExpression:
            case SyntaxKind.DivideAssignmentExpression:
            case SyntaxKind.ModuloAssignmentExpression:
            case SyntaxKind.AndAssignmentExpression:
            case SyntaxKind.ExclusiveOrAssignmentExpression:
            case SyntaxKind.OrAssignmentExpression:
            case SyntaxKind.LeftShiftAssignmentExpression:
            case SyntaxKind.SignedRightShiftAssignmentExpression:
            case SyntaxKind.UnsignedRightShiftAssignmentExpression:
            case SyntaxKind.LogicalOrExpression:
            case SyntaxKind.LogicalAndExpression:
            case SyntaxKind.BitwiseOrExpression:
            case SyntaxKind.BitwiseExclusiveOrExpression:
            case SyntaxKind.BitwiseAndExpression:
            case SyntaxKind.EqualsWithTypeConversionExpression:
            case SyntaxKind.NotEqualsWithTypeConversionExpression:
            case SyntaxKind.EqualsExpression:
            case SyntaxKind.NotEqualsExpression:
            case SyntaxKind.LessThanExpression:
            case SyntaxKind.GreaterThanExpression:
            case SyntaxKind.LessThanOrEqualExpression:
            case SyntaxKind.GreaterThanOrEqualExpression:
            case SyntaxKind.InstanceOfExpression:
            case SyntaxKind.InExpression:
            case SyntaxKind.LeftShiftExpression:
            case SyntaxKind.SignedRightShiftExpression:
            case SyntaxKind.UnsignedRightShiftExpression:
            case SyntaxKind.MultiplyExpression:
            case SyntaxKind.DivideExpression:
            case SyntaxKind.ModuloExpression:
            case SyntaxKind.AddExpression:
            case SyntaxKind.SubtractExpression:
                return true;
        }

        return false;
    }
}
///<reference path='..\Core\IntegerUtilities.ts' />
///<reference path='ISeparatedSyntaxList.ts' />
///<reference path='PositionedElement.ts' />
///<reference path='SyntaxFacts.ts' />
///<reference path='SyntaxFacts.ts' />

module Syntax {
    export var emptySeparatedList: ISeparatedSyntaxList = {
        kind: () => SyntaxKind.SeparatedList,

        isNode: () => false,
        isToken: () => false,
        isList: () => false,
        isSeparatedList: () => true,

        toJSON: (key) => [],

        childCount: () => 0,
        nonSeparatorCount: () => 0,
        separatorCount: () => 0,

        toArray: () => [],
        toNonSeparatorArray: () => [],

        childAt: (index: number): ISyntaxNodeOrToken => {
            throw Errors.argumentOutOfRange("index");
        },

        nonSeparatorAt: (index: number): ISyntaxNodeOrToken => {
            throw Errors.argumentOutOfRange("index");
        },

        separatorAt: (index: number): ISyntaxToken => {
            throw Errors.argumentOutOfRange("index");
        },

        collectTextElements: (elements: string[]): void => { },

        firstToken: (): ISyntaxToken => null,
        lastToken: (): ISyntaxToken => null,

        fullWidth: () => 0,
        fullText: () => "",

        width: () => 0,

        isTypeScriptSpecific: () => false,
        hasSkippedText: () => false,
        hasZeroWidthToken: () => false,
        hasRegularExpressionToken: () => false,

        findTokenInternal: (parent: PositionedElement, position: number, fullStart: number): PositionedToken => {
            // This should never have been called on this list.  It has a 0 width, so the client 
            // should have skipped over this.
            throw Errors.invalidOperation();
        },

        insertChildrenInto: (array: ISyntaxElement[], index: number): void => {
        },

        leadingTrivia: () => Syntax.emptyTriviaList,
        trailingTrivia: () => Syntax.emptyTriviaList,

        leadingTriviaWidth: () => 0,
        trailingTriviaWidth:() => 0
    }

    class SingletonSeparatedSyntaxList implements ISeparatedSyntaxList {
        private item: ISyntaxNodeOrToken;

        constructor(item: ISyntaxNodeOrToken) {
            this.item = item;
        }

        public toJSON(key) {
            return [this.item];
        }

        public kind() { return SyntaxKind.SeparatedList; }

        public isNode(): bool { return false; }
        public isToken(): bool { return false; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return true; }

        public childCount() { return 1; }
        public nonSeparatorCount() { return 1; }
        public separatorCount() { return 0; }

        public toArray() { return [this.item]; }
        public toNonSeparatorArray() { return [this.item]; }

        public childAt(index: number): ISyntaxNodeOrToken {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.item;
        }

        public nonSeparatorAt(index: number): ISyntaxNodeOrToken {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.item;
        }

        public separatorAt(index: number): ISyntaxToken {
            throw Errors.argumentOutOfRange("index");
        }

        private collectTextElements(elements: string[]): void {
            this.item.collectTextElements(elements);
        }

        public firstToken(): ISyntaxToken {
            return this.item.firstToken();
        }

        public lastToken(): ISyntaxToken {
            return this.item.lastToken();
        }

        public fullWidth(): number {
            return this.item.fullWidth();
        }

        public width(): number {
            return this.item.width();
        }

        public fullText(): string {
            return this.item.fullText();
        }

        public leadingTrivia(): ISyntaxTriviaList {
            return this.item.leadingTrivia();
        }

        public trailingTrivia(): ISyntaxTriviaList {
            return this.item.trailingTrivia();
        }

        public leadingTriviaWidth(): number {
            return this.item.leadingTriviaWidth();
        }

        public trailingTriviaWidth(): number {
            return this.item.trailingTriviaWidth();
        }

        public isTypeScriptSpecific(): bool {
            return this.item.isTypeScriptSpecific();
        }

        public hasSkippedText(): bool {
            return this.item.hasSkippedText();
        }

        public hasZeroWidthToken(): bool {
            return this.item.hasZeroWidthToken();
        }

        public hasRegularExpressionToken(): bool {
            return this.item.hasRegularExpressionToken();
        }

        public findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            Debug.assert(position >= 0 && position < this.item.fullWidth());
            return (<any>this.item).findTokenInternal(
                new PositionedSeparatedList(parent, this, fullStart), position, fullStart);
        }

        public insertChildrenInto(array: ISyntaxElement[], index: number): void {
            array.splice(index, 0, this.item);
        }
    }

    class NormalSeparatedSyntaxList implements ISeparatedSyntaxList {
        private elements: ISyntaxNodeOrToken[];
        private _data: number = -1;

        constructor(elements: ISyntaxNodeOrToken[]) {
            this.elements = elements;
        }

        public kind() { return SyntaxKind.SeparatedList; }

        public isToken(): bool { return false; }
        public isNode(): bool { return false; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return true; }
        public toJSON(key) { return this.elements; }

        public childCount() { return this.elements.length; }
        public nonSeparatorCount() { return IntegerUtilities.integerDivide(this.elements.length + 1, 2); }
        public separatorCount() { return IntegerUtilities.integerDivide(this.elements.length, 2); }

        public toArray(): ISyntaxNodeOrToken[] { return this.elements.slice(0); }

        public toNonSeparatorArray(): ISyntaxNodeOrToken[] {
            var result: ISyntaxNodeOrToken[] = [];
            for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                result.push(this.nonSeparatorAt(i));
            }

            return result;
        }
        
        public childAt(index: number): ISyntaxNodeOrToken {
            if (index < 0 || index >= this.elements.length) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.elements[index];
        }

        public nonSeparatorAt(index: number): ISyntaxNodeOrToken {
            var value = index * 2;
            if (value < 0 || value >= this.elements.length) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.elements[value];
        }

        public separatorAt(index: number): ISyntaxToken {
            var value = index * 2 + 1;
            if (value < 0 || value >= this.elements.length) {
                throw Errors.argumentOutOfRange("index");
            }

            return <ISyntaxToken>this.elements[value];
        }

        public firstToken(): ISyntaxToken {
            var token;
            for (var i = 0, n = this.elements.length; i < n; i++) {
                if (i % 2 === 0) {
                    var nodeOrToken = this.elements[i];
                    token = nodeOrToken.firstToken();
                    if (token !== null) {
                        return token;
                    }
                }
                else {
                    token = <ISyntaxToken>this.elements[i];
                    if (token.width() > 0) {
                        return token;
                    }
                }
            }

            return null;
        }

        public lastToken(): ISyntaxToken {
            var token;
            for (var i = this.elements.length - 1; i >= 0; i--) {
                if (i % 2 === 0) {
                    var nodeOrToken = this.elements[i];
                    token = nodeOrToken.lastToken();
                    if (token !== null) {
                        return token;
                    }
                }
                else {
                    token = <ISyntaxToken>this.elements[i];
                    if (token.width() > 0) {
                        return token;
                    }
                }
            }

            return null;
        }

        public fullText(): string {
            var elements: string[] = [];
            this.collectTextElements(elements);
            return elements.join("");
        }

        public isTypeScriptSpecific(): bool {
            for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                if (this.nonSeparatorAt(i).isTypeScriptSpecific()) {
                    return true;
                }
            }

            return false;
        }

        public hasSkippedText(): bool {
            return (this.data() & SyntaxConstants.NodeSkippedTextMask) !== 0;
        }

        public hasZeroWidthToken(): bool {
            return (this.data() & SyntaxConstants.NodeZeroWidthTokenMask) !== 0;
        }

        public hasRegularExpressionToken(): bool {
            return (this.data() & SyntaxConstants.NodeRegularExpressionTokenMask) !== 0;
        }

        public fullWidth(): number {
            return this.data() >>> SyntaxConstants.NodeFullWidthShift;
        }

        public width(): number {
            var fullWidth = this.fullWidth();
            return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        }

        public leadingTrivia(): ISyntaxTriviaList {
            return this.firstToken().leadingTrivia();
        }

        public trailingTrivia(): ISyntaxTriviaList {
            return this.lastToken().trailingTrivia();
        }

        public leadingTriviaWidth(): number {
            return this.firstToken().leadingTriviaWidth();
        }

        public trailingTriviaWidth(): number {
            return this.lastToken().trailingTriviaWidth();
        }

        private computeData(): number {
            var fullWidth = 0;
            var hasSkippedText = false;
            var hasZeroWidthToken = false;
            var hasRegularExpressionToken = false;

            for (var i = 0, n = this.elements.length; i < n; i++) {
                var element = this.elements[i];

                var childWidth = element.fullWidth();
                fullWidth += childWidth;

                if (i % 2 === 0) {
                    var nodeOrToken = element;

                    hasSkippedText = hasSkippedText || nodeOrToken.hasSkippedText();
                    hasZeroWidthToken = hasZeroWidthToken || nodeOrToken.hasZeroWidthToken();
                    hasRegularExpressionToken = hasRegularExpressionToken || nodeOrToken.hasRegularExpressionToken();
                }
                else {
                    var token = <ISyntaxToken>element;

                    hasSkippedText = hasSkippedText || token.hasSkippedText();
                    hasZeroWidthToken = hasZeroWidthToken || (childWidth === 0);

                    // A regex token never shows up as a separator token in a list.  If the language
                    // ever changes, add hte appropriate check here.
                }
            }

            return (fullWidth << SyntaxConstants.NodeFullWidthShift)
                 | (hasSkippedText ? SyntaxConstants.NodeSkippedTextMask : 0)
                 | (hasZeroWidthToken ? SyntaxConstants.NodeZeroWidthTokenMask : 0)
                 | (hasRegularExpressionToken ? SyntaxConstants.NodeRegularExpressionTokenMask : 0);
        }

        private data(): number {
            if (this._data === -1) {
                this._data = this.computeData();
            }

            return this._data;
        }

        public findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            parent = new PositionedSeparatedList(parent, this, fullStart);
            for (var i = 0, n = this.elements.length; i < n; i++) {
                var element = this.elements[i];

                var childWidth = element.fullWidth();
                if (position < childWidth) {
                    return (<any>element).findTokenInternal(parent, position, fullStart);
                }

                position -= childWidth;
                fullStart += childWidth;
            }

            throw Errors.invalidOperation();
        }

        private collectTextElements(elements: string[]): void {
            for (var i = 0, n = this.elements.length; i < n; i++) {
                var element = this.elements[i];
                element.collectTextElements(elements);
            }
        }

        public insertChildrenInto(array: ISyntaxElement[], index: number): void {
            if (index === 0) {
                array.unshift.apply(array, this.elements);
            }
            else {
                // TODO: this seems awfully innefficient.  Can we do better here?
                array.splice.apply(array, [index, <any>0].concat(this.elements));
            }
        }
    }

    export function separatedList(nodes: ISyntaxNodeOrToken[]): ISeparatedSyntaxList {
        return separatedListAndValidate(nodes, false);
    }

    function separatedListAndValidate(nodes: ISyntaxNodeOrToken[], validate: bool): ISeparatedSyntaxList {
        if (nodes === undefined || nodes === null || nodes.length === 0) {
            return emptySeparatedList;
        }

        if (validate) {
            for (var i = 0; i < nodes.length; i++) {
                var item = nodes[i];

                if (i % 2 === 1) {
                    Debug.assert(SyntaxFacts.isTokenKind(item.kind()));
                }
            }
        }

        if (nodes.length === 1) {
            return new SingletonSeparatedSyntaxList(nodes[0]);
        }

        return new NormalSeparatedSyntaxList(nodes);
    }
}
///<reference path='ISyntaxList.ts' />

module Syntax {
    class EmptySyntaxList implements ISyntaxList {
        public kind(): SyntaxKind { return SyntaxKind.List; }

        public isNode(): bool { return false; }
        public isToken(): bool { return false; }
        public isList(): bool { return true; }
        public isSeparatedList(): bool { return false; }

        public toJSON(key) {
            return [];
        }

        public childCount(): number {
            return 0;
        }

        public childAt(index: number): ISyntaxNodeOrToken {
            throw Errors.argumentOutOfRange("index");
        }

        public toArray(): ISyntaxNodeOrToken[] {
            return [];
        }

        private collectTextElements(elements: string[]): void {
        }

        public firstToken(): ISyntaxToken {
            return null;
        }

        public lastToken(): ISyntaxToken {
            return null;
        }

        public fullWidth(): number {
            return 0;
        }

        public width(): number {
            return 0;
        }

        public leadingTrivia(): ISyntaxTriviaList {
            return Syntax.emptyTriviaList;
        }

        public trailingTrivia(): ISyntaxTriviaList {
            return Syntax.emptyTriviaList;
        }

        public leadingTriviaWidth(): number {
            return 0;
        }

        public trailingTriviaWidth(): number {
            return 0;
        }

        public fullText(): string {
            return "";
        }

        public isTypeScriptSpecific(): bool {
            return false;
        }

        public hasSkippedText(): bool {
            return false;
        }

        public hasZeroWidthToken(): bool {
            return false;
        }

        public hasRegularExpressionToken(): bool {
            return false;
        }

        public findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            // This should never have been called on this list.  It has a 0 width, so the client 
            // should have skipped over this.
            throw Errors.invalidOperation();
        }

        public insertChildrenInto(array: ISyntaxElement[], index: number): void {
        }
    }

    export var emptyList: ISyntaxList = new EmptySyntaxList();

    class SingletonSyntaxList implements ISyntaxList {
        private item: ISyntaxNodeOrToken;

        constructor(item: ISyntaxNodeOrToken) {
            this.item = item;
        }

        public kind(): SyntaxKind { return SyntaxKind.List; }

        public isToken(): bool { return false; }
        public isNode(): bool { return false; }
        public isList(): bool { return true; }
        public isSeparatedList(): bool { return false; }

        public toJSON(key) {
            return [this.item];
        }

        public childCount() {
            return 1;
        }

        public childAt(index: number): ISyntaxNodeOrToken {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.item;
        }

        public toArray(): ISyntaxNodeOrToken[] {
            return [this.item];
        }

        private collectTextElements(elements: string[]): void {
            this.item.collectTextElements(elements);
        }

        public firstToken(): ISyntaxToken {
            return this.item.firstToken();
        }

        public lastToken(): ISyntaxToken {
            return this.item.lastToken();
        }

        public fullWidth(): number {
            return this.item.fullWidth();
        }

        public width(): number {
            return this.item.width();
        }
        
        public leadingTrivia(): ISyntaxTriviaList {
            return this.item.leadingTrivia();
        }

        public trailingTrivia(): ISyntaxTriviaList {
            return this.item.trailingTrivia();
        }

        public leadingTriviaWidth(): number {
            return this.item.leadingTriviaWidth();
        }

        public trailingTriviaWidth(): number {
            return this.item.trailingTriviaWidth();
        }

        public fullText(): string {
            return this.item.fullText();
        }

        public isTypeScriptSpecific(): bool {
            return this.item.isTypeScriptSpecific();
        }

        public hasSkippedText(): bool {
            return this.item.hasSkippedText();
        }

        public hasZeroWidthToken(): bool {
            return this.item.hasZeroWidthToken();
        }

        public hasRegularExpressionToken(): bool {
            return this.item.hasRegularExpressionToken();
        }

        public findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            Debug.assert(position >= 0 && position < this.item.fullWidth());
            return (<any>this.item).findTokenInternal(
                new PositionedList(parent, this, fullStart), position, fullStart);
        }

        public insertChildrenInto(array: ISyntaxElement[], index: number): void {
            array.splice(index, 0, this.item);
        }
    }

    class NormalSyntaxList implements ISyntaxList {
        private nodeOrTokens: ISyntaxNodeOrToken[];
        private _data: number = -1;

        constructor(nodeOrTokens: ISyntaxNodeOrToken[]) {
            this.nodeOrTokens = nodeOrTokens;
        }

        public kind(): SyntaxKind { return SyntaxKind.List; }

        public isNode(): bool { return false; }
        public isToken(): bool { return false; }
        public isList(): bool { return true; }
        public isSeparatedList(): bool { return false; }

        public toJSON(key) {
            return this.nodeOrTokens;
        }

        public childCount() {
            return this.nodeOrTokens.length;
        }

        public childAt(index: number): ISyntaxNodeOrToken {
            if (index < 0 || index >= this.nodeOrTokens.length) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.nodeOrTokens[index];
        }

        public toArray(): ISyntaxNodeOrToken[] {
            return this.nodeOrTokens.slice(0);
        }

        private collectTextElements(elements: string[]): void {
            for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var element = this.nodeOrTokens[i];
                element.collectTextElements(elements);
            }
        }

        public firstToken(): ISyntaxToken {
            for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var token = this.nodeOrTokens[i].firstToken();
                if (token !== null) {
                    return token;
                }
            }

            return null;
        }

        public lastToken(): ISyntaxToken {
            for (var i = this.nodeOrTokens.length - 1; i >= 0; i--) {
                var token = this.nodeOrTokens[i].lastToken();
                if (token !== null) {
                    return token;
                }
            }

            return null;
        }

        public fullText(): string {
            var elements: string[] = [];
            this.collectTextElements(elements);
            return elements.join("");
        }

        public isTypeScriptSpecific(): bool {
            for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                if (this.nodeOrTokens[i].isTypeScriptSpecific()) {
                    return true;
                }
            }

            return false;
        }

        public hasSkippedText(): bool {
            return (this.data() & SyntaxConstants.NodeSkippedTextMask) !== 0;
        }

        public hasZeroWidthToken(): bool {
            return (this.data() & SyntaxConstants.NodeZeroWidthTokenMask) !== 0;
        }

        public hasRegularExpressionToken(): bool {
            return (this.data() & SyntaxConstants.NodeRegularExpressionTokenMask) !== 0;
        }

        public fullWidth(): number {
            return this.data() >>> SyntaxConstants.NodeFullWidthShift;
        }

        public width(): number {
            var fullWidth = this.fullWidth();
            return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        }

        public leadingTrivia(): ISyntaxTriviaList {
            return this.firstToken().leadingTrivia();
        }

        public trailingTrivia(): ISyntaxTriviaList {
            return this.lastToken().trailingTrivia();
        }

        public leadingTriviaWidth(): number {
            return this.firstToken().leadingTriviaWidth();
        }

        public trailingTriviaWidth(): number {
            return this.lastToken().trailingTriviaWidth();
        }

        private computeData(): number {
            var fullWidth = 0;
            var hasSkippedText = false;
            var hasZeroWidthToken = false;
            var hasRegularExpressionToken = false;

            for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var node = this.nodeOrTokens[i];
                fullWidth += node.fullWidth();
                hasSkippedText = hasSkippedText || node.hasSkippedText();
                hasZeroWidthToken = hasZeroWidthToken || node.hasZeroWidthToken();
                hasRegularExpressionToken = hasRegularExpressionToken || node.hasRegularExpressionToken();
            }

            return (fullWidth << SyntaxConstants.NodeFullWidthShift)
                 | (hasSkippedText ? SyntaxConstants.NodeSkippedTextMask : 0)
                 | (hasZeroWidthToken ? SyntaxConstants.NodeZeroWidthTokenMask : 0)
                 | (hasRegularExpressionToken ? SyntaxConstants.NodeRegularExpressionTokenMask : 0);
        }

        private data(): number {
            if (this._data === -1) {
                this._data = this.computeData();
            }

            return this._data;
        }

        public findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            Debug.assert(position >= 0 && position < this.fullWidth());
            
            parent = new PositionedList(parent, this, fullStart);
            for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var nodeOrToken = this.nodeOrTokens[i];

                var childWidth = nodeOrToken.fullWidth();
                if (position < childWidth) {
                    return (<any>nodeOrToken).findTokenInternal(parent, position, fullStart);
                }

                position -= childWidth;
                fullStart += childWidth;
            }

            throw Errors.invalidOperation();
        }

        public insertChildrenInto(array: ISyntaxElement[], index: number): void {
            if (index === 0) {
                array.unshift.apply(array, this.nodeOrTokens);
            }
            else {
                // TODO: this seems awfully innefficient.  Can we do better here?
                array.splice.apply(array, [index, <any>0].concat(this.nodeOrTokens));
            }
        }
    }

    export function list(nodes: ISyntaxNodeOrToken[]): ISyntaxList {
        if (nodes === undefined || nodes === null || nodes.length === 0) {
            return emptyList;
        }

        if (nodes.length === 1) {
            var item = nodes[0];
            return new SingletonSyntaxList(item);
        }

        return new NormalSyntaxList(nodes);
    }
}
///<reference path='Errors.ts' />

class Hash {
    // This table uses FNV1a as a string hash
    private static FNV_BASE = 2166136261;
    private static FNV_PRIME = 16777619;

    private static computeFnv1aCharArrayHashCode(text: number[], start: number, len: number): number {
        var hashCode = FNV_BASE;
        var end = start + len;

        for (var i = start; i < end; i++) {
            hashCode = (hashCode ^ text[i]) * FNV_PRIME;
        }

        return hashCode;
    }

    public static computeSimple31BitCharArrayHashCode(key: number[], start: number, len: number): number {
        // Start with an int.
        var hash = 0;

        for (var i = 0; i < len; i++) {
            var ch = key[start + i];

            // Left shift keeps things as a 32bit int.  And we're only doing two adds.  Chakra and
            // V8 recognize this as not needing to go past the 53 bits needed for the float 
            // mantissa.  Or'ing with 0 keeps this 32 bits.
            hash = (((hash << 5) + hash) + ch) | 0;
        }

        // Ensure we fit in 31 bits.  That way if/when this gets stored, it won't require any heap
        // allocation.
        return hash & 0x7FFFFFFF;
    }

    public static computeSimple31BitStringHashCode(key: string): number {
        // Start with an int.
        var hash = 0;

        var start = 0;
        var len = key.length;

        for (var i = 0; i < len; i++) {
            var ch = key.charCodeAt(start + i);

            // Left shift keeps things as a 32bit int.  And we're only doing two adds.  Chakra and
            // V8 recognize this as not needing to go past the 53 bits needed for the float 
            // mantissa.  Or'ing with 0 keeps this 32 bits.
            hash = (((hash << 5) + hash) + ch) | 0;
        }

        // Ensure we fit in 31 bits.  That way if/when this gets stored, it won't require any heap
        // allocation.
        return hash & 0x7FFFFFFF;
    }

    public static computeMurmur2CharArrayHashCode(key: number[], start: number, len: number): number {
        // 'm' and 'r' are mixing constants generated offline.
        // They're not really 'magic', they just happen to work well.
        var m = 0x5bd1e995;
        var r = 24;

        // Initialize the hash to a 'random' value
        var numberOfCharsLeft = len;
        var h = (0 ^ numberOfCharsLeft);

        // Mix 4 bytes at a time into the hash.  NOTE: 4 bytes is two chars, so we iterate
        // through the string two chars at a time.
        var index = start;
        while (numberOfCharsLeft >= 2) {
            var c1 = key[index];
            var c2 = key[index + 1];

            var k = c1 | (c2 << 16);

            k *= m;
            k ^= k >> r;
            k *= m;

            h *= m;
            h ^= k;

            index += 2;
            numberOfCharsLeft -= 2;
        }

        // Handle the last char (or 2 bytes) if they exist.  This happens if the original string had
        // odd length.
        if (numberOfCharsLeft === 1) {
            h ^= key[index];
            h *= m;
        }

        // Do a few final mixes of the hash to ensure the last few bytes are well-incorporated.

        h ^= h >> 13;
        h *= m;
        h ^= h >> 15;

        return h;
    }

    public static computeMurmur2StringHashCode(key: string): number {
        // 'm' and 'r' are mixing constants generated offline.
        // They're not really 'magic', they just happen to work well.
        var m = 0x5bd1e995;
        var r = 24;

        var start = 0;
        var len = key.length;
        var numberOfCharsLeft = len;

        // Initialize the hash to a 'random' value.
        var h = (0 ^ numberOfCharsLeft);

        // Mix 4 bytes at a time into the hash.  NOTE: 4 bytes is two chars, so we iterate
        // through the string two chars at a time.
        var index = start;
        while (numberOfCharsLeft >= 2) {
            var c1 = key.charCodeAt(index);
            var c2 = key.charCodeAt(index + 1);

            var k = c1 | (c2 << 16);

            k *= m;
            k ^= k >> r;
            k *= m;

            h *= m;
            h ^= k;

            index += 2;
            numberOfCharsLeft -= 2;
        }

        // Handle the last char (or 2 bytes) if they exist.  This happens if the original string had
        // odd length.
        if (numberOfCharsLeft === 1) {
            h ^= key.charCodeAt(index);
            h *= m;
        }

        // Do a few final mixes of the hash to ensure the last few bytes are well-incorporated.

        h ^= h >> 13;
        h *= m;
        h ^= h >> 15;

        return h;
    }

    private static primes =
        [3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521,
          631, 761, 919, 1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419,
          10103, 12143, 14591, 17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431,
          90523, 108631, 130363, 156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689,
          672827, 807403, 968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899,
          4166287, 4999559, 5999471, 7199369];

    public static getPrime(min: number): number {
        for (var i = 0; i < primes.length; i++) {
            var num = primes[i];
            if (num >= min) {
                return num;
            }
        }

        throw Errors.notYetImplemented();
    }

    public static expandPrime(oldSize: number): number {
        var num = oldSize << 1;
        if (num > 2146435069 && 2146435069 > oldSize) {
            // NOTE: 2146435069 fits in 31 bits.
            return 2146435069;
        }
        return getPrime(num);
    }

    public static combine(value: number, currentHash: number): number {
        // Ensure we stay within 31 bits.
        return (((currentHash << 5) + currentHash) + value) & 0x7FFFFFFF;
    }
}
///<reference path='Debug.ts' />
///<reference path='Errors.ts' />

class ArrayUtilities {
    public static isArray(value: any): bool {
        return Object.prototype.toString.apply(value, []) === '[object Array]';
    }

    public static sequenceEquals(array1: any[], array2: any[], equals: (v1, v2) => bool) {
        if (array1 === array2) {
            return true;
        }

        if (array1 === null || array2 === null) {
            return false;
        }

        if (array1.length !== array2.length) {
            return false;
        }

        for (var i = 0, n = array1.length; i < n; i++) {
            if (!equals(array1[i], array2[i])) {
                return false;
            }
        }

        return true;
    }

    public static contains(array: any[], value: any): bool {
        for (var i = 0; i < array.length; i++) {
            if (array[i] === value) {
                return true;
            }
        }

        return false;
    }

    public static groupBy(array: any[], func:(v: any) => string): any {
        var result = {};

        for (var i = 0, n = array.length; i < n; i++) {
            var v = array[i];
            var k = func(v);

            var list = result[k] || [];
            list.push(v);
            result[k] = list;
        }

        return result;
    }

    public static min(array: any[], func: (v: any) => number): number {
        Debug.assert(array.length > 0);
        var min = func(array[0]);

        for (var i = 1; i < array.length; i++) {
            var next = func(array[i]);
            if (next < min) {
                min = next;
            }
        }

        return min;
    }

    public static max(array: any[], func: (v: any) => number): number {
        Debug.assert(array.length > 0);
        var max = func(array[0]);

        for (var i = 1; i < array.length; i++) {
            var next = func(array[i]);
            if (next > max) {
                max = next;
            }
        }

        return max;
    }

    public static last(array: any[]) {
        if (array.length === 0) {
            throw Errors.argumentOutOfRange('array');
        }

        return array[array.length - 1];
    }

    public static firstOrDefault(array: any[], func: (v: any) => bool): any {
        for (var i = 0, n = array.length; i < n; i++) {
            var value = array[i];
            if (func(value)) {
                return value;
            }
        }

        return null;
    }

    public static sum(array: any[], func: (v: any) => number): number {
        var result = 0;

        for (var i = 0, n = array.length; i < n; i++) {
            result += func(array[i]);
        }

        return result;
    }

    public static whereNotNull(array: any[]): any[] {
        var result = [];
        for (var i = 0; i < array.length; i++) {
            var value = array[i];
            if (value !== null) {
                result.push(value);
            }
        }

        return result;
    }

    public static select(values: any[], func: (v: any) => any): any[] {
        var result = [];

        for (var i = 0; i < values.length; i++) {
            result.push(func(values[i]));
        }

        return result;
    }

    public static where(values: any[], func: (v: any) => bool): any[] {
        var result = [];

        for (var i = 0; i < values.length; i++) {
            if (func(values[i])) {
                result.push(values[i]);
            }
        }

        return result;
    }

    public static any(array: any[], func: (v: any) => bool): bool {
        for (var i = 0, n = array.length; i < n; i++) {
            if (func(array[i])) {
                return true;
            }
        }

        return false;
    }

    public static all(array: any[], func: (v: any) => bool): bool {
        for (var i = 0, n = array.length; i < n; i++) {
            if (!func(array[i])) {
                return false;
            }
        }

        return true;
    }

    public static binarySearch(array: number[], value: number): number {
        var low = 0;
        var high = array.length - 1;

        while (low <= high) {
            var middle = low + ((high - low) >> 1);
            var midValue = array[middle];

            if (midValue === value) {
                return middle;
            }
            else if (midValue > value) {
                high = middle - 1;
            }
            else {
                low = middle + 1;
            }
        }

        return ~low;
    }

    public static createArray(length: number, defaultvalue = null): any[] {
        var result = [];
        for (var i = 0; i < length; i++) {
            result.push(defaultvalue);
        }

        return result;
    }

    public static grow(array: any[], length: number, defaultValue: any): void {
        var count = length - array.length;
        for (var i = 0; i < count; i++) {
            array.push(defaultValue);
        }
    }

    public static copy(sourceArray: any[], sourceIndex: number, destinationArray: any[], destinationIndex: number, length: number): void {
        for (var i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
        }
    }
}
///<reference path='..\Core\ArrayUtilities.ts' />

interface ISlidingWindowSource {
    // Asks the source to copy items starting at sourceIndex into the window at 'destinationIndex'
    // with up to 'spaceAvailable' items.  The actual number of items fetched should be given as 
    // the return value.
    fetchMoreItems(argument: any, sourceIndex: number, window: any[], destinationIndex: number, spaceAvailable: number): number;
}

class SlidingWindow {

    // The number of valid items in window.
    private windowCount: number = 0;

    // The *absolute* index in the *full* array of items the *window* array starts at.  i.e.
    // if there were 100 items, and window contains tokens [70, 80), then this value would be
    // 70.
    public windowAbsoluteStartIndex: number = 0;

    // The index in the window array that we're at. i.e. if there 100 items and 
    // window contains tokens [70, 80), and we're on item 75, then this value would be '5'.
    // Note: it is not absolute.  It is relative to the start of the window.
    private currentRelativeItemIndex: number = 0;

    // The number of pinned points there are.  As long as there is at least one  pinned point, we 
    // will not advance the start of the window array past the item marked by that pin point.
    private _pinCount: number = 0;

    // If there are any outstanding rewind points, this is index in the full array of items
    // that the first rewind point points to.  If this is not -1, then we will not shift the
    // start of the items array past this point.
    private firstPinnedAbsoluteIndex: number = -1;

    constructor(// Underlying source that we retrieve items from.
                private source: ISlidingWindowSource,
                // A window of items that has been read in from the underlying source.
                public window: any[],
                // The default value to return when there are no more items left in the window.
                private defaultValue: any,
                // The length of the source we're reading from if we know it up front.  -1 if we do not.
                private sourceLength = -1) {
    }

    // The last legal index of the window (exclusive).
    private windowAbsoluteEndIndex(): number {
        return this.windowAbsoluteStartIndex + this.windowCount;
    }

    private addMoreItemsToWindow(argument: any): bool {
        if (this.sourceLength >= 0 && this.absoluteIndex() >= this.sourceLength) {
            return false;
        }

        // First, make room for the new items if we're out of room.
        if (this.windowCount >= this.window.length) {
            this.tryShiftOrGrowWindow();
        }

        var spaceAvailable = this.window.length - this.windowCount;
        var amountFetched = this.source.fetchMoreItems(argument, this.windowAbsoluteEndIndex(), this.window, this.windowCount, spaceAvailable);

        // Assert disabled because it is actually expensive enugh to affect perf.

        this.windowCount += amountFetched;
        return amountFetched > 0;
    }

    private tryShiftOrGrowWindow(): void {
        // We want to shift if our current item is past the halfway point of the current item window.
        var currentIndexIsPastWindowHalfwayPoint = this.currentRelativeItemIndex > (this.window.length >>> 1);

        // However, we can only shift if we have no outstanding rewind points.  Or, if we have an 
        // outstanding rewind point, that it points to some point after the start of the window.
        var isAllowedToShift = 
            this.firstPinnedAbsoluteIndex === -1 ||
            this.firstPinnedAbsoluteIndex > this.windowAbsoluteStartIndex;

        if (currentIndexIsPastWindowHalfwayPoint && isAllowedToShift) {
            // Figure out where we're going to start shifting from. If we have no oustanding rewind 
            // points, then we'll start shifting over all the items starting from the current 
            // token we're point out.  Otherwise, we'll shift starting from the first item that 
            // the rewind point is pointing at.
            // 
            // We'll call that point 'N' from now on. 
            var shiftStartIndex = this.firstPinnedAbsoluteIndex === -1
                ? this.currentRelativeItemIndex 
                : this.firstPinnedAbsoluteIndex - this.windowAbsoluteStartIndex;

            // We have to shift the number of elements between the start index and the number of 
            // items in the window.
            var shiftCount = this.windowCount - shiftStartIndex;

            Debug.assert(shiftStartIndex > 0);
            if (shiftCount > 0) {
                ArrayUtilities.copy(this.window, shiftStartIndex, this.window, 0, shiftCount);
            }

            // The window has now moved over to the right by N.
            this.windowAbsoluteStartIndex += shiftStartIndex;

            // The number of valid items in the window has now decreased by N.
            this.windowCount -= shiftStartIndex;

            // The current item now starts further to the left in the window.
            this.currentRelativeItemIndex -= shiftStartIndex;
        }
        else {
            // Grow the exisitng array.
            // this.window[this.window.length * 2 - 1] = this.defaultValue;
            ArrayUtilities.grow(this.window, this.window.length * 2, this.defaultValue);
        }
    }

    public absoluteIndex(): number {
        return this.windowAbsoluteStartIndex + this.currentRelativeItemIndex;
    }

    public isAtEndOfSource(): bool {
        return this.absoluteIndex() >= this.sourceLength;
    }

    public getAndPinAbsoluteIndex(): number {
        // Find the absolute index of this pin point.  i.e. it's the index as if we had an 
        // array containing *all* tokens.  
        var absoluteIndex = this.absoluteIndex();
        var pinCount = this._pinCount++;
        if (pinCount === 0) {
            // If this is the first pinned point, then store off this index.  We will ensure that
            // we never shift the window past this point.
            this.firstPinnedAbsoluteIndex = absoluteIndex;
        }

        return absoluteIndex;
    }

    public releaseAndUnpinAbsoluteIndex(absoluteIndex: number) {
        this._pinCount--;
        if (this._pinCount === 0) {
            // If we just released the last outstanding pin, then we no longer need to 'fix' the 
            // token window so it can't move forward.  Set the index to -1 so that we can shift 
            // things over the next time we read past the end of the array.
            this.firstPinnedAbsoluteIndex = -1;
        }
    }

    public rewindToPinnedIndex(absoluteIndex: number): void {
        // The rewind point shows which absolute item we want to rewind to.  Get the relative 
        // index in the actual array that we want to point to.
        var relativeIndex = absoluteIndex - this.windowAbsoluteStartIndex;

        // Make sure we haven't screwed anything up.
        Debug.assert(relativeIndex >= 0 && relativeIndex < this.windowCount);

        // Set ourselves back to that point.
        this.currentRelativeItemIndex = relativeIndex;
    }

    public currentItem(argument: any): any {
        if (this.currentRelativeItemIndex >= this.windowCount) {
            if (!this.addMoreItemsToWindow(argument)) {
                return this.defaultValue;
            }
        }

        return this.window[this.currentRelativeItemIndex];
    }

    public peekItemN(n: number): any {
        // Assert disabled because it is actually expensive enugh to affect perf.
        Debug.assert(n >= 0);
        while (this.currentRelativeItemIndex + n >= this.windowCount) {
            if (!this.addMoreItemsToWindow(/*argument:*/ null)) {
                return this.defaultValue;
            }
        }
        
        return this.window[this.currentRelativeItemIndex + n];
    }

    public moveToNextItem(): void {
        this.currentRelativeItemIndex++;
    }

    public disgardAllItemsFromCurrentIndexOnwards(): void {
        // By setting the window count to the current relative offset, we are effectively making
        // any items we added to the window from the current offset onwards unusable.  When we
        // try to get the next item, we'll be forced to refetch them from the underlying source.
        this.windowCount = this.currentRelativeItemIndex;
    }

    public setAbsoluteIndex(absoluteIndex: number): void {
        if (this.absoluteIndex() === absoluteIndex) {
            // Nothing to do if we're setting hte absolute index to where we current are.
            return;
        }

        if (this._pinCount > 0) {
            // If we have any active pins, then the caller better be setting the index somewhere
            // inside our active window.
            Debug.assert(absoluteIndex >= this.windowAbsoluteStartIndex && absoluteIndex < this.windowAbsoluteEndIndex());
        }

        if (absoluteIndex >= this.windowAbsoluteStartIndex && absoluteIndex < this.windowAbsoluteEndIndex()) {
            // The caller is setting the index to some place inside our current window.  This is 
            // easy to handle (and should be the common case).
            this.currentRelativeItemIndex = (absoluteIndex - this.windowAbsoluteStartIndex);
        }
        else {
            // The caller is setting the index to a place not in the window.  Just throw away 
            // everything we've got.
            
            // First, set the window start to that index.
            this.windowAbsoluteStartIndex = absoluteIndex;

            // Now, set the count to 0.  So we'll be forced to fetch more items.
            this.windowCount = 0;

            // And set us back to the start of the window.
            this.currentRelativeItemIndex = 0;
        }
    }

    public pinCount(): number {
        return this._pinCount;
    }
}
enum CharacterCodes {
    nullCharacter = 0,
    maxAsciiCharacter = 127,

    lineFeed            = 10,       // \n
    carriageReturn      = 13,       // \r
    lineSeparator       = 0x2028,
    paragraphSeparator  = 0x2029,
    space               = 32,       // " "

    // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems 
    // like an odd disparity?  (Or maybe it's completely fine for them to be different).
    nextLine            = 0x0085,

    nonBreakingSpace    = 0x00A0,   //

    _ = 95,
    $ = 36,

    _0 = 48,
    _9 = 57,

    a = 97,
    b = 98,
    c = 99,
    d = 100,
    e = 101,
    f = 102,
    g = 103,
    h = 104,
    i = 105,
    k = 107,
    l = 108,
    m = 109,
    n = 110,
    o = 111,
    p = 112,
    r = 114,
    s = 115,
    t = 116,
    u = 117,
    v = 118,
    w = 119,
    x = 120,
    y = 121,
    z = 122,

    A = 65,
    E = 69,
    F = 70,
    X = 88,
    Z = 90,

    ampersand    = 38,          // &
    asterisk     = 42,          // *
    backslash    = 92,          // \
    bar          = 124,         // |
    caret        = 94,          // ^
    closeBrace   = 125,         // }
    closeBracket = 93,          // ]
    closeParen   = 41,          // )
    colon        = 58,          // : 
    comma        = 44,          // ,
    dot          = 46,          // .
    doubleQuote  = 34,          // "
    equals       = 61,          // =
    exclamation  = 33,          // !
    greaterThan  = 62,          // >
    lessThan     = 60,          // <
    minus        = 45,          // -
    openBrace    = 123,         // {
    openBracket  = 91,          // [
    openParen    = 40,          // (
    percent      = 37,          // %
    plus         = 43,          // +
    question     = 63,          // ?
    semicolon    = 59,          // ;
    singleQuote  = 39,          // '
    slash        = 47,          // /
    tilde        = 126,         // ~

    backspace     = 8,          // \b
    formFeed      = 12,         // \f
    byteOrderMark = 0xFEFF,
    tab           = 9,          // \t
    verticalTab   = 11,         // \v
}
///<reference path='..\Text\CharacterCodes.ts' />
///<reference path='..\Core\Debug.ts' />

class CharacterInfo {
    public static isDecimalDigit(c: number): bool {
        return c >= CharacterCodes._0 && c <= CharacterCodes._9;
    }

    public static isHexDigit(c: number): bool {
        return isDecimalDigit(c) ||
               (c >= CharacterCodes.A && c <= CharacterCodes.F) ||
               (c >= CharacterCodes.a && c <= CharacterCodes.f);
    }

    public static hexValue(c: number): number {
        Debug.assert(isHexDigit(c));
        return isDecimalDigit(c)
            ? (c - CharacterCodes._0)
            : (c >= CharacterCodes.A && c <= CharacterCodes.F)
                ? c - CharacterCodes.A + 10
                : c - CharacterCodes.a + 10;
    }

    public static isWhitespace(ch: number): bool {
        switch (ch) {
            case CharacterCodes.space:
            case CharacterCodes.tab:
            case CharacterCodes.verticalTab:
            case CharacterCodes.formFeed:
            case CharacterCodes.nonBreakingSpace:
            case CharacterCodes.byteOrderMark:
                return true;
        }

        return false;
    }

    public static isLineTerminator(ch: number): bool {
        switch (ch) {
            case CharacterCodes.carriageReturn:
            case CharacterCodes.lineFeed:
            case CharacterCodes.paragraphSeparator:
            case CharacterCodes.lineSeparator:
                return true;
        }

        return false;
    }
}
enum SyntaxConstants {
    // Masks that we use to place information about trivia into a single int. The first two flags 
    // mark bools that tell us if the trivia contains a comment or a newline. The width of the 
    // trivia is then stored in the rest of the int.  This allows trivia of nearly any length.
    // However, nearly all of the time the trivia will be less than 511MB, and will fit into 31
    // bits (which will only be stored a a single 32bit int in chakra).
    TriviaNewLineMask =    0x00000001, //  0000 0000 0000 0000 0000 0000 0000 0001
    TriviaCommentMask =    0x00000002, //  0000 0100 0000 0000 0000 0000 0000 0010
    TriviaFullWidthShift = 2,          //  1111 1111 1111 1111 1111 1111 1111 1100

    // Masks that we use to place information about a node into a single int.  The first three tell
    // us if the node either contained any skipped tokens, or if it had any zero width tokens 
    // anywhere within it, or if it had a regex token in it ("/", "/=" or "/.../").  If it does, 
    // then we cannot be reused by the incremental parser.
    //
    // The next bit lets us know if the nodes was parsed in a strict context or node.  A node can
    // only be used by the incremental parser if it is parsed in the same strict context as before.
    // last masks off the part of the int
    //
    // The width of the node is stored in the remainder of the int.  This allows us up to 255 MB
    // for a node by using all 28 bits.  However, in the common case, we'll use less than 28 bits
    // for the width.  Thus, the info will be stored in a single int in chakra.
    //
    // If we need more space, we can always merge the first 3 bits into a single bit:
    // 'canBeIncrementallyReused'.  That will allow us up to 1023MB for a single node.
    NodeSkippedTextMask =            0x00000001, // 0000 0000 0000 0000 0000 0000 0000 0001
    NodeZeroWidthTokenMask =         0x00000002, // 0000 0000 0000 0000 0000 0000 0000 0010
    NodeRegularExpressionTokenMask = 0x00000004, // 0000 0000 0000 0000 0000 0000 0000 0100
    NodeParsedInStrictModeMask =     0x00000008, // 0000 0000 0000 0000 0000 0000 0000 1000
    NodeFullWidthShift=              4,          // 1111 1111 1111 1111 1111 1111 1111 0000
}
enum LanguageVersion {
    EcmaScript3,
    EcmaScript5,
}
class Contract {
    public static requires(expression: bool): void {
        if (!expression) {
            throw new Error("Contract violated. False expression.");
        }
    }

    public static throwIfFalse(expression: bool): void {
        if (!expression) {
            throw new Error("Contract violated. False expression.");
        }
    }

    public static throwIfNull(value: any): void {
        if (value === null) {
            throw new Error("Contract violated. Null value.");
        }
    }
}
class MathPrototype {
    public static max(a: number, b: number): number {
        return a >= b ? a : b;
    }

    public static min(a: number, b: number): number {
        return a <= b ? a : b;
    }
}
///<reference path='..\Core\Contract.ts' />
///<reference path='..\Core\Errors.ts' />
///<reference path='..\Core\MathPrototype.ts' />

class TextSpan {
    private _start: number;
    private _length: number;

    /// <summary>
    /// Creates a TextSpan instance beginning with the position Start and having the Length
    /// specified with length.
    /// </summary>
    constructor(start: number, length: number) {
        if (start < 0) {
            Errors.argument("start");
        }

        if (start + length < start) {
            throw new Error("length");
        }

        this._start = start;
        this._length = length;
    }

    start(): number {
        return this._start;
    }

    length(): number {
        return this._length;
    }

    end(): number {
        return this._start + this._length;
    }

    isEmpty(): bool {
        return this._length === 0;
    }

    /// <summary>
    /// Determines whether the position lies within the span.
    /// </summary>
    /// <param name="position">
    /// The position to check.
    /// </param>
    /// <returns>
    /// <c>true</c> if the position is greater than or equal to Start and strictly less 
    /// than End, otherwise <c>false</c>.
    /// </returns>
    public containsPosition(position: number): bool {
        return position >= this._start && position < this.end();
    }

    /// <summary>
    /// Determines whether <paramref name="span"/> falls completely within this span.
    /// </summary>
    /// <param name="span">
    /// The span to check.
    /// </param>
    /// <returns>
    /// <c>true</c> if the specified span falls completely within this span, otherwise <c>false</c>.
    /// </returns>
    public containsTextSpan(span: TextSpan): bool {
        return span._start >= this._start && span.end() <= this.end();
    }

    /// <summary>
    /// Determines whether <paramref name="span"/> overlaps this span. Two spans are considered to overlap 
    /// if they have positions in common and neither is empty. Empty spans do not overlap with any 
    /// other span.
    /// </summary>
    /// <param name="span">
    /// The span to check.
    /// </param>
    /// <returns>
    /// <c>true</c> if the spans overlap, otherwise <c>false</c>.
    /// </returns>
    public overlapsWith(span: TextSpan): bool {
        var overlapStart = MathPrototype.max(this._start, span._start);
        var overlapEnd = MathPrototype.min(this.end(), span.end());

        return overlapStart < overlapEnd;
    }

    /// <summary>
    /// Returns the overlap with the given span, or null if there is no overlap.
    /// </summary>
    /// <param name="span">
    /// The span to check.
    /// </param>
    /// <returns>
    /// The overlap of the spans, or null if the overlap is empty.
    /// </returns>
    public overlap(span: TextSpan): TextSpan {
        var overlapStart = MathPrototype.max(this._start, span._start);
        var overlapEnd = MathPrototype.min(this.end(), span.end());

        if (overlapStart < overlapEnd)
        {
            return TextSpan.fromBounds(overlapStart, overlapEnd);
        }

        return null;
    }

    /// <summary>
    /// Determines whether <paramref name="span"/> intersects this span. Two spans are considered to 
    /// intersect if they have positions in common or the end of one span 
    /// coincides with the start of the other span.
    /// </summary>
    /// <param name="span">
    /// The span to check.
    /// </param>
    /// <returns>
    /// <c>true</c> if the spans intersect, otherwise <c>false</c>.
    /// </returns>
    public intersectsWithTextSpan(span: TextSpan): bool {
        return span._start <= this.end() && span.end() >= this._start;
    }

    public intersectsWith(start: number, length: number): bool {
        var end = start + length;
        return start <= this.end() && end >= this._start;
    }

    /// <summary>
    /// Determines whether <paramref name="position"/> intersects this span. 
    /// A position is considered to intersect if it is between the start and
    /// end positions (inclusive) of this span.
    /// </summary>
    /// <param name="position">
    /// The position to check.
    /// </param>
    /// <returns>
    /// <c>true</c> if the position intersects, otherwise <c>false</c>.
    /// </returns>
    public intersectsWithPosition(position: number): bool {
        return position <= this.end() && position >= this._start;
    }

    /// <summary>
    /// Returns the intersection with the given span, or null if there is no intersection.
    /// </summary>
    /// <param name="span">
    /// The span to check.
    /// </param>
    /// <returns>
    /// The intersection of the spans, or null if the intersection is empty.
    /// </returns>
    public intersection(span: TextSpan): TextSpan {
        var intersectStart = MathPrototype.max(this._start, span._start);
        var intersectEnd = MathPrototype.min(this.end(), span.end());

        if (intersectStart <= intersectEnd) {
            return TextSpan.fromBounds(intersectStart, intersectEnd);
        }

        return null;
    }

    /// <summary>
    /// Creates a new <see cref="T:TextSpan"/> from <param name="start" /> and <param
    /// name="end"/> positions as opposed to a position and length.
    /// </summary>
    public static fromBounds(start: number, end: number): TextSpan {
        Contract.requires(start >= 0);
        Contract.requires(end - start >= 0);
        return new TextSpan(start, end - start);
    }
}
///<reference path='TextSpan.ts' />

/// <summary>
/// Immutable representation of a line in an IText instance.
/// </summary>
interface ITextLine {
    /// <summary>
    /// Start of the line.
    /// </summary>
    start(): number;

    /// <summary>
    /// End of the line not including the line break.
    /// </summary>
    end(): number;

    /// <summary>
    /// End of the line including the line break.
    /// </summary>
    endIncludingLineBreak(): number;

    /// <summary>
    /// Extent of the line not including the line break.
    /// </summary>
    extent(): TextSpan;

    /// <summary>
    /// Extent of the line including the line break.
    /// </summary>
    extentIncludingLineBreak(): TextSpan;

    /// <summary>
    /// Gets the text of the line excluding the line break.
    /// </summary>
    toString(): string;

    /// <summary>
    /// Gets the line number for this line.
    /// </summary>
    lineNumber(): number;
}
///<reference path='..\Core\Errors.ts' />

class LinePosition {
    private _line: number = 0;
    private _character: number = 0;

    /// <summary>
    /// Initializes a new instance of a <see cref="LinePosition"/> with the given line and character.
    /// </summary>
    /// <param name="line">
    /// The line of the line position. The first line in a file is defined as line 0 (zero based line numbering).
    /// </param>
    /// <param name="character">
    /// The character position in the line.
    /// </param>
    /// <exception cref="ArgumentOutOfRangeException"><paramref name="line"/> or <paramref name="character"/> is less than zero. </exception>
    constructor(line: number, character: number) {
        if (line < 0) {
            throw Errors.argumentOutOfRange("line");
        }

        if (character < 0) {
            throw Errors.argumentOutOfRange("character");
        }

        this._line = line;
        this._character = character;
    }

    public line(): number {
        return this._line;
    }

    public character(): number {
        return this._character;
    }
}
///<reference path='ITextLine.ts' />
///<reference path='LinePosition.ts' />

/// <summary>
/// Represents an immutable snapshot of text.
/// </summary>
interface ISimpleText {
    /// <summary>
    /// Total number of characters in the text source.
    /// </summary>
    length(): number;

    /// <summary>
    /// Copy the count contents of IText starting from sourceIndex to destination starting at
    /// destinationIndex.
    /// </summary>
    copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void;

    substr(start: number, length: number, intern: bool): string;

    /// <summary>
    /// Gets the a new IText that corresponds to the contents of this IText for the given span.
    /// </summary>
    subText(span: TextSpan): ISimpleText;
}

/// <summary>
/// Represents an immutable snapshot of text.
/// </summary>
interface IText extends ISimpleText {
    /// <summary>
    /// Total number of lines in the text.
    /// </summary>
    lineCount(): number;

    /// <summary>
    /// Returns the collection of line information for the <see cref="T:IText"/> instance.
    /// </summary>
    lines(): ITextLine[];

    /// <summary>
    /// Return the char at position in the IText.
    /// </summary>
    charCodeAt(position: number): number;

    /// <summary>
    /// Gets the line corresponding to the provided line number.
    /// </summary>
    getLineFromLineNumber(lineNumber: number): ITextLine;

    /// <summary>
    /// Gets the line which encompasses the provided position.
    /// </summary>
    getLineFromPosition(position: number): ITextLine;

    /// <summary>
    /// Gets the number of the line that contains the character at the specified position.
    /// </summary>
    getLineNumberFromPosition(position: number): number;

    /// <summary>
    /// Gets a line number, and position within that line, for the character at the 
    /// specified position
    /// </summary>
    getLinePosition(position: number): LinePosition;

    /// <summary>
    /// Returns a string representation of the contents of this IText within the given span.
    /// </summary>
    toString(span?: TextSpan): string;

    /// <summary>
    /// Gets the a new IText that corresponds to the contents of this IText for the given span.
    /// </summary>
    subText(span: TextSpan): IText;
}
﻿///<reference path='..\Text\CharacterCodes.ts' />
///<reference path='SyntaxKind.ts' />

class ScannerUtilities {
    public static identifierKind(array: number[], startIndex: number, length: number): SyntaxKind {
        switch (length) {
        case 2:
            // do, if, in
            switch(array[startIndex]) {
            case CharacterCodes.d:
                // do
                return (array[startIndex + 1] === CharacterCodes.o) ? SyntaxKind.DoKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.i:
                // if, in
                switch(array[startIndex + 1]) {
                case CharacterCodes.f:
                    // if
                    return SyntaxKind.IfKeyword;
                case CharacterCodes.n:
                    // in
                    return SyntaxKind.InKeyword;
                default:
                    return SyntaxKind.IdentifierName;
                }

            default:
                return SyntaxKind.IdentifierName;
            }

        case 3:
            // for, new, try, var, let, any, get, set
            switch(array[startIndex]) {
            case CharacterCodes.f:
                // for
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.r) ? SyntaxKind.ForKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.n:
                // new
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.w) ? SyntaxKind.NewKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.t:
                // try
                return (array[startIndex + 1] === CharacterCodes.r && array[startIndex + 2] === CharacterCodes.y) ? SyntaxKind.TryKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.v:
                // var
                return (array[startIndex + 1] === CharacterCodes.a && array[startIndex + 2] === CharacterCodes.r) ? SyntaxKind.VarKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.l:
                // let
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.t) ? SyntaxKind.LetKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.a:
                // any
                return (array[startIndex + 1] === CharacterCodes.n && array[startIndex + 2] === CharacterCodes.y) ? SyntaxKind.AnyKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.g:
                // get
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.t) ? SyntaxKind.GetKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.s:
                // set
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.t) ? SyntaxKind.SetKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

        case 4:
            // case, else, null, this, true, void, with, enum, bool
            switch(array[startIndex]) {
            case CharacterCodes.c:
                // case
                return (array[startIndex + 1] === CharacterCodes.a && array[startIndex + 2] === CharacterCodes.s && array[startIndex + 3] === CharacterCodes.e) ? SyntaxKind.CaseKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.e:
                // else, enum
                switch(array[startIndex + 1]) {
                case CharacterCodes.l:
                    // else
                    return (array[startIndex + 2] === CharacterCodes.s && array[startIndex + 3] === CharacterCodes.e) ? SyntaxKind.ElseKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.n:
                    // enum
                    return (array[startIndex + 2] === CharacterCodes.u && array[startIndex + 3] === CharacterCodes.m) ? SyntaxKind.EnumKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.n:
                // null
                return (array[startIndex + 1] === CharacterCodes.u && array[startIndex + 2] === CharacterCodes.l && array[startIndex + 3] === CharacterCodes.l) ? SyntaxKind.NullKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.t:
                // this, true
                switch(array[startIndex + 1]) {
                case CharacterCodes.h:
                    // this
                    return (array[startIndex + 2] === CharacterCodes.i && array[startIndex + 3] === CharacterCodes.s) ? SyntaxKind.ThisKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.r:
                    // true
                    return (array[startIndex + 2] === CharacterCodes.u && array[startIndex + 3] === CharacterCodes.e) ? SyntaxKind.TrueKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.v:
                // void
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.i && array[startIndex + 3] === CharacterCodes.d) ? SyntaxKind.VoidKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.w:
                // with
                return (array[startIndex + 1] === CharacterCodes.i && array[startIndex + 2] === CharacterCodes.t && array[startIndex + 3] === CharacterCodes.h) ? SyntaxKind.WithKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.b:
                // bool
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.o && array[startIndex + 3] === CharacterCodes.l) ? SyntaxKind.BoolKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

        case 5:
            // break, catch, false, throw, while, class, const, super, yield
            switch(array[startIndex]) {
            case CharacterCodes.b:
                // break
                return (array[startIndex + 1] === CharacterCodes.r && array[startIndex + 2] === CharacterCodes.e && array[startIndex + 3] === CharacterCodes.a && array[startIndex + 4] === CharacterCodes.k) ? SyntaxKind.BreakKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.c:
                // catch, class, const
                switch(array[startIndex + 1]) {
                case CharacterCodes.a:
                    // catch
                    return (array[startIndex + 2] === CharacterCodes.t && array[startIndex + 3] === CharacterCodes.c && array[startIndex + 4] === CharacterCodes.h) ? SyntaxKind.CatchKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.l:
                    // class
                    return (array[startIndex + 2] === CharacterCodes.a && array[startIndex + 3] === CharacterCodes.s && array[startIndex + 4] === CharacterCodes.s) ? SyntaxKind.ClassKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.o:
                    // const
                    return (array[startIndex + 2] === CharacterCodes.n && array[startIndex + 3] === CharacterCodes.s && array[startIndex + 4] === CharacterCodes.t) ? SyntaxKind.ConstKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.f:
                // false
                return (array[startIndex + 1] === CharacterCodes.a && array[startIndex + 2] === CharacterCodes.l && array[startIndex + 3] === CharacterCodes.s && array[startIndex + 4] === CharacterCodes.e) ? SyntaxKind.FalseKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.t:
                // throw
                return (array[startIndex + 1] === CharacterCodes.h && array[startIndex + 2] === CharacterCodes.r && array[startIndex + 3] === CharacterCodes.o && array[startIndex + 4] === CharacterCodes.w) ? SyntaxKind.ThrowKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.w:
                // while
                return (array[startIndex + 1] === CharacterCodes.h && array[startIndex + 2] === CharacterCodes.i && array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.e) ? SyntaxKind.WhileKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.s:
                // super
                return (array[startIndex + 1] === CharacterCodes.u && array[startIndex + 2] === CharacterCodes.p && array[startIndex + 3] === CharacterCodes.e && array[startIndex + 4] === CharacterCodes.r) ? SyntaxKind.SuperKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.y:
                // yield
                return (array[startIndex + 1] === CharacterCodes.i && array[startIndex + 2] === CharacterCodes.e && array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.d) ? SyntaxKind.YieldKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

        case 6:
            // delete, return, switch, typeof, export, import, public, static, module, number, string
            switch(array[startIndex]) {
            case CharacterCodes.d:
                // delete
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.l && array[startIndex + 3] === CharacterCodes.e && array[startIndex + 4] === CharacterCodes.t && array[startIndex + 5] === CharacterCodes.e) ? SyntaxKind.DeleteKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.r:
                // return
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.t && array[startIndex + 3] === CharacterCodes.u && array[startIndex + 4] === CharacterCodes.r && array[startIndex + 5] === CharacterCodes.n) ? SyntaxKind.ReturnKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.s:
                // switch, static, string
                switch(array[startIndex + 1]) {
                case CharacterCodes.w:
                    // switch
                    return (array[startIndex + 2] === CharacterCodes.i && array[startIndex + 3] === CharacterCodes.t && array[startIndex + 4] === CharacterCodes.c && array[startIndex + 5] === CharacterCodes.h) ? SyntaxKind.SwitchKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.t:
                    // static, string
                    switch(array[startIndex + 2]) {
                    case CharacterCodes.a:
                        // static
                        return (array[startIndex + 3] === CharacterCodes.t && array[startIndex + 4] === CharacterCodes.i && array[startIndex + 5] === CharacterCodes.c) ? SyntaxKind.StaticKeyword : SyntaxKind.IdentifierName;
                    case CharacterCodes.r:
                        // string
                        return (array[startIndex + 3] === CharacterCodes.i && array[startIndex + 4] === CharacterCodes.n && array[startIndex + 5] === CharacterCodes.g) ? SyntaxKind.StringKeyword : SyntaxKind.IdentifierName;
                    default:
                        return SyntaxKind.IdentifierName;
                    }

                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.t:
                // typeof
                return (array[startIndex + 1] === CharacterCodes.y && array[startIndex + 2] === CharacterCodes.p && array[startIndex + 3] === CharacterCodes.e && array[startIndex + 4] === CharacterCodes.o && array[startIndex + 5] === CharacterCodes.f) ? SyntaxKind.TypeOfKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.e:
                // export
                return (array[startIndex + 1] === CharacterCodes.x && array[startIndex + 2] === CharacterCodes.p && array[startIndex + 3] === CharacterCodes.o && array[startIndex + 4] === CharacterCodes.r && array[startIndex + 5] === CharacterCodes.t) ? SyntaxKind.ExportKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.i:
                // import
                return (array[startIndex + 1] === CharacterCodes.m && array[startIndex + 2] === CharacterCodes.p && array[startIndex + 3] === CharacterCodes.o && array[startIndex + 4] === CharacterCodes.r && array[startIndex + 5] === CharacterCodes.t) ? SyntaxKind.ImportKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.p:
                // public
                return (array[startIndex + 1] === CharacterCodes.u && array[startIndex + 2] === CharacterCodes.b && array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.i && array[startIndex + 5] === CharacterCodes.c) ? SyntaxKind.PublicKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.m:
                // module
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.d && array[startIndex + 3] === CharacterCodes.u && array[startIndex + 4] === CharacterCodes.l && array[startIndex + 5] === CharacterCodes.e) ? SyntaxKind.ModuleKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.n:
                // number
                return (array[startIndex + 1] === CharacterCodes.u && array[startIndex + 2] === CharacterCodes.m && array[startIndex + 3] === CharacterCodes.b && array[startIndex + 4] === CharacterCodes.e && array[startIndex + 5] === CharacterCodes.r) ? SyntaxKind.NumberKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

        case 7:
            // default, finally, extends, package, private, boolean, declare
            switch(array[startIndex]) {
            case CharacterCodes.d:
                // default, declare
                switch(array[startIndex + 1]) {
                case CharacterCodes.e:
                    // default, declare
                    switch(array[startIndex + 2]) {
                    case CharacterCodes.f:
                        // default
                        return (array[startIndex + 3] === CharacterCodes.a && array[startIndex + 4] === CharacterCodes.u && array[startIndex + 5] === CharacterCodes.l && array[startIndex + 6] === CharacterCodes.t) ? SyntaxKind.DefaultKeyword : SyntaxKind.IdentifierName;
                    case CharacterCodes.c:
                        // declare
                        return (array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.a && array[startIndex + 5] === CharacterCodes.r && array[startIndex + 6] === CharacterCodes.e) ? SyntaxKind.DeclareKeyword : SyntaxKind.IdentifierName;
                    default:
                        return SyntaxKind.IdentifierName;
                    }

                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.f:
                // finally
                return (array[startIndex + 1] === CharacterCodes.i && array[startIndex + 2] === CharacterCodes.n && array[startIndex + 3] === CharacterCodes.a && array[startIndex + 4] === CharacterCodes.l && array[startIndex + 5] === CharacterCodes.l && array[startIndex + 6] === CharacterCodes.y) ? SyntaxKind.FinallyKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.e:
                // extends
                return (array[startIndex + 1] === CharacterCodes.x && array[startIndex + 2] === CharacterCodes.t && array[startIndex + 3] === CharacterCodes.e && array[startIndex + 4] === CharacterCodes.n && array[startIndex + 5] === CharacterCodes.d && array[startIndex + 6] === CharacterCodes.s) ? SyntaxKind.ExtendsKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.p:
                // package, private
                switch(array[startIndex + 1]) {
                case CharacterCodes.a:
                    // package
                    return (array[startIndex + 2] === CharacterCodes.c && array[startIndex + 3] === CharacterCodes.k && array[startIndex + 4] === CharacterCodes.a && array[startIndex + 5] === CharacterCodes.g && array[startIndex + 6] === CharacterCodes.e) ? SyntaxKind.PackageKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.r:
                    // private
                    return (array[startIndex + 2] === CharacterCodes.i && array[startIndex + 3] === CharacterCodes.v && array[startIndex + 4] === CharacterCodes.a && array[startIndex + 5] === CharacterCodes.t && array[startIndex + 6] === CharacterCodes.e) ? SyntaxKind.PrivateKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.b:
                // boolean
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.o && array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.e && array[startIndex + 5] === CharacterCodes.a && array[startIndex + 6] === CharacterCodes.n) ? SyntaxKind.BooleanKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

        case 8:
            // continue, debugger, function
            switch(array[startIndex]) {
            case CharacterCodes.c:
                // continue
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.n && array[startIndex + 3] === CharacterCodes.t && array[startIndex + 4] === CharacterCodes.i && array[startIndex + 5] === CharacterCodes.n && array[startIndex + 6] === CharacterCodes.u && array[startIndex + 7] === CharacterCodes.e) ? SyntaxKind.ContinueKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.d:
                // debugger
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.b && array[startIndex + 3] === CharacterCodes.u && array[startIndex + 4] === CharacterCodes.g && array[startIndex + 5] === CharacterCodes.g && array[startIndex + 6] === CharacterCodes.e && array[startIndex + 7] === CharacterCodes.r) ? SyntaxKind.DebuggerKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.f:
                // function
                return (array[startIndex + 1] === CharacterCodes.u && array[startIndex + 2] === CharacterCodes.n && array[startIndex + 3] === CharacterCodes.c && array[startIndex + 4] === CharacterCodes.t && array[startIndex + 5] === CharacterCodes.i && array[startIndex + 6] === CharacterCodes.o && array[startIndex + 7] === CharacterCodes.n) ? SyntaxKind.FunctionKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

        case 9:
            // interface, protected
            switch(array[startIndex]) {
            case CharacterCodes.i:
                // interface
                return (array[startIndex + 1] === CharacterCodes.n && array[startIndex + 2] === CharacterCodes.t && array[startIndex + 3] === CharacterCodes.e && array[startIndex + 4] === CharacterCodes.r && array[startIndex + 5] === CharacterCodes.f && array[startIndex + 6] === CharacterCodes.a && array[startIndex + 7] === CharacterCodes.c && array[startIndex + 8] === CharacterCodes.e) ? SyntaxKind.InterfaceKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.p:
                // protected
                return (array[startIndex + 1] === CharacterCodes.r && array[startIndex + 2] === CharacterCodes.o && array[startIndex + 3] === CharacterCodes.t && array[startIndex + 4] === CharacterCodes.e && array[startIndex + 5] === CharacterCodes.c && array[startIndex + 6] === CharacterCodes.t && array[startIndex + 7] === CharacterCodes.e && array[startIndex + 8] === CharacterCodes.d) ? SyntaxKind.ProtectedKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

        case 10:
            // instanceof, implements
            switch(array[startIndex]) {
            case CharacterCodes.i:
                // instanceof, implements
                switch(array[startIndex + 1]) {
                case CharacterCodes.n:
                    // instanceof
                    return (array[startIndex + 2] === CharacterCodes.s && array[startIndex + 3] === CharacterCodes.t && array[startIndex + 4] === CharacterCodes.a && array[startIndex + 5] === CharacterCodes.n && array[startIndex + 6] === CharacterCodes.c && array[startIndex + 7] === CharacterCodes.e && array[startIndex + 8] === CharacterCodes.o && array[startIndex + 9] === CharacterCodes.f) ? SyntaxKind.InstanceOfKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.m:
                    // implements
                    return (array[startIndex + 2] === CharacterCodes.p && array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.e && array[startIndex + 5] === CharacterCodes.m && array[startIndex + 6] === CharacterCodes.e && array[startIndex + 7] === CharacterCodes.n && array[startIndex + 8] === CharacterCodes.t && array[startIndex + 9] === CharacterCodes.s) ? SyntaxKind.ImplementsKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            default:
                return SyntaxKind.IdentifierName;
            }

        case 11:
            // constructor
            return (array[startIndex] === CharacterCodes.c && array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.n && array[startIndex + 3] === CharacterCodes.s && array[startIndex + 4] === CharacterCodes.t && array[startIndex + 5] === CharacterCodes.r && array[startIndex + 6] === CharacterCodes.u && array[startIndex + 7] === CharacterCodes.c && array[startIndex + 8] === CharacterCodes.t && array[startIndex + 9] === CharacterCodes.o && array[startIndex + 10] === CharacterCodes.r) ? SyntaxKind.ConstructorKeyword : SyntaxKind.IdentifierName;
        default:
            return SyntaxKind.IdentifierName;
        }
    }
}
class StringUtilities {
    public static fromCharCodeArray(array: number[]): string {
        return String.fromCharCode.apply(null, array);
    }

    public static endsWith(string: string, value: string): bool {
        return string.substring(string.length - value.length, string.length) === value;
    }

    public static startsWith(string: string, value: string): bool {
        return string.substr(0, value.length) === value;
    }

    public static copyTo(source: string, sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
        for (var i = 0; i < count; i++) {
            destination[destinationIndex + i] = source.charCodeAt(sourceIndex + i);
        }
    }

    public static repeat(value: string, count: number) {
        return Array(count + 1).join(value);
    }
}
///<reference path='ArrayUtilities.ts' />
///<reference path='Hash.ts' />
///<reference path='StringUtilities.ts' />

module Collections {
    export var DefaultStringTableCapacity = 256;

    class StringTableEntry {
        constructor(public Text: string,
                    public HashCode: number,
                    public Next: StringTableEntry) {
        }
    }

    // A table of interned strings.  Faster and better than an arbitrary hashtable for the needs of the
    // scanner. Specifically, the scanner operates over a sliding window of characters, with a start 
    // and end pointer for the current lexeme.  The scanner then wants to get the *interned* string
    // represented by that subsection.
    //
    // Importantly, if the string is already interned, then it wants ask "is the string represented by 
    // this section of a char array contained within the table" in a non-allocating fashion.  i.e. if 
    // you have "[' ', 'p', 'u', 'b', 'l', 'i', 'c', ' ']" and you ask to get the string represented by
    //  range [1, 7), then this table will return "public" without any allocations if that value was 
    // already in the table.
    //
    // Of course, if the value is not in the table then there will be an initial cost to allocate the 
    // string and the bucket for the table.  However, that is only incurred the first time each unique 
    // string is added.
    export class StringTable {
        private entries: StringTableEntry[] = [];
        private count: number = 0;

        constructor(capacity) {
            var size = Hash.getPrime(capacity);
            this.entries = ArrayUtilities.createArray(size);
        }

        public addCharArray(key: number[], start: number, len: number): string {
            // Compute the hash for this key.  Also ensure that it fits within 31 bits  (so that it 
            // stays a non-heap integer, and so we can index into the array safely).
            var hashCode = Hash.computeSimple31BitCharArrayHashCode(key, start, len) & 0x7FFFFFFF;
            Debug.assert(hashCode > 0);

            // First see if we already have the string represented by "key[start, start + len)" already
            // present in this table.  If we do, just return that string.  Do this without any 
            // allocations
            var entry = this.findCharArrayEntry(key, start, len, hashCode);
            if (entry !== null) {
                return entry.Text;
            }

            // We don't have an entry for that string in our table.  Convert that 
            var slice: number[] = key.slice(start, start + len);
            return this.addEntry(StringUtilities.fromCharCodeArray(slice), hashCode);
        }

        private findCharArrayEntry(key: number[], start: number, len: number, hashCode: number) {
            for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                if (e.HashCode === hashCode && StringTable.textCharArrayEquals(e.Text, key, start, len)) {
                    return e;
                }
            }

            return null;
        }

        private addEntry(text: string, hashCode: number): string {
            var index = hashCode % this.entries.length;

            var e = new StringTableEntry(text, hashCode, this.entries[index]);

            this.entries[index] = e;

            // We grow when our load factor equals 1.  I tried different load factors (like .75 and 
            // .5), however they seemed to have no effect on running time.  With a load factor of 1
            // we seem to get about 80% slot fill rate with an average of around 1.25 table entries 
            // per slot.
            if (this.count === this.entries.length) {
                this.grow();
            }

            this.count++;
            return e.Text;
        }

        //private dumpStats() {
        //    var standardOut = Environment.standardOut;

        //    standardOut.WriteLine("----------------------")
        //    standardOut.WriteLine("String table stats");
        //    standardOut.WriteLine("Count            : " + this.count);
        //    standardOut.WriteLine("Entries Length   : " + this.entries.length);

        //    var longestSlot = 0;
        //    var occupiedSlots = 0;
        //    for (var i = 0; i < this.entries.length; i++) {
        //        if (this.entries[i] !== null) {
        //            occupiedSlots++;

        //            var current = this.entries[i];
        //            var slotCount = 0;
        //            while (current !== null) {
        //                slotCount++;
        //                current = current.Next;
        //            }

        //            longestSlot = MathPrototype.max(longestSlot, slotCount);
        //        }
        //    }

        //    standardOut.WriteLine("Occupied slots   : " + occupiedSlots);
        //    standardOut.WriteLine("Longest  slot    : " + longestSlot);
        //    standardOut.WriteLine("Avg Length/Slot  : " + (this.count / occupiedSlots));
        //    standardOut.WriteLine("----------------------");
        //}

        private grow(): void {
            // this.dumpStats();

            var newSize = Hash.expandPrime(this.entries.length);

            var oldEntries = this.entries;
            var newEntries: StringTableEntry[] = ArrayUtilities.createArray(newSize);

            this.entries = newEntries;

            for (var i = 0; i < oldEntries.length; i++) {
                var e = oldEntries[i];
                while (e !== null) {
                    var newIndex = e.HashCode % newSize;
                    var tmp = e.Next;
                    e.Next = newEntries[newIndex];
                    newEntries[newIndex] = e;
                    e = tmp;
                }
            }

            // this.dumpStats();
        }

        private static textCharArrayEquals(text: string, array: number[], start: number, length: number): bool {
            if (text.length !== length) {
                return false;
            }

            var s = start;
            for (var i = 0; i < length; i++) {
                if (text.charCodeAt(i) !== array[s]) {
                    return false;
                }

                s++;
            }

            return true;
        }
    }

    export function createStringTable(capacity = DefaultStringTableCapacity): StringTable {
        return new StringTable(capacity);
    }
}
enum DiagnosticCode {
    Unrecognized_escape_sequence,
    Unexpected_character_0,
    Missing_closing_quote_character,
    Identifier_expected,
    _0_keyword_expected,
    _0_expected,
    Identifier_expected__0_is_a_keyword,
    Automatic_semicolon_insertion_not_allowed,
    Unexpected_token__0_expected,
    Trailing_separator_not_allowed,
    _StarSlash__expected,
}

class DiagnosticMessages {
    private static codeToFormatString: string[] = [];
    private static initializeStaticData(): void {
        if (codeToFormatString.length === 0) {
            codeToFormatString[DiagnosticCode.Unrecognized_escape_sequence]              = "Unrecognized escape sequence.";
            codeToFormatString[DiagnosticCode.Unexpected_character_0]                    = "Unexpected character {0}.";
            codeToFormatString[DiagnosticCode.Missing_closing_quote_character]           = "Missing close quote character.";
            codeToFormatString[DiagnosticCode.Identifier_expected]                       = "Identifier expected.";
            codeToFormatString[DiagnosticCode._0_keyword_expected]                       = "'{0}' keyword expected.";
            codeToFormatString[DiagnosticCode._0_expected]                               = "'{0}' expected.";
            codeToFormatString[DiagnosticCode.Identifier_expected__0_is_a_keyword]       = "Identifier expected; '{0}' is a keyword.";
            codeToFormatString[DiagnosticCode.Automatic_semicolon_insertion_not_allowed] = "Automatic semicolon insertion not allowed.";
            codeToFormatString[DiagnosticCode.Unexpected_token__0_expected]              = "Unexpected token; '{0}' expected.";
            codeToFormatString[DiagnosticCode.Trailing_separator_not_allowed]            = "Trailing separator not allowed.";
            codeToFormatString[DiagnosticCode._StarSlash__expected]                      = "'*/' expected.";
        }
    }

    private static getFormatString(code: DiagnosticCode): string {
        initializeStaticData();
        return codeToFormatString[code];
    }

    public static getDiagnosticMessage(code: DiagnosticCode, args: any[]): string {
        var formatString = getFormatString(code);

        var result = formatString.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined'
                ? args[num]
                : match;
        });

        return result;
    }
}
///<reference path='..\Core\ArrayUtilities.ts' />
///<reference path='DiagnosticCode.ts' />

class Diagnostic {
    private _diagnosticCode: DiagnosticCode;
    private _arguments: any[];

    constructor(diagnosticCode: DiagnosticCode, arguments: any[]) {
        this._diagnosticCode = diagnosticCode;
        this._arguments = (arguments && arguments.length > 0) ? arguments : null;
    }

    /// <summary>
    /// The error code, as an integer.
    /// </summary>
    public diagnosticCode(): DiagnosticCode {
        return this._diagnosticCode;
    }

    /// <summary>
    /// If a derived class has additional information about other referenced symbols, it can
    /// expose the locations of those symbols in a general way, so they can be reported along
    /// with the error.
    /// </summary>
    public additionalLocations(): Location[] {
        return [];
    }

    /// <summary>
    /// Get the text of the message in the given language.
    /// </summary>
    public message(): string {
        return DiagnosticMessages.getDiagnosticMessage(this._diagnosticCode, this._arguments);
    }

    public static equals(diagnostic1: Diagnostic, diagnostic2: Diagnostic): bool {
        return diagnostic1._diagnosticCode === diagnostic2._diagnosticCode &&
               ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, (v1, v2) => v1 === v2);
    }
}
///<reference path='Diagnostic.ts' />
///<reference path='..\Core\Errors.ts' />

class SyntaxDiagnostic extends Diagnostic {
    private _position: number;
    private _width: number;

    constructor(position: number, width: number, code: DiagnosticCode, args: any[]) {
        super(code, args);

        if (width < 0) {
            throw Errors.argumentOutOfRange("width");
        }

        this._position = position;
        this._width = width;
    }

    public toJSON(key) {
        var result: any = {};
        result._position = this._position;
        result._width = this._width;
        result._diagnosticCode = (<any>DiagnosticCode)._map[this.diagnosticCode()];

        var arguments = (<any>this)._arguments;
        if (arguments && arguments.length > 0) {
            result._arguments = arguments;
        }

        return result;
    }

    public position(): number {
        return this._position;
    }

    public width(): number {
        return this._width;
    }

    public static equals(diagnostic1: SyntaxDiagnostic, diagnostic2: SyntaxDiagnostic): bool {
        return diagnostic1._position === diagnostic2._position &&
               diagnostic1._width === diagnostic2._width &&
               Diagnostic.equals(diagnostic1, diagnostic2);
    }
}
﻿///<reference path='ISyntaxToken.ts' />
///<reference path='..\Text\IText.ts' />
///<reference path='SyntaxToken.ts' />

module Syntax {
    export class VariableWidthTokenWithNoTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _textOrWidth: any;
        private _value: any = null;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, textOrWidth: any) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._textOrWidth = textOrWidth;
        }

        public clone(): ISyntaxToken {
            return new VariableWidthTokenWithNoTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._textOrWidth);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return this.width(); }
        private start(): number { return this._fullStart; }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; }

        public text(): string {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(
                    this.start(), this._textOrWidth, /*intern:*/ this.tokenKind === SyntaxKind.IdentifierName);
            }

            return this._textOrWidth;
        }

        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return this._value || (this._value = value(this)); }
        public hasLeadingTrivia(): bool { return false; }
        public hasLeadingComment(): bool { return false; }
        public hasLeadingNewLine(): bool { return false; }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return 0; }
        public leadingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasTrailingTrivia(): bool { return false; }
        public hasTrailingComment(): bool { return false; }
        public hasTrailingNewLine(): bool { return false; }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return 0; }
        public trailingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realize(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class VariableWidthTokenWithLeadingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _leadingTriviaInfo: number;
        private _textOrWidth: any;
        private _value: any = null;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, leadingTriviaInfo: number, textOrWidth: any) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
            this._textOrWidth = textOrWidth;
        }

        public clone(): ISyntaxToken {
            return new VariableWidthTokenWithLeadingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._leadingTriviaInfo,
                this._textOrWidth);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return getTriviaWidth(this._leadingTriviaInfo) + this.width(); }
        private start(): number { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; }

        public text(): string {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(
                    this.start(), this._textOrWidth, /*intern:*/ this.tokenKind === SyntaxKind.IdentifierName);
            }

            return this._textOrWidth;
        }

        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return this._value || (this._value = value(this)); }
        public hasLeadingTrivia(): bool { return true; }
        public hasLeadingComment(): bool { return hasTriviaComment(this._leadingTriviaInfo); }
        public hasLeadingNewLine(): bool { return hasTriviaNewLine(this._leadingTriviaInfo); }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return getTriviaWidth(this._leadingTriviaInfo); }
        public leadingTrivia(): ISyntaxTriviaList { return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), /*isTrailing:*/ false); }

        public hasTrailingTrivia(): bool { return false; }
        public hasTrailingComment(): bool { return false; }
        public hasTrailingNewLine(): bool { return false; }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return 0; }
        public trailingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realize(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class VariableWidthTokenWithTrailingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _textOrWidth: any;
        private _value: any = null;
        private _trailingTriviaInfo: number;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, textOrWidth: any, trailingTriviaInfo: number) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._textOrWidth = textOrWidth;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }

        public clone(): ISyntaxToken {
            return new VariableWidthTokenWithTrailingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._textOrWidth,
                this._trailingTriviaInfo);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return this.width() + getTriviaWidth(this._trailingTriviaInfo); }
        private start(): number { return this._fullStart; }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; }

        public text(): string {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(
                    this.start(), this._textOrWidth, /*intern:*/ this.tokenKind === SyntaxKind.IdentifierName);
            }

            return this._textOrWidth;
        }

        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return this._value || (this._value = value(this)); }
        public hasLeadingTrivia(): bool { return false; }
        public hasLeadingComment(): bool { return false; }
        public hasLeadingNewLine(): bool { return false; }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return 0; }
        public leadingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasTrailingTrivia(): bool { return true; }
        public hasTrailingComment(): bool { return hasTriviaComment(this._trailingTriviaInfo); }
        public hasTrailingNewLine(): bool { return hasTriviaNewLine(this._trailingTriviaInfo); }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return getTriviaWidth(this._trailingTriviaInfo); }
        public trailingTrivia(): ISyntaxTriviaList { return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), /*isTrailing:*/ true); }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realize(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class VariableWidthTokenWithLeadingAndTrailingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _leadingTriviaInfo: number;
        private _textOrWidth: any;
        private _value: any = null;
        private _trailingTriviaInfo: number;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, leadingTriviaInfo: number, textOrWidth: any, trailingTriviaInfo: number) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
            this._textOrWidth = textOrWidth;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }

        public clone(): ISyntaxToken {
            return new VariableWidthTokenWithLeadingAndTrailingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._leadingTriviaInfo,
                this._textOrWidth,
                this._trailingTriviaInfo);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo); }
        private start(): number { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; }

        public text(): string {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(
                    this.start(), this._textOrWidth, /*intern:*/ this.tokenKind === SyntaxKind.IdentifierName);
            }

            return this._textOrWidth;
        }

        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return this._value || (this._value = value(this)); }
        public hasLeadingTrivia(): bool { return true; }
        public hasLeadingComment(): bool { return hasTriviaComment(this._leadingTriviaInfo); }
        public hasLeadingNewLine(): bool { return hasTriviaNewLine(this._leadingTriviaInfo); }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return getTriviaWidth(this._leadingTriviaInfo); }
        public leadingTrivia(): ISyntaxTriviaList { return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), /*isTrailing:*/ false); }

        public hasTrailingTrivia(): bool { return true; }
        public hasTrailingComment(): bool { return hasTriviaComment(this._trailingTriviaInfo); }
        public hasTrailingNewLine(): bool { return hasTriviaNewLine(this._trailingTriviaInfo); }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return getTriviaWidth(this._trailingTriviaInfo); }
        public trailingTrivia(): ISyntaxTriviaList { return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), /*isTrailing:*/ true); }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realize(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class FixedWidthTokenWithNoTrivia implements ISyntaxToken {
        public tokenKind: SyntaxKind;

        constructor(kind: SyntaxKind) {
            this.tokenKind = kind;
        }

        public clone(): ISyntaxToken {
            return new FixedWidthTokenWithNoTrivia(
                this.tokenKind);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return this.width(); }
        public width(): number { return this.text().length; }
        public text(): string { return SyntaxFacts.getText(this.tokenKind); }
        public fullText(): string { return this.text(); }

        public value(): any { return null; }
        public hasLeadingTrivia(): bool { return false; }
        public hasLeadingComment(): bool { return false; }
        public hasLeadingNewLine(): bool { return false; }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return 0; }
        public leadingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasTrailingTrivia(): bool { return false; }
        public hasTrailingComment(): bool { return false; }
        public hasTrailingNewLine(): bool { return false; }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return 0; }
        public trailingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realize(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class FixedWidthTokenWithLeadingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _leadingTriviaInfo: number;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, leadingTriviaInfo: number) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
        }

        public clone(): ISyntaxToken {
            return new FixedWidthTokenWithLeadingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._leadingTriviaInfo);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return getTriviaWidth(this._leadingTriviaInfo) + this.width(); }
        private start(): number { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return this.text().length; }
        public text(): string { return SyntaxFacts.getText(this.tokenKind); }
        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return null; }
        public hasLeadingTrivia(): bool { return true; }
        public hasLeadingComment(): bool { return hasTriviaComment(this._leadingTriviaInfo); }
        public hasLeadingNewLine(): bool { return hasTriviaNewLine(this._leadingTriviaInfo); }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return getTriviaWidth(this._leadingTriviaInfo); }
        public leadingTrivia(): ISyntaxTriviaList { return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), /*isTrailing:*/ false); }

        public hasTrailingTrivia(): bool { return false; }
        public hasTrailingComment(): bool { return false; }
        public hasTrailingNewLine(): bool { return false; }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return 0; }
        public trailingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realize(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class FixedWidthTokenWithTrailingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _trailingTriviaInfo: number;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, trailingTriviaInfo: number) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }

        public clone(): ISyntaxToken {
            return new FixedWidthTokenWithTrailingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._trailingTriviaInfo);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return this.width() + getTriviaWidth(this._trailingTriviaInfo); }
        private start(): number { return this._fullStart; }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return this.text().length; }
        public text(): string { return SyntaxFacts.getText(this.tokenKind); }
        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return null; }
        public hasLeadingTrivia(): bool { return false; }
        public hasLeadingComment(): bool { return false; }
        public hasLeadingNewLine(): bool { return false; }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return 0; }
        public leadingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasTrailingTrivia(): bool { return true; }
        public hasTrailingComment(): bool { return hasTriviaComment(this._trailingTriviaInfo); }
        public hasTrailingNewLine(): bool { return hasTriviaNewLine(this._trailingTriviaInfo); }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return getTriviaWidth(this._trailingTriviaInfo); }
        public trailingTrivia(): ISyntaxTriviaList { return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), /*isTrailing:*/ true); }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realize(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class FixedWidthTokenWithLeadingAndTrailingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _leadingTriviaInfo: number;
        private _trailingTriviaInfo: number;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, leadingTriviaInfo: number, trailingTriviaInfo: number) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }

        public clone(): ISyntaxToken {
            return new FixedWidthTokenWithLeadingAndTrailingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._leadingTriviaInfo,
                this._trailingTriviaInfo);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo); }
        private start(): number { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return this.text().length; }
        public text(): string { return SyntaxFacts.getText(this.tokenKind); }
        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return null; }
        public hasLeadingTrivia(): bool { return true; }
        public hasLeadingComment(): bool { return hasTriviaComment(this._leadingTriviaInfo); }
        public hasLeadingNewLine(): bool { return hasTriviaNewLine(this._leadingTriviaInfo); }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return getTriviaWidth(this._leadingTriviaInfo); }
        public leadingTrivia(): ISyntaxTriviaList { return Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), /*isTrailing:*/ false); }

        public hasTrailingTrivia(): bool { return true; }
        public hasTrailingComment(): bool { return hasTriviaComment(this._trailingTriviaInfo); }
        public hasTrailingNewLine(): bool { return hasTriviaNewLine(this._trailingTriviaInfo); }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return getTriviaWidth(this._trailingTriviaInfo); }
        public trailingTrivia(): ISyntaxTriviaList { return Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), /*isTrailing:*/ true); }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realize(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    function collectTokenTextElements(token: ISyntaxToken, elements: string[]): void {
        token.leadingTrivia().collectTextElements(elements);
        elements.push(token.text());
        token.trailingTrivia().collectTextElements(elements);
    }

    export function fixedWidthToken(sourceText: ISimpleText, fullStart: number,
        kind: SyntaxKind,
        leadingTriviaInfo: number,
        trailingTriviaInfo: number): ISyntaxToken {

        if (leadingTriviaInfo === 0) {
            if (trailingTriviaInfo === 0) {
                return new FixedWidthTokenWithNoTrivia(kind);
            }
            else {
                return new FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo);
            }
        }
        else if (trailingTriviaInfo === 0) {
            return new FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo);
        }
        else {
            return new FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
        }
    }

    export function variableWidthToken(sourceText: ISimpleText, fullStart: number,
        kind: SyntaxKind,
        leadingTriviaInfo: number,
        width: number,
        trailingTriviaInfo: number): ISyntaxToken {

        if (leadingTriviaInfo === 0) {
            if (trailingTriviaInfo === 0) {
                return new VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, width);
            }
            else {
                return new VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, width, trailingTriviaInfo);
            }
        }
        else if (trailingTriviaInfo === 0) {
            return new VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width);
        }
        else {
            return new VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
        }
    }

    function getTriviaWidth(value: number): number {
        return value >>> SyntaxConstants.TriviaFullWidthShift;
    }

    function hasTriviaComment(value: number): bool {
        return (value & SyntaxConstants.TriviaCommentMask) !== 0;
    }

    function hasTriviaNewLine(value: number): bool {
        return (value & SyntaxConstants.TriviaNewLineMask) !== 0;
    }
}
///<reference path='..\Text\CharacterCodes.ts' />
///<reference path='..\Core\Debug.ts' />
///<reference path='ISyntaxTrivia.ts' />
///<reference path='..\Core\StringUtilities.ts' />

module Syntax {
    class SyntaxTrivia implements ISyntaxTrivia {
        private _kind: SyntaxKind;
        private _text: string;

        constructor(kind: SyntaxKind, text: string) {
            this._kind = kind;
            this._text = text;
        }

        public toJSON(key) {
            var result: any = {};
            result.kind = (<any>SyntaxKind)._map[this._kind];
            result.text = this._text;
            return result;
        }

        public kind(): SyntaxKind {
            return this._kind;
        }

        public fullWidth(): number {
            return this._text.length;
        }

        public fullText(): string {
            return this._text;
        }

        public isWhitespace(): bool {
            return this.kind() === SyntaxKind.WhitespaceTrivia;
        }

        public isComment(): bool {
            return this.kind() === SyntaxKind.SingleLineCommentTrivia || this.kind() === SyntaxKind.MultiLineCommentTrivia;
        }

        public isNewLine(): bool {
            return this.kind() === SyntaxKind.NewLineTrivia;
        }

        public isSkippedText(): bool {
            return this.kind() === SyntaxKind.SkippedTextTrivia;
        }

        public collectTextElements(elements: string[]): void {
            elements.push(this.fullText());
        }
    }

    export function trivia(kind: SyntaxKind, text: string): ISyntaxTrivia {
        Debug.assert(kind === SyntaxKind.MultiLineCommentTrivia || kind === SyntaxKind.NewLineTrivia || kind === SyntaxKind.SingleLineCommentTrivia || kind === SyntaxKind.WhitespaceTrivia || kind === SyntaxKind.SkippedTextTrivia);
        Debug.assert(text.length > 0);
        return new SyntaxTrivia(kind, text);
    }

    export function spaces(count: number): ISyntaxTrivia {
        return trivia(SyntaxKind.WhitespaceTrivia, StringUtilities.repeat(" ", count));
    }

    export function whitespace(text: string): ISyntaxTrivia {
        return trivia(SyntaxKind.WhitespaceTrivia, text);
    }

    export function multiLineComment(text: string): ISyntaxTrivia {
        return trivia(SyntaxKind.MultiLineCommentTrivia, text);
    }

    export function singleLineComment(text: string): ISyntaxTrivia {
        return trivia(SyntaxKind.SingleLineCommentTrivia, text);
    }

    export var spaceTrivia: ISyntaxTrivia = spaces(1);
    export var lineFeedTrivia: ISyntaxTrivia = trivia(SyntaxKind.NewLineTrivia, "\n");
    export var carriageReturnTrivia: ISyntaxTrivia = trivia(SyntaxKind.NewLineTrivia, "\r");
    export var carriageReturnLineFeedTrivia: ISyntaxTrivia = trivia(SyntaxKind.NewLineTrivia, "\r\n");

    // Breaks a multiline trivia up into individual line components.  If the trivia doesn't span
    // any lines, then the result will be a single string with the entire text of the trivia. 
    // Otherwise, there will be one entry in the array for each line spanned by the trivia.  Each
    // entry will contain the line separator at the end of the string.
    export function splitMultiLineCommentTriviaIntoMultipleLines(trivia: ISyntaxTrivia): string[] {
        Debug.assert(trivia.kind() === SyntaxKind.MultiLineCommentTrivia);
        var result: string[] = [];

        var triviaText = trivia.fullText();
        var currentIndex = 0;

        for (var i = 0; i < triviaText.length; i++) {
            var ch = triviaText.charCodeAt(i);

            // When we run into a newline for the first time, create the string builder and copy
            // all the values up to this newline into it.
            var isCarriageReturnLineFeed = false;
            switch (ch) {
                case CharacterCodes.carriageReturn:
                    if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === CharacterCodes.lineFeed) {
                        // Consume the \r
                        i++;
                    }

                // Fall through.

                case CharacterCodes.lineFeed:
                case CharacterCodes.paragraphSeparator:
                case CharacterCodes.lineSeparator:
                    // Eat from the last stating position through to the end of the newline.
                    result.push(triviaText.substring(currentIndex, i + 1));

                    // Set the current index to *after* the newline.
                    currentIndex = i + 1;
                    continue;
            }
        }

        result.push(triviaText.substring(currentIndex));
        return result;
    }
}
///<reference path='..\Core\ArrayUtilities.ts' />
///<reference path='..\Core\Errors.ts' />
///<reference path='ISyntaxTriviaList.ts' />
///<reference path='SyntaxTrivia.ts' />

module Syntax {
    export var emptyTriviaList: ISyntaxTriviaList = {
        kind: (): SyntaxKind => SyntaxKind.TriviaList,

        count: (): number => 0,

        syntaxTriviaAt: (index: number): ISyntaxTrivia => {
            throw Errors.argumentOutOfRange("index");
        },

        last: (): ISyntaxTrivia => {
            throw Errors.argumentOutOfRange("index");
        },

        fullWidth: (): number => 0,
        fullText: (): string => "",

        hasComment: (): bool => false,
        hasNewLine: (): bool => false,
        hasSkippedText: (): bool => false,

        toJSON: (key) => [],

        collectTextElements: (elements: string[]): void => { },

        toArray: (): ISyntaxTrivia[] => [],

        concat: (trivia: ISyntaxTriviaList): ISyntaxTriviaList => trivia,
    };

    function concatTrivia(list1: ISyntaxTriviaList, list2: ISyntaxTriviaList): ISyntaxTriviaList {
        if (list1.count() === 0) {
            return list2;
        }

        if (list2.count() === 0) {
            return list1;
        }

        var trivia = list1.toArray();
        trivia.push.apply(trivia, list2.toArray());

        return triviaList(trivia);
    }

    function isComment(trivia: ISyntaxTrivia): bool {
        return trivia.kind() === SyntaxKind.MultiLineCommentTrivia || trivia.kind() === SyntaxKind.SingleLineCommentTrivia;
    }

    class SingletonSyntaxTriviaList implements ISyntaxTriviaList {
        private item: ISyntaxTrivia;

        constructor(item: ISyntaxTrivia) {
            this.item = item;
        }

        public kind(): SyntaxKind { return SyntaxKind.TriviaList; }

        public count(): number {
            return 1;
        }

        public syntaxTriviaAt(index: number): ISyntaxTrivia {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.item;
        }

        public last(): ISyntaxTrivia {
            return this.item;
        }

        public fullWidth(): number {
            return this.item.fullWidth();
        }

        public fullText(): string {
            return this.item.fullText();
        }

        public hasComment(): bool {
            return isComment(this.item);
        }

        public hasNewLine(): bool {
            return this.item.kind() === SyntaxKind.NewLineTrivia;
        }

        public hasSkippedText(): bool {
            return this.item.kind() === SyntaxKind.SkippedTextTrivia;
        }

        public toJSON(key) {
            return [this.item];
        }

        private collectTextElements(elements: string[]): void {
            (<any>this.item).collectTextElements(elements);
        }

        public toArray(): ISyntaxTrivia[] {
            return [this.item];
        }

        public concat(trivia: ISyntaxTriviaList): ISyntaxTriviaList {
            return concatTrivia(this, trivia);
        }
    }

    class NormalSyntaxTriviaList implements ISyntaxTriviaList {
        private trivia: ISyntaxTrivia[];

        constructor(trivia: ISyntaxTrivia[]) {
            this.trivia = trivia;
        }

        public kind(): SyntaxKind { return SyntaxKind.TriviaList; }

        public count() {
            return this.trivia.length;
        }

        public syntaxTriviaAt(index: number): ISyntaxTrivia {
            if (index < 0 || index >= this.trivia.length) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.trivia[index];
        }
        
        public last(): ISyntaxTrivia {
            return this.trivia[this.trivia.length - 1];
        }

        public fullWidth(): number {
            return ArrayUtilities.sum(this.trivia, t => t.fullWidth());
        }

        public fullText(): string {
            var result = "";

            for (var i = 0, n = this.trivia.length; i < n; i++) {
                result += this.trivia[i].fullText();
            }

            return result;
        }

        public hasComment(): bool {
            for (var i = 0; i < this.trivia.length; i++) {
                if (isComment(this.trivia[i])) {
                    return true;
                }
            }

            return false;
        }

        public hasNewLine(): bool {
            for (var i = 0; i < this.trivia.length; i++) {
                if (this.trivia[i].kind() === SyntaxKind.NewLineTrivia) {
                    return true;
                }
            }

            return false;
        }

        public hasSkippedText(): bool {
            for (var i = 0; i < this.trivia.length; i++) {
                if (this.trivia[i].kind() === SyntaxKind.SkippedTextTrivia) {
                    return true;
                }
            }

            return false;
        }

        public toJSON(key) {
            return this.trivia;
        }

        private collectTextElements(elements: string[]): void {
            for (var i = 0; i < this.trivia.length; i++) {
                (<any>this.trivia[i]).collectTextElements(elements);
            }
        }

        public toArray(): ISyntaxTrivia[] {
            return this.trivia.slice(0);
        }

        public concat(trivia: ISyntaxTriviaList): ISyntaxTriviaList {
            return concatTrivia(this, trivia);
        }
    }

    export function triviaList(trivia: ISyntaxTrivia[]): ISyntaxTriviaList {
        if (trivia === undefined || trivia === null || trivia.length === 0) {
            return Syntax.emptyTriviaList;
        }

        if (trivia.length === 1) {
            return new SingletonSyntaxTriviaList(trivia[0]);
        }

        return new NormalSyntaxTriviaList(trivia);
    }

    export var spaceTriviaList: ISyntaxTriviaList = triviaList([Syntax.spaceTrivia]);
}
///<reference path='..\Core\Errors.ts' />
///<reference path='LanguageVersion.ts' />

class Unicode {
    // Unicode range maps
    // REVIEW: These range maps have been extracted from the Unicode specifications, they might be missing values, and/or include 
    //         incorrect ranges. but for the most they seem to be correct. A more accurate and thorough review is needed.

    /*
        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
        IdentifierStart :: Can contain Unicode 3.0.0  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).
        IdentifierPart :: Can contain IdentifierStart + Unicode 3.0.0  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), or Connector punctuation (Pc).
                    
        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
    */
    static unicodeES3IdentifierStart = [
        170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,
        1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611,
        2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970,
        2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517,
        3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138,
        4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885,
        4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147,
        8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588,
        12593, 12686, 12704, 12727, 13312, 13312, 19893, 19893, 19968, 19968, 40869, 40869, 40960, 42124, 44032, 44032, 55203, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967,
        65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500
    ];

    static unicodeES3IdentifierPart = [
                768, 846, 864, 866, 1155, 1158, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1611, 1621, 1632, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 2305, 2307, 2364, 2364, 2366, 2381, 2385, 2388, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492,
                2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2562, 2562, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2662, 2673, 2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2790, 2799, 2817, 2819, 2876, 2876, 2878, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2918, 2927, 2946, 2947, 3006, 3010, 3014, 3016,
                3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3174, 3183, 3202, 3203, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3302, 3311, 3330, 3331, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3633, 3633,
                3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903, 3953, 3972, 3974, 3975, 3984, 3991, 3993, 4028, 4038, 4038, 4140, 4146, 4150, 4153, 4160, 4169, 4182, 4185, 4969, 4977, 6068, 6099, 6112, 6121, 6160, 6169, 6313, 6313,
                8255, 8256, 8400, 8412, 8417, 8417, 12330, 12335, 12441, 12442, 12539, 12539, 64286, 64286, 65056, 65059, 65075, 65076, 65101, 65103, 65296, 65305, 65343, 65343, 65381, 65381
    ];


    /*
        As per ECMAScript Language Specification 5th Edition, Section 7.6: Identifier Names and Identifiers
        IdentifierStart :: Can contain Unicode 6.2  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).
        IdentifierPart :: Can contain IdentifierStart + Unicode 6.2  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), Connector punctuation (Pc), <ZWNJ>, or <ZWJ>.
                    
        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
    */
    static unicodeES5IdentifierStart = [
                170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775,
                1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489,
                2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864,
                2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,
                3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743,
                3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680,
                4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000,
                6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957,
                7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486,
                8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726,
                11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 13312, 19893, 19893, 19968, 19968, 40908, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527,
                42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560,
                43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 44032, 55203, 55203, 55216, 55238, 55243, 55291,
                63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487,
                65490, 65495, 65498, 65500
    ];

    static unicodeES5IdentifierPart = [
                768, 879, 1155, 1159, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1552, 1562, 1611, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 1984, 1993, 2027, 2035, 2070, 2073, 2075, 2083, 2085, 2087, 2089, 2093, 2137, 2139, 2276, 2302, 2304, 2307, 2362, 2364,
                2366, 2383, 2385, 2391, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2561, 2563, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2662, 2673, 2677, 2677, 2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2786, 2787, 2790, 2799, 2817, 2819,
                2876, 2876, 2878, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2914, 2915, 2918, 2927, 2946, 2946, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3046, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3170, 3171, 3174, 3183, 3202, 3203, 3260, 3260, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3298, 3299, 3302, 3311,
                3330, 3331, 3390, 3396, 3398, 3400, 3402, 3405, 3415, 3415, 3426, 3427, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3633, 3633, 3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903,
                3953, 3972, 3974, 3975, 3981, 3991, 3993, 4028, 4038, 4038, 4139, 4158, 4160, 4169, 4182, 4185, 4190, 4192, 4194, 4196, 4199, 4205, 4209, 4212, 4226, 4237, 4239, 4253, 4957, 4959, 5906, 5908, 5938, 5940, 5970, 5971, 6002, 6003, 6068, 6099, 6109, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6313, 6313, 6432, 6443, 6448, 6459, 6470, 6479,
                6576, 6592, 6600, 6601, 6608, 6617, 6679, 6683, 6741, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6912, 6916, 6964, 6980, 6992, 7001, 7019, 7027, 7040, 7042, 7073, 7085, 7088, 7097, 7142, 7155, 7204, 7223, 7232, 7241, 7248, 7257, 7376, 7378, 7380, 7400, 7405, 7405, 7410, 7412, 7616, 7654, 7676, 7679, 8204, 8205, 8255, 8256, 8276, 8276,
                8400, 8412, 8417, 8417, 8421, 8432, 11503, 11505, 11647, 11647, 11744, 11775, 12330, 12335, 12441, 12442, 42528, 42537, 42607, 42607, 42612, 42621, 42655, 42655, 42736, 42737, 43010, 43010, 43014, 43014, 43019, 43019, 43043, 43047, 43136, 43137, 43188, 43204, 43216, 43225, 43232, 43249, 43264, 43273, 43302, 43309, 43335, 43347,
                43392, 43395, 43443, 43456, 43472, 43481, 43561, 43574, 43587, 43587, 43596, 43597, 43600, 43609, 43643, 43643, 43696, 43696, 43698, 43700, 43703, 43704, 43710, 43711, 43713, 43713, 43755, 43759, 43765, 43766, 44003, 44010, 44012, 44013, 44016, 44025, 64286, 64286, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103,
                65296, 65305, 65343, 65343
    ];

    static lookupInUnicodeMap(code: number, map: number[]): bool {
        // Bail out quickly if it couldn't possibly be in the map.
        if (code < map[0]) {
            return false;
        }

        // Perform binary search in one of the unicode range maps
        var lo: number = 0;
        var hi: number = map.length;
        var mid: number;

        while (lo + 1 < hi) {
            mid = lo + (hi - lo) / 2;
            // mid has to be even to catch a range's beginning
            mid -= mid % 2;
            if (map[mid] <= code && code <= map[mid + 1]) {
                return true;
            }

            if (code < map[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 2;
            }
        }

        return false;
    }

    public static isIdentifierStart(code: number, languageVersion: LanguageVersion) {
        if (languageVersion === LanguageVersion.EcmaScript3) {
            return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
        }
        else if (languageVersion === LanguageVersion.EcmaScript5) {
            return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
        }
        else {
            throw Errors.argumentOutOfRange("languageVersion");
        }
    }

    public static isIdentifierPart(code: number, languageVersion: LanguageVersion) {
        if (languageVersion === LanguageVersion.EcmaScript3) {
            return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
        }
        else if (languageVersion === LanguageVersion.EcmaScript5) {
            return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
        }
        else {
            throw Errors.argumentOutOfRange("languageVersion");
        }
    }
}
﻿///<reference path='SlidingWindow.ts' />

///<reference path='..\Text\CharacterCodes.ts' />
///<reference path='CharacterInfo.ts' />
///<reference path='Constants.ts' />
///<reference path='LanguageVersion.ts' />
///<reference path='ISyntaxToken.ts' />
///<reference path='..\Text\IText.ts' />
///<reference path='ScannerUtilities.generated.ts' />
///<reference path='..\Core\StringTable.ts' />
///<reference path='SyntaxDiagnostic.ts' />
///<reference path='SyntaxFacts.ts' />
///<reference path='SyntaxKind.ts' />
///<reference path='SyntaxToken.ts' />
///<reference path='SyntaxToken.generated.ts' />
///<reference path='SyntaxTriviaList.ts' />
///<reference path='Unicode.ts' />

class Scanner implements ISlidingWindowSource {
    private slidingWindow: SlidingWindow;

    private text: ISimpleText;
    private stringTable: Collections.StringTable;
    private languageVersion: LanguageVersion;

    private static isKeywordStartCharacter: bool[] = [];
    private static isIdentifierStartCharacter: bool[] = [];
    public static isIdentifierPartCharacter: bool[] = [];
    private static isNumericLiteralStart: bool[] = [];

    private static initializeStaticData() {
        if (Scanner.isKeywordStartCharacter.length === 0) {
            Scanner.isKeywordStartCharacter = ArrayUtilities.createArray(CharacterCodes.maxAsciiCharacter, false);
            Scanner.isIdentifierStartCharacter = ArrayUtilities.createArray(CharacterCodes.maxAsciiCharacter, false);
            Scanner.isIdentifierPartCharacter = ArrayUtilities.createArray(CharacterCodes.maxAsciiCharacter, false);
            Scanner.isNumericLiteralStart = ArrayUtilities.createArray(CharacterCodes.maxAsciiCharacter, false);

            for (var character = 0; character < CharacterCodes.maxAsciiCharacter; character++) {
                if (character >= CharacterCodes.a && character <= CharacterCodes.z) {
                    Scanner.isIdentifierStartCharacter[character] = true;
                    Scanner.isIdentifierPartCharacter[character] = true;
                }
                else if ((character >= CharacterCodes.A && character <= CharacterCodes.Z) ||
                         character === CharacterCodes._ ||
                         character === CharacterCodes.$) {
                    Scanner.isIdentifierStartCharacter[character] = true;
                    Scanner.isIdentifierPartCharacter[character] = true;
                }
                else if (character >= CharacterCodes._0 && character <= CharacterCodes._9) {
                    Scanner.isIdentifierPartCharacter[character] = true;
                    Scanner.isNumericLiteralStart[character] = true;
                }
            }

            Scanner.isNumericLiteralStart[CharacterCodes.dot] = true;

            for (var keywordKind = SyntaxKind.FirstKeyword; keywordKind <= SyntaxKind.LastKeyword; keywordKind++) {
                var keyword = SyntaxFacts.getText(keywordKind);
                Scanner.isKeywordStartCharacter[keyword.charCodeAt(0)] = true;
            }
        }
    }

    constructor(text: ISimpleText,
                languageVersion: LanguageVersion,
                stringTable: Collections.StringTable,
                window: number[] = ArrayUtilities.createArray(2048, 0)) {
        Scanner.initializeStaticData();
        
        this.slidingWindow = new SlidingWindow(this, window, 0, text.length());
        this.text = text;
        this.stringTable = stringTable;
        this.languageVersion = languageVersion;
    }

    private fetchMoreItems(argument: any, sourceIndex: number, window: number[], destinationIndex: number, spaceAvailable: number): number {
        var charactersRemaining = this.text.length() - sourceIndex;
        var amountToRead = MathPrototype.min(charactersRemaining, spaceAvailable);
        this.text.copyTo(sourceIndex, window, destinationIndex, amountToRead);
        return amountToRead;
    }

    private currentCharCode(): number {
        return this.slidingWindow.currentItem(/*argument:*/ null);
    }

    // Set's the scanner to a specific position in the text.
    public setAbsoluteIndex(index: number): void {
        this.slidingWindow.setAbsoluteIndex(index);
    }

    // Scans a token starting at the current position.  Any errors encountered will be added to 
    // 'diagnostics'.
    public scan(diagnostics: SyntaxDiagnostic[], allowRegularExpression: bool): ISyntaxToken {
        var fullStart = this.slidingWindow.absoluteIndex();
        var leadingTriviaInfo = this.scanTriviaInfo(diagnostics, /*isTrailing: */ false);

        var start = this.slidingWindow.absoluteIndex();
        var kind = this.scanSyntaxToken(diagnostics, allowRegularExpression);
        var end = this.slidingWindow.absoluteIndex();

        var trailingTriviaInfo = this.scanTriviaInfo(diagnostics,/*isTrailing: */true);

        if (kind >= SyntaxKind.FirstFixedWidth) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new Syntax.FixedWidthTokenWithNoTrivia(kind);
                }
                else {
                    return new Syntax.FixedWidthTokenWithTrailingTrivia(this.text, fullStart, kind, trailingTriviaInfo);
                }
            }
            else if (trailingTriviaInfo === 0) {
                return new Syntax.FixedWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo);
            }
            else {
                return new Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
            }
        }
        else {
            var width = end - start;
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new Syntax.VariableWidthTokenWithNoTrivia(this.text, fullStart, kind, width);
                }
                else {
                    return new Syntax.VariableWidthTokenWithTrailingTrivia(this.text, fullStart, kind, width, trailingTriviaInfo);
                }
            }
            else if (trailingTriviaInfo === 0) {
                return new Syntax.VariableWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width);
            }
            else {
                return new Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
            }
        }
    }

    private static triviaWindow = ArrayUtilities.createArray(2048, 0);

    // Scans a subsection of 'text' as trivia.
    public static scanTrivia(text: ISimpleText, start: number, length: number, isTrailing: bool): ISyntaxTriviaList {
        Debug.assert(length > 0);
        var scanner = new Scanner(text.subText(new TextSpan(start, length)), LanguageVersion.EcmaScript5, null, Scanner.triviaWindow);
        return scanner.scanTrivia(isTrailing);
    }
    
    private scanTrivia(isTrailing: bool): ISyntaxTriviaList {
        // Keep this exactly in sync with scanTriviaInfo
        var trivia: ISyntaxTrivia[] = [];

        while (true) {
            if (!this.slidingWindow.isAtEndOfSource()) {
                var ch = this.currentCharCode();

                switch (ch) {
                    case CharacterCodes.space:
                    case CharacterCodes.tab:
                    case CharacterCodes.verticalTab:
                    case CharacterCodes.formFeed:
                    case CharacterCodes.nonBreakingSpace:
                    case CharacterCodes.byteOrderMark:
                        // Normal whitespace.  Consume and continue.
                        trivia.push(this.scanWhitespaceTrivia());
                        continue;

                    case CharacterCodes.slash:
                        // Potential comment.  Consume if so.  Otherwise, break out and return.
                        var ch2 = this.slidingWindow.peekItemN(1);
                        if (ch2 === CharacterCodes.slash) {
                            trivia.push(this.scanSingleLineCommentTrivia());
                            continue;
                        }

                        if (ch2 === CharacterCodes.asterisk) {
                            trivia.push(this.scanMultiLineCommentTrivia());
                            continue;
                        }

                        // Not a comment.  Don't consume.
                        throw Errors.invalidOperation();

                    case CharacterCodes.carriageReturn:
                    case CharacterCodes.lineFeed:
                    case CharacterCodes.paragraphSeparator:
                    case CharacterCodes.lineSeparator:
                        trivia.push(this.scanLineTerminatorSequenceTrivia(ch));

                        // If we're consuming leading trivia, then we will continue consuming more 
                        // trivia (including newlines) up to the first token we see.  If we're 
                        // consuming trailing trivia, then we break after the first newline we see.
                        if (!isTrailing) {
                            continue;
                        }

                        break;

                    default:
                        throw Errors.invalidOperation();
                }
            }

            Debug.assert(trivia.length > 0);
            return Syntax.triviaList(trivia);
        }
    }

    private scanTriviaInfo(diagnostics: SyntaxDiagnostic[], isTrailing: bool): number {
        // Keep this exactly in sync with scanTrivia
        var width = 0;
        var hasCommentOrNewLine = 0;

        while (true) {
            var ch = this.currentCharCode();

            switch (ch) {
                case CharacterCodes.space:
                case CharacterCodes.tab:
                case CharacterCodes.verticalTab:
                case CharacterCodes.formFeed:
                case CharacterCodes.nonBreakingSpace:
                case CharacterCodes.byteOrderMark:
                    // Normal whitespace.  Consume and continue.
                    this.slidingWindow.moveToNextItem();
                    width++;
                    continue;

                case CharacterCodes.slash:
                    // Potential comment.  Consume if so.  Otherwise, break out and return.
                    var ch2 = this.slidingWindow.peekItemN(1);
                    if (ch2 === CharacterCodes.slash) {
                        hasCommentOrNewLine |= SyntaxConstants.TriviaCommentMask;
                        width += this.scanSingleLineCommentTriviaLength();
                        continue;
                    }

                    if (ch2 === CharacterCodes.asterisk) {
                        hasCommentOrNewLine |= SyntaxConstants.TriviaCommentMask;
                        width += this.scanMultiLineCommentTriviaLength(diagnostics);
                        continue;
                    }

                    // Not a comment.  Don't consume.
                    break;

                case CharacterCodes.carriageReturn:
                case CharacterCodes.lineFeed:
                case CharacterCodes.paragraphSeparator:
                case CharacterCodes.lineSeparator:
                    hasCommentOrNewLine |= SyntaxConstants.TriviaNewLineMask;
                    width += this.scanLineTerminatorSequenceLength(ch);

                    // If we're consuming leading trivia, then we will continue consuming more 
                    // trivia (including newlines) up to the first token we see.  If we're 
                    // consuming trailing trivia, then we break after the first newline we see.
                    if (!isTrailing) {
                        continue;
                    }

                    break;
            }

            return (width << SyntaxConstants.TriviaFullWidthShift) | hasCommentOrNewLine;
        }
    }

    private isNewLineCharacter(ch: number): bool {
        switch (ch) {
            case CharacterCodes.carriageReturn:
            case CharacterCodes.lineFeed:
            case CharacterCodes.paragraphSeparator:
            case CharacterCodes.lineSeparator:
                return true;
            default:
                return false;
        }
    }

    private scanWhitespaceTrivia(): ISyntaxTrivia {
        // We're going to be extracting text out of sliding window.  Make sure it can't move past
        // this point.
        var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();

        var width = 0;
        while (true) {
            var ch = this.currentCharCode();

            switch (ch) {
                case CharacterCodes.space:
                case CharacterCodes.tab:
                case CharacterCodes.verticalTab:
                case CharacterCodes.formFeed:
                case CharacterCodes.nonBreakingSpace:
                case CharacterCodes.byteOrderMark:
                    // Normal whitespace.  Consume and continue.
                    this.slidingWindow.moveToNextItem();
                    width++;
                    continue;
            }

            break;
        }
        
        // TODO: we probably should intern whitespace.
        var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, /*intern:*/ false);
        this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

        return Syntax.whitespace(text);
    }
    
    private scanSingleLineCommentTrivia(): ISyntaxTrivia {
        var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
        var width = this.scanSingleLineCommentTriviaLength();
        
        var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, /*intern:*/ false);
        this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

        return Syntax.singleLineComment(text);
    }

    private scanSingleLineCommentTriviaLength(): number {
        this.slidingWindow.moveToNextItem();
        this.slidingWindow.moveToNextItem();
        
        // The '2' is for the "//" we consumed.
        var width = 2;
        while (true) {
            if (this.slidingWindow.isAtEndOfSource() || this.isNewLineCharacter(this.currentCharCode())) {
                return width;
            }

            this.slidingWindow.moveToNextItem();
            width++;
        }
    }

    private scanMultiLineCommentTrivia(): ISyntaxTrivia {
        var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
        var width = this.scanMultiLineCommentTriviaLength(null);
        
        var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, /*intern:*/ false);
        this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

        return Syntax.multiLineComment(text);
    }

    private scanMultiLineCommentTriviaLength(diagnostics: SyntaxDiagnostic[]): number {
        this.slidingWindow.moveToNextItem();
        this.slidingWindow.moveToNextItem();

        // The '2' is for the "/*" we consumed.
        var width = 2;
        while (true) {
            if (this.slidingWindow.isAtEndOfSource()) {
                if (diagnostics !== null) {
                    diagnostics.push(new SyntaxDiagnostic(
                        this.slidingWindow.absoluteIndex(), 0, DiagnosticCode._StarSlash__expected, null));
                }

                return width;
            }

            var ch = this.currentCharCode();
            if (ch === CharacterCodes.asterisk && this.slidingWindow.peekItemN(1) === CharacterCodes.slash) {
                this.slidingWindow.moveToNextItem();
                this.slidingWindow.moveToNextItem();
                width += 2;
                return width;
            }

            this.slidingWindow.moveToNextItem();
            width++;
        }
    }

    private scanLineTerminatorSequenceTrivia(ch: number): ISyntaxTrivia {
        var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
        var width = this.scanLineTerminatorSequenceLength(ch);
        
        var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, /*intern:*/ false);
        this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

        return Syntax.trivia(SyntaxKind.NewLineTrivia, text);
    }

    private scanLineTerminatorSequenceLength(ch: number): number {
        // Consume the first of the line terminator we saw.
        this.slidingWindow.moveToNextItem();

        // If it happened to be a \r and there's a following \n, then consume both.
        if (ch === CharacterCodes.carriageReturn && this.currentCharCode() === CharacterCodes.lineFeed) {
            this.slidingWindow.moveToNextItem();
            return 2;
        }
        else {
            return 1;
        }
    }

    private scanSyntaxToken(diagnostics: SyntaxDiagnostic[], allowRegularExpression: bool): SyntaxKind {
        if (this.slidingWindow.isAtEndOfSource()) {
            return SyntaxKind.EndOfFileToken;
        }

        var character = this.currentCharCode();

        switch (character) {
            case CharacterCodes.doubleQuote:
            case CharacterCodes.singleQuote:
                return this.scanStringLiteral(diagnostics);

            // These are the set of variable width punctuation tokens.
            case CharacterCodes.slash:
                return this.scanSlashToken(allowRegularExpression);

            case CharacterCodes.dot:
                return this.scanDotToken();

            case CharacterCodes.minus:
                return this.scanMinusToken();

            case CharacterCodes.exclamation:
                return this.scanExclamationToken();

            case CharacterCodes.equals:
                return this.scanEqualsToken();

            case CharacterCodes.bar:
                return this.scanBarToken();

            case CharacterCodes.asterisk:
                return this.scanAsteriskToken();

            case CharacterCodes.plus:
                return this.scanPlusToken();

            case CharacterCodes.percent:
                return this.scanPercentToken();

            case CharacterCodes.ampersand:
                return this.scanAmpersandToken();

            case CharacterCodes.caret:
                return this.scanCaretToken();

            case CharacterCodes.lessThan:
                return this.scanLessThanToken();

            // These are the set of fixed, single character length punctuation tokens.
            // The token kind does not depend on what follows.
            case CharacterCodes.greaterThan:
                return this.advanceAndSetTokenKind(SyntaxKind.GreaterThanToken);

            case CharacterCodes.comma:
                return this.advanceAndSetTokenKind(SyntaxKind.CommaToken);

            case CharacterCodes.colon:
                return this.advanceAndSetTokenKind(SyntaxKind.ColonToken);

            case CharacterCodes.semicolon:
                return this.advanceAndSetTokenKind(SyntaxKind.SemicolonToken);

            case CharacterCodes.tilde:
                return this.advanceAndSetTokenKind(SyntaxKind.TildeToken);

            case CharacterCodes.openParen:
                return this.advanceAndSetTokenKind(SyntaxKind.OpenParenToken);

            case CharacterCodes.closeParen:
                return this.advanceAndSetTokenKind(SyntaxKind.CloseParenToken);

            case CharacterCodes.openBrace:
                return this.advanceAndSetTokenKind(SyntaxKind.OpenBraceToken);

            case CharacterCodes.closeBrace:
                return this.advanceAndSetTokenKind(SyntaxKind.CloseBraceToken);

            case CharacterCodes.openBracket:
                return this.advanceAndSetTokenKind(SyntaxKind.OpenBracketToken);

            case CharacterCodes.closeBracket:
                return this.advanceAndSetTokenKind(SyntaxKind.CloseBracketToken);

            case CharacterCodes.question:
                return this.advanceAndSetTokenKind(SyntaxKind.QuestionToken);
        }

        if (Scanner.isNumericLiteralStart[character]) {
            return this.scanNumericLiteral();
        }

        // We run into so many identifiers (and keywords) when scanning, that we want the code to
        // be as fast as possible.  To that end, we have an extremely fast path for scanning that
        // handles the 99.9% case of no-unicode characters and no unicode escapes.
        if (Scanner.isIdentifierStartCharacter[character]) {
            var result = this.tryFastScanIdentifierOrKeyword(character);
            if (result !== SyntaxKind.None) {
                return result;
            }
        }

        if (this.isIdentifierStart(this.peekCharOrUnicodeEscape())) {
            return this.slowScanIdentifier(diagnostics);
        }

        return this.scanDefaultCharacter(character, diagnostics);
    }

    private isIdentifierStart(interpretedChar: number): bool {
        if (Scanner.isIdentifierStartCharacter[interpretedChar]) {
            return true;
        }

        return interpretedChar > CharacterCodes.maxAsciiCharacter && Unicode.isIdentifierStart(interpretedChar, this.languageVersion);
    }

    private isIdentifierPart(interpretedChar: number): bool {
        if (Scanner.isIdentifierPartCharacter[interpretedChar]) {
            return true;
        }

        return interpretedChar > CharacterCodes.maxAsciiCharacter && Unicode.isIdentifierPart(interpretedChar, this.languageVersion);
    }

    private tryFastScanIdentifierOrKeyword(firstCharacter: number): SyntaxKind {
        var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();

        while (true) {
            var character = this.currentCharCode();
            if (Scanner.isIdentifierPartCharacter[character]) {
                // Still part of an identifier.  Move to the next caracter.
                this.slidingWindow.moveToNextItem();
            }
            else if (character === CharacterCodes.backslash || character > CharacterCodes.maxAsciiCharacter) {
                // We saw a \ (which could start a unicode escape), or we saw a unicode character.
                // This can't be scanned quickly.  Reset to the beginning and bail out.  We'll 
                // go and try the slow path instead.
                this.slidingWindow.rewindToPinnedIndex(startIndex);
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                return SyntaxKind.None;
            }
            else {
                // Saw an ascii character that wasn't a backslash and wasn't an identifier 
                // character.  This identifier is done.
                var endIndex = this.slidingWindow.absoluteIndex();

                // Also check if it a keyword if it started with a lowercase letter.
                var kind;
                if (Scanner.isKeywordStartCharacter[firstCharacter]) {
                    var offset = startIndex - this.slidingWindow.windowAbsoluteStartIndex;
                    kind = ScannerUtilities.identifierKind(this.slidingWindow.window, offset, endIndex - startIndex);
                }
                else {
                    kind = SyntaxKind.IdentifierName;
                }

                this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                return kind;
            }
        }
    }

    // A slow path for scanning identifiers.  Called when we run into a unicode character or 
    // escape sequence while processing the fast path.
    private slowScanIdentifier(diagnostics: SyntaxDiagnostic[]): SyntaxKind {
        var startIndex = this.slidingWindow.absoluteIndex();

        do {
            this.scanCharOrUnicodeEscape(diagnostics);
        }
        while (this.isIdentifierPart(this.peekCharOrUnicodeEscape()));

        return SyntaxKind.IdentifierName;
    }

    private scanNumericLiteral(): SyntaxKind {
        if (this.isHexNumericLiteral()) {
            return this.scanHexNumericLiteral();
        }
        else {
            return this.scanDecimalNumericLiteral();
        }
    }

    private scanDecimalNumericLiteral(): SyntaxKind {
        while (CharacterInfo.isDecimalDigit(this.currentCharCode())) {
            this.slidingWindow.moveToNextItem();
        }

        if (this.currentCharCode() === CharacterCodes.dot) {
            this.slidingWindow.moveToNextItem();
        }

        while (CharacterInfo.isDecimalDigit(this.currentCharCode())) {
            this.slidingWindow.moveToNextItem();
        }

        var ch = this.currentCharCode();
        if (ch === CharacterCodes.e || ch === CharacterCodes.E) {
            this.slidingWindow.moveToNextItem();

            ch = this.currentCharCode();
            if (ch === CharacterCodes.minus || ch === CharacterCodes.plus) {
                if (CharacterInfo.isDecimalDigit(this.slidingWindow.peekItemN(1))) {
                    this.slidingWindow.moveToNextItem();
                }
            }
        }

        while (CharacterInfo.isDecimalDigit(this.currentCharCode())) {
            this.slidingWindow.moveToNextItem();
        }

        return SyntaxKind.NumericLiteral;
    }
    
    private scanHexNumericLiteral(): SyntaxKind {
        Debug.assert(this.isHexNumericLiteral());

        // Move past the 0x.
        this.slidingWindow.moveToNextItem();
        this.slidingWindow.moveToNextItem();

        while (CharacterInfo.isHexDigit(this.currentCharCode())) {
            this.slidingWindow.moveToNextItem();
        }

        return SyntaxKind.NumericLiteral;
    }

    private isHexNumericLiteral(): bool {
        if (this.currentCharCode() === CharacterCodes._0) {
            var ch = this.slidingWindow.peekItemN(1);

            if (ch === CharacterCodes.x || ch === CharacterCodes.X) {
                ch = this.slidingWindow.peekItemN(2);

                return CharacterInfo.isHexDigit(ch);
            }
        }

        return false;
    }

    private advanceAndSetTokenKind(kind: SyntaxKind): SyntaxKind {
        this.slidingWindow.moveToNextItem();
        return kind;
    }

    private scanLessThanToken(): SyntaxKind {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === CharacterCodes.equals) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.LessThanEqualsToken;
        }
        else if (this.currentCharCode() === CharacterCodes.lessThan) {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.LessThanLessThanEqualsToken;
            }
            else {
                return SyntaxKind.LessThanLessThanToken;
            }
        }
        else {
            return SyntaxKind.LessThanToken;
        }
    }

    private scanBarToken(): SyntaxKind {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === CharacterCodes.equals) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.BarEqualsToken;
        }
        else if (this.currentCharCode() === CharacterCodes.bar) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.BarBarToken;
        }
        else {
            return SyntaxKind.BarToken;
        }
    }

    private scanCaretToken(): SyntaxKind {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === CharacterCodes.equals) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.CaretEqualsToken;
        }
        else {
            return SyntaxKind.CaretToken;
        }
    }

    private scanAmpersandToken(): SyntaxKind {
        this.slidingWindow.moveToNextItem();
        var character = this.currentCharCode();
        if (character === CharacterCodes.equals) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.AmpersandEqualsToken;
        }
        else if (this.currentCharCode() === CharacterCodes.ampersand) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.AmpersandAmpersandToken;
        }
        else {
            return SyntaxKind.AmpersandToken;
        }
    }

    private scanPercentToken(): SyntaxKind {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === CharacterCodes.equals) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.PercentEqualsToken;
        }
        else {
            return SyntaxKind.PercentToken;
        }
    }

    private scanMinusToken(): SyntaxKind {
        this.slidingWindow.moveToNextItem();
        var character = this.currentCharCode();

        if (character === CharacterCodes.equals) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.MinusEqualsToken;
        }
        else if (character === CharacterCodes.minus) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.MinusMinusToken;
        }
        else {
            return SyntaxKind.MinusToken;
        }
    }

    private scanPlusToken(): SyntaxKind {
        this.slidingWindow.moveToNextItem();
        var character = this.currentCharCode();
        if (character === CharacterCodes.equals) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.PlusEqualsToken;
        }
        else if (character === CharacterCodes.plus) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.PlusPlusToken;
        }
        else {
            return SyntaxKind.PlusToken;
        }
    }

    private scanAsteriskToken(): SyntaxKind {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === CharacterCodes.equals) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.AsteriskEqualsToken;
        }
        else {
            return SyntaxKind.AsteriskToken;
        }
    }

    private scanEqualsToken(): SyntaxKind {
        this.slidingWindow.moveToNextItem();
        var character = this.currentCharCode()
        if (character === CharacterCodes.equals) {
            this.slidingWindow.moveToNextItem();

            if (this.currentCharCode() === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();

                return SyntaxKind.EqualsEqualsEqualsToken;
            }
            else {
                return SyntaxKind.EqualsEqualsToken;
            }
        }
        else if (character === CharacterCodes.greaterThan) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.EqualsGreaterThanToken;
        }
        else {
            return SyntaxKind.EqualsToken;
        }
    }

    private isDotPrefixedNumericLiteral(): bool {
        if (this.currentCharCode() === CharacterCodes.dot) {
            var ch = this.slidingWindow.peekItemN(1);
            return CharacterInfo.isDecimalDigit(ch);
        }

        return false;
    }

    private scanDotToken(): SyntaxKind {
        if (this.isDotPrefixedNumericLiteral()) {
            return this.scanNumericLiteral();
        }

        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === CharacterCodes.dot &&
            this.slidingWindow.peekItemN(1) === CharacterCodes.dot) {

            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.DotDotDotToken;
        }
        else {
            return SyntaxKind.DotToken;
        }
    }

    private scanSlashToken(allowRegularExpression: bool): SyntaxKind {
        // NOTE: By default, we do not try scanning a / as a regexp here.  We instead consider it a
        // div or div-assign.  Later on, if the parser runs into a situation where it would like a 
        // term, and it sees one of these then it may restart us asking specifically if we could 
        // scan out a regex.
        if (allowRegularExpression) {
            var result = this.tryScanRegularExpressionToken();
            if (result !== SyntaxKind.None) {
                return result;
            }
        }

        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === CharacterCodes.equals) {
            this.slidingWindow.moveToNextItem();
            return SyntaxKind.SlashEqualsToken;
        }
        else {
            return SyntaxKind.SlashToken;
        }
    }

    private tryScanRegularExpressionToken(): SyntaxKind {
        Debug.assert(this.currentCharCode() === CharacterCodes.slash);

        var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();
        try {
            this.slidingWindow.moveToNextItem();

            var inEscape = false;
            var inCharacterClass = false;
            while (true) {
                var ch = this.currentCharCode();
                if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                    this.slidingWindow.rewindToPinnedIndex(startIndex);
                    return SyntaxKind.None;
                }

                this.slidingWindow.moveToNextItem();
                if (inEscape) {
                    inEscape = false;
                    continue;
                }

                switch (ch) {
                    case CharacterCodes.backslash:
                        // We're now in an escape.  Consume the next character we see (unless it's
                        // a newline or null.
                        inEscape = true;
                        continue;
                
                    case CharacterCodes.openBracket:
                        // If we see a [ then we're starting an character class.  Note: it's ok if 
                        // we then hit another [ inside a character class.  We'll just set the value
                        // to true again and that's ok.
                        inCharacterClass = true;
                        continue;

                    case CharacterCodes.closeBracket:
                        // If we ever hit a cloe bracket then we're now no longer in a character 
                        // class.  If we weren't in a character class to begin with, then this has 
                        // no effect.
                        inCharacterClass = false;
                        continue;

                    case CharacterCodes.slash:
                        // If we see a slash, and we're in a character class, then ignore it.
                        if (inCharacterClass) {
                            continue;
                        }

                        // We're done with the regex.  Break out of the switch (which will break 
                        // out of hte loop.
                        break;

                    default:
                        // Just consume any other characters.
                        continue;
                }

                break;
            }

            // TODO: The grammar says any identifier part is allowed here.  Do we need to support
            // \u identifiers here?  The existing typescript parser does not.  
            while (Scanner.isIdentifierPartCharacter[this.currentCharCode()]) {
                this.slidingWindow.moveToNextItem();
            }

            return SyntaxKind.RegularExpressionLiteral;
        }
        finally {
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
        }
    }

    private scanExclamationToken(): SyntaxKind {
        this.slidingWindow.moveToNextItem();
        if (this.currentCharCode() === CharacterCodes.equals) {
            this.slidingWindow.moveToNextItem();

            if (this.currentCharCode() === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();

                return SyntaxKind.ExclamationEqualsEqualsToken;
            }
            else {
                return SyntaxKind.ExclamationEqualsToken;
            }
        }
        else {
            return SyntaxKind.ExclamationToken;
        }
    }

    private scanDefaultCharacter(character: number, diagnostics: SyntaxDiagnostic[]): SyntaxKind {
        var position = this.slidingWindow.absoluteIndex();
        this.slidingWindow.moveToNextItem();

        var text = String.fromCharCode(character);
        var messageText = this.getErrorMessageText(text);
        diagnostics.push(new SyntaxDiagnostic(
            position, 1, DiagnosticCode.Unexpected_character_0, [messageText]));

        return SyntaxKind.ErrorToken;
    }

    // Convert text into a printable form usable for an error message.  This will both quote the 
    // string, and ensure all characters printable (i.e. by using unicode escapes when they're not).
    private getErrorMessageText(text: string): string {
        // For just a simple backslash, we return it as is.  The default behavior of JSON2.stringify
        // is not what we want here.
        if (text === "\\") {
            return '"\\"';
        }

        return JSON2.stringify(text);
    }

    // Code for if we ever want the value of a string literal:
    //    private skipEscapeSequence(diagnostics: SyntaxDiagnostic[]): void {
    //    Debug.assert(this.currentCharCode() === CharacterCodes.backslash);

    //    var rewindPoint = this.slidingWindow.getAndPinAbsoluteIndex();
    //    try {
    //    // Consume the backslash.
    //        this.slidingWindow.moveToNextItem();

    //    // Get the char after the backslash
    //        var ch = this.currentCharCode();
    //        this.slidingWindow.moveToNextItem();
    //        switch (ch) {
    //            case CharacterCodes.singleQuote:
    //            case CharacterCodes.doubleQuote:
    //            case CharacterCodes.backslash:
    //                // value is ch itself;
    //                return;

    //            case CharacterCodes._0:
    //                // TODO: Deal with this part of the spec rule: 0 [lookahead ∉DecimalDigit]
    //                // value is CharacterCodes.nullCharacter;
    //                return;

    //            case CharacterCodes.b:
    //                // value is CharacterCodes.backspace;
    //                return;

    //            case CharacterCodes.f:
    //                // value is CharacterCodes.formFeed;
    //                return;

    //            case CharacterCodes.n:
    //                // value is CharacterCodes.newLine;
    //                return;

    //            case CharacterCodes.r:
    //                // value is CharacterCodes.carriageReturn;
    //                return;

    //            case CharacterCodes.t:
    //                // value is CharacterCodes.tab;
    //                return;

    //            case CharacterCodes.v:
    //                // value is CharacterCodes.verticalTab;
    //                return;

    //            case CharacterCodes.x:
    //            case CharacterCodes.u:
    //                this.rewind(rewindPoint);
    //                var value = this.scanUnicodeOrHexEscape(diagnostics);
    //                return;

    //            case CharacterCodes.carriageReturn:
    //                // If it's \r\n then consume both characters.
    //                if (this.currentCharCode() === CharacterCodes.lineFeed) {
    //                    this.slidingWindow.moveToNextItem();
    //                }
    //                return;
    //            case CharacterCodes.lineFeed:
    //            case CharacterCodes.paragraphSeparator:
    //            case CharacterCodes.lineSeparator:
    //                return;

    //            default:
    //                // Any other character is ok as well.  As per rule:
    //                // EscapeSequence :: CharacterEscapeSequence
    //                // CharacterEscapeSequence :: NonEscapeCharacter
    //                // NonEscapeCharacter :: SourceCharacter but notEscapeCharacter or LineTerminator
    //                return;
    //        }
    //    }
    //    finally {
    //        this.releaseAndUnpinAbsoluteIndex(rewindPoint);
    //    }
    //}

    private skipEscapeSequence(diagnostics: SyntaxDiagnostic[]): void {
        Debug.assert(this.currentCharCode() === CharacterCodes.backslash);

        var rewindPoint = this.slidingWindow.getAndPinAbsoluteIndex();
        try {
            // Consume the backslash.
            this.slidingWindow.moveToNextItem();

            // Get the char after the backslash
            var ch = this.currentCharCode();
            this.slidingWindow.moveToNextItem();
            switch (ch) {
                case CharacterCodes.x:
                case CharacterCodes.u:
                    this.slidingWindow.rewindToPinnedIndex(rewindPoint);
                    var value = this.scanUnicodeOrHexEscape(diagnostics);
                    return;

                case CharacterCodes.carriageReturn:
                    // If it's \r\n then consume both characters.
                    if (this.currentCharCode() === CharacterCodes.lineFeed) {
                        this.slidingWindow.moveToNextItem();
                    }
                    return;

                // We don't have to do anything special about these characters.  I'm including them
                // Just so it's clear that we intentially process them in the exact same way:
                //case CharacterCodes.singleQuote:
                //case CharacterCodes.doubleQuote:
                //case CharacterCodes.backslash:
                //case CharacterCodes._0:
                //case CharacterCodes.b:
                //case CharacterCodes.f:
                //case CharacterCodes.n:
                //case CharacterCodes.r:
                //case CharacterCodes.t:
                //case CharacterCodes.v:
                //case CharacterCodes.lineFeed:
                //case CharacterCodes.paragraphSeparator:
                //case CharacterCodes.lineSeparator:
                default:
                    // Any other character is ok as well.  As per rule:
                    // EscapeSequence :: CharacterEscapeSequence
                    // CharacterEscapeSequence :: NonEscapeCharacter
                    // NonEscapeCharacter :: SourceCharacter but notEscapeCharacter or LineTerminator
                    return;
            }
        }
        finally {
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(rewindPoint);
        }
    }

    private scanStringLiteral(diagnostics: SyntaxDiagnostic[]): SyntaxKind {
        var quoteCharacter = this.currentCharCode();

        Debug.assert(quoteCharacter === CharacterCodes.singleQuote || quoteCharacter === CharacterCodes.doubleQuote);

        this.slidingWindow.moveToNextItem();

        while (true) {
            var ch = this.currentCharCode();
            if (ch === CharacterCodes.backslash) {
                this.skipEscapeSequence(diagnostics);
            }
            else if (ch === quoteCharacter) {
                this.slidingWindow.moveToNextItem();
                break;
            }
            else if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                diagnostics.push(new SyntaxDiagnostic(
                    this.slidingWindow.absoluteIndex(), 1, DiagnosticCode.Missing_closing_quote_character, null));
                break;
            }
            else {
                this.slidingWindow.moveToNextItem();
            }
        }

        return SyntaxKind.StringLiteral;
    }

    private isUnicodeOrHexEscape(character: number): bool {
        return this.isUnicodeEscape(character) || this.isHexEscape(character);
    }

    private isUnicodeEscape(character: number): bool {
        if (character === CharacterCodes.backslash) {
            var ch2 = this.slidingWindow.peekItemN(1);
            if (ch2 === CharacterCodes.u) {
                return true;
            }
        }

        return false;
    }

    private isHexEscape(character: number): bool {
        if (character === CharacterCodes.backslash) {
            var ch2 = this.slidingWindow.peekItemN(1);
            if (ch2 === CharacterCodes.x) {
                return true;
            }
        }

        return false;
    }

    private peekCharOrUnicodeOrHexEscape(): number {
        var character = this.currentCharCode();
        if (this.isUnicodeOrHexEscape(character)) {
            return this.peekUnicodeOrHexEscape();
        }
        else {
            return character;
        }
    }

    private peekCharOrUnicodeEscape(): number {
        var character = this.currentCharCode();
        if (this.isUnicodeEscape(character)) {
            return this.peekUnicodeOrHexEscape();
        }
        else {
            return character;
        }
    }

    private peekUnicodeOrHexEscape(): number {
        var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();

        // if we're peeking, then we don't want to change the position
        var ch = this.scanUnicodeOrHexEscape(/*errors:*/ null);

        this.slidingWindow.rewindToPinnedIndex(startIndex);
        this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);

        return ch;
    }

    private scanCharOrUnicodeEscape(errors: SyntaxDiagnostic[]): number {
        var ch = this.currentCharCode();
        if (ch === CharacterCodes.backslash) {
            var ch2 = this.slidingWindow.peekItemN(1);
            if (ch2 === CharacterCodes.u) {
                return this.scanUnicodeOrHexEscape(errors);
            }
        }

        this.slidingWindow.moveToNextItem();
        return ch;
    }

    private scanCharOrUnicodeOrHexEscape(errors: SyntaxDiagnostic[]): number {
        var ch = this.currentCharCode();
        if (ch === CharacterCodes.backslash) {
            var ch2 = this.slidingWindow.peekItemN(1);
            if (ch2 === CharacterCodes.u || ch2 === CharacterCodes.x) {
                return this.scanUnicodeOrHexEscape(errors);
            }
        }

        this.slidingWindow.moveToNextItem();
        return ch;
    }

    private scanUnicodeOrHexEscape(errors: SyntaxDiagnostic[]): number {
        var start = this.slidingWindow.absoluteIndex();
        var character = this.currentCharCode();
        Debug.assert(character === CharacterCodes.backslash);
        this.slidingWindow.moveToNextItem();

        character = this.currentCharCode();
        Debug.assert(character === CharacterCodes.u || character === CharacterCodes.x);

        var intChar = 0;
        this.slidingWindow.moveToNextItem();

        var count = character === CharacterCodes.u ? 4 : 2;

        for (var i = 0; i < count; i++) {
            var ch2 = this.currentCharCode();
            if (!CharacterInfo.isHexDigit(ch2)) {
                if (errors !== null) {
                    var end = this.slidingWindow.absoluteIndex();
                    var info = this.createIllegalEscapeDiagnostic(start, end);
                    errors.push(info);
                }

                break;
            }

            intChar = (intChar << 4) + CharacterInfo.hexValue(ch2);
            this.slidingWindow.moveToNextItem();
        }

        return intChar;
    }

    public substring(start: number, end: number, intern: bool): string {
        var length = end - start;
        var offset = start - this.slidingWindow.windowAbsoluteStartIndex;

        Debug.assert(offset >= 0);
        if (intern) {
            return this.stringTable.addCharArray(this.slidingWindow.window, offset, length);
        }
        else {
            return StringUtilities.fromCharCodeArray(this.slidingWindow.window.slice(offset, offset + length));
        }
    }

    private createIllegalEscapeDiagnostic(start: number, end: number): SyntaxDiagnostic {
        return new SyntaxDiagnostic(start, end - start,
            DiagnosticCode.Unrecognized_escape_sequence, null);
    }
}
///<reference path='ISyntaxToken.ts' />
///<reference path='..\Core\Hash.ts' />
///<reference path='Scanner.ts' />

module Syntax {
    export function realize(token: ISyntaxToken): ISyntaxToken {
        return new RealizedToken(token.tokenKind,
            token.leadingTrivia(), token.text(), token.value(), token.trailingTrivia());
    }

    export function tokenToJSON(token: ISyntaxToken) {
        var result: any = {};

        result.kind = (<any>SyntaxKind)._map[token.kind()];

        result.width = token.width();
        if (token.fullWidth() !== token.width()) {
            result.fullWidth = token.fullWidth();
        }

        result.text = token.text();

        if (token.value() !== null) {
            result.valueText = token.value();
        }

        if (token.hasLeadingTrivia()) {
            result.hasLeadingTrivia = true;
        }

        if (token.hasLeadingComment()) {
            result.hasLeadingComment = true;
        }

        if (token.hasLeadingNewLine()) {
            result.hasLeadingNewLine = true;
        }

        if (token.hasLeadingSkippedText()) {
            result.hasLeadingSkippedText = true;
        }

        if (token.hasTrailingTrivia()) {
            result.hasTrailingTrivia = true;
        }

        if (token.hasTrailingComment()) {
            result.hasTrailingComment = true;
        }

        if (token.hasTrailingNewLine()) {
            result.hasTrailingNewLine = true;
        }

        if (token.hasTrailingSkippedText()) {
            result.hasTrailingSkippedText = true;
        }

        var trivia = token.leadingTrivia();
        if (trivia.count() > 0) {
            result.leadingTrivia = trivia;
        }

        trivia = token.trailingTrivia();
        if (trivia.count() > 0) {
            result.trailingTrivia = trivia;
        }

        return result;
    }

    export function value(token: ISyntaxToken): any {
        if (token.tokenKind === SyntaxKind.IdentifierName) {
            var text = token.text();
            for (var i = 0; i < text.length; i++) {
                // TODO: handle unicode and escapes.
                if (!Scanner.isIdentifierPartCharacter[text.charCodeAt(i)]) {
                    return null;
                }
            }

            return text;
        }
        else if (token.tokenKind === SyntaxKind.NumericLiteral) {
            // TODO: implement this.
            return null;
        }
        else if (token.tokenKind === SyntaxKind.StringLiteral) {
            // TODO: implement this.
            return null;
        }
        else if (token.tokenKind === SyntaxKind.RegularExpressionLiteral) {
            // TODO: implement this.
            return null;
        }
        else if (token.tokenKind === SyntaxKind.EndOfFileToken || token.tokenKind === SyntaxKind.ErrorToken) {
            return null;
        }
        else {
            throw Errors.invalidOperation();
        }
    }

    class EmptyToken implements ISyntaxToken {
        public tokenKind: SyntaxKind;

        constructor(kind: SyntaxKind) {
            this.tokenKind = kind;
        }

        public clone(): ISyntaxToken {
            return new EmptyToken(this.tokenKind);
        }

        public kind() { return this.tokenKind; }

        public isToken(): bool { return true; }
        public isNode(): bool { return false; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public childCount(): number {
            return 0;
        }

        public childAt(index: number): ISyntaxElement {
            throw Errors.argumentOutOfRange("index");
        }

        public toJSON(key) { return tokenToJSON(this); }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }

        public fullWidth() { return 0; }
        public width() { return 0; }
        public text() { return ""; }
        public fullText(): string { return ""; }
        public value() { return null; }

        public hasLeadingTrivia() { return false; }
        public hasLeadingComment() { return false; }
        public hasLeadingNewLine() { return false; }
        public hasLeadingSkippedText() { return false; }
        public leadingTriviaWidth() { return 0; }
        public hasTrailingTrivia() { return false; }
        public hasTrailingComment() { return false; }
        public hasTrailingNewLine() { return false; }
        public hasTrailingSkippedText() { return false; }
        public hasSkippedText() { return false; }

        public trailingTriviaWidth() { return 0; }
        public leadingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }
        public trailingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }
        public realize(): ISyntaxToken { return realize(this); }
        private collectTextElements(elements: string[]): void { }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export function emptyToken(kind: SyntaxKind): ISyntaxToken {
        return new EmptyToken(kind);
    }

    class RealizedToken implements ISyntaxToken {
        public tokenKind: SyntaxKind;
        // public tokenKeywordKind: SyntaxKind;
        private _leadingTrivia: ISyntaxTriviaList;
        private _text: string;
        private _value: any;
        private _trailingTrivia: ISyntaxTriviaList;

        constructor(tokenKind: SyntaxKind,
                    leadingTrivia: ISyntaxTriviaList,
                    text: string,
                    value: any,
                    trailingTrivia: ISyntaxTriviaList) {
            this.tokenKind = tokenKind;
            this._leadingTrivia = leadingTrivia;
            this._text = text;
            this._value = value;
            this._trailingTrivia = trailingTrivia;
        }

        public clone(): ISyntaxToken {
            return new RealizedToken(this.tokenKind, /*this.tokenKeywordKind,*/ this._leadingTrivia,
                this._text, this._value, this._trailingTrivia);
        }

        public kind(): SyntaxKind { return this.tokenKind; }
        public toJSON(key) { return tokenToJSON(this); }
        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.kind()); }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }

        public childCount(): number {
            return 0;
        }

        public childAt(index: number): ISyntaxElement {
            throw Errors.argumentOutOfRange("index");
        }

        public isToken(): bool { return true; }
        public isNode(): bool { return false; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }
        public isTrivia(): bool { return false; }
        public isTriviaList(): bool { return false; }

        public fullWidth(): number { return this._leadingTrivia.fullWidth() + this.width() + this._trailingTrivia.fullWidth(); }
        public width(): number { return this.text().length; }

        public text(): string { return this._text; }
        public fullText(): string { return this._leadingTrivia.fullText() + this.text() + this._trailingTrivia.fullText(); }

        public value(): any { return this._value; }

        public hasLeadingTrivia(): bool { return this._leadingTrivia.count() > 0; }
        public hasLeadingComment(): bool { return this._leadingTrivia.hasComment(); }
        public hasLeadingNewLine(): bool { return this._leadingTrivia.hasNewLine(); }
        public hasLeadingSkippedText(): bool { return this._leadingTrivia.hasSkippedText(); }
        public leadingTriviaWidth(): number { return this._leadingTrivia.fullWidth(); }

        public hasTrailingTrivia(): bool { return this._trailingTrivia.count() > 0; }
        public hasTrailingComment(): bool { return this._trailingTrivia.hasComment(); }
        public hasTrailingNewLine(): bool { return this._trailingTrivia.hasNewLine(); }
        public hasTrailingSkippedText(): bool { return this._trailingTrivia.hasSkippedText(); }
        public trailingTriviaWidth(): number { return this._trailingTrivia.fullWidth(); }

        public hasSkippedText(): bool { return this.hasLeadingSkippedText() || this.hasTrailingSkippedText(); }

        public leadingTrivia(): ISyntaxTriviaList { return this._leadingTrivia; }
        public trailingTrivia(): ISyntaxTriviaList { return this._trailingTrivia; }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        private collectTextElements(elements: string[]): void {
            this.leadingTrivia().collectTextElements(elements);
            elements.push(this.text());
            this.trailingTrivia().collectTextElements(elements);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return new RealizedToken(
                this.tokenKind, /*this.tokenKeywordKind,*/
                leadingTrivia, this._text, this._value,
                this._trailingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return new RealizedToken(
                this.tokenKind, /*this.tokenKeywordKind,*/
                this._leadingTrivia, this._text, this._value,
                trailingTrivia);
        }
    }

    export function token(kind: SyntaxKind, info: ITokenInfo = null): ISyntaxToken {
        var text = (info !== null && info.text !== undefined) ? info.text : SyntaxFacts.getText(kind);
        var value = (info !== null && info.value !== undefined) ? info.value : null;

        return new RealizedToken(
            kind,
            Syntax.triviaList(info === null ? null : info.leadingTrivia),
            text,
            value,
            Syntax.triviaList(info === null ? null : info.trailingTrivia));
    }
    
    export function identifier(text: string, info: ITokenInfo = null): ISyntaxToken {
        info = info || {};
        info.text = text;
        return token(SyntaxKind.IdentifierName, info);
    }
}
﻿///<reference path='ISyntaxList.ts' />

module Syntax {
    export interface IFactory {
        sourceUnit(moduleElements: ISyntaxList, endOfFileToken: ISyntaxToken): SourceUnitSyntax;
        externalModuleReference(moduleKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax;
        moduleNameModuleReference(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax;
        importDeclaration(importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: ModuleReferenceSyntax, semicolonToken: ISyntaxToken): ImportDeclarationSyntax;
        classDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, implementsClause: ImplementsClauseSyntax, openBraceToken: ISyntaxToken, classElements: ISyntaxList, closeBraceToken: ISyntaxToken): ClassDeclarationSyntax;
        interfaceDeclaration(exportKeyword: ISyntaxToken, interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, body: ObjectTypeSyntax): InterfaceDeclarationSyntax;
        extendsClause(extendsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax;
        implementsClause(implementsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax;
        moduleDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, moduleKeyword: ISyntaxToken, moduleName: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: ISyntaxList, closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax;
        functionDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, functionKeyword: ISyntaxToken, functionSignature: FunctionSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): FunctionDeclarationSyntax;
        variableStatement(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken): VariableStatementSyntax;
        variableDeclaration(varKeyword: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax;
        variableDeclarator(identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax;
        equalsValueClause(equalsToken: ISyntaxToken, value: IExpressionSyntax): EqualsValueClauseSyntax;
        prefixUnaryExpression(kind: SyntaxKind, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax;
        arrayLiteralExpression(openBracketToken: ISyntaxToken, expressions: ISeparatedSyntaxList, closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax;
        omittedExpression(): OmittedExpressionSyntax;
        parenthesizedExpression(openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax;
        simpleArrowFunctionExpression(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax;
        parenthesizedArrowFunctionExpression(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax;
        qualifiedName(left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken): QualifiedNameSyntax;
        typeArgumentList(lessThanToken: ISyntaxToken, typeArguments: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeArgumentListSyntax;
        constructorType(newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): ConstructorTypeSyntax;
        functionType(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): FunctionTypeSyntax;
        objectType(openBraceToken: ISyntaxToken, typeMembers: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectTypeSyntax;
        arrayType(type: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken): ArrayTypeSyntax;
        genericType(name: INameSyntax, typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax;
        typeAnnotation(colonToken: ISyntaxToken, type: ITypeSyntax): TypeAnnotationSyntax;
        block(openBraceToken: ISyntaxToken, statements: ISyntaxList, closeBraceToken: ISyntaxToken): BlockSyntax;
        parameter(dotDotDotToken: ISyntaxToken, publicOrPrivateKeyword: ISyntaxToken, identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax;
        memberAccessExpression(expression: IExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken): MemberAccessExpressionSyntax;
        postfixUnaryExpression(kind: SyntaxKind, operand: IExpressionSyntax, operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax;
        elementAccessExpression(expression: IExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax;
        invocationExpression(expression: IExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax;
        argumentList(typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, arguments: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ArgumentListSyntax;
        binaryExpression(kind: SyntaxKind, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax;
        conditionalExpression(condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax): ConditionalExpressionSyntax;
        constructSignature(newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax): ConstructSignatureSyntax;
        functionSignature(identifier: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax): FunctionSignatureSyntax;
        indexSignature(openBracketToken: ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax;
        propertySignature(identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax;
        parameterList(openParenToken: ISyntaxToken, parameters: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ParameterListSyntax;
        callSignature(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax;
        typeParameterList(lessThanToken: ISyntaxToken, typeParameters: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeParameterListSyntax;
        typeParameter(identifier: ISyntaxToken, constraint: ConstraintSyntax): TypeParameterSyntax;
        constraint(extendsKeyword: ISyntaxToken, type: ITypeSyntax): ConstraintSyntax;
        elseClause(elseKeyword: ISyntaxToken, statement: IStatementSyntax): ElseClauseSyntax;
        ifStatement(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax): IfStatementSyntax;
        expressionStatement(expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ExpressionStatementSyntax;
        constructorDeclaration(constructorKeyword: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax;
        memberFunctionDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, functionSignature: FunctionSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax;
        getMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, getKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetMemberAccessorDeclarationSyntax;
        setMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, setKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetMemberAccessorDeclarationSyntax;
        memberVariableDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax;
        throwStatement(throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ThrowStatementSyntax;
        returnStatement(returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ReturnStatementSyntax;
        objectCreationExpression(newKeyword: ISyntaxToken, expression: IExpressionSyntax, argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax;
        switchStatement(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISyntaxList, closeBraceToken: ISyntaxToken): SwitchStatementSyntax;
        caseSwitchClause(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: ISyntaxList): CaseSwitchClauseSyntax;
        defaultSwitchClause(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: ISyntaxList): DefaultSwitchClauseSyntax;
        breakStatement(breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): BreakStatementSyntax;
        continueStatement(continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ContinueStatementSyntax;
        forStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForStatementSyntax;
        forInStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForInStatementSyntax;
        whileStatement(whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WhileStatementSyntax;
        withStatement(withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WithStatementSyntax;
        enumDeclaration(exportKeyword: ISyntaxToken, enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): EnumDeclarationSyntax;
        castExpression(lessThanToken: ISyntaxToken, type: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax): CastExpressionSyntax;
        objectLiteralExpression(openBraceToken: ISyntaxToken, propertyAssignments: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax;
        simplePropertyAssignment(propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax): SimplePropertyAssignmentSyntax;
        getAccessorPropertyAssignment(getKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, closeParenToken: ISyntaxToken, block: BlockSyntax): GetAccessorPropertyAssignmentSyntax;
        setAccessorPropertyAssignment(setKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, parameterName: ISyntaxToken, closeParenToken: ISyntaxToken, block: BlockSyntax): SetAccessorPropertyAssignmentSyntax;
        functionExpression(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax;
        emptyStatement(semicolonToken: ISyntaxToken): EmptyStatementSyntax;
        tryStatement(tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax): TryStatementSyntax;
        catchClause(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, closeParenToken: ISyntaxToken, block: BlockSyntax): CatchClauseSyntax;
        finallyClause(finallyKeyword: ISyntaxToken, block: BlockSyntax): FinallyClauseSyntax;
        labeledStatement(identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax): LabeledStatementSyntax;
        doStatement(doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken): DoStatementSyntax;
        typeOfExpression(typeOfKeyword: ISyntaxToken, expression: IExpressionSyntax): TypeOfExpressionSyntax;
        deleteExpression(deleteKeyword: ISyntaxToken, expression: IExpressionSyntax): DeleteExpressionSyntax;
        voidExpression(voidKeyword: ISyntaxToken, expression: IExpressionSyntax): VoidExpressionSyntax;
        debuggerStatement(debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): DebuggerStatementSyntax;
    }

    class NormalModeFactory implements IFactory {
        sourceUnit(moduleElements: ISyntaxList, endOfFileToken: ISyntaxToken): SourceUnitSyntax {
            return new SourceUnitSyntax(moduleElements, endOfFileToken, /*parsedInStrictMode:*/ false);
        }
        externalModuleReference(moduleKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax {
            return new ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, /*parsedInStrictMode:*/ false);
        }
        moduleNameModuleReference(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax {
            return new ModuleNameModuleReferenceSyntax(moduleName, /*parsedInStrictMode:*/ false);
        }
        importDeclaration(importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: ModuleReferenceSyntax, semicolonToken: ISyntaxToken): ImportDeclarationSyntax {
            return new ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        classDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, implementsClause: ImplementsClauseSyntax, openBraceToken: ISyntaxToken, classElements: ISyntaxList, closeBraceToken: ISyntaxToken): ClassDeclarationSyntax {
            return new ClassDeclarationSyntax(exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        interfaceDeclaration(exportKeyword: ISyntaxToken, interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, body: ObjectTypeSyntax): InterfaceDeclarationSyntax {
            return new InterfaceDeclarationSyntax(exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body, /*parsedInStrictMode:*/ false);
        }
        extendsClause(extendsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax {
            return new ExtendsClauseSyntax(extendsKeyword, typeNames, /*parsedInStrictMode:*/ false);
        }
        implementsClause(implementsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax {
            return new ImplementsClauseSyntax(implementsKeyword, typeNames, /*parsedInStrictMode:*/ false);
        }
        moduleDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, moduleKeyword: ISyntaxToken, moduleName: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: ISyntaxList, closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
            return new ModuleDeclarationSyntax(exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        functionDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, functionKeyword: ISyntaxToken, functionSignature: FunctionSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): FunctionDeclarationSyntax {
            return new FunctionDeclarationSyntax(exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        variableStatement(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken): VariableStatementSyntax {
            return new VariableStatementSyntax(exportKeyword, declareKeyword, variableDeclaration, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        variableDeclaration(varKeyword: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax {
            return new VariableDeclarationSyntax(varKeyword, variableDeclarators, /*parsedInStrictMode:*/ false);
        }
        variableDeclarator(identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax {
            return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ false);
        }
        equalsValueClause(equalsToken: ISyntaxToken, value: IExpressionSyntax): EqualsValueClauseSyntax {
            return new EqualsValueClauseSyntax(equalsToken, value, /*parsedInStrictMode:*/ false);
        }
        prefixUnaryExpression(kind: SyntaxKind, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax {
            return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, /*parsedInStrictMode:*/ false);
        }
        arrayLiteralExpression(openBracketToken: ISyntaxToken, expressions: ISeparatedSyntaxList, closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
            return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, /*parsedInStrictMode:*/ false);
        }
        omittedExpression(): OmittedExpressionSyntax {
            return new OmittedExpressionSyntax(/*parsedInStrictMode:*/ false);
        }
        parenthesizedExpression(openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax {
            return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, /*parsedInStrictMode:*/ false);
        }
        simpleArrowFunctionExpression(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax {
            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ false);
        }
        parenthesizedArrowFunctionExpression(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax {
            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ false);
        }
        qualifiedName(left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken): QualifiedNameSyntax {
            return new QualifiedNameSyntax(left, dotToken, right, /*parsedInStrictMode:*/ false);
        }
        typeArgumentList(lessThanToken: ISyntaxToken, typeArguments: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeArgumentListSyntax {
            return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, /*parsedInStrictMode:*/ false);
        }
        constructorType(newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): ConstructorTypeSyntax {
            return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ false);
        }
        functionType(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): FunctionTypeSyntax {
            return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ false);
        }
        objectType(openBraceToken: ISyntaxToken, typeMembers: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectTypeSyntax {
            return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        arrayType(type: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken): ArrayTypeSyntax {
            return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, /*parsedInStrictMode:*/ false);
        }
        genericType(name: INameSyntax, typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax {
            return new GenericTypeSyntax(name, typeArgumentList, /*parsedInStrictMode:*/ false);
        }
        typeAnnotation(colonToken: ISyntaxToken, type: ITypeSyntax): TypeAnnotationSyntax {
            return new TypeAnnotationSyntax(colonToken, type, /*parsedInStrictMode:*/ false);
        }
        block(openBraceToken: ISyntaxToken, statements: ISyntaxList, closeBraceToken: ISyntaxToken): BlockSyntax {
            return new BlockSyntax(openBraceToken, statements, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        parameter(dotDotDotToken: ISyntaxToken, publicOrPrivateKeyword: ISyntaxToken, identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax {
            return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ false);
        }
        memberAccessExpression(expression: IExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken): MemberAccessExpressionSyntax {
            return new MemberAccessExpressionSyntax(expression, dotToken, name, /*parsedInStrictMode:*/ false);
        }
        postfixUnaryExpression(kind: SyntaxKind, operand: IExpressionSyntax, operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax {
            return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, /*parsedInStrictMode:*/ false);
        }
        elementAccessExpression(expression: IExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax {
            return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, /*parsedInStrictMode:*/ false);
        }
        invocationExpression(expression: IExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax {
            return new InvocationExpressionSyntax(expression, argumentList, /*parsedInStrictMode:*/ false);
        }
        argumentList(typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, _arguments: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ArgumentListSyntax {
            return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, /*parsedInStrictMode:*/ false);
        }
        binaryExpression(kind: SyntaxKind, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax {
            return new BinaryExpressionSyntax(kind, left, operatorToken, right, /*parsedInStrictMode:*/ false);
        }
        conditionalExpression(condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax): ConditionalExpressionSyntax {
            return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, /*parsedInStrictMode:*/ false);
        }
        constructSignature(newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax): ConstructSignatureSyntax {
            return new ConstructSignatureSyntax(newKeyword, callSignature, /*parsedInStrictMode:*/ false);
        }
        functionSignature(identifier: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax): FunctionSignatureSyntax {
            return new FunctionSignatureSyntax(identifier, questionToken, callSignature, /*parsedInStrictMode:*/ false);
        }
        indexSignature(openBracketToken: ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax {
            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, /*parsedInStrictMode:*/ false);
        }
        propertySignature(identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax {
            return new PropertySignatureSyntax(identifier, questionToken, typeAnnotation, /*parsedInStrictMode:*/ false);
        }
        parameterList(openParenToken: ISyntaxToken, parameters: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ParameterListSyntax {
            return new ParameterListSyntax(openParenToken, parameters, closeParenToken, /*parsedInStrictMode:*/ false);
        }
        callSignature(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax {
            return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, /*parsedInStrictMode:*/ false);
        }
        typeParameterList(lessThanToken: ISyntaxToken, typeParameters: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeParameterListSyntax {
            return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, /*parsedInStrictMode:*/ false);
        }
        typeParameter(identifier: ISyntaxToken, constraint: ConstraintSyntax): TypeParameterSyntax {
            return new TypeParameterSyntax(identifier, constraint, /*parsedInStrictMode:*/ false);
        }
        constraint(extendsKeyword: ISyntaxToken, type: ITypeSyntax): ConstraintSyntax {
            return new ConstraintSyntax(extendsKeyword, type, /*parsedInStrictMode:*/ false);
        }
        elseClause(elseKeyword: ISyntaxToken, statement: IStatementSyntax): ElseClauseSyntax {
            return new ElseClauseSyntax(elseKeyword, statement, /*parsedInStrictMode:*/ false);
        }
        ifStatement(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax): IfStatementSyntax {
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, /*parsedInStrictMode:*/ false);
        }
        expressionStatement(expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ExpressionStatementSyntax {
            return new ExpressionStatementSyntax(expression, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        constructorDeclaration(constructorKeyword: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax {
            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        memberFunctionDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, functionSignature: FunctionSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax {
            return new MemberFunctionDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        getMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, getKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetMemberAccessorDeclarationSyntax {
            return new GetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block, /*parsedInStrictMode:*/ false);
        }
        setMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, setKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetMemberAccessorDeclarationSyntax {
            return new SetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block, /*parsedInStrictMode:*/ false);
        }
        memberVariableDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax {
            return new MemberVariableDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        throwStatement(throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ThrowStatementSyntax {
            return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        returnStatement(returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ReturnStatementSyntax {
            return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        objectCreationExpression(newKeyword: ISyntaxToken, expression: IExpressionSyntax, argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax {
            return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, /*parsedInStrictMode:*/ false);
        }
        switchStatement(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISyntaxList, closeBraceToken: ISyntaxToken): SwitchStatementSyntax {
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        caseSwitchClause(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: ISyntaxList): CaseSwitchClauseSyntax {
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, /*parsedInStrictMode:*/ false);
        }
        defaultSwitchClause(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: ISyntaxList): DefaultSwitchClauseSyntax {
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, /*parsedInStrictMode:*/ false);
        }
        breakStatement(breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): BreakStatementSyntax {
            return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        continueStatement(continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ContinueStatementSyntax {
            return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        forStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForStatementSyntax {
            return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, /*parsedInStrictMode:*/ false);
        }
        forInStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForInStatementSyntax {
            return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, /*parsedInStrictMode:*/ false);
        }
        whileStatement(whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WhileStatementSyntax {
            return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ false);
        }
        withStatement(withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WithStatementSyntax {
            return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ false);
        }
        enumDeclaration(exportKeyword: ISyntaxToken, enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): EnumDeclarationSyntax {
            return new EnumDeclarationSyntax(exportKeyword, enumKeyword, identifier, openBraceToken, variableDeclarators, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        castExpression(lessThanToken: ISyntaxToken, type: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax): CastExpressionSyntax {
            return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, /*parsedInStrictMode:*/ false);
        }
        objectLiteralExpression(openBraceToken: ISyntaxToken, propertyAssignments: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
            return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        simplePropertyAssignment(propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax): SimplePropertyAssignmentSyntax {
            return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, /*parsedInStrictMode:*/ false);
        }
        getAccessorPropertyAssignment(getKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, closeParenToken: ISyntaxToken, block: BlockSyntax): GetAccessorPropertyAssignmentSyntax {
            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, block, /*parsedInStrictMode:*/ false);
        }
        setAccessorPropertyAssignment(setKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, parameterName: ISyntaxToken, closeParenToken: ISyntaxToken, block: BlockSyntax): SetAccessorPropertyAssignmentSyntax {
            return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block, /*parsedInStrictMode:*/ false);
        }
        functionExpression(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax {
            return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, /*parsedInStrictMode:*/ false);
        }
        emptyStatement(semicolonToken: ISyntaxToken): EmptyStatementSyntax {
            return new EmptyStatementSyntax(semicolonToken, /*parsedInStrictMode:*/ false);
        }
        tryStatement(tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax): TryStatementSyntax {
            return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, /*parsedInStrictMode:*/ false);
        }
        catchClause(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, closeParenToken: ISyntaxToken, block: BlockSyntax): CatchClauseSyntax {
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, closeParenToken, block, /*parsedInStrictMode:*/ false);
        }
        finallyClause(finallyKeyword: ISyntaxToken, block: BlockSyntax): FinallyClauseSyntax {
            return new FinallyClauseSyntax(finallyKeyword, block, /*parsedInStrictMode:*/ false);
        }
        labeledStatement(identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax): LabeledStatementSyntax {
            return new LabeledStatementSyntax(identifier, colonToken, statement, /*parsedInStrictMode:*/ false);
        }
        doStatement(doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken): DoStatementSyntax {
            return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        typeOfExpression(typeOfKeyword: ISyntaxToken, expression: IExpressionSyntax): TypeOfExpressionSyntax {
            return new TypeOfExpressionSyntax(typeOfKeyword, expression, /*parsedInStrictMode:*/ false);
        }
        deleteExpression(deleteKeyword: ISyntaxToken, expression: IExpressionSyntax): DeleteExpressionSyntax {
            return new DeleteExpressionSyntax(deleteKeyword, expression, /*parsedInStrictMode:*/ false);
        }
        voidExpression(voidKeyword: ISyntaxToken, expression: IExpressionSyntax): VoidExpressionSyntax {
            return new VoidExpressionSyntax(voidKeyword, expression, /*parsedInStrictMode:*/ false);
        }
        debuggerStatement(debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): DebuggerStatementSyntax {
            return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, /*parsedInStrictMode:*/ false);
        }
    }

    class StrictModeFactory implements IFactory {
        sourceUnit(moduleElements: ISyntaxList, endOfFileToken: ISyntaxToken): SourceUnitSyntax {
            return new SourceUnitSyntax(moduleElements, endOfFileToken, /*parsedInStrictMode:*/ true);
        }
        externalModuleReference(moduleKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax {
            return new ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, /*parsedInStrictMode:*/ true);
        }
        moduleNameModuleReference(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax {
            return new ModuleNameModuleReferenceSyntax(moduleName, /*parsedInStrictMode:*/ true);
        }
        importDeclaration(importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: ModuleReferenceSyntax, semicolonToken: ISyntaxToken): ImportDeclarationSyntax {
            return new ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        classDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, implementsClause: ImplementsClauseSyntax, openBraceToken: ISyntaxToken, classElements: ISyntaxList, closeBraceToken: ISyntaxToken): ClassDeclarationSyntax {
            return new ClassDeclarationSyntax(exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        interfaceDeclaration(exportKeyword: ISyntaxToken, interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, body: ObjectTypeSyntax): InterfaceDeclarationSyntax {
            return new InterfaceDeclarationSyntax(exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body, /*parsedInStrictMode:*/ true);
        }
        extendsClause(extendsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax {
            return new ExtendsClauseSyntax(extendsKeyword, typeNames, /*parsedInStrictMode:*/ true);
        }
        implementsClause(implementsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax {
            return new ImplementsClauseSyntax(implementsKeyword, typeNames, /*parsedInStrictMode:*/ true);
        }
        moduleDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, moduleKeyword: ISyntaxToken, moduleName: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: ISyntaxList, closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
            return new ModuleDeclarationSyntax(exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        functionDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, functionKeyword: ISyntaxToken, functionSignature: FunctionSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): FunctionDeclarationSyntax {
            return new FunctionDeclarationSyntax(exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        variableStatement(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken): VariableStatementSyntax {
            return new VariableStatementSyntax(exportKeyword, declareKeyword, variableDeclaration, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        variableDeclaration(varKeyword: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax {
            return new VariableDeclarationSyntax(varKeyword, variableDeclarators, /*parsedInStrictMode:*/ true);
        }
        variableDeclarator(identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax {
            return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ true);
        }
        equalsValueClause(equalsToken: ISyntaxToken, value: IExpressionSyntax): EqualsValueClauseSyntax {
            return new EqualsValueClauseSyntax(equalsToken, value, /*parsedInStrictMode:*/ true);
        }
        prefixUnaryExpression(kind: SyntaxKind, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax {
            return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, /*parsedInStrictMode:*/ true);
        }
        arrayLiteralExpression(openBracketToken: ISyntaxToken, expressions: ISeparatedSyntaxList, closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
            return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, /*parsedInStrictMode:*/ true);
        }
        omittedExpression(): OmittedExpressionSyntax {
            return new OmittedExpressionSyntax(/*parsedInStrictMode:*/ true);
        }
        parenthesizedExpression(openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax {
            return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, /*parsedInStrictMode:*/ true);
        }
        simpleArrowFunctionExpression(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax {
            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ true);
        }
        parenthesizedArrowFunctionExpression(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax {
            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ true);
        }
        qualifiedName(left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken): QualifiedNameSyntax {
            return new QualifiedNameSyntax(left, dotToken, right, /*parsedInStrictMode:*/ true);
        }
        typeArgumentList(lessThanToken: ISyntaxToken, typeArguments: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeArgumentListSyntax {
            return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, /*parsedInStrictMode:*/ true);
        }
        constructorType(newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): ConstructorTypeSyntax {
            return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ true);
        }
        functionType(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): FunctionTypeSyntax {
            return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ true);
        }
        objectType(openBraceToken: ISyntaxToken, typeMembers: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectTypeSyntax {
            return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        arrayType(type: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken): ArrayTypeSyntax {
            return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, /*parsedInStrictMode:*/ true);
        }
        genericType(name: INameSyntax, typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax {
            return new GenericTypeSyntax(name, typeArgumentList, /*parsedInStrictMode:*/ true);
        }
        typeAnnotation(colonToken: ISyntaxToken, type: ITypeSyntax): TypeAnnotationSyntax {
            return new TypeAnnotationSyntax(colonToken, type, /*parsedInStrictMode:*/ true);
        }
        block(openBraceToken: ISyntaxToken, statements: ISyntaxList, closeBraceToken: ISyntaxToken): BlockSyntax {
            return new BlockSyntax(openBraceToken, statements, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        parameter(dotDotDotToken: ISyntaxToken, publicOrPrivateKeyword: ISyntaxToken, identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax {
            return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ true);
        }
        memberAccessExpression(expression: IExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken): MemberAccessExpressionSyntax {
            return new MemberAccessExpressionSyntax(expression, dotToken, name, /*parsedInStrictMode:*/ true);
        }
        postfixUnaryExpression(kind: SyntaxKind, operand: IExpressionSyntax, operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax {
            return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, /*parsedInStrictMode:*/ true);
        }
        elementAccessExpression(expression: IExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax {
            return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, /*parsedInStrictMode:*/ true);
        }
        invocationExpression(expression: IExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax {
            return new InvocationExpressionSyntax(expression, argumentList, /*parsedInStrictMode:*/ true);
        }
        argumentList(typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, _arguments: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ArgumentListSyntax {
            return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, /*parsedInStrictMode:*/ true);
        }
        binaryExpression(kind: SyntaxKind, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax {
            return new BinaryExpressionSyntax(kind, left, operatorToken, right, /*parsedInStrictMode:*/ true);
        }
        conditionalExpression(condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax): ConditionalExpressionSyntax {
            return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, /*parsedInStrictMode:*/ true);
        }
        constructSignature(newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax): ConstructSignatureSyntax {
            return new ConstructSignatureSyntax(newKeyword, callSignature, /*parsedInStrictMode:*/ true);
        }
        functionSignature(identifier: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax): FunctionSignatureSyntax {
            return new FunctionSignatureSyntax(identifier, questionToken, callSignature, /*parsedInStrictMode:*/ true);
        }
        indexSignature(openBracketToken: ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax {
            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, /*parsedInStrictMode:*/ true);
        }
        propertySignature(identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax {
            return new PropertySignatureSyntax(identifier, questionToken, typeAnnotation, /*parsedInStrictMode:*/ true);
        }
        parameterList(openParenToken: ISyntaxToken, parameters: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ParameterListSyntax {
            return new ParameterListSyntax(openParenToken, parameters, closeParenToken, /*parsedInStrictMode:*/ true);
        }
        callSignature(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax {
            return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, /*parsedInStrictMode:*/ true);
        }
        typeParameterList(lessThanToken: ISyntaxToken, typeParameters: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeParameterListSyntax {
            return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, /*parsedInStrictMode:*/ true);
        }
        typeParameter(identifier: ISyntaxToken, constraint: ConstraintSyntax): TypeParameterSyntax {
            return new TypeParameterSyntax(identifier, constraint, /*parsedInStrictMode:*/ true);
        }
        constraint(extendsKeyword: ISyntaxToken, type: ITypeSyntax): ConstraintSyntax {
            return new ConstraintSyntax(extendsKeyword, type, /*parsedInStrictMode:*/ true);
        }
        elseClause(elseKeyword: ISyntaxToken, statement: IStatementSyntax): ElseClauseSyntax {
            return new ElseClauseSyntax(elseKeyword, statement, /*parsedInStrictMode:*/ true);
        }
        ifStatement(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax): IfStatementSyntax {
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, /*parsedInStrictMode:*/ true);
        }
        expressionStatement(expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ExpressionStatementSyntax {
            return new ExpressionStatementSyntax(expression, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        constructorDeclaration(constructorKeyword: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax {
            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        memberFunctionDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, functionSignature: FunctionSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax {
            return new MemberFunctionDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        getMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, getKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetMemberAccessorDeclarationSyntax {
            return new GetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block, /*parsedInStrictMode:*/ true);
        }
        setMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, setKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetMemberAccessorDeclarationSyntax {
            return new SetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block, /*parsedInStrictMode:*/ true);
        }
        memberVariableDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax {
            return new MemberVariableDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        throwStatement(throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ThrowStatementSyntax {
            return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        returnStatement(returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ReturnStatementSyntax {
            return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        objectCreationExpression(newKeyword: ISyntaxToken, expression: IExpressionSyntax, argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax {
            return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, /*parsedInStrictMode:*/ true);
        }
        switchStatement(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISyntaxList, closeBraceToken: ISyntaxToken): SwitchStatementSyntax {
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        caseSwitchClause(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: ISyntaxList): CaseSwitchClauseSyntax {
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, /*parsedInStrictMode:*/ true);
        }
        defaultSwitchClause(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: ISyntaxList): DefaultSwitchClauseSyntax {
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, /*parsedInStrictMode:*/ true);
        }
        breakStatement(breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): BreakStatementSyntax {
            return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        continueStatement(continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ContinueStatementSyntax {
            return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        forStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForStatementSyntax {
            return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, /*parsedInStrictMode:*/ true);
        }
        forInStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForInStatementSyntax {
            return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, /*parsedInStrictMode:*/ true);
        }
        whileStatement(whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WhileStatementSyntax {
            return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ true);
        }
        withStatement(withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WithStatementSyntax {
            return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ true);
        }
        enumDeclaration(exportKeyword: ISyntaxToken, enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): EnumDeclarationSyntax {
            return new EnumDeclarationSyntax(exportKeyword, enumKeyword, identifier, openBraceToken, variableDeclarators, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        castExpression(lessThanToken: ISyntaxToken, type: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax): CastExpressionSyntax {
            return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, /*parsedInStrictMode:*/ true);
        }
        objectLiteralExpression(openBraceToken: ISyntaxToken, propertyAssignments: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
            return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        simplePropertyAssignment(propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax): SimplePropertyAssignmentSyntax {
            return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, /*parsedInStrictMode:*/ true);
        }
        getAccessorPropertyAssignment(getKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, closeParenToken: ISyntaxToken, block: BlockSyntax): GetAccessorPropertyAssignmentSyntax {
            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, block, /*parsedInStrictMode:*/ true);
        }
        setAccessorPropertyAssignment(setKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, parameterName: ISyntaxToken, closeParenToken: ISyntaxToken, block: BlockSyntax): SetAccessorPropertyAssignmentSyntax {
            return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block, /*parsedInStrictMode:*/ true);
        }
        functionExpression(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax {
            return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, /*parsedInStrictMode:*/ true);
        }
        emptyStatement(semicolonToken: ISyntaxToken): EmptyStatementSyntax {
            return new EmptyStatementSyntax(semicolonToken, /*parsedInStrictMode:*/ true);
        }
        tryStatement(tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax): TryStatementSyntax {
            return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, /*parsedInStrictMode:*/ true);
        }
        catchClause(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, closeParenToken: ISyntaxToken, block: BlockSyntax): CatchClauseSyntax {
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, closeParenToken, block, /*parsedInStrictMode:*/ true);
        }
        finallyClause(finallyKeyword: ISyntaxToken, block: BlockSyntax): FinallyClauseSyntax {
            return new FinallyClauseSyntax(finallyKeyword, block, /*parsedInStrictMode:*/ true);
        }
        labeledStatement(identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax): LabeledStatementSyntax {
            return new LabeledStatementSyntax(identifier, colonToken, statement, /*parsedInStrictMode:*/ true);
        }
        doStatement(doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken): DoStatementSyntax {
            return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        typeOfExpression(typeOfKeyword: ISyntaxToken, expression: IExpressionSyntax): TypeOfExpressionSyntax {
            return new TypeOfExpressionSyntax(typeOfKeyword, expression, /*parsedInStrictMode:*/ true);
        }
        deleteExpression(deleteKeyword: ISyntaxToken, expression: IExpressionSyntax): DeleteExpressionSyntax {
            return new DeleteExpressionSyntax(deleteKeyword, expression, /*parsedInStrictMode:*/ true);
        }
        voidExpression(voidKeyword: ISyntaxToken, expression: IExpressionSyntax): VoidExpressionSyntax {
            return new VoidExpressionSyntax(voidKeyword, expression, /*parsedInStrictMode:*/ true);
        }
        debuggerStatement(debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): DebuggerStatementSyntax {
            return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, /*parsedInStrictMode:*/ true);
        }
    }

    export var normalModeFactory: IFactory = new NormalModeFactory();
    export var strictModeFactory: IFactory = new StrictModeFactory();
}
/// <reference path='SyntaxFactory.generated.ts' />

module Syntax {
    export function emptySourceUnit() {
        return Syntax.normalModeFactory.sourceUnit(Syntax.emptyList, Syntax.token(SyntaxKind.EndOfFileToken, { text: "" }));
    }

    export function getStandaloneExpression(positionedToken: PositionedToken): PositionedNodeOrToken
    {
        var token = positionedToken.token();
        if (positionedToken !== null && positionedToken.kind() === SyntaxKind.IdentifierName) {
            var parentPositionedNode = positionedToken.containingNode();
            var parentNode = parentPositionedNode.node();

            if (parentNode.kind() === SyntaxKind.QualifiedName && (<QualifiedNameSyntax>parentNode).right === token) {
                return parentPositionedNode;
            }
            else if (parentNode.kind() === SyntaxKind.MemberAccessExpression && (<MemberAccessExpressionSyntax>parentNode).name === token) {
                return parentPositionedNode;
            }
        }

        return positionedToken;
    }

    export function isInModuleOrTypeContext(positionedToken: PositionedToken): bool {
        if (positionedToken !== null) {
            var positionedNodeOrToken = Syntax.getStandaloneExpression(positionedToken);
            var parent = positionedNodeOrToken.containingNode();

            if (parent !== null) {
                switch (parent.kind()) {
                    case SyntaxKind.ModuleNameModuleReference:
                        return true;
                    case SyntaxKind.QualifiedName:
                        // left of QN is namespace or type.  Note: when you have "a.b.c()", then
                        // "a.b" is not a qualified name, it is a member access expression.
                        // Qualified names are only parsed when the parser knows it's a type only
                        // context.
                        return true;
                    default:
                        return isInTypeOnlyContext(positionedToken);
                }
            }
        }

        return false;
    }

    export function isInTypeOnlyContext(positionedToken: PositionedToken): bool {
        var positionedNodeOrToken = Syntax.getStandaloneExpression(positionedToken);
        var positionedParent = positionedNodeOrToken.containingNode();

        var parent = positionedParent.node();
        var nodeOrToken = positionedNodeOrToken.nodeOrToken();

        if (parent !== null) {
            switch (parent.kind()) {
                case SyntaxKind.ArrayType:
                    return (<ArrayTypeSyntax>parent).type === nodeOrToken;
                case SyntaxKind.CastExpression:
                    return (<CastExpressionSyntax>parent).type === nodeOrToken;
                case SyntaxKind.TypeAnnotation:
                case SyntaxKind.ExtendsClause:
                case SyntaxKind.ImplementsClause:
                case SyntaxKind.TypeArgumentList:
                    return true;
                // TODO: add more cases if necessary.  This list may not be complete.
            }
        }

        return false;
    }

    export function childOffset(parent: ISyntaxElement, child: ISyntaxElement): number {
        var offset = 0;
        for (var i = 0, n = parent.childCount(); i < n; i++) {
            var current = parent.childAt(i);
            if (current === child) {
                return offset;
            }

            if (current !== null) {
                offset += current.fullWidth();
            }
        }

        throw Errors.invalidOperation();
    }

    export function nodeStructuralEquals(node1: SyntaxNode, node2: SyntaxNode): bool {
        if (node1 === null) {
            return node2 === null;
        }

        return node1.structuralEquals(node2);
    }

    export function nodeOrTokenStructuralEquals(node1: ISyntaxNodeOrToken, node2: ISyntaxNodeOrToken): bool {
        if (node1 === node2) {
            return true;
        }

        if (node1 === null || node2 === null) {
            return false;
        }

        if (node1.isToken()) {
            return node2.isToken() ? tokenStructuralEquals(<ISyntaxToken>node1, <ISyntaxToken>node2) : false;
        }

        return node2.isNode() ? nodeStructuralEquals(<SyntaxNode>node1, <SyntaxNode>node2) : false;
    }

    export function tokenStructuralEquals(token1: ISyntaxToken, token2: ISyntaxToken): bool {
        if (token1 === token2) {
            return true;
        }

        if (token1 === null || token2 === null) {
            return false;
        }

        return token1.kind() === token2.kind() &&
               token1.width() === token2.width() &&
               token1.fullWidth() === token2.fullWidth() &&
               token1.text() === token2.text() &&
               Syntax.triviaListStructuralEquals(token1.leadingTrivia(), token2.leadingTrivia()) &&
               Syntax.triviaListStructuralEquals(token1.trailingTrivia(), token2.trailingTrivia());
    }

    export function triviaListStructuralEquals(triviaList1: ISyntaxTriviaList, triviaList2: ISyntaxTriviaList): bool {
        if (triviaList1.count() !== triviaList2.count()) {
            return false;
        }

        for (var i = 0, n = triviaList1.count(); i < n; i++) {
            if (!Syntax.triviaStructuralEquals(triviaList1.syntaxTriviaAt(i), triviaList2.syntaxTriviaAt(i))) {
                return false;
            }
        }

        return true;
    }

    export function triviaStructuralEquals(trivia1: ISyntaxTrivia, trivia2: ISyntaxTrivia): bool {
        return trivia1.kind() === trivia2.kind() &&
               trivia1.fullWidth() === trivia2.fullWidth() &&
               trivia1.fullText() === trivia2.fullText();
    }

    export function listStructuralEquals(list1: ISyntaxList, list2: ISyntaxList): bool {
        if (list1.childCount() !== list2.childCount()) {
            return false;
        }

        for (var i = 0, n = list1.childCount(); i < n; i++) {
            if (!Syntax.nodeOrTokenStructuralEquals(list1.childAt(i), list2.childAt(i))) {
                return false;
            }
        }

        return true;
    }

    export function separatedListStructuralEquals(list1: ISeparatedSyntaxList, list2: ISeparatedSyntaxList): bool {
        if (list1.childCount() !== list2.childCount()) {
            return false;
        }

        for (var i = 0, n = list1.childCount(); i < n; i++) {
            var element1 = list1.childAt(i);
            var element2 = list2.childAt(i);
            if (!Syntax.nodeOrTokenStructuralEquals(element1, element2)) {
                return false;
            }
        }

        return true;
    }
    
    export function elementStructuralEquals(element1: ISyntaxElement, element2: ISyntaxElement) {
        if (element1 === element2) {
            return true;
        }

        if (element1 === null || element2 === null) {
            return false;
        }

        if (element2.kind() !== element2.kind()) {
            return false;
        }

        if (element1.isToken()) {
            return tokenStructuralEquals(<ISyntaxToken>element1, <ISyntaxToken>element2);
        }
        else if (element1.isNode()) {
            return nodeStructuralEquals(<SyntaxNode>element1, <SyntaxNode>element2) ;
        }
        else if (element1.isList()) {
            return listStructuralEquals(<ISyntaxList>element1, <ISyntaxList>element2);
        }
        else if (element1.isSeparatedList()) {
            return separatedListStructuralEquals(<ISeparatedSyntaxList>element1, <ISeparatedSyntaxList>element2);
        }

        throw Errors.invalidOperation();
    }

    export function identifierName(text: string, info: ITokenInfo = null): ISyntaxToken {
        return identifier(text);
    }

    export function trueExpression(): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.TrueKeyword);
    }

    export function falseExpression(): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.FalseKeyword);
    }

    export function numericLiteralExpression(text: string): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.NumericLiteral, { text: text });
    }

    export function stringLiteralExpression(text: string): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.StringLiteral, { text: text });
    }

    export function isSuperInvocationExpression(node: IExpressionSyntax): bool {
        return node.kind() === SyntaxKind.InvocationExpression &&
            (<InvocationExpressionSyntax>node).expression.kind() === SyntaxKind.SuperKeyword;
    }

    export function isSuperInvocationExpressionStatement(node: SyntaxNode): bool {
        return node.kind() === SyntaxKind.ExpressionStatement &&
            isSuperInvocationExpression((<ExpressionStatementSyntax>node).expression);
    }

    export function isSuperMemberAccessExpression(node: IExpressionSyntax): bool {
        return node.kind() === SyntaxKind.MemberAccessExpression &&
            (<MemberAccessExpressionSyntax>node).expression.kind() === SyntaxKind.SuperKeyword;
    }

    export function isSuperMemberAccessInvocationExpression(node: SyntaxNode): bool {
        return node.kind() === SyntaxKind.InvocationExpression &&
            isSuperMemberAccessExpression((<InvocationExpressionSyntax>node).expression);
    }

    export function assignmentExpression(left: IExpressionSyntax, token: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax {
        return Syntax.normalModeFactory.binaryExpression(SyntaxKind.AssignmentExpression, left, token, right);
    }
}
﻿///<reference path='SyntaxNode.ts' />
///<reference path='ISyntaxList.ts' />
///<reference path='ISeparatedSyntaxList.ts' />
///<reference path='SeparatedSyntaxList.ts' />
///<reference path='SyntaxList.ts' />
///<reference path='SyntaxToken.ts' />
///<reference path='Syntax.ts' />

class SourceUnitSyntax extends SyntaxNode {

    constructor(public moduleElements: ISyntaxList,
                public endOfFileToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSourceUnit(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SourceUnit;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.moduleElements;
            case 1: return this.endOfFileToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(moduleElements: ISyntaxList,
                  endOfFileToken: ISyntaxToken): SourceUnitSyntax {
        if (this.moduleElements === moduleElements && this.endOfFileToken === endOfFileToken) {
            return this;
        }

        return new SourceUnitSyntax(moduleElements, endOfFileToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(endOfFileToken: ISyntaxToken): SourceUnitSyntax {
        return new SourceUnitSyntax(Syntax.emptyList, endOfFileToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(endOfFileToken: ISyntaxToken): SourceUnitSyntax {
        return new SourceUnitSyntax(Syntax.emptyList, endOfFileToken, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SourceUnitSyntax {
        return <SourceUnitSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SourceUnitSyntax {
        return <SourceUnitSyntax>super.withTrailingTrivia(trivia);
    }

    public withModuleElements(moduleElements: ISyntaxList): SourceUnitSyntax {
        return this.update(moduleElements, this.endOfFileToken);
    }

    public withModuleElement(moduleElement: IModuleElementSyntax): SourceUnitSyntax {
        return this.withModuleElements(Syntax.list([moduleElement]));
    }

    public withEndOfFileToken(endOfFileToken: ISyntaxToken): SourceUnitSyntax {
        return this.update(this.moduleElements, endOfFileToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.moduleElements.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ModuleReferenceSyntax extends SyntaxNode implements IModuleReferenceSyntax {
    constructor(parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    private isModuleReference(): bool {
        return true;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ModuleReferenceSyntax {
        return <ModuleReferenceSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ModuleReferenceSyntax {
        return <ModuleReferenceSyntax>super.withTrailingTrivia(trivia);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ExternalModuleReferenceSyntax extends ModuleReferenceSyntax {

    constructor(public moduleKeyword: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public stringLiteral: ISyntaxToken,
                public closeParenToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitExternalModuleReference(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ExternalModuleReference;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.moduleKeyword;
            case 1: return this.openParenToken;
            case 2: return this.stringLiteral;
            case 3: return this.closeParenToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(moduleKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  stringLiteral: ISyntaxToken,
                  closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax {
        if (this.moduleKeyword === moduleKeyword && this.openParenToken === openParenToken && this.stringLiteral === stringLiteral && this.closeParenToken === closeParenToken) {
            return this;
        }

        return new ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(stringLiteral: ISyntaxToken): ExternalModuleReferenceSyntax {
        return new ExternalModuleReferenceSyntax(Syntax.token(SyntaxKind.ModuleKeyword), Syntax.token(SyntaxKind.OpenParenToken), stringLiteral, Syntax.token(SyntaxKind.CloseParenToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ExternalModuleReferenceSyntax {
        return <ExternalModuleReferenceSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ExternalModuleReferenceSyntax {
        return <ExternalModuleReferenceSyntax>super.withTrailingTrivia(trivia);
    }

    public withModuleKeyword(moduleKeyword: ISyntaxToken): ExternalModuleReferenceSyntax {
        return this.update(moduleKeyword, this.openParenToken, this.stringLiteral, this.closeParenToken);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ExternalModuleReferenceSyntax {
        return this.update(this.moduleKeyword, openParenToken, this.stringLiteral, this.closeParenToken);
    }

    public withStringLiteral(stringLiteral: ISyntaxToken): ExternalModuleReferenceSyntax {
        return this.update(this.moduleKeyword, this.openParenToken, stringLiteral, this.closeParenToken);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax {
        return this.update(this.moduleKeyword, this.openParenToken, this.stringLiteral, closeParenToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ModuleNameModuleReferenceSyntax extends ModuleReferenceSyntax {

    constructor(public moduleName: INameSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitModuleNameModuleReference(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ModuleNameModuleReference;
    }

    private childCount(): number {
        return 1;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.moduleName;
            default: throw Errors.invalidOperation();
        }
    }

    public update(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax {
        if (this.moduleName === moduleName) {
            return this;
        }

        return new ModuleNameModuleReferenceSyntax(moduleName, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ModuleNameModuleReferenceSyntax {
        return <ModuleNameModuleReferenceSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ModuleNameModuleReferenceSyntax {
        return <ModuleNameModuleReferenceSyntax>super.withTrailingTrivia(trivia);
    }

    public withModuleName(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax {
        return this.update(moduleName);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ImportDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {

    constructor(public importKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public equalsToken: ISyntaxToken,
                public moduleReference: ModuleReferenceSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitImportDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ImportDeclaration;
    }

    private childCount(): number {
        return 5;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.importKeyword;
            case 1: return this.identifier;
            case 2: return this.equalsToken;
            case 3: return this.moduleReference;
            case 4: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(importKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  equalsToken: ISyntaxToken,
                  moduleReference: ModuleReferenceSyntax,
                  semicolonToken: ISyntaxToken): ImportDeclarationSyntax {
        if (this.importKeyword === importKeyword && this.identifier === identifier && this.equalsToken === equalsToken && this.moduleReference === moduleReference && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(identifier: ISyntaxToken,
                          moduleReference: ModuleReferenceSyntax): ImportDeclarationSyntax {
        return new ImportDeclarationSyntax(Syntax.token(SyntaxKind.ImportKeyword), identifier, Syntax.token(SyntaxKind.EqualsToken), moduleReference, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ImportDeclarationSyntax {
        return <ImportDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ImportDeclarationSyntax {
        return <ImportDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withImportKeyword(importKeyword: ISyntaxToken): ImportDeclarationSyntax {
        return this.update(importKeyword, this.identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
    }

    public withIdentifier(identifier: ISyntaxToken): ImportDeclarationSyntax {
        return this.update(this.importKeyword, identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
    }

    public withEqualsToken(equalsToken: ISyntaxToken): ImportDeclarationSyntax {
        return this.update(this.importKeyword, this.identifier, equalsToken, this.moduleReference, this.semicolonToken);
    }

    public withModuleReference(moduleReference: ModuleReferenceSyntax): ImportDeclarationSyntax {
        return this.update(this.importKeyword, this.identifier, this.equalsToken, moduleReference, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ImportDeclarationSyntax {
        return this.update(this.importKeyword, this.identifier, this.equalsToken, this.moduleReference, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ClassDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public declareKeyword: ISyntaxToken,
                public classKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public typeParameterList: TypeParameterListSyntax,
                public extendsClause: ExtendsClauseSyntax,
                public implementsClause: ImplementsClauseSyntax,
                public openBraceToken: ISyntaxToken,
                public classElements: ISyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitClassDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ClassDeclaration;
    }

    private childCount(): number {
        return 10;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.declareKeyword;
            case 2: return this.classKeyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.extendsClause;
            case 6: return this.implementsClause;
            case 7: return this.openBraceToken;
            case 8: return this.classElements;
            case 9: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  declareKeyword: ISyntaxToken,
                  classKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  typeParameterList: TypeParameterListSyntax,
                  extendsClause: ExtendsClauseSyntax,
                  implementsClause: ImplementsClauseSyntax,
                  openBraceToken: ISyntaxToken,
                  classElements: ISyntaxList,
                  closeBraceToken: ISyntaxToken): ClassDeclarationSyntax {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.classKeyword === classKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.extendsClause === extendsClause && this.implementsClause === implementsClause && this.openBraceToken === openBraceToken && this.classElements === classElements && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new ClassDeclarationSyntax(exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(classKeyword: ISyntaxToken,
                         identifier: ISyntaxToken,
                         openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): ClassDeclarationSyntax {
        return new ClassDeclarationSyntax(null, null, classKeyword, identifier, null, null, null, openBraceToken, Syntax.emptyList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): ClassDeclarationSyntax {
        return new ClassDeclarationSyntax(null, null, Syntax.token(SyntaxKind.ClassKeyword), identifier, null, null, null, Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptyList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ClassDeclarationSyntax {
        return <ClassDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ClassDeclarationSyntax {
        return <ClassDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withDeclareKeyword(declareKeyword: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withClassKeyword(classKeyword: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withIdentifier(identifier: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withTypeParameterList(typeParameterList: TypeParameterListSyntax): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withExtendsClause(extendsClause: ExtendsClauseSyntax): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withImplementsClause(implementsClause: ImplementsClauseSyntax): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withClassElements(classElements: ISyntaxList): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, classElements, this.closeBraceToken);
    }

    public withClassElement(classElement: IClassElementSyntax): ClassDeclarationSyntax {
        return this.withClassElements(Syntax.list([classElement]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, closeBraceToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class InterfaceDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public interfaceKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public typeParameterList: TypeParameterListSyntax,
                public extendsClause: ExtendsClauseSyntax,
                public body: ObjectTypeSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitInterfaceDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.InterfaceDeclaration;
    }

    private childCount(): number {
        return 6;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.interfaceKeyword;
            case 2: return this.identifier;
            case 3: return this.typeParameterList;
            case 4: return this.extendsClause;
            case 5: return this.body;
            default: throw Errors.invalidOperation();
        }
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  interfaceKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  typeParameterList: TypeParameterListSyntax,
                  extendsClause: ExtendsClauseSyntax,
                  body: ObjectTypeSyntax): InterfaceDeclarationSyntax {
        if (this.exportKeyword === exportKeyword && this.interfaceKeyword === interfaceKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.extendsClause === extendsClause && this.body === body) {
            return this;
        }

        return new InterfaceDeclarationSyntax(exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(interfaceKeyword: ISyntaxToken,
                         identifier: ISyntaxToken,
                         body: ObjectTypeSyntax): InterfaceDeclarationSyntax {
        return new InterfaceDeclarationSyntax(null, interfaceKeyword, identifier, null, null, body, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): InterfaceDeclarationSyntax {
        return new InterfaceDeclarationSyntax(null, Syntax.token(SyntaxKind.InterfaceKeyword), identifier, null, null, ObjectTypeSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): InterfaceDeclarationSyntax {
        return <InterfaceDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): InterfaceDeclarationSyntax {
        return <InterfaceDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): InterfaceDeclarationSyntax {
        return this.update(exportKeyword, this.interfaceKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.body);
    }

    public withInterfaceKeyword(interfaceKeyword: ISyntaxToken): InterfaceDeclarationSyntax {
        return this.update(this.exportKeyword, interfaceKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.body);
    }

    public withIdentifier(identifier: ISyntaxToken): InterfaceDeclarationSyntax {
        return this.update(this.exportKeyword, this.interfaceKeyword, identifier, this.typeParameterList, this.extendsClause, this.body);
    }

    public withTypeParameterList(typeParameterList: TypeParameterListSyntax): InterfaceDeclarationSyntax {
        return this.update(this.exportKeyword, this.interfaceKeyword, this.identifier, typeParameterList, this.extendsClause, this.body);
    }

    public withExtendsClause(extendsClause: ExtendsClauseSyntax): InterfaceDeclarationSyntax {
        return this.update(this.exportKeyword, this.interfaceKeyword, this.identifier, this.typeParameterList, extendsClause, this.body);
    }

    public withBody(body: ObjectTypeSyntax): InterfaceDeclarationSyntax {
        return this.update(this.exportKeyword, this.interfaceKeyword, this.identifier, this.typeParameterList, this.extendsClause, body);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ExtendsClauseSyntax extends SyntaxNode {

    constructor(public extendsKeyword: ISyntaxToken,
                public typeNames: ISeparatedSyntaxList,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitExtendsClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ExtendsClause;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.extendsKeyword;
            case 1: return this.typeNames;
            default: throw Errors.invalidOperation();
        }
    }

    public update(extendsKeyword: ISyntaxToken,
                  typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax {
        if (this.extendsKeyword === extendsKeyword && this.typeNames === typeNames) {
            return this;
        }

        return new ExtendsClauseSyntax(extendsKeyword, typeNames, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax {
        return new ExtendsClauseSyntax(Syntax.token(SyntaxKind.ExtendsKeyword), typeNames, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ExtendsClauseSyntax {
        return <ExtendsClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ExtendsClauseSyntax {
        return <ExtendsClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withExtendsKeyword(extendsKeyword: ISyntaxToken): ExtendsClauseSyntax {
        return this.update(extendsKeyword, this.typeNames);
    }

    public withTypeNames(typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax {
        return this.update(this.extendsKeyword, typeNames);
    }

    public withTypeName(typeName: INameSyntax): ExtendsClauseSyntax {
        return this.withTypeNames(Syntax.separatedList([typeName]));
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ImplementsClauseSyntax extends SyntaxNode {

    constructor(public implementsKeyword: ISyntaxToken,
                public typeNames: ISeparatedSyntaxList,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitImplementsClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ImplementsClause;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.implementsKeyword;
            case 1: return this.typeNames;
            default: throw Errors.invalidOperation();
        }
    }

    public update(implementsKeyword: ISyntaxToken,
                  typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax {
        if (this.implementsKeyword === implementsKeyword && this.typeNames === typeNames) {
            return this;
        }

        return new ImplementsClauseSyntax(implementsKeyword, typeNames, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax {
        return new ImplementsClauseSyntax(Syntax.token(SyntaxKind.ImplementsKeyword), typeNames, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ImplementsClauseSyntax {
        return <ImplementsClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ImplementsClauseSyntax {
        return <ImplementsClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withImplementsKeyword(implementsKeyword: ISyntaxToken): ImplementsClauseSyntax {
        return this.update(implementsKeyword, this.typeNames);
    }

    public withTypeNames(typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax {
        return this.update(this.implementsKeyword, typeNames);
    }

    public withTypeName(typeName: INameSyntax): ImplementsClauseSyntax {
        return this.withTypeNames(Syntax.separatedList([typeName]));
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ModuleDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public declareKeyword: ISyntaxToken,
                public moduleKeyword: ISyntaxToken,
                public moduleName: INameSyntax,
                public stringLiteral: ISyntaxToken,
                public openBraceToken: ISyntaxToken,
                public moduleElements: ISyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitModuleDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ModuleDeclaration;
    }

    private childCount(): number {
        return 8;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.declareKeyword;
            case 2: return this.moduleKeyword;
            case 3: return this.moduleName;
            case 4: return this.stringLiteral;
            case 5: return this.openBraceToken;
            case 6: return this.moduleElements;
            case 7: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  declareKeyword: ISyntaxToken,
                  moduleKeyword: ISyntaxToken,
                  moduleName: INameSyntax,
                  stringLiteral: ISyntaxToken,
                  openBraceToken: ISyntaxToken,
                  moduleElements: ISyntaxList,
                  closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.moduleKeyword === moduleKeyword && this.moduleName === moduleName && this.stringLiteral === stringLiteral && this.openBraceToken === openBraceToken && this.moduleElements === moduleElements && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new ModuleDeclarationSyntax(exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(moduleKeyword: ISyntaxToken,
                         openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
        return new ModuleDeclarationSyntax(null, null, moduleKeyword, null, null, openBraceToken, Syntax.emptyList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ModuleDeclarationSyntax {
        return new ModuleDeclarationSyntax(null, null, Syntax.token(SyntaxKind.ModuleKeyword), null, null, Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptyList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ModuleDeclarationSyntax {
        return <ModuleDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ModuleDeclarationSyntax {
        return <ModuleDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withDeclareKeyword(declareKeyword: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withModuleKeyword(moduleKeyword: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withModuleName(moduleName: INameSyntax): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withStringLiteral(stringLiteral: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withModuleElements(moduleElements: ISyntaxList): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, moduleElements, this.closeBraceToken);
    }

    public withModuleElement(moduleElement: IModuleElementSyntax): ModuleDeclarationSyntax {
        return this.withModuleElements(Syntax.list([moduleElement]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, closeBraceToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class FunctionDeclarationSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public declareKeyword: ISyntaxToken,
                public functionKeyword: ISyntaxToken,
                public functionSignature: FunctionSignatureSyntax,
                public block: BlockSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitFunctionDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.FunctionDeclaration;
    }

    private childCount(): number {
        return 6;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.declareKeyword;
            case 2: return this.functionKeyword;
            case 3: return this.functionSignature;
            case 4: return this.block;
            case 5: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  declareKeyword: ISyntaxToken,
                  functionKeyword: ISyntaxToken,
                  functionSignature: FunctionSignatureSyntax,
                  block: BlockSyntax,
                  semicolonToken: ISyntaxToken): FunctionDeclarationSyntax {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.functionKeyword === functionKeyword && this.functionSignature === functionSignature && this.block === block && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new FunctionDeclarationSyntax(exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(functionKeyword: ISyntaxToken,
                         functionSignature: FunctionSignatureSyntax): FunctionDeclarationSyntax {
        return new FunctionDeclarationSyntax(null, null, functionKeyword, functionSignature, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(functionSignature: FunctionSignatureSyntax): FunctionDeclarationSyntax {
        return new FunctionDeclarationSyntax(null, null, Syntax.token(SyntaxKind.FunctionKeyword), functionSignature, null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): FunctionDeclarationSyntax {
        return <FunctionDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): FunctionDeclarationSyntax {
        return <FunctionDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): FunctionDeclarationSyntax {
        return this.update(exportKeyword, this.declareKeyword, this.functionKeyword, this.functionSignature, this.block, this.semicolonToken);
    }

    public withDeclareKeyword(declareKeyword: ISyntaxToken): FunctionDeclarationSyntax {
        return this.update(this.exportKeyword, declareKeyword, this.functionKeyword, this.functionSignature, this.block, this.semicolonToken);
    }

    public withFunctionKeyword(functionKeyword: ISyntaxToken): FunctionDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, functionKeyword, this.functionSignature, this.block, this.semicolonToken);
    }

    public withFunctionSignature(functionSignature: FunctionSignatureSyntax): FunctionDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.functionKeyword, functionSignature, this.block, this.semicolonToken);
    }

    public withBlock(block: BlockSyntax): FunctionDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.functionKeyword, this.functionSignature, block, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): FunctionDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.functionKeyword, this.functionSignature, this.block, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.exportKeyword !== null) { return true; }
        if (this.declareKeyword !== null) { return true; }
        if (this.functionSignature.isTypeScriptSpecific()) { return true; }
        if (this.block !== null && this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class VariableStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public declareKeyword: ISyntaxToken,
                public variableDeclaration: VariableDeclarationSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitVariableStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.VariableStatement;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.declareKeyword;
            case 2: return this.variableDeclaration;
            case 3: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  declareKeyword: ISyntaxToken,
                  variableDeclaration: VariableDeclarationSyntax,
                  semicolonToken: ISyntaxToken): VariableStatementSyntax {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.variableDeclaration === variableDeclaration && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new VariableStatementSyntax(exportKeyword, declareKeyword, variableDeclaration, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(variableDeclaration: VariableDeclarationSyntax,
                         semicolonToken: ISyntaxToken): VariableStatementSyntax {
        return new VariableStatementSyntax(null, null, variableDeclaration, semicolonToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(variableDeclaration: VariableDeclarationSyntax): VariableStatementSyntax {
        return new VariableStatementSyntax(null, null, variableDeclaration, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): VariableStatementSyntax {
        return <VariableStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): VariableStatementSyntax {
        return <VariableStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): VariableStatementSyntax {
        return this.update(exportKeyword, this.declareKeyword, this.variableDeclaration, this.semicolonToken);
    }

    public withDeclareKeyword(declareKeyword: ISyntaxToken): VariableStatementSyntax {
        return this.update(this.exportKeyword, declareKeyword, this.variableDeclaration, this.semicolonToken);
    }

    public withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): VariableStatementSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, variableDeclaration, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): VariableStatementSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.variableDeclaration, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.exportKeyword !== null) { return true; }
        if (this.declareKeyword !== null) { return true; }
        if (this.variableDeclaration.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class VariableDeclarationSyntax extends SyntaxNode {

    constructor(public varKeyword: ISyntaxToken,
                public variableDeclarators: ISeparatedSyntaxList,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitVariableDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.VariableDeclaration;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.varKeyword;
            case 1: return this.variableDeclarators;
            default: throw Errors.invalidOperation();
        }
    }

    public update(varKeyword: ISyntaxToken,
                  variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax {
        if (this.varKeyword === varKeyword && this.variableDeclarators === variableDeclarators) {
            return this;
        }

        return new VariableDeclarationSyntax(varKeyword, variableDeclarators, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax {
        return new VariableDeclarationSyntax(Syntax.token(SyntaxKind.VarKeyword), variableDeclarators, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): VariableDeclarationSyntax {
        return <VariableDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): VariableDeclarationSyntax {
        return <VariableDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withVarKeyword(varKeyword: ISyntaxToken): VariableDeclarationSyntax {
        return this.update(varKeyword, this.variableDeclarators);
    }

    public withVariableDeclarators(variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax {
        return this.update(this.varKeyword, variableDeclarators);
    }

    public withVariableDeclarator(variableDeclarator: VariableDeclaratorSyntax): VariableDeclarationSyntax {
        return this.withVariableDeclarators(Syntax.separatedList([variableDeclarator]));
    }

    private isTypeScriptSpecific(): bool {
        if (this.variableDeclarators.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class VariableDeclaratorSyntax extends SyntaxNode {

    constructor(public identifier: ISyntaxToken,
                public typeAnnotation: TypeAnnotationSyntax,
                public equalsValueClause: EqualsValueClauseSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitVariableDeclarator(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.VariableDeclarator;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.identifier;
            case 1: return this.typeAnnotation;
            case 2: return this.equalsValueClause;
            default: throw Errors.invalidOperation();
        }
    }

    public update(identifier: ISyntaxToken,
                  typeAnnotation: TypeAnnotationSyntax,
                  equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax {
        if (this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
            return this;
        }

        return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(identifier: ISyntaxToken): VariableDeclaratorSyntax {
        return new VariableDeclaratorSyntax(identifier, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): VariableDeclaratorSyntax {
        return new VariableDeclaratorSyntax(identifier, null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): VariableDeclaratorSyntax {
        return <VariableDeclaratorSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): VariableDeclaratorSyntax {
        return <VariableDeclaratorSyntax>super.withTrailingTrivia(trivia);
    }

    public withIdentifier(identifier: ISyntaxToken): VariableDeclaratorSyntax {
        return this.update(identifier, this.typeAnnotation, this.equalsValueClause);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): VariableDeclaratorSyntax {
        return this.update(this.identifier, typeAnnotation, this.equalsValueClause);
    }

    public withEqualsValueClause(equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax {
        return this.update(this.identifier, this.typeAnnotation, equalsValueClause);
    }

    private isTypeScriptSpecific(): bool {
        if (this.typeAnnotation !== null) { return true; }
        if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class EqualsValueClauseSyntax extends SyntaxNode {

    constructor(public equalsToken: ISyntaxToken,
                public value: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitEqualsValueClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.EqualsValueClause;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.equalsToken;
            case 1: return this.value;
            default: throw Errors.invalidOperation();
        }
    }

    public update(equalsToken: ISyntaxToken,
                  value: IExpressionSyntax): EqualsValueClauseSyntax {
        if (this.equalsToken === equalsToken && this.value === value) {
            return this;
        }

        return new EqualsValueClauseSyntax(equalsToken, value, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(value: IExpressionSyntax): EqualsValueClauseSyntax {
        return new EqualsValueClauseSyntax(Syntax.token(SyntaxKind.EqualsToken), value, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): EqualsValueClauseSyntax {
        return <EqualsValueClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): EqualsValueClauseSyntax {
        return <EqualsValueClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withEqualsToken(equalsToken: ISyntaxToken): EqualsValueClauseSyntax {
        return this.update(equalsToken, this.value);
    }

    public withValue(value: IExpressionSyntax): EqualsValueClauseSyntax {
        return this.update(this.equalsToken, value);
    }

    private isTypeScriptSpecific(): bool {
        if (this.value.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class PrefixUnaryExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
    private _kind: SyntaxKind;

    constructor(kind: SyntaxKind,
                public operatorToken: ISyntaxToken,
                public operand: IUnaryExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

        this._kind = kind;
    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitPrefixUnaryExpression(this);
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.operatorToken;
            case 1: return this.operand;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public kind(): SyntaxKind {
        return this._kind;
    }

    public update(kind: SyntaxKind,
                  operatorToken: ISyntaxToken,
                  operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax {
        if (this._kind === kind && this.operatorToken === operatorToken && this.operand === operand) {
            return this;
        }

        return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): PrefixUnaryExpressionSyntax {
        return <PrefixUnaryExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): PrefixUnaryExpressionSyntax {
        return <PrefixUnaryExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withKind(kind: SyntaxKind): PrefixUnaryExpressionSyntax {
        return this.update(kind, this.operatorToken, this.operand);
    }

    public withOperatorToken(operatorToken: ISyntaxToken): PrefixUnaryExpressionSyntax {
        return this.update(this._kind, operatorToken, this.operand);
    }

    public withOperand(operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax {
        return this.update(this._kind, this.operatorToken, operand);
    }

    private isTypeScriptSpecific(): bool {
        if (this.operand.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ArrayLiteralExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public openBracketToken: ISyntaxToken,
                public expressions: ISeparatedSyntaxList,
                public closeBracketToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitArrayLiteralExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ArrayLiteralExpression;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openBracketToken;
            case 1: return this.expressions;
            case 2: return this.closeBracketToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(openBracketToken: ISyntaxToken,
                  expressions: ISeparatedSyntaxList,
                  closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
        if (this.openBracketToken === openBracketToken && this.expressions === expressions && this.closeBracketToken === closeBracketToken) {
            return this;
        }

        return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openBracketToken: ISyntaxToken,
                         closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
        return new ArrayLiteralExpressionSyntax(openBracketToken, Syntax.emptySeparatedList, closeBracketToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ArrayLiteralExpressionSyntax {
        return new ArrayLiteralExpressionSyntax(Syntax.token(SyntaxKind.OpenBracketToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseBracketToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ArrayLiteralExpressionSyntax {
        return <ArrayLiteralExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ArrayLiteralExpressionSyntax {
        return <ArrayLiteralExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenBracketToken(openBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
        return this.update(openBracketToken, this.expressions, this.closeBracketToken);
    }

    public withExpressions(expressions: ISeparatedSyntaxList): ArrayLiteralExpressionSyntax {
        return this.update(this.openBracketToken, expressions, this.closeBracketToken);
    }

    public withExpression(expression: IExpressionSyntax): ArrayLiteralExpressionSyntax {
        return this.withExpressions(Syntax.separatedList([expression]));
    }

    public withCloseBracketToken(closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
        return this.update(this.openBracketToken, this.expressions, closeBracketToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expressions.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class OmittedExpressionSyntax extends SyntaxNode implements IExpressionSyntax {
    constructor(parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitOmittedExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.OmittedExpression;
    }

    private childCount(): number {
        return 0;
    }

    private childAt(slot: number): ISyntaxElement {
        throw Errors.invalidOperation();
    }

    private isExpression(): bool {
        return true;
    }

    public update(): OmittedExpressionSyntax {
        return this;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): OmittedExpressionSyntax {
        return <OmittedExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): OmittedExpressionSyntax {
        return <OmittedExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    private isTypeScriptSpecific(): bool {
        return false;
    }
}

class ParenthesizedExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public openParenToken: ISyntaxToken,
                public expression: IExpressionSyntax,
                public closeParenToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitParenthesizedExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ParenthesizedExpression;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openParenToken;
            case 1: return this.expression;
            case 2: return this.closeParenToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(openParenToken: ISyntaxToken,
                  expression: IExpressionSyntax,
                  closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax {
        if (this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken) {
            return this;
        }

        return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): ParenthesizedExpressionSyntax {
        return new ParenthesizedExpressionSyntax(Syntax.token(SyntaxKind.OpenParenToken), expression, Syntax.token(SyntaxKind.CloseParenToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ParenthesizedExpressionSyntax {
        return <ParenthesizedExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ParenthesizedExpressionSyntax {
        return <ParenthesizedExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ParenthesizedExpressionSyntax {
        return this.update(openParenToken, this.expression, this.closeParenToken);
    }

    public withExpression(expression: IExpressionSyntax): ParenthesizedExpressionSyntax {
        return this.update(this.openParenToken, expression, this.closeParenToken);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax {
        return this.update(this.openParenToken, this.expression, closeParenToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ArrowFunctionExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
    constructor(public equalsGreaterThanToken: ISyntaxToken,
                public body: ISyntaxNodeOrToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ArrowFunctionExpressionSyntax {
        return <ArrowFunctionExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ArrowFunctionExpressionSyntax {
        return <ArrowFunctionExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class SimpleArrowFunctionExpressionSyntax extends ArrowFunctionExpressionSyntax {

    constructor(public identifier: ISyntaxToken,
                equalsGreaterThanToken: ISyntaxToken,
                body: ISyntaxNodeOrToken,
                parsedInStrictMode: bool) {
        super(equalsGreaterThanToken, body, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSimpleArrowFunctionExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SimpleArrowFunctionExpression;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.identifier;
            case 1: return this.equalsGreaterThanToken;
            case 2: return this.body;
            default: throw Errors.invalidOperation();
        }
    }

    public update(identifier: ISyntaxToken,
                  equalsGreaterThanToken: ISyntaxToken,
                  body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax {
        if (this.identifier === identifier && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
            return this;
        }

        return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(identifier: ISyntaxToken,
                          body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax {
        return new SimpleArrowFunctionExpressionSyntax(identifier, Syntax.token(SyntaxKind.EqualsGreaterThanToken), body, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SimpleArrowFunctionExpressionSyntax {
        return <SimpleArrowFunctionExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SimpleArrowFunctionExpressionSyntax {
        return <SimpleArrowFunctionExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withIdentifier(identifier: ISyntaxToken): SimpleArrowFunctionExpressionSyntax {
        return this.update(identifier, this.equalsGreaterThanToken, this.body);
    }

    public withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): SimpleArrowFunctionExpressionSyntax {
        return this.update(this.identifier, equalsGreaterThanToken, this.body);
    }

    public withBody(body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax {
        return this.update(this.identifier, this.equalsGreaterThanToken, body);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ParenthesizedArrowFunctionExpressionSyntax extends ArrowFunctionExpressionSyntax {

    constructor(public callSignature: CallSignatureSyntax,
                equalsGreaterThanToken: ISyntaxToken,
                body: ISyntaxNodeOrToken,
                parsedInStrictMode: bool) {
        super(equalsGreaterThanToken, body, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitParenthesizedArrowFunctionExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ParenthesizedArrowFunctionExpression;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.callSignature;
            case 1: return this.equalsGreaterThanToken;
            case 2: return this.body;
            default: throw Errors.invalidOperation();
        }
    }

    public update(callSignature: CallSignatureSyntax,
                  equalsGreaterThanToken: ISyntaxToken,
                  body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax {
        if (this.callSignature === callSignature && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
            return this;
        }

        return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax {
        return new ParenthesizedArrowFunctionExpressionSyntax(CallSignatureSyntax.create1(), Syntax.token(SyntaxKind.EqualsGreaterThanToken), body, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ParenthesizedArrowFunctionExpressionSyntax {
        return <ParenthesizedArrowFunctionExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ParenthesizedArrowFunctionExpressionSyntax {
        return <ParenthesizedArrowFunctionExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withCallSignature(callSignature: CallSignatureSyntax): ParenthesizedArrowFunctionExpressionSyntax {
        return this.update(callSignature, this.equalsGreaterThanToken, this.body);
    }

    public withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): ParenthesizedArrowFunctionExpressionSyntax {
        return this.update(this.callSignature, equalsGreaterThanToken, this.body);
    }

    public withBody(body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax {
        return this.update(this.callSignature, this.equalsGreaterThanToken, body);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class QualifiedNameSyntax extends SyntaxNode implements INameSyntax {

    constructor(public left: INameSyntax,
                public dotToken: ISyntaxToken,
                public right: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitQualifiedName(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.QualifiedName;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.left;
            case 1: return this.dotToken;
            case 2: return this.right;
            default: throw Errors.invalidOperation();
        }
    }

    private isName(): bool {
        return true;
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(left: INameSyntax,
                  dotToken: ISyntaxToken,
                  right: ISyntaxToken): QualifiedNameSyntax {
        if (this.left === left && this.dotToken === dotToken && this.right === right) {
            return this;
        }

        return new QualifiedNameSyntax(left, dotToken, right, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(left: INameSyntax,
                          right: ISyntaxToken): QualifiedNameSyntax {
        return new QualifiedNameSyntax(left, Syntax.token(SyntaxKind.DotToken), right, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): QualifiedNameSyntax {
        return <QualifiedNameSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): QualifiedNameSyntax {
        return <QualifiedNameSyntax>super.withTrailingTrivia(trivia);
    }

    public withLeft(left: INameSyntax): QualifiedNameSyntax {
        return this.update(left, this.dotToken, this.right);
    }

    public withDotToken(dotToken: ISyntaxToken): QualifiedNameSyntax {
        return this.update(this.left, dotToken, this.right);
    }

    public withRight(right: ISyntaxToken): QualifiedNameSyntax {
        return this.update(this.left, this.dotToken, right);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class TypeArgumentListSyntax extends SyntaxNode {

    constructor(public lessThanToken: ISyntaxToken,
                public typeArguments: ISeparatedSyntaxList,
                public greaterThanToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTypeArgumentList(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TypeArgumentList;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.lessThanToken;
            case 1: return this.typeArguments;
            case 2: return this.greaterThanToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(lessThanToken: ISyntaxToken,
                  typeArguments: ISeparatedSyntaxList,
                  greaterThanToken: ISyntaxToken): TypeArgumentListSyntax {
        if (this.lessThanToken === lessThanToken && this.typeArguments === typeArguments && this.greaterThanToken === greaterThanToken) {
            return this;
        }

        return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(lessThanToken: ISyntaxToken,
                         greaterThanToken: ISyntaxToken): TypeArgumentListSyntax {
        return new TypeArgumentListSyntax(lessThanToken, Syntax.emptySeparatedList, greaterThanToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): TypeArgumentListSyntax {
        return new TypeArgumentListSyntax(Syntax.token(SyntaxKind.LessThanToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.GreaterThanToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TypeArgumentListSyntax {
        return <TypeArgumentListSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TypeArgumentListSyntax {
        return <TypeArgumentListSyntax>super.withTrailingTrivia(trivia);
    }

    public withLessThanToken(lessThanToken: ISyntaxToken): TypeArgumentListSyntax {
        return this.update(lessThanToken, this.typeArguments, this.greaterThanToken);
    }

    public withTypeArguments(typeArguments: ISeparatedSyntaxList): TypeArgumentListSyntax {
        return this.update(this.lessThanToken, typeArguments, this.greaterThanToken);
    }

    public withTypeArgument(typeArgument: ITypeSyntax): TypeArgumentListSyntax {
        return this.withTypeArguments(Syntax.separatedList([typeArgument]));
    }

    public withGreaterThanToken(greaterThanToken: ISyntaxToken): TypeArgumentListSyntax {
        return this.update(this.lessThanToken, this.typeArguments, greaterThanToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ConstructorTypeSyntax extends SyntaxNode implements ITypeSyntax {

    constructor(public newKeyword: ISyntaxToken,
                public typeParameterList: TypeParameterListSyntax,
                public parameterList: ParameterListSyntax,
                public equalsGreaterThanToken: ISyntaxToken,
                public type: ITypeSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitConstructorType(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ConstructorType;
    }

    private childCount(): number {
        return 5;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.newKeyword;
            case 1: return this.typeParameterList;
            case 2: return this.parameterList;
            case 3: return this.equalsGreaterThanToken;
            case 4: return this.type;
            default: throw Errors.invalidOperation();
        }
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(newKeyword: ISyntaxToken,
                  typeParameterList: TypeParameterListSyntax,
                  parameterList: ParameterListSyntax,
                  equalsGreaterThanToken: ISyntaxToken,
                  type: ITypeSyntax): ConstructorTypeSyntax {
        if (this.newKeyword === newKeyword && this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
            return this;
        }

        return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(newKeyword: ISyntaxToken,
                         parameterList: ParameterListSyntax,
                         equalsGreaterThanToken: ISyntaxToken,
                         type: ITypeSyntax): ConstructorTypeSyntax {
        return new ConstructorTypeSyntax(newKeyword, null, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ false);
    }

    public static create1(type: ITypeSyntax): ConstructorTypeSyntax {
        return new ConstructorTypeSyntax(Syntax.token(SyntaxKind.NewKeyword), null, ParameterListSyntax.create1(), Syntax.token(SyntaxKind.EqualsGreaterThanToken), type, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ConstructorTypeSyntax {
        return <ConstructorTypeSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ConstructorTypeSyntax {
        return <ConstructorTypeSyntax>super.withTrailingTrivia(trivia);
    }

    public withNewKeyword(newKeyword: ISyntaxToken): ConstructorTypeSyntax {
        return this.update(newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
    }

    public withTypeParameterList(typeParameterList: TypeParameterListSyntax): ConstructorTypeSyntax {
        return this.update(this.newKeyword, typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
    }

    public withParameterList(parameterList: ParameterListSyntax): ConstructorTypeSyntax {
        return this.update(this.newKeyword, this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
    }

    public withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): ConstructorTypeSyntax {
        return this.update(this.newKeyword, this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
    }

    public withType(type: ITypeSyntax): ConstructorTypeSyntax {
        return this.update(this.newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class FunctionTypeSyntax extends SyntaxNode implements ITypeSyntax {

    constructor(public typeParameterList: TypeParameterListSyntax,
                public parameterList: ParameterListSyntax,
                public equalsGreaterThanToken: ISyntaxToken,
                public type: ITypeSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitFunctionType(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.FunctionType;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.typeParameterList;
            case 1: return this.parameterList;
            case 2: return this.equalsGreaterThanToken;
            case 3: return this.type;
            default: throw Errors.invalidOperation();
        }
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(typeParameterList: TypeParameterListSyntax,
                  parameterList: ParameterListSyntax,
                  equalsGreaterThanToken: ISyntaxToken,
                  type: ITypeSyntax): FunctionTypeSyntax {
        if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
            return this;
        }

        return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(parameterList: ParameterListSyntax,
                         equalsGreaterThanToken: ISyntaxToken,
                         type: ITypeSyntax): FunctionTypeSyntax {
        return new FunctionTypeSyntax(null, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ false);
    }

    public static create1(type: ITypeSyntax): FunctionTypeSyntax {
        return new FunctionTypeSyntax(null, ParameterListSyntax.create1(), Syntax.token(SyntaxKind.EqualsGreaterThanToken), type, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): FunctionTypeSyntax {
        return <FunctionTypeSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): FunctionTypeSyntax {
        return <FunctionTypeSyntax>super.withTrailingTrivia(trivia);
    }

    public withTypeParameterList(typeParameterList: TypeParameterListSyntax): FunctionTypeSyntax {
        return this.update(typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
    }

    public withParameterList(parameterList: ParameterListSyntax): FunctionTypeSyntax {
        return this.update(this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
    }

    public withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): FunctionTypeSyntax {
        return this.update(this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
    }

    public withType(type: ITypeSyntax): FunctionTypeSyntax {
        return this.update(this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ObjectTypeSyntax extends SyntaxNode implements ITypeSyntax {

    constructor(public openBraceToken: ISyntaxToken,
                public typeMembers: ISeparatedSyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitObjectType(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ObjectType;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openBraceToken;
            case 1: return this.typeMembers;
            case 2: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(openBraceToken: ISyntaxToken,
                  typeMembers: ISeparatedSyntaxList,
                  closeBraceToken: ISyntaxToken): ObjectTypeSyntax {
        if (this.openBraceToken === openBraceToken && this.typeMembers === typeMembers && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): ObjectTypeSyntax {
        return new ObjectTypeSyntax(openBraceToken, Syntax.emptySeparatedList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ObjectTypeSyntax {
        return new ObjectTypeSyntax(Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ObjectTypeSyntax {
        return <ObjectTypeSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ObjectTypeSyntax {
        return <ObjectTypeSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): ObjectTypeSyntax {
        return this.update(openBraceToken, this.typeMembers, this.closeBraceToken);
    }

    public withTypeMembers(typeMembers: ISeparatedSyntaxList): ObjectTypeSyntax {
        return this.update(this.openBraceToken, typeMembers, this.closeBraceToken);
    }

    public withTypeMember(typeMember: TypeMemberSyntax): ObjectTypeSyntax {
        return this.withTypeMembers(Syntax.separatedList([typeMember]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): ObjectTypeSyntax {
        return this.update(this.openBraceToken, this.typeMembers, closeBraceToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ArrayTypeSyntax extends SyntaxNode implements ITypeSyntax {

    constructor(public type: ITypeSyntax,
                public openBracketToken: ISyntaxToken,
                public closeBracketToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitArrayType(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ArrayType;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.type;
            case 1: return this.openBracketToken;
            case 2: return this.closeBracketToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(type: ITypeSyntax,
                  openBracketToken: ISyntaxToken,
                  closeBracketToken: ISyntaxToken): ArrayTypeSyntax {
        if (this.type === type && this.openBracketToken === openBracketToken && this.closeBracketToken === closeBracketToken) {
            return this;
        }

        return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(type: ITypeSyntax): ArrayTypeSyntax {
        return new ArrayTypeSyntax(type, Syntax.token(SyntaxKind.OpenBracketToken), Syntax.token(SyntaxKind.CloseBracketToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ArrayTypeSyntax {
        return <ArrayTypeSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ArrayTypeSyntax {
        return <ArrayTypeSyntax>super.withTrailingTrivia(trivia);
    }

    public withType(type: ITypeSyntax): ArrayTypeSyntax {
        return this.update(type, this.openBracketToken, this.closeBracketToken);
    }

    public withOpenBracketToken(openBracketToken: ISyntaxToken): ArrayTypeSyntax {
        return this.update(this.type, openBracketToken, this.closeBracketToken);
    }

    public withCloseBracketToken(closeBracketToken: ISyntaxToken): ArrayTypeSyntax {
        return this.update(this.type, this.openBracketToken, closeBracketToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class GenericTypeSyntax extends SyntaxNode implements ITypeSyntax {

    constructor(public name: INameSyntax,
                public typeArgumentList: TypeArgumentListSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitGenericType(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.GenericType;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.name;
            case 1: return this.typeArgumentList;
            default: throw Errors.invalidOperation();
        }
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(name: INameSyntax,
                  typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax {
        if (this.name === name && this.typeArgumentList === typeArgumentList) {
            return this;
        }

        return new GenericTypeSyntax(name, typeArgumentList, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(name: INameSyntax): GenericTypeSyntax {
        return new GenericTypeSyntax(name, TypeArgumentListSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): GenericTypeSyntax {
        return <GenericTypeSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): GenericTypeSyntax {
        return <GenericTypeSyntax>super.withTrailingTrivia(trivia);
    }

    public withName(name: INameSyntax): GenericTypeSyntax {
        return this.update(name, this.typeArgumentList);
    }

    public withTypeArgumentList(typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax {
        return this.update(this.name, typeArgumentList);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class TypeAnnotationSyntax extends SyntaxNode {

    constructor(public colonToken: ISyntaxToken,
                public type: ITypeSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTypeAnnotation(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TypeAnnotation;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.colonToken;
            case 1: return this.type;
            default: throw Errors.invalidOperation();
        }
    }

    public update(colonToken: ISyntaxToken,
                  type: ITypeSyntax): TypeAnnotationSyntax {
        if (this.colonToken === colonToken && this.type === type) {
            return this;
        }

        return new TypeAnnotationSyntax(colonToken, type, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(type: ITypeSyntax): TypeAnnotationSyntax {
        return new TypeAnnotationSyntax(Syntax.token(SyntaxKind.ColonToken), type, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TypeAnnotationSyntax {
        return <TypeAnnotationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TypeAnnotationSyntax {
        return <TypeAnnotationSyntax>super.withTrailingTrivia(trivia);
    }

    public withColonToken(colonToken: ISyntaxToken): TypeAnnotationSyntax {
        return this.update(colonToken, this.type);
    }

    public withType(type: ITypeSyntax): TypeAnnotationSyntax {
        return this.update(this.colonToken, type);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class BlockSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public openBraceToken: ISyntaxToken,
                public statements: ISyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitBlock(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.Block;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openBraceToken;
            case 1: return this.statements;
            case 2: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(openBraceToken: ISyntaxToken,
                  statements: ISyntaxList,
                  closeBraceToken: ISyntaxToken): BlockSyntax {
        if (this.openBraceToken === openBraceToken && this.statements === statements && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new BlockSyntax(openBraceToken, statements, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): BlockSyntax {
        return new BlockSyntax(openBraceToken, Syntax.emptyList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): BlockSyntax {
        return new BlockSyntax(Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptyList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): BlockSyntax {
        return <BlockSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): BlockSyntax {
        return <BlockSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): BlockSyntax {
        return this.update(openBraceToken, this.statements, this.closeBraceToken);
    }

    public withStatements(statements: ISyntaxList): BlockSyntax {
        return this.update(this.openBraceToken, statements, this.closeBraceToken);
    }

    public withStatement(statement: IStatementSyntax): BlockSyntax {
        return this.withStatements(Syntax.list([statement]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): BlockSyntax {
        return this.update(this.openBraceToken, this.statements, closeBraceToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.statements.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ParameterSyntax extends SyntaxNode {

    constructor(public dotDotDotToken: ISyntaxToken,
                public publicOrPrivateKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public questionToken: ISyntaxToken,
                public typeAnnotation: TypeAnnotationSyntax,
                public equalsValueClause: EqualsValueClauseSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitParameter(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.Parameter;
    }

    private childCount(): number {
        return 6;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.dotDotDotToken;
            case 1: return this.publicOrPrivateKeyword;
            case 2: return this.identifier;
            case 3: return this.questionToken;
            case 4: return this.typeAnnotation;
            case 5: return this.equalsValueClause;
            default: throw Errors.invalidOperation();
        }
    }

    public update(dotDotDotToken: ISyntaxToken,
                  publicOrPrivateKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  questionToken: ISyntaxToken,
                  typeAnnotation: TypeAnnotationSyntax,
                  equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax {
        if (this.dotDotDotToken === dotDotDotToken && this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.identifier === identifier && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
            return this;
        }

        return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(identifier: ISyntaxToken): ParameterSyntax {
        return new ParameterSyntax(null, null, identifier, null, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): ParameterSyntax {
        return new ParameterSyntax(null, null, identifier, null, null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ParameterSyntax {
        return <ParameterSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ParameterSyntax {
        return <ParameterSyntax>super.withTrailingTrivia(trivia);
    }

    public withDotDotDotToken(dotDotDotToken: ISyntaxToken): ParameterSyntax {
        return this.update(dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
    }

    public withPublicOrPrivateKeyword(publicOrPrivateKeyword: ISyntaxToken): ParameterSyntax {
        return this.update(this.dotDotDotToken, publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
    }

    public withIdentifier(identifier: ISyntaxToken): ParameterSyntax {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
    }

    public withQuestionToken(questionToken: ISyntaxToken): ParameterSyntax {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, questionToken, this.typeAnnotation, this.equalsValueClause);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): ParameterSyntax {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, typeAnnotation, this.equalsValueClause);
    }

    public withEqualsValueClause(equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, equalsValueClause);
    }

    private isTypeScriptSpecific(): bool {
        if (this.dotDotDotToken !== null) { return true; }
        if (this.publicOrPrivateKeyword !== null) { return true; }
        if (this.questionToken !== null) { return true; }
        if (this.typeAnnotation !== null) { return true; }
        if (this.equalsValueClause !== null) { return true; }
        return false;
    }
}

class MemberAccessExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public expression: IExpressionSyntax,
                public dotToken: ISyntaxToken,
                public name: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitMemberAccessExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.MemberAccessExpression;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.expression;
            case 1: return this.dotToken;
            case 2: return this.name;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(expression: IExpressionSyntax,
                  dotToken: ISyntaxToken,
                  name: ISyntaxToken): MemberAccessExpressionSyntax {
        if (this.expression === expression && this.dotToken === dotToken && this.name === name) {
            return this;
        }

        return new MemberAccessExpressionSyntax(expression, dotToken, name, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax,
                          name: ISyntaxToken): MemberAccessExpressionSyntax {
        return new MemberAccessExpressionSyntax(expression, Syntax.token(SyntaxKind.DotToken), name, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): MemberAccessExpressionSyntax {
        return <MemberAccessExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): MemberAccessExpressionSyntax {
        return <MemberAccessExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withExpression(expression: IExpressionSyntax): MemberAccessExpressionSyntax {
        return this.update(expression, this.dotToken, this.name);
    }

    public withDotToken(dotToken: ISyntaxToken): MemberAccessExpressionSyntax {
        return this.update(this.expression, dotToken, this.name);
    }

    public withName(name: ISyntaxToken): MemberAccessExpressionSyntax {
        return this.update(this.expression, this.dotToken, name);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class PostfixUnaryExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
    private _kind: SyntaxKind;

    constructor(kind: SyntaxKind,
                public operand: IExpressionSyntax,
                public operatorToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

        this._kind = kind;
    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitPostfixUnaryExpression(this);
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.operand;
            case 1: return this.operatorToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public kind(): SyntaxKind {
        return this._kind;
    }

    public update(kind: SyntaxKind,
                  operand: IExpressionSyntax,
                  operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax {
        if (this._kind === kind && this.operand === operand && this.operatorToken === operatorToken) {
            return this;
        }

        return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): PostfixUnaryExpressionSyntax {
        return <PostfixUnaryExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): PostfixUnaryExpressionSyntax {
        return <PostfixUnaryExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withKind(kind: SyntaxKind): PostfixUnaryExpressionSyntax {
        return this.update(kind, this.operand, this.operatorToken);
    }

    public withOperand(operand: IExpressionSyntax): PostfixUnaryExpressionSyntax {
        return this.update(this._kind, operand, this.operatorToken);
    }

    public withOperatorToken(operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax {
        return this.update(this._kind, this.operand, operatorToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.operand.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ElementAccessExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public expression: IExpressionSyntax,
                public openBracketToken: ISyntaxToken,
                public argumentExpression: IExpressionSyntax,
                public closeBracketToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitElementAccessExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ElementAccessExpression;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.expression;
            case 1: return this.openBracketToken;
            case 2: return this.argumentExpression;
            case 3: return this.closeBracketToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(expression: IExpressionSyntax,
                  openBracketToken: ISyntaxToken,
                  argumentExpression: IExpressionSyntax,
                  closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax {
        if (this.expression === expression && this.openBracketToken === openBracketToken && this.argumentExpression === argumentExpression && this.closeBracketToken === closeBracketToken) {
            return this;
        }

        return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax,
                          argumentExpression: IExpressionSyntax): ElementAccessExpressionSyntax {
        return new ElementAccessExpressionSyntax(expression, Syntax.token(SyntaxKind.OpenBracketToken), argumentExpression, Syntax.token(SyntaxKind.CloseBracketToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ElementAccessExpressionSyntax {
        return <ElementAccessExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ElementAccessExpressionSyntax {
        return <ElementAccessExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withExpression(expression: IExpressionSyntax): ElementAccessExpressionSyntax {
        return this.update(expression, this.openBracketToken, this.argumentExpression, this.closeBracketToken);
    }

    public withOpenBracketToken(openBracketToken: ISyntaxToken): ElementAccessExpressionSyntax {
        return this.update(this.expression, openBracketToken, this.argumentExpression, this.closeBracketToken);
    }

    public withArgumentExpression(argumentExpression: IExpressionSyntax): ElementAccessExpressionSyntax {
        return this.update(this.expression, this.openBracketToken, argumentExpression, this.closeBracketToken);
    }

    public withCloseBracketToken(closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax {
        return this.update(this.expression, this.openBracketToken, this.argumentExpression, closeBracketToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.argumentExpression.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class InvocationExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public expression: IExpressionSyntax,
                public argumentList: ArgumentListSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitInvocationExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.InvocationExpression;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(expression: IExpressionSyntax,
                  argumentList: ArgumentListSyntax): InvocationExpressionSyntax {
        if (this.expression === expression && this.argumentList === argumentList) {
            return this;
        }

        return new InvocationExpressionSyntax(expression, argumentList, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): InvocationExpressionSyntax {
        return new InvocationExpressionSyntax(expression, ArgumentListSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): InvocationExpressionSyntax {
        return <InvocationExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): InvocationExpressionSyntax {
        return <InvocationExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withExpression(expression: IExpressionSyntax): InvocationExpressionSyntax {
        return this.update(expression, this.argumentList);
    }

    public withArgumentList(argumentList: ArgumentListSyntax): InvocationExpressionSyntax {
        return this.update(this.expression, argumentList);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.argumentList.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ArgumentListSyntax extends SyntaxNode {

    constructor(public typeArgumentList: TypeArgumentListSyntax,
                public openParenToken: ISyntaxToken,
                public arguments: ISeparatedSyntaxList,
                public closeParenToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitArgumentList(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ArgumentList;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.typeArgumentList;
            case 1: return this.openParenToken;
            case 2: return this.arguments;
            case 3: return this.closeParenToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(typeArgumentList: TypeArgumentListSyntax,
                  openParenToken: ISyntaxToken,
                  _arguments: ISeparatedSyntaxList,
                  closeParenToken: ISyntaxToken): ArgumentListSyntax {
        if (this.typeArgumentList === typeArgumentList && this.openParenToken === openParenToken && this.arguments === _arguments && this.closeParenToken === closeParenToken) {
            return this;
        }

        return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openParenToken: ISyntaxToken,
                         closeParenToken: ISyntaxToken): ArgumentListSyntax {
        return new ArgumentListSyntax(null, openParenToken, Syntax.emptySeparatedList, closeParenToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ArgumentListSyntax {
        return new ArgumentListSyntax(null, Syntax.token(SyntaxKind.OpenParenToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseParenToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ArgumentListSyntax {
        return <ArgumentListSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ArgumentListSyntax {
        return <ArgumentListSyntax>super.withTrailingTrivia(trivia);
    }

    public withTypeArgumentList(typeArgumentList: TypeArgumentListSyntax): ArgumentListSyntax {
        return this.update(typeArgumentList, this.openParenToken, this.arguments, this.closeParenToken);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ArgumentListSyntax {
        return this.update(this.typeArgumentList, openParenToken, this.arguments, this.closeParenToken);
    }

    public withArguments(_arguments: ISeparatedSyntaxList): ArgumentListSyntax {
        return this.update(this.typeArgumentList, this.openParenToken, _arguments, this.closeParenToken);
    }

    public withArgument(_argument: IExpressionSyntax): ArgumentListSyntax {
        return this.withArguments(Syntax.separatedList([_argument]));
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ArgumentListSyntax {
        return this.update(this.typeArgumentList, this.openParenToken, this.arguments, closeParenToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.typeArgumentList !== null && this.typeArgumentList.isTypeScriptSpecific()) { return true; }
        if (this.arguments.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class BinaryExpressionSyntax extends SyntaxNode implements IExpressionSyntax {
    private _kind: SyntaxKind;

    constructor(kind: SyntaxKind,
                public left: IExpressionSyntax,
                public operatorToken: ISyntaxToken,
                public right: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

        this._kind = kind;
    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitBinaryExpression(this);
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.left;
            case 1: return this.operatorToken;
            case 2: return this.right;
            default: throw Errors.invalidOperation();
        }
    }

    private isExpression(): bool {
        return true;
    }

    public kind(): SyntaxKind {
        return this._kind;
    }

    public update(kind: SyntaxKind,
                  left: IExpressionSyntax,
                  operatorToken: ISyntaxToken,
                  right: IExpressionSyntax): BinaryExpressionSyntax {
        if (this._kind === kind && this.left === left && this.operatorToken === operatorToken && this.right === right) {
            return this;
        }

        return new BinaryExpressionSyntax(kind, left, operatorToken, right, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): BinaryExpressionSyntax {
        return <BinaryExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): BinaryExpressionSyntax {
        return <BinaryExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withKind(kind: SyntaxKind): BinaryExpressionSyntax {
        return this.update(kind, this.left, this.operatorToken, this.right);
    }

    public withLeft(left: IExpressionSyntax): BinaryExpressionSyntax {
        return this.update(this._kind, left, this.operatorToken, this.right);
    }

    public withOperatorToken(operatorToken: ISyntaxToken): BinaryExpressionSyntax {
        return this.update(this._kind, this.left, operatorToken, this.right);
    }

    public withRight(right: IExpressionSyntax): BinaryExpressionSyntax {
        return this.update(this._kind, this.left, this.operatorToken, right);
    }

    private isTypeScriptSpecific(): bool {
        if (this.left.isTypeScriptSpecific()) { return true; }
        if (this.right.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ConditionalExpressionSyntax extends SyntaxNode implements IExpressionSyntax {

    constructor(public condition: IExpressionSyntax,
                public questionToken: ISyntaxToken,
                public whenTrue: IExpressionSyntax,
                public colonToken: ISyntaxToken,
                public whenFalse: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitConditionalExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ConditionalExpression;
    }

    private childCount(): number {
        return 5;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.condition;
            case 1: return this.questionToken;
            case 2: return this.whenTrue;
            case 3: return this.colonToken;
            case 4: return this.whenFalse;
            default: throw Errors.invalidOperation();
        }
    }

    private isExpression(): bool {
        return true;
    }

    public update(condition: IExpressionSyntax,
                  questionToken: ISyntaxToken,
                  whenTrue: IExpressionSyntax,
                  colonToken: ISyntaxToken,
                  whenFalse: IExpressionSyntax): ConditionalExpressionSyntax {
        if (this.condition === condition && this.questionToken === questionToken && this.whenTrue === whenTrue && this.colonToken === colonToken && this.whenFalse === whenFalse) {
            return this;
        }

        return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(condition: IExpressionSyntax,
                          whenTrue: IExpressionSyntax,
                          whenFalse: IExpressionSyntax): ConditionalExpressionSyntax {
        return new ConditionalExpressionSyntax(condition, Syntax.token(SyntaxKind.QuestionToken), whenTrue, Syntax.token(SyntaxKind.ColonToken), whenFalse, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ConditionalExpressionSyntax {
        return <ConditionalExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ConditionalExpressionSyntax {
        return <ConditionalExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withCondition(condition: IExpressionSyntax): ConditionalExpressionSyntax {
        return this.update(condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse);
    }

    public withQuestionToken(questionToken: ISyntaxToken): ConditionalExpressionSyntax {
        return this.update(this.condition, questionToken, this.whenTrue, this.colonToken, this.whenFalse);
    }

    public withWhenTrue(whenTrue: IExpressionSyntax): ConditionalExpressionSyntax {
        return this.update(this.condition, this.questionToken, whenTrue, this.colonToken, this.whenFalse);
    }

    public withColonToken(colonToken: ISyntaxToken): ConditionalExpressionSyntax {
        return this.update(this.condition, this.questionToken, this.whenTrue, colonToken, this.whenFalse);
    }

    public withWhenFalse(whenFalse: IExpressionSyntax): ConditionalExpressionSyntax {
        return this.update(this.condition, this.questionToken, this.whenTrue, this.colonToken, whenFalse);
    }

    private isTypeScriptSpecific(): bool {
        if (this.condition.isTypeScriptSpecific()) { return true; }
        if (this.whenTrue.isTypeScriptSpecific()) { return true; }
        if (this.whenFalse.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class TypeMemberSyntax extends SyntaxNode implements ITypeMemberSyntax {
    constructor(parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    private isTypeMember(): bool {
        return true;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TypeMemberSyntax {
        return <TypeMemberSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TypeMemberSyntax {
        return <TypeMemberSyntax>super.withTrailingTrivia(trivia);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ConstructSignatureSyntax extends TypeMemberSyntax {

    constructor(public newKeyword: ISyntaxToken,
                public callSignature: CallSignatureSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitConstructSignature(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ConstructSignature;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.newKeyword;
            case 1: return this.callSignature;
            default: throw Errors.invalidOperation();
        }
    }

    public update(newKeyword: ISyntaxToken,
                  callSignature: CallSignatureSyntax): ConstructSignatureSyntax {
        if (this.newKeyword === newKeyword && this.callSignature === callSignature) {
            return this;
        }

        return new ConstructSignatureSyntax(newKeyword, callSignature, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(): ConstructSignatureSyntax {
        return new ConstructSignatureSyntax(Syntax.token(SyntaxKind.NewKeyword), CallSignatureSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ConstructSignatureSyntax {
        return <ConstructSignatureSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ConstructSignatureSyntax {
        return <ConstructSignatureSyntax>super.withTrailingTrivia(trivia);
    }

    public withNewKeyword(newKeyword: ISyntaxToken): ConstructSignatureSyntax {
        return this.update(newKeyword, this.callSignature);
    }

    public withCallSignature(callSignature: CallSignatureSyntax): ConstructSignatureSyntax {
        return this.update(this.newKeyword, callSignature);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class FunctionSignatureSyntax extends TypeMemberSyntax {

    constructor(public identifier: ISyntaxToken,
                public questionToken: ISyntaxToken,
                public callSignature: CallSignatureSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitFunctionSignature(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.FunctionSignature;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.identifier;
            case 1: return this.questionToken;
            case 2: return this.callSignature;
            default: throw Errors.invalidOperation();
        }
    }

    public update(identifier: ISyntaxToken,
                  questionToken: ISyntaxToken,
                  callSignature: CallSignatureSyntax): FunctionSignatureSyntax {
        if (this.identifier === identifier && this.questionToken === questionToken && this.callSignature === callSignature) {
            return this;
        }

        return new FunctionSignatureSyntax(identifier, questionToken, callSignature, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(identifier: ISyntaxToken,
                         callSignature: CallSignatureSyntax): FunctionSignatureSyntax {
        return new FunctionSignatureSyntax(identifier, null, callSignature, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): FunctionSignatureSyntax {
        return new FunctionSignatureSyntax(identifier, null, CallSignatureSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): FunctionSignatureSyntax {
        return <FunctionSignatureSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): FunctionSignatureSyntax {
        return <FunctionSignatureSyntax>super.withTrailingTrivia(trivia);
    }

    public withIdentifier(identifier: ISyntaxToken): FunctionSignatureSyntax {
        return this.update(identifier, this.questionToken, this.callSignature);
    }

    public withQuestionToken(questionToken: ISyntaxToken): FunctionSignatureSyntax {
        return this.update(this.identifier, questionToken, this.callSignature);
    }

    public withCallSignature(callSignature: CallSignatureSyntax): FunctionSignatureSyntax {
        return this.update(this.identifier, this.questionToken, callSignature);
    }

    private isTypeScriptSpecific(): bool {
        if (this.callSignature.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class IndexSignatureSyntax extends TypeMemberSyntax {

    constructor(public openBracketToken: ISyntaxToken,
                public parameter: ParameterSyntax,
                public closeBracketToken: ISyntaxToken,
                public typeAnnotation: TypeAnnotationSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitIndexSignature(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.IndexSignature;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openBracketToken;
            case 1: return this.parameter;
            case 2: return this.closeBracketToken;
            case 3: return this.typeAnnotation;
            default: throw Errors.invalidOperation();
        }
    }

    public update(openBracketToken: ISyntaxToken,
                  parameter: ParameterSyntax,
                  closeBracketToken: ISyntaxToken,
                  typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax {
        if (this.openBracketToken === openBracketToken && this.parameter === parameter && this.closeBracketToken === closeBracketToken && this.typeAnnotation === typeAnnotation) {
            return this;
        }

        return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openBracketToken: ISyntaxToken,
                         parameter: ParameterSyntax,
                         closeBracketToken: ISyntaxToken): IndexSignatureSyntax {
        return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(parameter: ParameterSyntax): IndexSignatureSyntax {
        return new IndexSignatureSyntax(Syntax.token(SyntaxKind.OpenBracketToken), parameter, Syntax.token(SyntaxKind.CloseBracketToken), null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): IndexSignatureSyntax {
        return <IndexSignatureSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): IndexSignatureSyntax {
        return <IndexSignatureSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenBracketToken(openBracketToken: ISyntaxToken): IndexSignatureSyntax {
        return this.update(openBracketToken, this.parameter, this.closeBracketToken, this.typeAnnotation);
    }

    public withParameter(parameter: ParameterSyntax): IndexSignatureSyntax {
        return this.update(this.openBracketToken, parameter, this.closeBracketToken, this.typeAnnotation);
    }

    public withCloseBracketToken(closeBracketToken: ISyntaxToken): IndexSignatureSyntax {
        return this.update(this.openBracketToken, this.parameter, closeBracketToken, this.typeAnnotation);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax {
        return this.update(this.openBracketToken, this.parameter, this.closeBracketToken, typeAnnotation);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class PropertySignatureSyntax extends TypeMemberSyntax {

    constructor(public identifier: ISyntaxToken,
                public questionToken: ISyntaxToken,
                public typeAnnotation: TypeAnnotationSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitPropertySignature(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.PropertySignature;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.identifier;
            case 1: return this.questionToken;
            case 2: return this.typeAnnotation;
            default: throw Errors.invalidOperation();
        }
    }

    public update(identifier: ISyntaxToken,
                  questionToken: ISyntaxToken,
                  typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax {
        if (this.identifier === identifier && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation) {
            return this;
        }

        return new PropertySignatureSyntax(identifier, questionToken, typeAnnotation, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(identifier: ISyntaxToken): PropertySignatureSyntax {
        return new PropertySignatureSyntax(identifier, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): PropertySignatureSyntax {
        return new PropertySignatureSyntax(identifier, null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): PropertySignatureSyntax {
        return <PropertySignatureSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): PropertySignatureSyntax {
        return <PropertySignatureSyntax>super.withTrailingTrivia(trivia);
    }

    public withIdentifier(identifier: ISyntaxToken): PropertySignatureSyntax {
        return this.update(identifier, this.questionToken, this.typeAnnotation);
    }

    public withQuestionToken(questionToken: ISyntaxToken): PropertySignatureSyntax {
        return this.update(this.identifier, questionToken, this.typeAnnotation);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax {
        return this.update(this.identifier, this.questionToken, typeAnnotation);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ParameterListSyntax extends SyntaxNode {

    constructor(public openParenToken: ISyntaxToken,
                public parameters: ISeparatedSyntaxList,
                public closeParenToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitParameterList(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ParameterList;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openParenToken;
            case 1: return this.parameters;
            case 2: return this.closeParenToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(openParenToken: ISyntaxToken,
                  parameters: ISeparatedSyntaxList,
                  closeParenToken: ISyntaxToken): ParameterListSyntax {
        if (this.openParenToken === openParenToken && this.parameters === parameters && this.closeParenToken === closeParenToken) {
            return this;
        }

        return new ParameterListSyntax(openParenToken, parameters, closeParenToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openParenToken: ISyntaxToken,
                         closeParenToken: ISyntaxToken): ParameterListSyntax {
        return new ParameterListSyntax(openParenToken, Syntax.emptySeparatedList, closeParenToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ParameterListSyntax {
        return new ParameterListSyntax(Syntax.token(SyntaxKind.OpenParenToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseParenToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ParameterListSyntax {
        return <ParameterListSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ParameterListSyntax {
        return <ParameterListSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ParameterListSyntax {
        return this.update(openParenToken, this.parameters, this.closeParenToken);
    }

    public withParameters(parameters: ISeparatedSyntaxList): ParameterListSyntax {
        return this.update(this.openParenToken, parameters, this.closeParenToken);
    }

    public withParameter(parameter: ParameterSyntax): ParameterListSyntax {
        return this.withParameters(Syntax.separatedList([parameter]));
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ParameterListSyntax {
        return this.update(this.openParenToken, this.parameters, closeParenToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.parameters.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class CallSignatureSyntax extends TypeMemberSyntax {

    constructor(public typeParameterList: TypeParameterListSyntax,
                public parameterList: ParameterListSyntax,
                public typeAnnotation: TypeAnnotationSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitCallSignature(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.CallSignature;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.typeParameterList;
            case 1: return this.parameterList;
            case 2: return this.typeAnnotation;
            default: throw Errors.invalidOperation();
        }
    }

    public update(typeParameterList: TypeParameterListSyntax,
                  parameterList: ParameterListSyntax,
                  typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax {
        if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation) {
            return this;
        }

        return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(parameterList: ParameterListSyntax): CallSignatureSyntax {
        return new CallSignatureSyntax(null, parameterList, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(): CallSignatureSyntax {
        return new CallSignatureSyntax(null, ParameterListSyntax.create1(), null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): CallSignatureSyntax {
        return <CallSignatureSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): CallSignatureSyntax {
        return <CallSignatureSyntax>super.withTrailingTrivia(trivia);
    }

    public withTypeParameterList(typeParameterList: TypeParameterListSyntax): CallSignatureSyntax {
        return this.update(typeParameterList, this.parameterList, this.typeAnnotation);
    }

    public withParameterList(parameterList: ParameterListSyntax): CallSignatureSyntax {
        return this.update(this.typeParameterList, parameterList, this.typeAnnotation);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax {
        return this.update(this.typeParameterList, this.parameterList, typeAnnotation);
    }

    private isTypeScriptSpecific(): bool {
        if (this.typeParameterList !== null) { return true; }
        if (this.parameterList.isTypeScriptSpecific()) { return true; }
        if (this.typeAnnotation !== null) { return true; }
        return false;
    }
}

class TypeParameterListSyntax extends SyntaxNode {

    constructor(public lessThanToken: ISyntaxToken,
                public typeParameters: ISeparatedSyntaxList,
                public greaterThanToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTypeParameterList(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TypeParameterList;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.lessThanToken;
            case 1: return this.typeParameters;
            case 2: return this.greaterThanToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(lessThanToken: ISyntaxToken,
                  typeParameters: ISeparatedSyntaxList,
                  greaterThanToken: ISyntaxToken): TypeParameterListSyntax {
        if (this.lessThanToken === lessThanToken && this.typeParameters === typeParameters && this.greaterThanToken === greaterThanToken) {
            return this;
        }

        return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(lessThanToken: ISyntaxToken,
                         greaterThanToken: ISyntaxToken): TypeParameterListSyntax {
        return new TypeParameterListSyntax(lessThanToken, Syntax.emptySeparatedList, greaterThanToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): TypeParameterListSyntax {
        return new TypeParameterListSyntax(Syntax.token(SyntaxKind.LessThanToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.GreaterThanToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TypeParameterListSyntax {
        return <TypeParameterListSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TypeParameterListSyntax {
        return <TypeParameterListSyntax>super.withTrailingTrivia(trivia);
    }

    public withLessThanToken(lessThanToken: ISyntaxToken): TypeParameterListSyntax {
        return this.update(lessThanToken, this.typeParameters, this.greaterThanToken);
    }

    public withTypeParameters(typeParameters: ISeparatedSyntaxList): TypeParameterListSyntax {
        return this.update(this.lessThanToken, typeParameters, this.greaterThanToken);
    }

    public withTypeParameter(typeParameter: TypeParameterSyntax): TypeParameterListSyntax {
        return this.withTypeParameters(Syntax.separatedList([typeParameter]));
    }

    public withGreaterThanToken(greaterThanToken: ISyntaxToken): TypeParameterListSyntax {
        return this.update(this.lessThanToken, this.typeParameters, greaterThanToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class TypeParameterSyntax extends SyntaxNode {

    constructor(public identifier: ISyntaxToken,
                public constraint: ConstraintSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTypeParameter(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TypeParameter;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.identifier;
            case 1: return this.constraint;
            default: throw Errors.invalidOperation();
        }
    }

    public update(identifier: ISyntaxToken,
                  constraint: ConstraintSyntax): TypeParameterSyntax {
        if (this.identifier === identifier && this.constraint === constraint) {
            return this;
        }

        return new TypeParameterSyntax(identifier, constraint, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(identifier: ISyntaxToken): TypeParameterSyntax {
        return new TypeParameterSyntax(identifier, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): TypeParameterSyntax {
        return new TypeParameterSyntax(identifier, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TypeParameterSyntax {
        return <TypeParameterSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TypeParameterSyntax {
        return <TypeParameterSyntax>super.withTrailingTrivia(trivia);
    }

    public withIdentifier(identifier: ISyntaxToken): TypeParameterSyntax {
        return this.update(identifier, this.constraint);
    }

    public withConstraint(constraint: ConstraintSyntax): TypeParameterSyntax {
        return this.update(this.identifier, constraint);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ConstraintSyntax extends SyntaxNode {

    constructor(public extendsKeyword: ISyntaxToken,
                public type: ITypeSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitConstraint(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.Constraint;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.extendsKeyword;
            case 1: return this.type;
            default: throw Errors.invalidOperation();
        }
    }

    public update(extendsKeyword: ISyntaxToken,
                  type: ITypeSyntax): ConstraintSyntax {
        if (this.extendsKeyword === extendsKeyword && this.type === type) {
            return this;
        }

        return new ConstraintSyntax(extendsKeyword, type, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(type: ITypeSyntax): ConstraintSyntax {
        return new ConstraintSyntax(Syntax.token(SyntaxKind.ExtendsKeyword), type, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ConstraintSyntax {
        return <ConstraintSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ConstraintSyntax {
        return <ConstraintSyntax>super.withTrailingTrivia(trivia);
    }

    public withExtendsKeyword(extendsKeyword: ISyntaxToken): ConstraintSyntax {
        return this.update(extendsKeyword, this.type);
    }

    public withType(type: ITypeSyntax): ConstraintSyntax {
        return this.update(this.extendsKeyword, type);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ElseClauseSyntax extends SyntaxNode {

    constructor(public elseKeyword: ISyntaxToken,
                public statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitElseClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ElseClause;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.elseKeyword;
            case 1: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    public update(elseKeyword: ISyntaxToken,
                  statement: IStatementSyntax): ElseClauseSyntax {
        if (this.elseKeyword === elseKeyword && this.statement === statement) {
            return this;
        }

        return new ElseClauseSyntax(elseKeyword, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(statement: IStatementSyntax): ElseClauseSyntax {
        return new ElseClauseSyntax(Syntax.token(SyntaxKind.ElseKeyword), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ElseClauseSyntax {
        return <ElseClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ElseClauseSyntax {
        return <ElseClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withElseKeyword(elseKeyword: ISyntaxToken): ElseClauseSyntax {
        return this.update(elseKeyword, this.statement);
    }

    public withStatement(statement: IStatementSyntax): ElseClauseSyntax {
        return this.update(this.elseKeyword, statement);
    }

    private isTypeScriptSpecific(): bool {
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class IfStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public ifKeyword: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public condition: IExpressionSyntax,
                public closeParenToken: ISyntaxToken,
                public statement: IStatementSyntax,
                public elseClause: ElseClauseSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitIfStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.IfStatement;
    }

    private childCount(): number {
        return 6;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.ifKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            case 5: return this.elseClause;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(ifKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  condition: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  statement: IStatementSyntax,
                  elseClause: ElseClauseSyntax): IfStatementSyntax {
        if (this.ifKeyword === ifKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement && this.elseClause === elseClause) {
            return this;
        }

        return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(ifKeyword: ISyntaxToken,
                         openParenToken: ISyntaxToken,
                         condition: IExpressionSyntax,
                         closeParenToken: ISyntaxToken,
                         statement: IStatementSyntax): IfStatementSyntax {
        return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(condition: IExpressionSyntax,
                          statement: IStatementSyntax): IfStatementSyntax {
        return new IfStatementSyntax(Syntax.token(SyntaxKind.IfKeyword), Syntax.token(SyntaxKind.OpenParenToken), condition, Syntax.token(SyntaxKind.CloseParenToken), statement, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): IfStatementSyntax {
        return <IfStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): IfStatementSyntax {
        return <IfStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withIfKeyword(ifKeyword: ISyntaxToken): IfStatementSyntax {
        return this.update(ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): IfStatementSyntax {
        return this.update(this.ifKeyword, openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
    }

    public withCondition(condition: IExpressionSyntax): IfStatementSyntax {
        return this.update(this.ifKeyword, this.openParenToken, condition, this.closeParenToken, this.statement, this.elseClause);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): IfStatementSyntax {
        return this.update(this.ifKeyword, this.openParenToken, this.condition, closeParenToken, this.statement, this.elseClause);
    }

    public withStatement(statement: IStatementSyntax): IfStatementSyntax {
        return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, statement, this.elseClause);
    }

    public withElseClause(elseClause: ElseClauseSyntax): IfStatementSyntax {
        return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, elseClause);
    }

    private isTypeScriptSpecific(): bool {
        if (this.condition.isTypeScriptSpecific()) { return true; }
        if (this.statement.isTypeScriptSpecific()) { return true; }
        if (this.elseClause !== null && this.elseClause.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ExpressionStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public expression: IExpressionSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitExpressionStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ExpressionStatement;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.expression;
            case 1: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(expression: IExpressionSyntax,
                  semicolonToken: ISyntaxToken): ExpressionStatementSyntax {
        if (this.expression === expression && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ExpressionStatementSyntax(expression, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): ExpressionStatementSyntax {
        return new ExpressionStatementSyntax(expression, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ExpressionStatementSyntax {
        return <ExpressionStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ExpressionStatementSyntax {
        return <ExpressionStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withExpression(expression: IExpressionSyntax): ExpressionStatementSyntax {
        return this.update(expression, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ExpressionStatementSyntax {
        return this.update(this.expression, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ConstructorDeclarationSyntax extends SyntaxNode implements IClassElementSyntax {

    constructor(public constructorKeyword: ISyntaxToken,
                public parameterList: ParameterListSyntax,
                public block: BlockSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitConstructorDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ConstructorDeclaration;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.constructorKeyword;
            case 1: return this.parameterList;
            case 2: return this.block;
            case 3: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isClassElement(): bool {
        return true;
    }

    public update(constructorKeyword: ISyntaxToken,
                  parameterList: ParameterListSyntax,
                  block: BlockSyntax,
                  semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax {
        if (this.constructorKeyword === constructorKeyword && this.parameterList === parameterList && this.block === block && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(constructorKeyword: ISyntaxToken,
                         parameterList: ParameterListSyntax): ConstructorDeclarationSyntax {
        return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ConstructorDeclarationSyntax {
        return new ConstructorDeclarationSyntax(Syntax.token(SyntaxKind.ConstructorKeyword), ParameterListSyntax.create1(), null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ConstructorDeclarationSyntax {
        return <ConstructorDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ConstructorDeclarationSyntax {
        return <ConstructorDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withConstructorKeyword(constructorKeyword: ISyntaxToken): ConstructorDeclarationSyntax {
        return this.update(constructorKeyword, this.parameterList, this.block, this.semicolonToken);
    }

    public withParameterList(parameterList: ParameterListSyntax): ConstructorDeclarationSyntax {
        return this.update(this.constructorKeyword, parameterList, this.block, this.semicolonToken);
    }

    public withBlock(block: BlockSyntax): ConstructorDeclarationSyntax {
        return this.update(this.constructorKeyword, this.parameterList, block, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax {
        return this.update(this.constructorKeyword, this.parameterList, this.block, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class MemberFunctionDeclarationSyntax extends SyntaxNode implements IMemberDeclarationSyntax {

    constructor(public publicOrPrivateKeyword: ISyntaxToken,
                public staticKeyword: ISyntaxToken,
                public functionSignature: FunctionSignatureSyntax,
                public block: BlockSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitMemberFunctionDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.MemberFunctionDeclaration;
    }

    private childCount(): number {
        return 5;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.publicOrPrivateKeyword;
            case 1: return this.staticKeyword;
            case 2: return this.functionSignature;
            case 3: return this.block;
            case 4: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isMemberDeclaration(): bool {
        return true;
    }

    private isClassElement(): bool {
        return true;
    }

    public update(publicOrPrivateKeyword: ISyntaxToken,
                  staticKeyword: ISyntaxToken,
                  functionSignature: FunctionSignatureSyntax,
                  block: BlockSyntax,
                  semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.functionSignature === functionSignature && this.block === block && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new MemberFunctionDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(functionSignature: FunctionSignatureSyntax): MemberFunctionDeclarationSyntax {
        return new MemberFunctionDeclarationSyntax(null, null, functionSignature, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(functionSignature: FunctionSignatureSyntax): MemberFunctionDeclarationSyntax {
        return new MemberFunctionDeclarationSyntax(null, null, functionSignature, null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): MemberFunctionDeclarationSyntax {
        return <MemberFunctionDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): MemberFunctionDeclarationSyntax {
        return <MemberFunctionDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withPublicOrPrivateKeyword(publicOrPrivateKeyword: ISyntaxToken): MemberFunctionDeclarationSyntax {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.functionSignature, this.block, this.semicolonToken);
    }

    public withStaticKeyword(staticKeyword: ISyntaxToken): MemberFunctionDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.functionSignature, this.block, this.semicolonToken);
    }

    public withFunctionSignature(functionSignature: FunctionSignatureSyntax): MemberFunctionDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, functionSignature, this.block, this.semicolonToken);
    }

    public withBlock(block: BlockSyntax): MemberFunctionDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.functionSignature, block, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.functionSignature, this.block, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class MemberAccessorDeclarationSyntax extends SyntaxNode implements IMemberDeclarationSyntax {
    constructor(public publicOrPrivateKeyword: ISyntaxToken,
                public staticKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public parameterList: ParameterListSyntax,
                public block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    private isMemberDeclaration(): bool {
        return true;
    }

    private isClassElement(): bool {
        return true;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): MemberAccessorDeclarationSyntax {
        return <MemberAccessorDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): MemberAccessorDeclarationSyntax {
        return <MemberAccessorDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class GetMemberAccessorDeclarationSyntax extends MemberAccessorDeclarationSyntax {

    constructor(publicOrPrivateKeyword: ISyntaxToken,
                staticKeyword: ISyntaxToken,
                public getKeyword: ISyntaxToken,
                identifier: ISyntaxToken,
                parameterList: ParameterListSyntax,
                public typeAnnotation: TypeAnnotationSyntax,
                block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(publicOrPrivateKeyword, staticKeyword, identifier, parameterList, block, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitGetMemberAccessorDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.GetMemberAccessorDeclaration;
    }

    private childCount(): number {
        return 7;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.publicOrPrivateKeyword;
            case 1: return this.staticKeyword;
            case 2: return this.getKeyword;
            case 3: return this.identifier;
            case 4: return this.parameterList;
            case 5: return this.typeAnnotation;
            case 6: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(publicOrPrivateKeyword: ISyntaxToken,
                  staticKeyword: ISyntaxToken,
                  getKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  parameterList: ParameterListSyntax,
                  typeAnnotation: TypeAnnotationSyntax,
                  block: BlockSyntax): GetMemberAccessorDeclarationSyntax {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.getKeyword === getKeyword && this.identifier === identifier && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation && this.block === block) {
            return this;
        }

        return new GetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(getKeyword: ISyntaxToken,
                         identifier: ISyntaxToken,
                         parameterList: ParameterListSyntax,
                         block: BlockSyntax): GetMemberAccessorDeclarationSyntax {
        return new GetMemberAccessorDeclarationSyntax(null, null, getKeyword, identifier, parameterList, null, block, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
        return new GetMemberAccessorDeclarationSyntax(null, null, Syntax.token(SyntaxKind.GetKeyword), identifier, ParameterListSyntax.create1(), null, BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): GetMemberAccessorDeclarationSyntax {
        return <GetMemberAccessorDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): GetMemberAccessorDeclarationSyntax {
        return <GetMemberAccessorDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withPublicOrPrivateKeyword(publicOrPrivateKeyword: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, this.parameterList, this.typeAnnotation, this.block);
    }

    public withStaticKeyword(staticKeyword: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.getKeyword, this.identifier, this.parameterList, this.typeAnnotation, this.block);
    }

    public withGetKeyword(getKeyword: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, getKeyword, this.identifier, this.parameterList, this.typeAnnotation, this.block);
    }

    public withIdentifier(identifier: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, identifier, this.parameterList, this.typeAnnotation, this.block);
    }

    public withParameterList(parameterList: ParameterListSyntax): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, parameterList, this.typeAnnotation, this.block);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, this.parameterList, typeAnnotation, this.block);
    }

    public withBlock(block: BlockSyntax): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, this.parameterList, this.typeAnnotation, block);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class SetMemberAccessorDeclarationSyntax extends MemberAccessorDeclarationSyntax {

    constructor(publicOrPrivateKeyword: ISyntaxToken,
                staticKeyword: ISyntaxToken,
                public setKeyword: ISyntaxToken,
                identifier: ISyntaxToken,
                parameterList: ParameterListSyntax,
                block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(publicOrPrivateKeyword, staticKeyword, identifier, parameterList, block, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSetMemberAccessorDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SetMemberAccessorDeclaration;
    }

    private childCount(): number {
        return 6;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.publicOrPrivateKeyword;
            case 1: return this.staticKeyword;
            case 2: return this.setKeyword;
            case 3: return this.identifier;
            case 4: return this.parameterList;
            case 5: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(publicOrPrivateKeyword: ISyntaxToken,
                  staticKeyword: ISyntaxToken,
                  setKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  parameterList: ParameterListSyntax,
                  block: BlockSyntax): SetMemberAccessorDeclarationSyntax {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.setKeyword === setKeyword && this.identifier === identifier && this.parameterList === parameterList && this.block === block) {
            return this;
        }

        return new SetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(setKeyword: ISyntaxToken,
                         identifier: ISyntaxToken,
                         parameterList: ParameterListSyntax,
                         block: BlockSyntax): SetMemberAccessorDeclarationSyntax {
        return new SetMemberAccessorDeclarationSyntax(null, null, setKeyword, identifier, parameterList, block, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
        return new SetMemberAccessorDeclarationSyntax(null, null, Syntax.token(SyntaxKind.SetKeyword), identifier, ParameterListSyntax.create1(), BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SetMemberAccessorDeclarationSyntax {
        return <SetMemberAccessorDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SetMemberAccessorDeclarationSyntax {
        return <SetMemberAccessorDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withPublicOrPrivateKeyword(publicOrPrivateKeyword: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, this.identifier, this.parameterList, this.block);
    }

    public withStaticKeyword(staticKeyword: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.setKeyword, this.identifier, this.parameterList, this.block);
    }

    public withSetKeyword(setKeyword: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, setKeyword, this.identifier, this.parameterList, this.block);
    }

    public withIdentifier(identifier: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, identifier, this.parameterList, this.block);
    }

    public withParameterList(parameterList: ParameterListSyntax): SetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, this.identifier, parameterList, this.block);
    }

    public withBlock(block: BlockSyntax): SetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, this.identifier, this.parameterList, block);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class MemberVariableDeclarationSyntax extends SyntaxNode implements IMemberDeclarationSyntax {

    constructor(public publicOrPrivateKeyword: ISyntaxToken,
                public staticKeyword: ISyntaxToken,
                public variableDeclarator: VariableDeclaratorSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitMemberVariableDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.MemberVariableDeclaration;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.publicOrPrivateKeyword;
            case 1: return this.staticKeyword;
            case 2: return this.variableDeclarator;
            case 3: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isMemberDeclaration(): bool {
        return true;
    }

    private isClassElement(): bool {
        return true;
    }

    public update(publicOrPrivateKeyword: ISyntaxToken,
                  staticKeyword: ISyntaxToken,
                  variableDeclarator: VariableDeclaratorSyntax,
                  semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.variableDeclarator === variableDeclarator && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new MemberVariableDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(variableDeclarator: VariableDeclaratorSyntax,
                         semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax {
        return new MemberVariableDeclarationSyntax(null, null, variableDeclarator, semicolonToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(variableDeclarator: VariableDeclaratorSyntax): MemberVariableDeclarationSyntax {
        return new MemberVariableDeclarationSyntax(null, null, variableDeclarator, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): MemberVariableDeclarationSyntax {
        return <MemberVariableDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): MemberVariableDeclarationSyntax {
        return <MemberVariableDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withPublicOrPrivateKeyword(publicOrPrivateKeyword: ISyntaxToken): MemberVariableDeclarationSyntax {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.variableDeclarator, this.semicolonToken);
    }

    public withStaticKeyword(staticKeyword: ISyntaxToken): MemberVariableDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.variableDeclarator, this.semicolonToken);
    }

    public withVariableDeclarator(variableDeclarator: VariableDeclaratorSyntax): MemberVariableDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, variableDeclarator, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.variableDeclarator, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ThrowStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public throwKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitThrowStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ThrowStatement;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.throwKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(throwKeyword: ISyntaxToken,
                  expression: IExpressionSyntax,
                  semicolonToken: ISyntaxToken): ThrowStatementSyntax {
        if (this.throwKeyword === throwKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): ThrowStatementSyntax {
        return new ThrowStatementSyntax(Syntax.token(SyntaxKind.ThrowKeyword), expression, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ThrowStatementSyntax {
        return <ThrowStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ThrowStatementSyntax {
        return <ThrowStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withThrowKeyword(throwKeyword: ISyntaxToken): ThrowStatementSyntax {
        return this.update(throwKeyword, this.expression, this.semicolonToken);
    }

    public withExpression(expression: IExpressionSyntax): ThrowStatementSyntax {
        return this.update(this.throwKeyword, expression, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ThrowStatementSyntax {
        return this.update(this.throwKeyword, this.expression, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ReturnStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public returnKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitReturnStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ReturnStatement;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.returnKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(returnKeyword: ISyntaxToken,
                  expression: IExpressionSyntax,
                  semicolonToken: ISyntaxToken): ReturnStatementSyntax {
        if (this.returnKeyword === returnKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(returnKeyword: ISyntaxToken,
                         semicolonToken: ISyntaxToken): ReturnStatementSyntax {
        return new ReturnStatementSyntax(returnKeyword, null, semicolonToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ReturnStatementSyntax {
        return new ReturnStatementSyntax(Syntax.token(SyntaxKind.ReturnKeyword), null, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ReturnStatementSyntax {
        return <ReturnStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ReturnStatementSyntax {
        return <ReturnStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withReturnKeyword(returnKeyword: ISyntaxToken): ReturnStatementSyntax {
        return this.update(returnKeyword, this.expression, this.semicolonToken);
    }

    public withExpression(expression: IExpressionSyntax): ReturnStatementSyntax {
        return this.update(this.returnKeyword, expression, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ReturnStatementSyntax {
        return this.update(this.returnKeyword, this.expression, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression !== null && this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ObjectCreationExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public newKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                public argumentList: ArgumentListSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitObjectCreationExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ObjectCreationExpression;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.newKeyword;
            case 1: return this.expression;
            case 2: return this.argumentList;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(newKeyword: ISyntaxToken,
                  expression: IExpressionSyntax,
                  argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax {
        if (this.newKeyword === newKeyword && this.expression === expression && this.argumentList === argumentList) {
            return this;
        }

        return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(newKeyword: ISyntaxToken,
                         expression: IExpressionSyntax): ObjectCreationExpressionSyntax {
        return new ObjectCreationExpressionSyntax(newKeyword, expression, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(expression: IExpressionSyntax): ObjectCreationExpressionSyntax {
        return new ObjectCreationExpressionSyntax(Syntax.token(SyntaxKind.NewKeyword), expression, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ObjectCreationExpressionSyntax {
        return <ObjectCreationExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ObjectCreationExpressionSyntax {
        return <ObjectCreationExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withNewKeyword(newKeyword: ISyntaxToken): ObjectCreationExpressionSyntax {
        return this.update(newKeyword, this.expression, this.argumentList);
    }

    public withExpression(expression: IExpressionSyntax): ObjectCreationExpressionSyntax {
        return this.update(this.newKeyword, expression, this.argumentList);
    }

    public withArgumentList(argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax {
        return this.update(this.newKeyword, this.expression, argumentList);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.argumentList !== null && this.argumentList.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class SwitchStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public switchKeyword: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public expression: IExpressionSyntax,
                public closeParenToken: ISyntaxToken,
                public openBraceToken: ISyntaxToken,
                public switchClauses: ISyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSwitchStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SwitchStatement;
    }

    private childCount(): number {
        return 7;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.switchKeyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            case 4: return this.openBraceToken;
            case 5: return this.switchClauses;
            case 6: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(switchKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  expression: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  openBraceToken: ISyntaxToken,
                  switchClauses: ISyntaxList,
                  closeBraceToken: ISyntaxToken): SwitchStatementSyntax {
        if (this.switchKeyword === switchKeyword && this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken && this.openBraceToken === openBraceToken && this.switchClauses === switchClauses && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(switchKeyword: ISyntaxToken,
                         openParenToken: ISyntaxToken,
                         expression: IExpressionSyntax,
                         closeParenToken: ISyntaxToken,
                         openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): SwitchStatementSyntax {
        return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, Syntax.emptyList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(expression: IExpressionSyntax): SwitchStatementSyntax {
        return new SwitchStatementSyntax(Syntax.token(SyntaxKind.SwitchKeyword), Syntax.token(SyntaxKind.OpenParenToken), expression, Syntax.token(SyntaxKind.CloseParenToken), Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptyList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SwitchStatementSyntax {
        return <SwitchStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SwitchStatementSyntax {
        return <SwitchStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withSwitchKeyword(switchKeyword: ISyntaxToken): SwitchStatementSyntax {
        return this.update(switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): SwitchStatementSyntax {
        return this.update(this.switchKeyword, openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    }

    public withExpression(expression: IExpressionSyntax): SwitchStatementSyntax {
        return this.update(this.switchKeyword, this.openParenToken, expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): SwitchStatementSyntax {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): SwitchStatementSyntax {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, openBraceToken, this.switchClauses, this.closeBraceToken);
    }

    public withSwitchClauses(switchClauses: ISyntaxList): SwitchStatementSyntax {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, switchClauses, this.closeBraceToken);
    }

    public withSwitchClause(switchClause: SwitchClauseSyntax): SwitchStatementSyntax {
        return this.withSwitchClauses(Syntax.list([switchClause]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): SwitchStatementSyntax {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, closeBraceToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.switchClauses.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class SwitchClauseSyntax extends SyntaxNode implements ISwitchClauseSyntax {
    constructor(public colonToken: ISyntaxToken,
                public statements: ISyntaxList,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    private isSwitchClause(): bool {
        return true;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SwitchClauseSyntax {
        return <SwitchClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SwitchClauseSyntax {
        return <SwitchClauseSyntax>super.withTrailingTrivia(trivia);
    }

    private isTypeScriptSpecific(): bool {
        return false;
    }
}

class CaseSwitchClauseSyntax extends SwitchClauseSyntax {

    constructor(public caseKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                colonToken: ISyntaxToken,
                statements: ISyntaxList,
                parsedInStrictMode: bool) {
        super(colonToken, statements, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitCaseSwitchClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.CaseSwitchClause;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.caseKeyword;
            case 1: return this.expression;
            case 2: return this.colonToken;
            case 3: return this.statements;
            default: throw Errors.invalidOperation();
        }
    }

    public update(caseKeyword: ISyntaxToken,
                  expression: IExpressionSyntax,
                  colonToken: ISyntaxToken,
                  statements: ISyntaxList): CaseSwitchClauseSyntax {
        if (this.caseKeyword === caseKeyword && this.expression === expression && this.colonToken === colonToken && this.statements === statements) {
            return this;
        }

        return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(caseKeyword: ISyntaxToken,
                         expression: IExpressionSyntax,
                         colonToken: ISyntaxToken): CaseSwitchClauseSyntax {
        return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, Syntax.emptyList, /*parsedInStrictMode:*/ false);
    }

    public static create1(expression: IExpressionSyntax): CaseSwitchClauseSyntax {
        return new CaseSwitchClauseSyntax(Syntax.token(SyntaxKind.CaseKeyword), expression, Syntax.token(SyntaxKind.ColonToken), Syntax.emptyList, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): CaseSwitchClauseSyntax {
        return <CaseSwitchClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): CaseSwitchClauseSyntax {
        return <CaseSwitchClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withCaseKeyword(caseKeyword: ISyntaxToken): CaseSwitchClauseSyntax {
        return this.update(caseKeyword, this.expression, this.colonToken, this.statements);
    }

    public withExpression(expression: IExpressionSyntax): CaseSwitchClauseSyntax {
        return this.update(this.caseKeyword, expression, this.colonToken, this.statements);
    }

    public withColonToken(colonToken: ISyntaxToken): CaseSwitchClauseSyntax {
        return this.update(this.caseKeyword, this.expression, colonToken, this.statements);
    }

    public withStatements(statements: ISyntaxList): CaseSwitchClauseSyntax {
        return this.update(this.caseKeyword, this.expression, this.colonToken, statements);
    }

    public withStatement(statement: IStatementSyntax): CaseSwitchClauseSyntax {
        return this.withStatements(Syntax.list([statement]));
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.statements.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class DefaultSwitchClauseSyntax extends SwitchClauseSyntax {

    constructor(public defaultKeyword: ISyntaxToken,
                colonToken: ISyntaxToken,
                statements: ISyntaxList,
                parsedInStrictMode: bool) {
        super(colonToken, statements, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitDefaultSwitchClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.DefaultSwitchClause;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.defaultKeyword;
            case 1: return this.colonToken;
            case 2: return this.statements;
            default: throw Errors.invalidOperation();
        }
    }

    public update(defaultKeyword: ISyntaxToken,
                  colonToken: ISyntaxToken,
                  statements: ISyntaxList): DefaultSwitchClauseSyntax {
        if (this.defaultKeyword === defaultKeyword && this.colonToken === colonToken && this.statements === statements) {
            return this;
        }

        return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(defaultKeyword: ISyntaxToken,
                         colonToken: ISyntaxToken): DefaultSwitchClauseSyntax {
        return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, Syntax.emptyList, /*parsedInStrictMode:*/ false);
    }

    public static create1(): DefaultSwitchClauseSyntax {
        return new DefaultSwitchClauseSyntax(Syntax.token(SyntaxKind.DefaultKeyword), Syntax.token(SyntaxKind.ColonToken), Syntax.emptyList, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): DefaultSwitchClauseSyntax {
        return <DefaultSwitchClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): DefaultSwitchClauseSyntax {
        return <DefaultSwitchClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withDefaultKeyword(defaultKeyword: ISyntaxToken): DefaultSwitchClauseSyntax {
        return this.update(defaultKeyword, this.colonToken, this.statements);
    }

    public withColonToken(colonToken: ISyntaxToken): DefaultSwitchClauseSyntax {
        return this.update(this.defaultKeyword, colonToken, this.statements);
    }

    public withStatements(statements: ISyntaxList): DefaultSwitchClauseSyntax {
        return this.update(this.defaultKeyword, this.colonToken, statements);
    }

    public withStatement(statement: IStatementSyntax): DefaultSwitchClauseSyntax {
        return this.withStatements(Syntax.list([statement]));
    }

    private isTypeScriptSpecific(): bool {
        if (this.statements.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class BreakStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public breakKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitBreakStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.BreakStatement;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.breakKeyword;
            case 1: return this.identifier;
            case 2: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(breakKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  semicolonToken: ISyntaxToken): BreakStatementSyntax {
        if (this.breakKeyword === breakKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(breakKeyword: ISyntaxToken,
                         semicolonToken: ISyntaxToken): BreakStatementSyntax {
        return new BreakStatementSyntax(breakKeyword, null, semicolonToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): BreakStatementSyntax {
        return new BreakStatementSyntax(Syntax.token(SyntaxKind.BreakKeyword), null, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): BreakStatementSyntax {
        return <BreakStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): BreakStatementSyntax {
        return <BreakStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withBreakKeyword(breakKeyword: ISyntaxToken): BreakStatementSyntax {
        return this.update(breakKeyword, this.identifier, this.semicolonToken);
    }

    public withIdentifier(identifier: ISyntaxToken): BreakStatementSyntax {
        return this.update(this.breakKeyword, identifier, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): BreakStatementSyntax {
        return this.update(this.breakKeyword, this.identifier, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        return false;
    }
}

class ContinueStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public continueKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitContinueStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ContinueStatement;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.continueKeyword;
            case 1: return this.identifier;
            case 2: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(continueKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  semicolonToken: ISyntaxToken): ContinueStatementSyntax {
        if (this.continueKeyword === continueKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(continueKeyword: ISyntaxToken,
                         semicolonToken: ISyntaxToken): ContinueStatementSyntax {
        return new ContinueStatementSyntax(continueKeyword, null, semicolonToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ContinueStatementSyntax {
        return new ContinueStatementSyntax(Syntax.token(SyntaxKind.ContinueKeyword), null, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ContinueStatementSyntax {
        return <ContinueStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ContinueStatementSyntax {
        return <ContinueStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withContinueKeyword(continueKeyword: ISyntaxToken): ContinueStatementSyntax {
        return this.update(continueKeyword, this.identifier, this.semicolonToken);
    }

    public withIdentifier(identifier: ISyntaxToken): ContinueStatementSyntax {
        return this.update(this.continueKeyword, identifier, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ContinueStatementSyntax {
        return this.update(this.continueKeyword, this.identifier, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        return false;
    }
}

class IterationStatementSyntax extends SyntaxNode implements IStatementSyntax {
    constructor(public openParenToken: ISyntaxToken,
                public closeParenToken: ISyntaxToken,
                public statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): IterationStatementSyntax {
        return <IterationStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): IterationStatementSyntax {
        return <IterationStatementSyntax>super.withTrailingTrivia(trivia);
    }

    private isTypeScriptSpecific(): bool {
        return false;
    }
}

class BaseForStatementSyntax extends IterationStatementSyntax {
    constructor(public forKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                public variableDeclaration: VariableDeclarationSyntax,
                closeParenToken: ISyntaxToken,
                statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(openParenToken, closeParenToken, statement, parsedInStrictMode); 
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): BaseForStatementSyntax {
        return <BaseForStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): BaseForStatementSyntax {
        return <BaseForStatementSyntax>super.withTrailingTrivia(trivia);
    }

    private isTypeScriptSpecific(): bool {
        return false;
    }
}

class ForStatementSyntax extends BaseForStatementSyntax {

    constructor(forKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                variableDeclaration: VariableDeclarationSyntax,
                public initializer: IExpressionSyntax,
                public firstSemicolonToken: ISyntaxToken,
                public condition: IExpressionSyntax,
                public secondSemicolonToken: ISyntaxToken,
                public incrementor: IExpressionSyntax,
                closeParenToken: ISyntaxToken,
                statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitForStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ForStatement;
    }

    private childCount(): number {
        return 10;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.forKeyword;
            case 1: return this.openParenToken;
            case 2: return this.variableDeclaration;
            case 3: return this.initializer;
            case 4: return this.firstSemicolonToken;
            case 5: return this.condition;
            case 6: return this.secondSemicolonToken;
            case 7: return this.incrementor;
            case 8: return this.closeParenToken;
            case 9: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    public update(forKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  variableDeclaration: VariableDeclarationSyntax,
                  initializer: IExpressionSyntax,
                  firstSemicolonToken: ISyntaxToken,
                  condition: IExpressionSyntax,
                  secondSemicolonToken: ISyntaxToken,
                  incrementor: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  statement: IStatementSyntax): ForStatementSyntax {
        if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.initializer === initializer && this.firstSemicolonToken === firstSemicolonToken && this.condition === condition && this.secondSemicolonToken === secondSemicolonToken && this.incrementor === incrementor && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }

        return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(forKeyword: ISyntaxToken,
                         openParenToken: ISyntaxToken,
                         firstSemicolonToken: ISyntaxToken,
                         secondSemicolonToken: ISyntaxToken,
                         closeParenToken: ISyntaxToken,
                         statement: IStatementSyntax): ForStatementSyntax {
        return new ForStatementSyntax(forKeyword, openParenToken, null, null, firstSemicolonToken, null, secondSemicolonToken, null, closeParenToken, statement, /*parsedInStrictMode:*/ false);
    }

    public static create1(statement: IStatementSyntax): ForStatementSyntax {
        return new ForStatementSyntax(Syntax.token(SyntaxKind.ForKeyword), Syntax.token(SyntaxKind.OpenParenToken), null, null, Syntax.token(SyntaxKind.SemicolonToken), null, Syntax.token(SyntaxKind.SemicolonToken), null, Syntax.token(SyntaxKind.CloseParenToken), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ForStatementSyntax {
        return <ForStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ForStatementSyntax {
        return <ForStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withForKeyword(forKeyword: ISyntaxToken): ForStatementSyntax {
        return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ForStatementSyntax {
        return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withInitializer(initializer: IExpressionSyntax): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withFirstSemicolonToken(firstSemicolonToken: ISyntaxToken): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withCondition(condition: IExpressionSyntax): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withSecondSemicolonToken(secondSemicolonToken: ISyntaxToken): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withIncrementor(incrementor: IExpressionSyntax): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, incrementor, this.closeParenToken, this.statement);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, closeParenToken, this.statement);
    }

    public withStatement(statement: IStatementSyntax): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, statement);
    }

    private isTypeScriptSpecific(): bool {
        if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) { return true; }
        if (this.initializer !== null && this.initializer.isTypeScriptSpecific()) { return true; }
        if (this.condition !== null && this.condition.isTypeScriptSpecific()) { return true; }
        if (this.incrementor !== null && this.incrementor.isTypeScriptSpecific()) { return true; }
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class ForInStatementSyntax extends BaseForStatementSyntax {

    constructor(forKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                variableDeclaration: VariableDeclarationSyntax,
                public left: IExpressionSyntax,
                public inKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                closeParenToken: ISyntaxToken,
                statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitForInStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ForInStatement;
    }

    private childCount(): number {
        return 8;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.forKeyword;
            case 1: return this.openParenToken;
            case 2: return this.variableDeclaration;
            case 3: return this.left;
            case 4: return this.inKeyword;
            case 5: return this.expression;
            case 6: return this.closeParenToken;
            case 7: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    public update(forKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  variableDeclaration: VariableDeclarationSyntax,
                  left: IExpressionSyntax,
                  inKeyword: ISyntaxToken,
                  expression: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  statement: IStatementSyntax): ForInStatementSyntax {
        if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.left === left && this.inKeyword === inKeyword && this.expression === expression && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }

        return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(forKeyword: ISyntaxToken,
                         openParenToken: ISyntaxToken,
                         inKeyword: ISyntaxToken,
                         expression: IExpressionSyntax,
                         closeParenToken: ISyntaxToken,
                         statement: IStatementSyntax): ForInStatementSyntax {
        return new ForInStatementSyntax(forKeyword, openParenToken, null, null, inKeyword, expression, closeParenToken, statement, /*parsedInStrictMode:*/ false);
    }

    public static create1(expression: IExpressionSyntax,
                          statement: IStatementSyntax): ForInStatementSyntax {
        return new ForInStatementSyntax(Syntax.token(SyntaxKind.ForKeyword), Syntax.token(SyntaxKind.OpenParenToken), null, null, Syntax.token(SyntaxKind.InKeyword), expression, Syntax.token(SyntaxKind.CloseParenToken), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ForInStatementSyntax {
        return <ForInStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ForInStatementSyntax {
        return <ForInStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withForKeyword(forKeyword: ISyntaxToken): ForInStatementSyntax {
        return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ForInStatementSyntax {
        return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    }

    public withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    }

    public withLeft(left: IExpressionSyntax): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    }

    public withInKeyword(inKeyword: ISyntaxToken): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, inKeyword, this.expression, this.closeParenToken, this.statement);
    }

    public withExpression(expression: IExpressionSyntax): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, expression, this.closeParenToken, this.statement);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, closeParenToken, this.statement);
    }

    public withStatement(statement: IStatementSyntax): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, statement);
    }

    private isTypeScriptSpecific(): bool {
        if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) { return true; }
        if (this.left !== null && this.left.isTypeScriptSpecific()) { return true; }
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class WhileStatementSyntax extends IterationStatementSyntax {

    constructor(public whileKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                public condition: IExpressionSyntax,
                closeParenToken: ISyntaxToken,
                statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(openParenToken, closeParenToken, statement, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitWhileStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.WhileStatement;
    }

    private childCount(): number {
        return 5;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.whileKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    public update(whileKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  condition: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  statement: IStatementSyntax): WhileStatementSyntax {
        if (this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }

        return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(condition: IExpressionSyntax,
                          statement: IStatementSyntax): WhileStatementSyntax {
        return new WhileStatementSyntax(Syntax.token(SyntaxKind.WhileKeyword), Syntax.token(SyntaxKind.OpenParenToken), condition, Syntax.token(SyntaxKind.CloseParenToken), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): WhileStatementSyntax {
        return <WhileStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): WhileStatementSyntax {
        return <WhileStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withWhileKeyword(whileKeyword: ISyntaxToken): WhileStatementSyntax {
        return this.update(whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): WhileStatementSyntax {
        return this.update(this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
    }

    public withCondition(condition: IExpressionSyntax): WhileStatementSyntax {
        return this.update(this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): WhileStatementSyntax {
        return this.update(this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
    }

    public withStatement(statement: IStatementSyntax): WhileStatementSyntax {
        return this.update(this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
    }

    private isTypeScriptSpecific(): bool {
        if (this.condition.isTypeScriptSpecific()) { return true; }
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class WithStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public withKeyword: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public condition: IExpressionSyntax,
                public closeParenToken: ISyntaxToken,
                public statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitWithStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.WithStatement;
    }

    private childCount(): number {
        return 5;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.withKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(withKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  condition: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  statement: IStatementSyntax): WithStatementSyntax {
        if (this.withKeyword === withKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }

        return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(condition: IExpressionSyntax,
                          statement: IStatementSyntax): WithStatementSyntax {
        return new WithStatementSyntax(Syntax.token(SyntaxKind.WithKeyword), Syntax.token(SyntaxKind.OpenParenToken), condition, Syntax.token(SyntaxKind.CloseParenToken), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): WithStatementSyntax {
        return <WithStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): WithStatementSyntax {
        return <WithStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withWithKeyword(withKeyword: ISyntaxToken): WithStatementSyntax {
        return this.update(withKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): WithStatementSyntax {
        return this.update(this.withKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
    }

    public withCondition(condition: IExpressionSyntax): WithStatementSyntax {
        return this.update(this.withKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): WithStatementSyntax {
        return this.update(this.withKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
    }

    public withStatement(statement: IStatementSyntax): WithStatementSyntax {
        return this.update(this.withKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
    }

    private isTypeScriptSpecific(): bool {
        if (this.condition.isTypeScriptSpecific()) { return true; }
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class EnumDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public enumKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public openBraceToken: ISyntaxToken,
                public variableDeclarators: ISeparatedSyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitEnumDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.EnumDeclaration;
    }

    private childCount(): number {
        return 6;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.enumKeyword;
            case 2: return this.identifier;
            case 3: return this.openBraceToken;
            case 4: return this.variableDeclarators;
            case 5: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  enumKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  openBraceToken: ISyntaxToken,
                  variableDeclarators: ISeparatedSyntaxList,
                  closeBraceToken: ISyntaxToken): EnumDeclarationSyntax {
        if (this.exportKeyword === exportKeyword && this.enumKeyword === enumKeyword && this.identifier === identifier && this.openBraceToken === openBraceToken && this.variableDeclarators === variableDeclarators && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new EnumDeclarationSyntax(exportKeyword, enumKeyword, identifier, openBraceToken, variableDeclarators, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(enumKeyword: ISyntaxToken,
                         identifier: ISyntaxToken,
                         openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): EnumDeclarationSyntax {
        return new EnumDeclarationSyntax(null, enumKeyword, identifier, openBraceToken, Syntax.emptySeparatedList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): EnumDeclarationSyntax {
        return new EnumDeclarationSyntax(null, Syntax.token(SyntaxKind.EnumKeyword), identifier, Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): EnumDeclarationSyntax {
        return <EnumDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): EnumDeclarationSyntax {
        return <EnumDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): EnumDeclarationSyntax {
        return this.update(exportKeyword, this.enumKeyword, this.identifier, this.openBraceToken, this.variableDeclarators, this.closeBraceToken);
    }

    public withEnumKeyword(enumKeyword: ISyntaxToken): EnumDeclarationSyntax {
        return this.update(this.exportKeyword, enumKeyword, this.identifier, this.openBraceToken, this.variableDeclarators, this.closeBraceToken);
    }

    public withIdentifier(identifier: ISyntaxToken): EnumDeclarationSyntax {
        return this.update(this.exportKeyword, this.enumKeyword, identifier, this.openBraceToken, this.variableDeclarators, this.closeBraceToken);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): EnumDeclarationSyntax {
        return this.update(this.exportKeyword, this.enumKeyword, this.identifier, openBraceToken, this.variableDeclarators, this.closeBraceToken);
    }

    public withVariableDeclarators(variableDeclarators: ISeparatedSyntaxList): EnumDeclarationSyntax {
        return this.update(this.exportKeyword, this.enumKeyword, this.identifier, this.openBraceToken, variableDeclarators, this.closeBraceToken);
    }

    public withVariableDeclarator(variableDeclarator: VariableDeclaratorSyntax): EnumDeclarationSyntax {
        return this.withVariableDeclarators(Syntax.separatedList([variableDeclarator]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): EnumDeclarationSyntax {
        return this.update(this.exportKeyword, this.enumKeyword, this.identifier, this.openBraceToken, this.variableDeclarators, closeBraceToken);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class CastExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public lessThanToken: ISyntaxToken,
                public type: ITypeSyntax,
                public greaterThanToken: ISyntaxToken,
                public expression: IUnaryExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitCastExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.CastExpression;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.lessThanToken;
            case 1: return this.type;
            case 2: return this.greaterThanToken;
            case 3: return this.expression;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(lessThanToken: ISyntaxToken,
                  type: ITypeSyntax,
                  greaterThanToken: ISyntaxToken,
                  expression: IUnaryExpressionSyntax): CastExpressionSyntax {
        if (this.lessThanToken === lessThanToken && this.type === type && this.greaterThanToken === greaterThanToken && this.expression === expression) {
            return this;
        }

        return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(type: ITypeSyntax,
                          expression: IUnaryExpressionSyntax): CastExpressionSyntax {
        return new CastExpressionSyntax(Syntax.token(SyntaxKind.LessThanToken), type, Syntax.token(SyntaxKind.GreaterThanToken), expression, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): CastExpressionSyntax {
        return <CastExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): CastExpressionSyntax {
        return <CastExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withLessThanToken(lessThanToken: ISyntaxToken): CastExpressionSyntax {
        return this.update(lessThanToken, this.type, this.greaterThanToken, this.expression);
    }

    public withType(type: ITypeSyntax): CastExpressionSyntax {
        return this.update(this.lessThanToken, type, this.greaterThanToken, this.expression);
    }

    public withGreaterThanToken(greaterThanToken: ISyntaxToken): CastExpressionSyntax {
        return this.update(this.lessThanToken, this.type, greaterThanToken, this.expression);
    }

    public withExpression(expression: IUnaryExpressionSyntax): CastExpressionSyntax {
        return this.update(this.lessThanToken, this.type, this.greaterThanToken, expression);
    }

    private isTypeScriptSpecific(): bool {
        return true;
    }
}

class ObjectLiteralExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public openBraceToken: ISyntaxToken,
                public propertyAssignments: ISeparatedSyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitObjectLiteralExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ObjectLiteralExpression;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openBraceToken;
            case 1: return this.propertyAssignments;
            case 2: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(openBraceToken: ISyntaxToken,
                  propertyAssignments: ISeparatedSyntaxList,
                  closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
        if (this.openBraceToken === openBraceToken && this.propertyAssignments === propertyAssignments && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
        return new ObjectLiteralExpressionSyntax(openBraceToken, Syntax.emptySeparatedList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ObjectLiteralExpressionSyntax {
        return new ObjectLiteralExpressionSyntax(Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ObjectLiteralExpressionSyntax {
        return <ObjectLiteralExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ObjectLiteralExpressionSyntax {
        return <ObjectLiteralExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
        return this.update(openBraceToken, this.propertyAssignments, this.closeBraceToken);
    }

    public withPropertyAssignments(propertyAssignments: ISeparatedSyntaxList): ObjectLiteralExpressionSyntax {
        return this.update(this.openBraceToken, propertyAssignments, this.closeBraceToken);
    }

    public withPropertyAssignment(propertyAssignment: PropertyAssignmentSyntax): ObjectLiteralExpressionSyntax {
        return this.withPropertyAssignments(Syntax.separatedList([propertyAssignment]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
        return this.update(this.openBraceToken, this.propertyAssignments, closeBraceToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.propertyAssignments.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class PropertyAssignmentSyntax extends SyntaxNode {
    constructor(public propertyName: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): PropertyAssignmentSyntax {
        return <PropertyAssignmentSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): PropertyAssignmentSyntax {
        return <PropertyAssignmentSyntax>super.withTrailingTrivia(trivia);
    }

    private isTypeScriptSpecific(): bool {
        return false;
    }
}

class SimplePropertyAssignmentSyntax extends PropertyAssignmentSyntax {

    constructor(propertyName: ISyntaxToken,
                public colonToken: ISyntaxToken,
                public expression: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(propertyName, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSimplePropertyAssignment(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SimplePropertyAssignment;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.propertyName;
            case 1: return this.colonToken;
            case 2: return this.expression;
            default: throw Errors.invalidOperation();
        }
    }

    public update(propertyName: ISyntaxToken,
                  colonToken: ISyntaxToken,
                  expression: IExpressionSyntax): SimplePropertyAssignmentSyntax {
        if (this.propertyName === propertyName && this.colonToken === colonToken && this.expression === expression) {
            return this;
        }

        return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(propertyName: ISyntaxToken,
                          expression: IExpressionSyntax): SimplePropertyAssignmentSyntax {
        return new SimplePropertyAssignmentSyntax(propertyName, Syntax.token(SyntaxKind.ColonToken), expression, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SimplePropertyAssignmentSyntax {
        return <SimplePropertyAssignmentSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SimplePropertyAssignmentSyntax {
        return <SimplePropertyAssignmentSyntax>super.withTrailingTrivia(trivia);
    }

    public withPropertyName(propertyName: ISyntaxToken): SimplePropertyAssignmentSyntax {
        return this.update(propertyName, this.colonToken, this.expression);
    }

    public withColonToken(colonToken: ISyntaxToken): SimplePropertyAssignmentSyntax {
        return this.update(this.propertyName, colonToken, this.expression);
    }

    public withExpression(expression: IExpressionSyntax): SimplePropertyAssignmentSyntax {
        return this.update(this.propertyName, this.colonToken, expression);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class AccessorPropertyAssignmentSyntax extends PropertyAssignmentSyntax {
    constructor(propertyName: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public closeParenToken: ISyntaxToken,
                public block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(propertyName, parsedInStrictMode); 
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): AccessorPropertyAssignmentSyntax {
        return <AccessorPropertyAssignmentSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): AccessorPropertyAssignmentSyntax {
        return <AccessorPropertyAssignmentSyntax>super.withTrailingTrivia(trivia);
    }

    private isTypeScriptSpecific(): bool {
        return false;
    }
}

class GetAccessorPropertyAssignmentSyntax extends AccessorPropertyAssignmentSyntax {

    constructor(public getKeyword: ISyntaxToken,
                propertyName: ISyntaxToken,
                openParenToken: ISyntaxToken,
                closeParenToken: ISyntaxToken,
                block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(propertyName, openParenToken, closeParenToken, block, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitGetAccessorPropertyAssignment(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.GetAccessorPropertyAssignment;
    }

    private childCount(): number {
        return 5;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.getKeyword;
            case 1: return this.propertyName;
            case 2: return this.openParenToken;
            case 3: return this.closeParenToken;
            case 4: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(getKeyword: ISyntaxToken,
                  propertyName: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  closeParenToken: ISyntaxToken,
                  block: BlockSyntax): GetAccessorPropertyAssignmentSyntax {
        if (this.getKeyword === getKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.closeParenToken === closeParenToken && this.block === block) {
            return this;
        }

        return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(propertyName: ISyntaxToken): GetAccessorPropertyAssignmentSyntax {
        return new GetAccessorPropertyAssignmentSyntax(Syntax.token(SyntaxKind.GetKeyword), propertyName, Syntax.token(SyntaxKind.OpenParenToken), Syntax.token(SyntaxKind.CloseParenToken), BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): GetAccessorPropertyAssignmentSyntax {
        return <GetAccessorPropertyAssignmentSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): GetAccessorPropertyAssignmentSyntax {
        return <GetAccessorPropertyAssignmentSyntax>super.withTrailingTrivia(trivia);
    }

    public withGetKeyword(getKeyword: ISyntaxToken): GetAccessorPropertyAssignmentSyntax {
        return this.update(getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.block);
    }

    public withPropertyName(propertyName: ISyntaxToken): GetAccessorPropertyAssignmentSyntax {
        return this.update(this.getKeyword, propertyName, this.openParenToken, this.closeParenToken, this.block);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): GetAccessorPropertyAssignmentSyntax {
        return this.update(this.getKeyword, this.propertyName, openParenToken, this.closeParenToken, this.block);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): GetAccessorPropertyAssignmentSyntax {
        return this.update(this.getKeyword, this.propertyName, this.openParenToken, closeParenToken, this.block);
    }

    public withBlock(block: BlockSyntax): GetAccessorPropertyAssignmentSyntax {
        return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, block);
    }

    private isTypeScriptSpecific(): bool {
        if (this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class SetAccessorPropertyAssignmentSyntax extends AccessorPropertyAssignmentSyntax {

    constructor(public setKeyword: ISyntaxToken,
                propertyName: ISyntaxToken,
                openParenToken: ISyntaxToken,
                public parameterName: ISyntaxToken,
                closeParenToken: ISyntaxToken,
                block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(propertyName, openParenToken, closeParenToken, block, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSetAccessorPropertyAssignment(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SetAccessorPropertyAssignment;
    }

    private childCount(): number {
        return 6;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.setKeyword;
            case 1: return this.propertyName;
            case 2: return this.openParenToken;
            case 3: return this.parameterName;
            case 4: return this.closeParenToken;
            case 5: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(setKeyword: ISyntaxToken,
                  propertyName: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  parameterName: ISyntaxToken,
                  closeParenToken: ISyntaxToken,
                  block: BlockSyntax): SetAccessorPropertyAssignmentSyntax {
        if (this.setKeyword === setKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.parameterName === parameterName && this.closeParenToken === closeParenToken && this.block === block) {
            return this;
        }

        return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(propertyName: ISyntaxToken,
                          parameterName: ISyntaxToken): SetAccessorPropertyAssignmentSyntax {
        return new SetAccessorPropertyAssignmentSyntax(Syntax.token(SyntaxKind.SetKeyword), propertyName, Syntax.token(SyntaxKind.OpenParenToken), parameterName, Syntax.token(SyntaxKind.CloseParenToken), BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SetAccessorPropertyAssignmentSyntax {
        return <SetAccessorPropertyAssignmentSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SetAccessorPropertyAssignmentSyntax {
        return <SetAccessorPropertyAssignmentSyntax>super.withTrailingTrivia(trivia);
    }

    public withSetKeyword(setKeyword: ISyntaxToken): SetAccessorPropertyAssignmentSyntax {
        return this.update(setKeyword, this.propertyName, this.openParenToken, this.parameterName, this.closeParenToken, this.block);
    }

    public withPropertyName(propertyName: ISyntaxToken): SetAccessorPropertyAssignmentSyntax {
        return this.update(this.setKeyword, propertyName, this.openParenToken, this.parameterName, this.closeParenToken, this.block);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): SetAccessorPropertyAssignmentSyntax {
        return this.update(this.setKeyword, this.propertyName, openParenToken, this.parameterName, this.closeParenToken, this.block);
    }

    public withParameterName(parameterName: ISyntaxToken): SetAccessorPropertyAssignmentSyntax {
        return this.update(this.setKeyword, this.propertyName, this.openParenToken, parameterName, this.closeParenToken, this.block);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): SetAccessorPropertyAssignmentSyntax {
        return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameterName, closeParenToken, this.block);
    }

    public withBlock(block: BlockSyntax): SetAccessorPropertyAssignmentSyntax {
        return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameterName, this.closeParenToken, block);
    }

    private isTypeScriptSpecific(): bool {
        if (this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class FunctionExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public functionKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public callSignature: CallSignatureSyntax,
                public block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitFunctionExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.FunctionExpression;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.functionKeyword;
            case 1: return this.identifier;
            case 2: return this.callSignature;
            case 3: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(functionKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  callSignature: CallSignatureSyntax,
                  block: BlockSyntax): FunctionExpressionSyntax {
        if (this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block) {
            return this;
        }

        return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(functionKeyword: ISyntaxToken,
                         callSignature: CallSignatureSyntax,
                         block: BlockSyntax): FunctionExpressionSyntax {
        return new FunctionExpressionSyntax(functionKeyword, null, callSignature, block, /*parsedInStrictMode:*/ false);
    }

    public static create1(): FunctionExpressionSyntax {
        return new FunctionExpressionSyntax(Syntax.token(SyntaxKind.FunctionKeyword), null, CallSignatureSyntax.create1(), BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): FunctionExpressionSyntax {
        return <FunctionExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): FunctionExpressionSyntax {
        return <FunctionExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withFunctionKeyword(functionKeyword: ISyntaxToken): FunctionExpressionSyntax {
        return this.update(functionKeyword, this.identifier, this.callSignature, this.block);
    }

    public withIdentifier(identifier: ISyntaxToken): FunctionExpressionSyntax {
        return this.update(this.functionKeyword, identifier, this.callSignature, this.block);
    }

    public withCallSignature(callSignature: CallSignatureSyntax): FunctionExpressionSyntax {
        return this.update(this.functionKeyword, this.identifier, callSignature, this.block);
    }

    public withBlock(block: BlockSyntax): FunctionExpressionSyntax {
        return this.update(this.functionKeyword, this.identifier, this.callSignature, block);
    }

    private isTypeScriptSpecific(): bool {
        if (this.callSignature.isTypeScriptSpecific()) { return true; }
        if (this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class EmptyStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitEmptyStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.EmptyStatement;
    }

    private childCount(): number {
        return 1;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(semicolonToken: ISyntaxToken): EmptyStatementSyntax {
        if (this.semicolonToken === semicolonToken) {
            return this;
        }

        return new EmptyStatementSyntax(semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(): EmptyStatementSyntax {
        return new EmptyStatementSyntax(Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): EmptyStatementSyntax {
        return <EmptyStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): EmptyStatementSyntax {
        return <EmptyStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): EmptyStatementSyntax {
        return this.update(semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        return false;
    }
}

class TryStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public tryKeyword: ISyntaxToken,
                public block: BlockSyntax,
                public catchClause: CatchClauseSyntax,
                public finallyClause: FinallyClauseSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTryStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TryStatement;
    }

    private childCount(): number {
        return 4;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.tryKeyword;
            case 1: return this.block;
            case 2: return this.catchClause;
            case 3: return this.finallyClause;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(tryKeyword: ISyntaxToken,
                  block: BlockSyntax,
                  catchClause: CatchClauseSyntax,
                  finallyClause: FinallyClauseSyntax): TryStatementSyntax {
        if (this.tryKeyword === tryKeyword && this.block === block && this.catchClause === catchClause && this.finallyClause === finallyClause) {
            return this;
        }

        return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(tryKeyword: ISyntaxToken,
                         block: BlockSyntax): TryStatementSyntax {
        return new TryStatementSyntax(tryKeyword, block, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(): TryStatementSyntax {
        return new TryStatementSyntax(Syntax.token(SyntaxKind.TryKeyword), BlockSyntax.create1(), null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TryStatementSyntax {
        return <TryStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TryStatementSyntax {
        return <TryStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withTryKeyword(tryKeyword: ISyntaxToken): TryStatementSyntax {
        return this.update(tryKeyword, this.block, this.catchClause, this.finallyClause);
    }

    public withBlock(block: BlockSyntax): TryStatementSyntax {
        return this.update(this.tryKeyword, block, this.catchClause, this.finallyClause);
    }

    public withCatchClause(catchClause: CatchClauseSyntax): TryStatementSyntax {
        return this.update(this.tryKeyword, this.block, catchClause, this.finallyClause);
    }

    public withFinallyClause(finallyClause: FinallyClauseSyntax): TryStatementSyntax {
        return this.update(this.tryKeyword, this.block, this.catchClause, finallyClause);
    }

    private isTypeScriptSpecific(): bool {
        if (this.block.isTypeScriptSpecific()) { return true; }
        if (this.catchClause !== null && this.catchClause.isTypeScriptSpecific()) { return true; }
        if (this.finallyClause !== null && this.finallyClause.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class CatchClauseSyntax extends SyntaxNode {

    constructor(public catchKeyword: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public identifier: ISyntaxToken,
                public closeParenToken: ISyntaxToken,
                public block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitCatchClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.CatchClause;
    }

    private childCount(): number {
        return 5;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.catchKeyword;
            case 1: return this.openParenToken;
            case 2: return this.identifier;
            case 3: return this.closeParenToken;
            case 4: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(catchKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  identifier: ISyntaxToken,
                  closeParenToken: ISyntaxToken,
                  block: BlockSyntax): CatchClauseSyntax {
        if (this.catchKeyword === catchKeyword && this.openParenToken === openParenToken && this.identifier === identifier && this.closeParenToken === closeParenToken && this.block === block) {
            return this;
        }

        return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, closeParenToken, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(identifier: ISyntaxToken): CatchClauseSyntax {
        return new CatchClauseSyntax(Syntax.token(SyntaxKind.CatchKeyword), Syntax.token(SyntaxKind.OpenParenToken), identifier, Syntax.token(SyntaxKind.CloseParenToken), BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): CatchClauseSyntax {
        return <CatchClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): CatchClauseSyntax {
        return <CatchClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withCatchKeyword(catchKeyword: ISyntaxToken): CatchClauseSyntax {
        return this.update(catchKeyword, this.openParenToken, this.identifier, this.closeParenToken, this.block);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): CatchClauseSyntax {
        return this.update(this.catchKeyword, openParenToken, this.identifier, this.closeParenToken, this.block);
    }

    public withIdentifier(identifier: ISyntaxToken): CatchClauseSyntax {
        return this.update(this.catchKeyword, this.openParenToken, identifier, this.closeParenToken, this.block);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): CatchClauseSyntax {
        return this.update(this.catchKeyword, this.openParenToken, this.identifier, closeParenToken, this.block);
    }

    public withBlock(block: BlockSyntax): CatchClauseSyntax {
        return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.closeParenToken, block);
    }

    private isTypeScriptSpecific(): bool {
        if (this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class FinallyClauseSyntax extends SyntaxNode {

    constructor(public finallyKeyword: ISyntaxToken,
                public block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitFinallyClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.FinallyClause;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.finallyKeyword;
            case 1: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(finallyKeyword: ISyntaxToken,
                  block: BlockSyntax): FinallyClauseSyntax {
        if (this.finallyKeyword === finallyKeyword && this.block === block) {
            return this;
        }

        return new FinallyClauseSyntax(finallyKeyword, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(): FinallyClauseSyntax {
        return new FinallyClauseSyntax(Syntax.token(SyntaxKind.FinallyKeyword), BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): FinallyClauseSyntax {
        return <FinallyClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): FinallyClauseSyntax {
        return <FinallyClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withFinallyKeyword(finallyKeyword: ISyntaxToken): FinallyClauseSyntax {
        return this.update(finallyKeyword, this.block);
    }

    public withBlock(block: BlockSyntax): FinallyClauseSyntax {
        return this.update(this.finallyKeyword, block);
    }

    private isTypeScriptSpecific(): bool {
        if (this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class LabeledStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public identifier: ISyntaxToken,
                public colonToken: ISyntaxToken,
                public statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitLabeledStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.LabeledStatement;
    }

    private childCount(): number {
        return 3;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            case 2: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(identifier: ISyntaxToken,
                  colonToken: ISyntaxToken,
                  statement: IStatementSyntax): LabeledStatementSyntax {
        if (this.identifier === identifier && this.colonToken === colonToken && this.statement === statement) {
            return this;
        }

        return new LabeledStatementSyntax(identifier, colonToken, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(identifier: ISyntaxToken,
                          statement: IStatementSyntax): LabeledStatementSyntax {
        return new LabeledStatementSyntax(identifier, Syntax.token(SyntaxKind.ColonToken), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): LabeledStatementSyntax {
        return <LabeledStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): LabeledStatementSyntax {
        return <LabeledStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withIdentifier(identifier: ISyntaxToken): LabeledStatementSyntax {
        return this.update(identifier, this.colonToken, this.statement);
    }

    public withColonToken(colonToken: ISyntaxToken): LabeledStatementSyntax {
        return this.update(this.identifier, colonToken, this.statement);
    }

    public withStatement(statement: IStatementSyntax): LabeledStatementSyntax {
        return this.update(this.identifier, this.colonToken, statement);
    }

    private isTypeScriptSpecific(): bool {
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class DoStatementSyntax extends IterationStatementSyntax {

    constructor(public doKeyword: ISyntaxToken,
                statement: IStatementSyntax,
                public whileKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                public condition: IExpressionSyntax,
                closeParenToken: ISyntaxToken,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(openParenToken, closeParenToken, statement, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitDoStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.DoStatement;
    }

    private childCount(): number {
        return 7;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.doKeyword;
            case 1: return this.statement;
            case 2: return this.whileKeyword;
            case 3: return this.openParenToken;
            case 4: return this.condition;
            case 5: return this.closeParenToken;
            case 6: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(doKeyword: ISyntaxToken,
                  statement: IStatementSyntax,
                  whileKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  condition: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  semicolonToken: ISyntaxToken): DoStatementSyntax {
        if (this.doKeyword === doKeyword && this.statement === statement && this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(statement: IStatementSyntax,
                          condition: IExpressionSyntax): DoStatementSyntax {
        return new DoStatementSyntax(Syntax.token(SyntaxKind.DoKeyword), statement, Syntax.token(SyntaxKind.WhileKeyword), Syntax.token(SyntaxKind.OpenParenToken), condition, Syntax.token(SyntaxKind.CloseParenToken), Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): DoStatementSyntax {
        return <DoStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): DoStatementSyntax {
        return <DoStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withDoKeyword(doKeyword: ISyntaxToken): DoStatementSyntax {
        return this.update(doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    }

    public withStatement(statement: IStatementSyntax): DoStatementSyntax {
        return this.update(this.doKeyword, statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    }

    public withWhileKeyword(whileKeyword: ISyntaxToken): DoStatementSyntax {
        return this.update(this.doKeyword, this.statement, whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): DoStatementSyntax {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    }

    public withCondition(condition: IExpressionSyntax): DoStatementSyntax {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.semicolonToken);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): DoStatementSyntax {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): DoStatementSyntax {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        if (this.statement.isTypeScriptSpecific()) { return true; }
        if (this.condition.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class TypeOfExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public typeOfKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTypeOfExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TypeOfExpression;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.typeOfKeyword;
            case 1: return this.expression;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(typeOfKeyword: ISyntaxToken,
                  expression: IExpressionSyntax): TypeOfExpressionSyntax {
        if (this.typeOfKeyword === typeOfKeyword && this.expression === expression) {
            return this;
        }

        return new TypeOfExpressionSyntax(typeOfKeyword, expression, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): TypeOfExpressionSyntax {
        return new TypeOfExpressionSyntax(Syntax.token(SyntaxKind.TypeOfKeyword), expression, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TypeOfExpressionSyntax {
        return <TypeOfExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TypeOfExpressionSyntax {
        return <TypeOfExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withTypeOfKeyword(typeOfKeyword: ISyntaxToken): TypeOfExpressionSyntax {
        return this.update(typeOfKeyword, this.expression);
    }

    public withExpression(expression: IExpressionSyntax): TypeOfExpressionSyntax {
        return this.update(this.typeOfKeyword, expression);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class DeleteExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public deleteKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitDeleteExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.DeleteExpression;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.deleteKeyword;
            case 1: return this.expression;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(deleteKeyword: ISyntaxToken,
                  expression: IExpressionSyntax): DeleteExpressionSyntax {
        if (this.deleteKeyword === deleteKeyword && this.expression === expression) {
            return this;
        }

        return new DeleteExpressionSyntax(deleteKeyword, expression, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): DeleteExpressionSyntax {
        return new DeleteExpressionSyntax(Syntax.token(SyntaxKind.DeleteKeyword), expression, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): DeleteExpressionSyntax {
        return <DeleteExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): DeleteExpressionSyntax {
        return <DeleteExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withDeleteKeyword(deleteKeyword: ISyntaxToken): DeleteExpressionSyntax {
        return this.update(deleteKeyword, this.expression);
    }

    public withExpression(expression: IExpressionSyntax): DeleteExpressionSyntax {
        return this.update(this.deleteKeyword, expression);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class VoidExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public voidKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitVoidExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.VoidExpression;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.voidKeyword;
            case 1: return this.expression;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(voidKeyword: ISyntaxToken,
                  expression: IExpressionSyntax): VoidExpressionSyntax {
        if (this.voidKeyword === voidKeyword && this.expression === expression) {
            return this;
        }

        return new VoidExpressionSyntax(voidKeyword, expression, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): VoidExpressionSyntax {
        return new VoidExpressionSyntax(Syntax.token(SyntaxKind.VoidKeyword), expression, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): VoidExpressionSyntax {
        return <VoidExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): VoidExpressionSyntax {
        return <VoidExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withVoidKeyword(voidKeyword: ISyntaxToken): VoidExpressionSyntax {
        return this.update(voidKeyword, this.expression);
    }

    public withExpression(expression: IExpressionSyntax): VoidExpressionSyntax {
        return this.update(this.voidKeyword, expression);
    }

    private isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
}

class DebuggerStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public debuggerKeyword: ISyntaxToken,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitDebuggerStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.DebuggerStatement;
    }

    private childCount(): number {
        return 2;
    }

    private childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.debuggerKeyword;
            case 1: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(debuggerKeyword: ISyntaxToken,
                  semicolonToken: ISyntaxToken): DebuggerStatementSyntax {
        if (this.debuggerKeyword === debuggerKeyword && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(): DebuggerStatementSyntax {
        return new DebuggerStatementSyntax(Syntax.token(SyntaxKind.DebuggerKeyword), Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): DebuggerStatementSyntax {
        return <DebuggerStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): DebuggerStatementSyntax {
        return <DebuggerStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withDebuggerKeyword(debuggerKeyword: ISyntaxToken): DebuggerStatementSyntax {
        return this.update(debuggerKeyword, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): DebuggerStatementSyntax {
        return this.update(this.debuggerKeyword, semicolonToken);
    }

    private isTypeScriptSpecific(): bool {
        return false;
    }
}
﻿///<reference path='SyntaxNodes.generated.ts' />

interface ISyntaxVisitor {
    visitToken(token: ISyntaxToken): any;
    visitSourceUnit(node: SourceUnitSyntax): any;
    visitExternalModuleReference(node: ExternalModuleReferenceSyntax): any;
    visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): any;
    visitImportDeclaration(node: ImportDeclarationSyntax): any;
    visitClassDeclaration(node: ClassDeclarationSyntax): any;
    visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): any;
    visitExtendsClause(node: ExtendsClauseSyntax): any;
    visitImplementsClause(node: ImplementsClauseSyntax): any;
    visitModuleDeclaration(node: ModuleDeclarationSyntax): any;
    visitFunctionDeclaration(node: FunctionDeclarationSyntax): any;
    visitVariableStatement(node: VariableStatementSyntax): any;
    visitVariableDeclaration(node: VariableDeclarationSyntax): any;
    visitVariableDeclarator(node: VariableDeclaratorSyntax): any;
    visitEqualsValueClause(node: EqualsValueClauseSyntax): any;
    visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): any;
    visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): any;
    visitOmittedExpression(node: OmittedExpressionSyntax): any;
    visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): any;
    visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): any;
    visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): any;
    visitQualifiedName(node: QualifiedNameSyntax): any;
    visitTypeArgumentList(node: TypeArgumentListSyntax): any;
    visitConstructorType(node: ConstructorTypeSyntax): any;
    visitFunctionType(node: FunctionTypeSyntax): any;
    visitObjectType(node: ObjectTypeSyntax): any;
    visitArrayType(node: ArrayTypeSyntax): any;
    visitGenericType(node: GenericTypeSyntax): any;
    visitTypeAnnotation(node: TypeAnnotationSyntax): any;
    visitBlock(node: BlockSyntax): any;
    visitParameter(node: ParameterSyntax): any;
    visitMemberAccessExpression(node: MemberAccessExpressionSyntax): any;
    visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): any;
    visitElementAccessExpression(node: ElementAccessExpressionSyntax): any;
    visitInvocationExpression(node: InvocationExpressionSyntax): any;
    visitArgumentList(node: ArgumentListSyntax): any;
    visitBinaryExpression(node: BinaryExpressionSyntax): any;
    visitConditionalExpression(node: ConditionalExpressionSyntax): any;
    visitConstructSignature(node: ConstructSignatureSyntax): any;
    visitFunctionSignature(node: FunctionSignatureSyntax): any;
    visitIndexSignature(node: IndexSignatureSyntax): any;
    visitPropertySignature(node: PropertySignatureSyntax): any;
    visitParameterList(node: ParameterListSyntax): any;
    visitCallSignature(node: CallSignatureSyntax): any;
    visitTypeParameterList(node: TypeParameterListSyntax): any;
    visitTypeParameter(node: TypeParameterSyntax): any;
    visitConstraint(node: ConstraintSyntax): any;
    visitElseClause(node: ElseClauseSyntax): any;
    visitIfStatement(node: IfStatementSyntax): any;
    visitExpressionStatement(node: ExpressionStatementSyntax): any;
    visitConstructorDeclaration(node: ConstructorDeclarationSyntax): any;
    visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): any;
    visitGetMemberAccessorDeclaration(node: GetMemberAccessorDeclarationSyntax): any;
    visitSetMemberAccessorDeclaration(node: SetMemberAccessorDeclarationSyntax): any;
    visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): any;
    visitThrowStatement(node: ThrowStatementSyntax): any;
    visitReturnStatement(node: ReturnStatementSyntax): any;
    visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): any;
    visitSwitchStatement(node: SwitchStatementSyntax): any;
    visitCaseSwitchClause(node: CaseSwitchClauseSyntax): any;
    visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): any;
    visitBreakStatement(node: BreakStatementSyntax): any;
    visitContinueStatement(node: ContinueStatementSyntax): any;
    visitForStatement(node: ForStatementSyntax): any;
    visitForInStatement(node: ForInStatementSyntax): any;
    visitWhileStatement(node: WhileStatementSyntax): any;
    visitWithStatement(node: WithStatementSyntax): any;
    visitEnumDeclaration(node: EnumDeclarationSyntax): any;
    visitCastExpression(node: CastExpressionSyntax): any;
    visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): any;
    visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): any;
    visitGetAccessorPropertyAssignment(node: GetAccessorPropertyAssignmentSyntax): any;
    visitSetAccessorPropertyAssignment(node: SetAccessorPropertyAssignmentSyntax): any;
    visitFunctionExpression(node: FunctionExpressionSyntax): any;
    visitEmptyStatement(node: EmptyStatementSyntax): any;
    visitTryStatement(node: TryStatementSyntax): any;
    visitCatchClause(node: CatchClauseSyntax): any;
    visitFinallyClause(node: FinallyClauseSyntax): any;
    visitLabeledStatement(node: LabeledStatementSyntax): any;
    visitDoStatement(node: DoStatementSyntax): any;
    visitTypeOfExpression(node: TypeOfExpressionSyntax): any;
    visitDeleteExpression(node: DeleteExpressionSyntax): any;
    visitVoidExpression(node: VoidExpressionSyntax): any;
    visitDebuggerStatement(node: DebuggerStatementSyntax): any;
}

class SyntaxVisitor implements ISyntaxVisitor {
    public defaultVisit(node: ISyntaxNodeOrToken): any {
        return null;
    }

    private visitToken(token: ISyntaxToken): any {
        return this.defaultVisit(token);
    }

    private visitSourceUnit(node: SourceUnitSyntax): any {
        return this.defaultVisit(node);
    }

    private visitExternalModuleReference(node: ExternalModuleReferenceSyntax): any {
        return this.defaultVisit(node);
    }

    private visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): any {
        return this.defaultVisit(node);
    }

    private visitImportDeclaration(node: ImportDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitClassDeclaration(node: ClassDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitExtendsClause(node: ExtendsClauseSyntax): any {
        return this.defaultVisit(node);
    }

    private visitImplementsClause(node: ImplementsClauseSyntax): any {
        return this.defaultVisit(node);
    }

    private visitModuleDeclaration(node: ModuleDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitFunctionDeclaration(node: FunctionDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitVariableStatement(node: VariableStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitVariableDeclaration(node: VariableDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitVariableDeclarator(node: VariableDeclaratorSyntax): any {
        return this.defaultVisit(node);
    }

    private visitEqualsValueClause(node: EqualsValueClauseSyntax): any {
        return this.defaultVisit(node);
    }

    private visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitOmittedExpression(node: OmittedExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitQualifiedName(node: QualifiedNameSyntax): any {
        return this.defaultVisit(node);
    }

    private visitTypeArgumentList(node: TypeArgumentListSyntax): any {
        return this.defaultVisit(node);
    }

    private visitConstructorType(node: ConstructorTypeSyntax): any {
        return this.defaultVisit(node);
    }

    private visitFunctionType(node: FunctionTypeSyntax): any {
        return this.defaultVisit(node);
    }

    private visitObjectType(node: ObjectTypeSyntax): any {
        return this.defaultVisit(node);
    }

    private visitArrayType(node: ArrayTypeSyntax): any {
        return this.defaultVisit(node);
    }

    private visitGenericType(node: GenericTypeSyntax): any {
        return this.defaultVisit(node);
    }

    private visitTypeAnnotation(node: TypeAnnotationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitBlock(node: BlockSyntax): any {
        return this.defaultVisit(node);
    }

    private visitParameter(node: ParameterSyntax): any {
        return this.defaultVisit(node);
    }

    private visitMemberAccessExpression(node: MemberAccessExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitElementAccessExpression(node: ElementAccessExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitInvocationExpression(node: InvocationExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitArgumentList(node: ArgumentListSyntax): any {
        return this.defaultVisit(node);
    }

    private visitBinaryExpression(node: BinaryExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitConditionalExpression(node: ConditionalExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitConstructSignature(node: ConstructSignatureSyntax): any {
        return this.defaultVisit(node);
    }

    private visitFunctionSignature(node: FunctionSignatureSyntax): any {
        return this.defaultVisit(node);
    }

    private visitIndexSignature(node: IndexSignatureSyntax): any {
        return this.defaultVisit(node);
    }

    private visitPropertySignature(node: PropertySignatureSyntax): any {
        return this.defaultVisit(node);
    }

    private visitParameterList(node: ParameterListSyntax): any {
        return this.defaultVisit(node);
    }

    private visitCallSignature(node: CallSignatureSyntax): any {
        return this.defaultVisit(node);
    }

    private visitTypeParameterList(node: TypeParameterListSyntax): any {
        return this.defaultVisit(node);
    }

    private visitTypeParameter(node: TypeParameterSyntax): any {
        return this.defaultVisit(node);
    }

    private visitConstraint(node: ConstraintSyntax): any {
        return this.defaultVisit(node);
    }

    private visitElseClause(node: ElseClauseSyntax): any {
        return this.defaultVisit(node);
    }

    private visitIfStatement(node: IfStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitExpressionStatement(node: ExpressionStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitConstructorDeclaration(node: ConstructorDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitGetMemberAccessorDeclaration(node: GetMemberAccessorDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitSetMemberAccessorDeclaration(node: SetMemberAccessorDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitThrowStatement(node: ThrowStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitReturnStatement(node: ReturnStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitSwitchStatement(node: SwitchStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitCaseSwitchClause(node: CaseSwitchClauseSyntax): any {
        return this.defaultVisit(node);
    }

    private visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): any {
        return this.defaultVisit(node);
    }

    private visitBreakStatement(node: BreakStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitContinueStatement(node: ContinueStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitForStatement(node: ForStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitForInStatement(node: ForInStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitWhileStatement(node: WhileStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitWithStatement(node: WithStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitEnumDeclaration(node: EnumDeclarationSyntax): any {
        return this.defaultVisit(node);
    }

    private visitCastExpression(node: CastExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): any {
        return this.defaultVisit(node);
    }

    private visitGetAccessorPropertyAssignment(node: GetAccessorPropertyAssignmentSyntax): any {
        return this.defaultVisit(node);
    }

    private visitSetAccessorPropertyAssignment(node: SetAccessorPropertyAssignmentSyntax): any {
        return this.defaultVisit(node);
    }

    private visitFunctionExpression(node: FunctionExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitEmptyStatement(node: EmptyStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitTryStatement(node: TryStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitCatchClause(node: CatchClauseSyntax): any {
        return this.defaultVisit(node);
    }

    private visitFinallyClause(node: FinallyClauseSyntax): any {
        return this.defaultVisit(node);
    }

    private visitLabeledStatement(node: LabeledStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitDoStatement(node: DoStatementSyntax): any {
        return this.defaultVisit(node);
    }

    private visitTypeOfExpression(node: TypeOfExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitDeleteExpression(node: DeleteExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitVoidExpression(node: VoidExpressionSyntax): any {
        return this.defaultVisit(node);
    }

    private visitDebuggerStatement(node: DebuggerStatementSyntax): any {
        return this.defaultVisit(node);
    }
}
///<reference path='ISyntaxElement.ts' />
///<reference path='ISyntaxTriviaList.ts' />
///<reference path='SyntaxVisitor.generated.ts' />

interface ISyntaxToken extends ISyntaxNodeOrToken, INameSyntax {
    // Same as kind(), just exposed through a property for perf.
    tokenKind: SyntaxKind;

    // Text for this token, not including leading or trailing trivia.
    text(): string;

    value(): any;

    hasLeadingTrivia(): bool;
    hasLeadingComment(): bool;
    hasLeadingNewLine(): bool;
    hasLeadingSkippedText(): bool;

    hasTrailingTrivia(): bool;
    hasTrailingComment(): bool;
    hasTrailingNewLine(): bool;
    hasTrailingSkippedText(): bool;

    hasSkippedText(): bool;

    leadingTrivia(): ISyntaxTriviaList;
    trailingTrivia(): ISyntaxTriviaList;

    withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken;
    withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken;

    clone(): ISyntaxToken;
}

interface ITokenInfo {
    leadingTrivia?: ISyntaxTrivia[];
    text?: string;
    value?: any;
    trailingTrivia?: ISyntaxTrivia[];
}
///<reference path='SyntaxKind.ts' />
///<reference path='ISyntaxToken.ts' />

interface ISyntaxElement {
    kind(): SyntaxKind;

    isNode(): bool;
    isToken(): bool;
    isList(): bool;
    isSeparatedList(): bool;

    childCount(): number;
    childAt(index: number): ISyntaxElement;

    // True if this element is typescript specific and would not be legal in pure javascript.
    isTypeScriptSpecific(): bool;

    // True if this element (or any child element) contains any skipped text trivia.
    hasSkippedText(): bool;

    // True if this element (or any child element) contains any zero width tokens.
    hasZeroWidthToken(): bool;

    // True if this element (or any child element) contains any regular expression token.
    hasRegularExpressionToken(): bool;

    // With of this element, including leading and trailing trivia.
    fullWidth(): number;

    // Width of this element, not including leading and trailing trivia.
    width(): number;

    // Text for this element, including leading and trailing trivia.
    fullText(): string;

    leadingTrivia(): ISyntaxTriviaList;
    trailingTrivia(): ISyntaxTriviaList;

    leadingTriviaWidth(): number;
    trailingTriviaWidth(): number;

    firstToken(): ISyntaxToken;
    lastToken(): ISyntaxToken;

    collectTextElements(elements: string[]): void;
}

interface ISyntaxNode extends ISyntaxNodeOrToken {
}

interface IModuleReferenceSyntax extends ISyntaxNode {
}

interface IModuleElementSyntax extends ISyntaxNode {
}

interface IStatementSyntax extends IModuleElementSyntax {
}

interface ITypeMemberSyntax extends ISyntaxNode {
}

interface IClassElementSyntax extends ISyntaxNode {
}

interface IMemberDeclarationSyntax extends IClassElementSyntax {
}

interface ISwitchClauseSyntax extends ISyntaxNode {
}

interface IExpressionSyntax extends ISyntaxNodeOrToken {
}

interface IUnaryExpressionSyntax extends IExpressionSyntax {
}

interface ITypeSyntax extends IUnaryExpressionSyntax {
}

interface INameSyntax extends ITypeSyntax {
}
///<reference path='ISyntaxElement.ts' />

interface ISyntaxNodeOrToken extends ISyntaxElement {
    withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxNodeOrToken;
    withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxNodeOrToken;

    accept(visitor: ISyntaxVisitor): any;
}
class ParseOptions {
    private _allowAutomaticSemicolonInsertion: bool;

    constructor(allowAutomaticSemicolonInsertion?: bool = true) {
        this._allowAutomaticSemicolonInsertion = allowAutomaticSemicolonInsertion;
    }

    public allowAutomaticSemicolonInsertion(): bool {
        return this._allowAutomaticSemicolonInsertion;
    }
}
// Localizable string constants.  TODO: Figure out a way to actually localize things.
class Strings {
    public static module__class__interface__enum__import_or_statement: string = "module, class, interface, enum, import or statement";
    public static constructor__function__accessor_or_variable: string = "constructor, function, accessor or variable";
    public static statement: string = "statement";
    public static case_or_default_clause: string = "case or default clause";
    public static identifier: string = "identifier";
    public static call__construct__index__property_or_function_signature: string = "call, construct, index, property or function signature";
    public static expression: string = "expression";
    public static type_name: string = "type name";
    public static property_or_accessor: string = "property or accessor";
    public static parameter: string = "parameter";
    public static type: string = "type";
    public static type_parameter: string = "type parameter";
}
///<reference path='SyntaxNodes.generated.ts' />
///<reference path='SyntaxDiagnostic.ts' />

class SyntaxTree {
    private _sourceUnit: SourceUnitSyntax;
    private _diagnostics: SyntaxDiagnostic[];

    constructor(sourceUnit: SourceUnitSyntax,
                diagnostics: SyntaxDiagnostic[]) {
        this._sourceUnit = sourceUnit;
        this._diagnostics = diagnostics;
    }

    public toJSON(key) {
        var result: any = { };

        if (this._diagnostics.length > 0) {
            result._diagnostics = this._diagnostics;
        }

        result._sourceUnit = this._sourceUnit;
        return result;
    }

    public sourceUnit(): SourceUnitSyntax {
        return this._sourceUnit;
    }

    public diagnostics(): SyntaxDiagnostic[] {
        return this._diagnostics;
    }

    public structuralEquals(tree: SyntaxTree): bool {
        return ArrayUtilities.sequenceEquals(this.diagnostics(), tree.diagnostics(), SyntaxDiagnostic.equals) &&
            this.sourceUnit().structuralEquals(tree.sourceUnit());
    }
}
enum Constants {
    // 2^30-1
    Max31BitInteger = 1073741823,
    Min31BitInteger = -1073741824,
}
///<reference path='..\Core\Constants.ts' />
///<reference path='TextSpan.ts' />

class TextChangeRange {
    private _span: TextSpan;
    private _newLength: number;

    /// <summary>
    /// Initializes a new instance of <see cref="T:TextChangeRange"/>.
    /// </summary>
    /// <param name="span"></param>
    /// <param name="newLength"></param>
    constructor(span: TextSpan, newLength: number) {
        if (newLength < 0) {
            throw Errors.argumentOutOfRange("newLength");
        }

        this._span = span;
        this._newLength = newLength;
    }

    /// <summary>
    /// The span of text before the edit which is being changed
    /// </summary>
    public span(): TextSpan {
        return this._span;
    }

    /// <summary>
    /// Width of the span after the edit.  A 0 here would represent a delete
    /// </summary>
    public newLength(): number {
        return this._newLength;
    }

    public newSpan(): TextSpan {
        return new TextSpan(this.span().start(), this.newLength());
    }

    public static collapse(changes: TextChangeRange[]): TextChangeRange {
        var diff = 0;
        var start = Constants.Max31BitInteger;
        var end = 0;

        // TODO: we are assuming that changes are normalized. That is currently not guaranteed,
        // but changes that we get from IDE are normalized. Idealy changes should come in a kind
        // of normalized change collection instead of IEnumerable to really guarantee that they
        // are normalized.
        for (var i = 0; i < changes.length; i++) {
            var change = changes[i];
            diff += change.newLength() - change.span().length();

            if (change.span().start() < start) {
                start = change.span().start();
            }

            if (change.span().end() > end) {
                end = change.span().end();
            }
        }

        if (start > end) {
            return null;
        }

        var combined = TextSpan.fromBounds(start, end);
        var newLen = combined.length() + diff;

        return new TextChangeRange(combined, newLen);
    }
}
/// <reference path='SlidingWindow.ts' />

/// <reference path='ParseOptions.ts' />
/// <reference path='Scanner.ts' />
/// <reference path='Strings.ts' />
/// <reference path='SyntaxFactory.generated.ts' />
/// <reference path='SyntaxTree.ts' />
/// <reference path='SyntaxTriviaList.ts' />
/// <reference path='..\Text\TextChangeRange.ts' />

module Parser1 {
    // Information the parser needs to effectively rewind.
    interface IParserRewindPoint {
        // Information used by normal parser source.
        previousToken: ISyntaxToken;
        absolutePosition: number;
        slidingWindowIndex: number;

        // Information used by the incremental parser source.
        oldSourceUnitCursorIndex: number;
        changeDelta: number;
        changeRange: TextChangeRange;

        // Information used by the parser itself.

        // As we speculatively parser, we may build up diagnostics.  When we rewind we want to 
        // 'forget' that information.In order to do that we store the count of diagnostics and 
        // when we start speculating, and we reset to that count when we're done.  That way the
        // speculative parse does not affect any further results.
        diagnosticsCount: number;

        // For debug purposes only, we also track the following information. They help us assert 
        // that we're not doing anything unexpected.

        // Rewind points should work like a stack.  The first rewind point given out should be the
        // last one released.  By keeping track of the count of points out when this was created, 
        // we can ensure that invariant was preserved.
        pinCount: number;

        // isInStrictMode and listParsingState should not have to be tracked by a rewind point.
        // Because they are naturally mutated and restored based on the normal stack movement of 
        // the parser, they should automatically return to whatever value they had to begin with
        // if the parser decides to rewind or not.  However, to ensure that this is true, we track
        // these variables and check if they have the same value when we're rewinding/releasing.
        isInStrictMode: bool;
        listParsingState: ListParsingState;
    }

    // The precedence of expressions in typescript.  While we're parsing an expression, we will 
    // continue to consume and form new trees if the precedence is greater than our current
    // precedence.  For example, if we have: a + b * c, we will first parse 'a' with precedence 0. 
    // We will then see the + with precedence 13.  13 is greater than 0 so we will decide to create
    // a binary expression with the result of parsing the sub expression "b * c".  We'll then parse
    // the term 'b' (passing in precedence 13).  We will then see the * with precedence 14.  14 is
    // greater than 13, so we will create a binary expression from "b" and "c", return that, and 
    // join it with "a" producing:
    //
    //      +
    //     / \
    //    a   *
    //       / \
    //      b   c
    //
    // If we instead had: "a * b + c", we would first parser 'a' with precedence 0.  We would then see 
    // the * with precedence 14.  14 is greater than 0 so we will decide to create a binary expression
    // with the result of parsing the sub expression "b + c".  We'll then parse the term 'b' (passing in
    // precedence 14).  We will then see the + with precedence 13.  13 is less than 14, so we won't 
    // continue parsing subexpressions and will just return the expression 'b'.  The caller will join 
    // that into "a * b" (and will be back at precedence 0). It will then see the + with precedence 11.
    // 11 is greater than 0 so it will parse the sub expression and make a binary expression out of it
    // producing:
    //
    //        +
    //       / \
    //      *   c
    //     / \
    //    a   b
    enum ExpressionPrecedence {
        // Intuitively, commas have the lowest precedence.  "a || b, c" is "(a || b), c", not
        // "a || (b, c)"
        CommaExpressionPrecedence = 1,

        AssignmentExpressionPrecedence = 2,

        ConditionalExpressionPrecedence = 3,

        // REVIEW: Should ArrowFunctions have higher, lower, or the same precedence as ternary?
        ArrowFunctionPrecedence = 4,

        LogicalOrExpressionPrecedence = 5,
        LogicalAndExpressionPrecedence = 6,
        BitwiseOrExpressionPrecedence = 7,
        BitwiseExclusiveOrExpressionPrecedence = 8,
        BitwiseAndExpressionPrecedence = 9,
        EqualityExpressionPrecedence = 10,
        RelationalExpressionPrecedence = 11,
        ShiftExpressionPrecdence = 12,
        AdditiveExpressionPrecedence = 13,
        MultiplicativeExpressionPrecedence = 14,

        // Intuitively, unary expressions have the highest precedence.  After all, if you have:
        //   !foo || bar
        //
        // Then you have "(!foo) || bar", not "!(foo || bar)"
        UnaryExpressionPrecedence = 15,
    }

    // The current state of the parser wrt to list parsing.  The way to read these is as:
    // CurrentProduction_SubList.  i.e. "Block_Statements" means "we're parsing a Block, and we're 
    // currently parsing list of statements within it".  This is used by the list parsing mechanism
    // to parse the elements of the lists, and recover from errors we encounter when we run into 
    // unexpected code.
    // 
    // For example, when we are in ArgumentList_Arguments, we will continue trying to consume code 
    // as long as "isArgument" is true.  If we run into a token for which "isArgument" is not true 
    // we will do the following:
    //
    // If the token is a StopToken for ArgumentList_Arguments (like ")" ) then we will stop parsing
    // the list of arguments with no error.
    //
    // Otherwise, we *do* report an error for this unexpected token, and then enter error recovery 
    // mode to decide how to try to recover from this unexpected token.
    //
    // Error recovery will walk up the list of states we're in seeing if the token is a stop token
    // for that construct *or* could start another element within what construct.  For example, if
    // the unexpected token was '}' then that would be a stop token for Block_Statements. 
    // Alternatively, if the unexpected token was 'return', then that would be a start token for 
    // the next statment in Block_Statements.
    // 
    // If either of those cases are true, We will then return *without* consuming  that token. 
    // (Remember, we've already reported an error).  Now we're just letting the higher up parse 
    // constructs eventually try to consume that token.
    //
    // If none of the higher up states consider this a stop or start token, then we will simply 
    // consume the token and add it to our list of 'skipped tokens'.  We will then repeat the 
    // above algorithm until we resynchronize at some point.
    enum ListParsingState {
        SourceUnit_ModuleElements = 1 << 0,
        ClassDeclaration_ClassElements = 1 << 1,
        ModuleDeclaration_ModuleElements = 1 << 2,
        SwitchStatement_SwitchClauses = 1 << 3,
        SwitchClause_Statements = 1 << 4,
        Block_Statements = 1 << 5,
        TryBlock_Statements = 1 << 6,
        CatchBlock_Statements = 1 << 7,
        EnumDeclaration_VariableDeclarators = 1 << 8,
        ObjectType_TypeMembers = 1 << 9,
        ExtendsOrImplementsClause_TypeNameList = 1 << 10,
        VariableDeclaration_VariableDeclarators_AllowIn = 1 << 11,
        VariableDeclaration_VariableDeclarators_DisallowIn = 1 << 12,
        ArgumentList_AssignmentExpressions = 1 << 13,
        ObjectLiteralExpression_PropertyAssignments = 1 << 14,
        ArrayLiteralExpression_AssignmentExpressions = 1 << 15,
        ParameterList_Parameters = 1 << 16,
        TypeArgumentList_Types = 1 << 17,
        TypeParameterList_TypeParameters = 1 << 18,

        FirstListParsingState = SourceUnit_ModuleElements,
        LastListParsingState = TypeArgumentList_Types,
    }

    // Allows one to easily move over a syntax tree.  Used during incremental parsing to move over
    // the previously parsed tree to provide nodes and tokens that can be reused when parsing the
    // updated text.
    class SyntaxCursor {
        private _elements: ISyntaxElement[] = [];
        private _index: number = 0;
        private _pinCount: number = 0;

        constructor(sourceUnit: SourceUnitSyntax) {
            sourceUnit.insertChildrenInto(this._elements, 0);
        }

        public isFinished(): bool {
            return this._index === this._elements.length;
        }

        public currentElement(): ISyntaxElement {
            if (this.isFinished()) {
                return null;
            }

            return this._elements[this._index];
        }

        public currentNode(): SyntaxNode {
            var element = this.currentElement();
            return element !== null && element.isNode() ? <SyntaxNode>element : null;
        }

        public moveToFirstChild() {
            if (this.isFinished()) {
                return;
            }

            var element = this._elements[this._index];
            if (element.isToken()) {
                // If we're already on a token, there's nothing to do.
                return;
            }

            // Otherwise, break the node we're pointing at into its children.  We'll then be 
            // pointing at the first child
            var node = <SyntaxNode>element;

            // Remove the item that we're pointing at.
            this._elements.splice(this._index, 1);

            // And add its children into the position it was at.
            node.insertChildrenInto(this._elements, this._index);
        }

        public moveToNextSibling() {
            if (this.isFinished()) {
                return;
            }

            if (this._pinCount > 0) {
                // If we're currently pinned, then just move our index forward.  We'll then be 
                // pointing at the next sibling.
                this._index++;
                return;
            }

            // if we're not pinned, we better be pointed at the first item in the list.
            Debug.assert(this._index === 0);

            // Just shift ourselves over so we forget the current element we're pointing at and 
            // we're pointing at the next slibing.
            this._elements.shift();
        }

        public getAndPinCursorIndex(): number {
            this._pinCount++;
            return this._index;
        }

        public releaseAndUnpinCursorIndex(index: number) {
            // this._index = index;

            Debug.assert(this._pinCount > 0);
            this._pinCount--;
            if (this._pinCount === 0) {
                // The first pin was given out at index 0.  So we better be back at index 0.
                Debug.assert(this._index === 0);
            }
        }

        public rewindToPinnedCursorIndex(index: number): void {
            Debug.assert(index >= 0 && index <= this._elements.length);
            Debug.assert(this._pinCount > 0);
            this._index = index;
        }

        public pinCount(): number {
            return this._pinCount;
        }

        private moveToFirstToken(): void {
            var element: ISyntaxElement;

            while (!this.isFinished()) {
                var element = this.currentElement();
                if (element.isNode()) {
                    this.moveToFirstChild();
                    continue;
                }

                Debug.assert(element.isToken());
                return;
            }
        }

        public currentToken(): ISyntaxToken {
            this.moveToFirstToken();
            if (this.isFinished()) {
                return null;
            }

            var element = this.currentElement();

            Debug.assert(element.isToken());
            return <ISyntaxToken>element;
        }

        public peekToken(n: number): ISyntaxToken {
            this.moveToFirstToken();
            var pin = this.getAndPinCursorIndex();
            try {
                for (var i = 0; i < n; i++) {
                    this.moveToNextSibling();
                    this.moveToFirstToken();
                }

                return this.currentToken();
            }
            finally {
                this.rewindToPinnedCursorIndex(pin);
                this.releaseAndUnpinCursorIndex(pin);
            }
        }
    }
    
    // Interface that represents the source that the parser pulls tokens from.  Essentially, this 
    // is the interface that the parser needs an underlying scanner to provide.  This allows us to
    // separate out "what" the parser does with the tokens it retrieves versus "how" it obtains
    // the tokens.  i.e. all the logic for parsing language constructs sits in ParserImpl, while 
    // all the logic for retrieving tokens sits in individual IParserSources.
    //
    // By separating out this interface, we also make incremental parsing much easier.  Instead of
    // having the parser directly sit on top of the scanner, we sit it on this abstraction.  Then
    // in incremental scenarios, we can use the IncrementalParserSource to pull tokens (or even 
    // full nodes) from the previous tree when possible.  Of course, we'll still end up using a 
    // scanner for new text.  But that can all happen inside the source, with none of the logic in
    // the parser having to be aware of it.
    //
    // In general terms, a parser source represents a position within a text.  At that position, 
    // one can ask for the 'currentToken' that the source is pointing at.  The 'previousToken' that
    // precedes this token (generally used for automatic semicolon insertion, and other minor 
    // parsing decisions).  Then, once the parser consumes that token it can ask the source to
    // 'moveToNextToken'.
    //
    // Additional special abilities include:
    //  1) Being able to peek an arbitrary number of tokens ahead efficiently.
    //  2) Being able to retrieve fully parsed nodes from the source, not just tokens. This happens
    //     in incremental scenarios when the source is certain that the node is completley safe to
    //     reuse.
    //  3) Being able to get a 'rewind point' to the current location.  This allows the parser to
    //     speculatively parse as much as it wants, and then reset itself back to that point, 
    //     ensuring that no state changes that occurred after getting the 'rewing point' are 
    //     observable.
    //  4) Being able to reinterpret the current token being pointed at as a regular expression 
    //     token.  This is necessary as the scanner does not have enough information to correctly
    //     distinguish "/" or "/=" as divide tokens, versus "/..../" as a regex token.  If the 
    //     parser sees a "/" in a place where a divide is not allowed, but a regex would be, then
    //     it can call into the source and ask if a regex token could be returned instead.  The 
    //     sources are smart enough to do that and not be affected by any additional work they may
    //     have done when they originally scanned that token.
    interface IParserSource {
        // The absolute index that the current token starts at.  'currentToken' and 'currentNode'
        // have their fullStart at this position.  previousToken has it's fullEnd at this position.
        absolutePosition(): number;

        // The token that comes before the 'currentToken' that hte source is pointing at. Initially
        // null. 
        previousToken(): ISyntaxToken;

        // The current syntax node the source is pointing at.  Only available in incremental settings.
        // The source can point at a node if that node doesn't intersect any of the text changes in
        // the file, and doesn't contain certain unacceptable constructs.  For example, if the node
        // contains skipped text, then it will not be reused.
        currentNode(): SyntaxNode;

        // The current token the source is pointing at.
        currentToken(): ISyntaxToken;

        // The current token reinterpretted as a regex token.  This must only be called when the 
        // source is pointing at a "/" or "/=" token. 
        currentTokenAllowingRegularExpression(): ISyntaxToken;

        // Peek any number of tokens ahead from the current location in source.  peekToken(0) is
        // equivalent to 'currentToken', peekToken(1) is the next token, peekToken(2) the token
        // after that, etc.  If the caller peeks past the end of the text, then EndOfFile tokens
        // will be returned.
        peekToken(n: number): ISyntaxToken;

        // Called to move the source to the next node or token once the parser has consumed the 
        // current one.
        moveToNextNode(): void;
        moveToNextToken(): void;

        // Gets a rewind point that the parser can use to move back to after it speculatively 
        // parses something.  The source guarantees that if the parser calls 'rewind' with that 
        // point that it will be mostly in the same state that it was in when 'getRewindPoint'
        // was called.  i.e. calling currentToken, peekToken, tokenDiagnostics, etc. will result
        // in the same values.  One allowed exemption to this is 'currentNode'.  If a rewind point
        // is requested and rewound, then getting the currentNode may not be possible.  However,
        // as this is purely a performance optimization, it will not affect correctness.
        //
        // Note: that rewind points are not free (but they should also not be too expensive).  So
        // they should be used judiciously.  While a rewind point is held by the parser, the source
        // is not free to do things that it would normally do.  For example, it cannot throw away
        // tokens that it has scanned on or after the rewind point as it must keep them alive for
        // the parser to move back to.
        //
        // Rewind points also work in a stack fashion.  The first rewind point given out must be
        // the last rewind point released.  Do not release them out of order, or bad things can 
        // happen.
        //
        // Do *NOT* forget to release a rewind point.  Always put them in a finally block to ensure
        // that they are released.  If they are not released, things will still work, you will just
        // consume far more memory than necessary.
        getRewindPoint(): IParserRewindPoint;

        // Rewinds the source to the position and state it was at when this rewind point was created.
        // This does not need to be called if the parser decides it does not need to rewind.  For 
        // example, the parser may speculatively parse out a lambda expression when it sees something
        // ambiguous like "(a = b, c = ...".  If it succeeds parsing that as a lambda, then it will
        // just return that result.  However, if it fails *then* it will rewind and try it again as
        // a parenthesized expression.  
        rewind(rewindPoint: IParserRewindPoint): void;

        // Called when the parser is done speculative parsing and no longer needs the rewind point.
        // Must be called for every rewing point retrived.
        releaseRewindPoint(rewindPoint: IParserRewindPoint): void;

        // Retrieves the diagnostics generated while the source was producing nodes or tokens. 
        // Should generally only be called after the document has been completely parsed.
        tokenDiagnostics(): SyntaxDiagnostic[];
    }

    // Parser source used in batch scenarios.  Directly calls into an underlying text scanner and
    // supports none of the functionality to reuse nodes.  Good for when you just want want to do
    // a single parse of a file.
    class NormalParserSource implements IParserSource {
        // The sliding window that we store tokens in.
        private slidingWindow: SlidingWindow;

        // The scanner we're pulling tokens from.
        private scanner: Scanner;

        // The previous token to the current token.  Set when we advance to the next token.
        private _previousToken: ISyntaxToken = null;

        // The absolute position we're at in the text we're reading from.
        private _absolutePosition: number = 0;

        // The diagnostics we get while scanning.  Note: this never gets rewound when we do a normal
        // rewind.  That's because rewinding doesn't affect the tokens created.  It only affects where
        // in the token stream we're pointing at.  However, it will get modified if we we decide to
        // reparse a / or /= as a regular expression.
        private _tokenDiagnostics: SyntaxDiagnostic[] = [];

        // Pool of rewind points we give out if the parser needs one.
        private rewindPointPool: IParserRewindPoint[] = [];
        private rewindPointPoolCount = 0;

        constructor(text: ISimpleText,
                    languageVersion: LanguageVersion,
                    stringTable: Collections.StringTable) {
            this.slidingWindow = new SlidingWindow(this, ArrayUtilities.createArray(/*defaultWindowSize:*/ 32, null), null);
            this.scanner = new Scanner(text, languageVersion, stringTable);
        }

        private currentNode(): SyntaxNode {
            // The normal parser source never returns nodes.  They're only returned by the 
            // incremental parser source.
            return null;
        }

        private moveToNextNode(): void {
            // Should never get called.
            throw Errors.invalidOperation();
        }

        public absolutePosition() {
            return this._absolutePosition;
        }

        public previousToken(): ISyntaxToken {
            return this._previousToken;
        }

        public tokenDiagnostics(): SyntaxDiagnostic[] {
            return this._tokenDiagnostics;
        }

        private getOrCreateRewindPoint(): IParserRewindPoint {
            if (this.rewindPointPoolCount === 0) {
                return <IParserRewindPoint>{};
            }

            this.rewindPointPoolCount--;
            var result = this.rewindPointPool[this.rewindPointPoolCount];
            this.rewindPointPool[this.rewindPointPoolCount] = null;
            return result;
        }

        public getRewindPoint(): IParserRewindPoint {
            var slidingWindowIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            var rewindPoint = this.getOrCreateRewindPoint();

            rewindPoint.slidingWindowIndex = slidingWindowIndex;
            rewindPoint.previousToken = this._previousToken;
            rewindPoint.absolutePosition = this._absolutePosition;

            rewindPoint.pinCount = this.slidingWindow.pinCount();

            return rewindPoint;
        }

        public isPinned(): bool {
            return this.slidingWindow.pinCount() > 0;
        }

        public rewind(rewindPoint: IParserRewindPoint): void {
            this.slidingWindow.rewindToPinnedIndex(rewindPoint.slidingWindowIndex);

            this._previousToken = rewindPoint.previousToken;
            this._absolutePosition = rewindPoint.absolutePosition;
        }

        public releaseRewindPoint(rewindPoint: IParserRewindPoint): void {
            Debug.assert(this.slidingWindow.pinCount() === rewindPoint.pinCount);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex((<any>rewindPoint).absoluteIndex);

            this.rewindPointPool[this.rewindPointPoolCount] = rewindPoint;
            this.rewindPointPoolCount++;
        }

        private fetchMoreItems(allowRegularExpression: bool, sourceIndex: number, window: any[], destinationIndex: number, spaceAvailable: number): number {
            // Assert disabled because it is actually expensive enugh to affect perf.
            Debug.assert(spaceAvailable > 0);
            window[destinationIndex] = this.scanner.scan(this._tokenDiagnostics, allowRegularExpression);
            return 1;
        }

        public peekToken(n: number): ISyntaxToken {
            return this.slidingWindow.peekItemN(n);
        }

        public moveToNextToken(): void {
            var currentToken = this.currentToken();
            this._absolutePosition += currentToken.fullWidth();
            this._previousToken = currentToken;

            this.slidingWindow.moveToNextItem();
        }

        public currentToken(): ISyntaxToken {
            return this.slidingWindow.currentItem(/*allowRegularExpression:*/ false);
        }

        private removeDiagnosticsOnOrAfterPosition(position: number): void {
            // walk backwards, removing any diagnostics that came after the the current token's
            // full start position.
            var tokenDiagnosticsLength = this._tokenDiagnostics.length;
            while (tokenDiagnosticsLength > 0) {
                var diagnostic = this._tokenDiagnostics[tokenDiagnosticsLength - 1];
                if (diagnostic.position() >= position) {
                    tokenDiagnosticsLength--;
                }
                else {
                    break;
                }
            }

            this._tokenDiagnostics.length = tokenDiagnosticsLength;
        }

        public resetToPosition(absolutePosition: number, previousToken: ISyntaxToken): void {
            this._absolutePosition = absolutePosition;
            this._previousToken = previousToken;

            // First, remove any diagnostics that came after this position.
            this.removeDiagnosticsOnOrAfterPosition(absolutePosition);

            // Now, tell our sliding window to throw away all tokens after this position as well.
            this.slidingWindow.disgardAllItemsFromCurrentIndexOnwards();

            // Now tell the scanner to reset its position to this position as well.  That way
            // when we try to scan the next item, we'll be at the right location.
            this.scanner.setAbsoluteIndex(absolutePosition);
        }

        public currentTokenAllowingRegularExpression(): ISyntaxToken {
            // We better be on a divide token right now.
            Debug.assert(SyntaxFacts.isAnyDivideToken(this.currentToken().tokenKind));

            // First, we're going to rewind all our data to the point where this / or /= token started.
            // That's because if it does turn out to be a regular expression, then any tokens or token 
            // diagnostics we produced after the original / may no longer be valid.  This would actually
            // be a  fairly expected case.  For example, if you had:  / ... gibberish ... /, we may have 
            // produced several diagnostics in the process of scanning the tokens after the first / as
            // they may not have been legal javascript okens.
            //
            // We also need to remove all the tokens we've gotten from the slash and onwards.  They may
            // not have been what the scanner would have produced if it decides that this is actually
            // a regular expresion.
            this.resetToPosition(this._absolutePosition, this._previousToken);

            // Now actually fetch the token again from the scanner. This time let it know that it
            // can scan it as a regex token if it wants to.
            var token = this.slidingWindow.currentItem(/*allowRegularExpression:*/ true);

            // We have better gotten some sort of regex token.  Otherwise, something *very* wrong has
            // occurred.
            Debug.assert(SyntaxFacts.isAnyDivideOrRegularExpressionToken(token.tokenKind));

            return token;
        }
    }

    // Parser source used in incremental scenarios. This parser source wraps an old tree, text 
    // change and new text, and uses all three to provide nodes and tokens to the parser.  In
    // general, nodes from the old tree are returned as long as they do not intersect with the text 
    // change.  Then, once the text change is reached, tokens from the old tree are returned as 
    // long as they do not intersect with the text change.  Then, the text that is actually changed
    // will be scanned using a normal scanner.  Then, once the new text is scanned, the source will
    // attempt to sync back up with nodes or tokens that started where the new tokens end. Once it
    // can do that, then all subsequent data will come from the original tree.
    //
    // This allows for an enormous amount of tree reuse in common scenarios.  Situations that 
    // prevent this level of reuse include substantially destructive operations like introducing
    // "/*" without a "*/" nearby to terminate the comment.
    class IncrementalParserSource implements IParserSource {
        // The underlying parser source that we will use to scan tokens from any new text, or any 
        // tokens from the old tree that we decide we can't use for any reason.  We will also 
        // continue scanning tokens from this source until we've decided that we're resynchronized
        // and can read in subsequent data from the old tree.
        //
        // This parser source also keeps track of the absolute position in the text that we're in,
        // the previous token, and any token diagnostics produced.  That way we dont' have to track
        // that ourselves.
        private _normalParserSource: NormalParserSource;

        // The range of text in the *original* text that was changed, and the new length of it after
        // the change.
        private _changeRange: TextChangeRange;

        // This number represents how our position in the old tree relates to the position we're 
        // pointing at in the new text.  If it is 0 then our positions are in sync and we can read
        // nodes or tokens from the old tree.  If it is non-zero, then our positions are not in 
        // sync and we cannot use nodes or tokens from the old tree.
        //
        // Now, changeDelta could be negative or positive.  Negative means 'the position we're at
        // in the original tree is behind the position we're at in the text'.  In this case we 
        // keep throwing out old nodes or tokens (and thus move forward in the original tree) until
        // changeDelta becomes 0 again or positive.  If it becomes 0 then we are resynched and can
        // read nodes or tokesn from the tree.
        //
        // If changeDelta is positive, that means the current node or token we're pointing at in 
        // the old tree is at a further ahead position than the position we're pointing at in the
        // new text.  In this case we have no choice but to scan tokens from teh new text.  We will
        // continue to do so until, again, changeDelta becomes 0 and we've resynced, or change delta
        // becomes negative and we need to skip nodes or tokes in the original tree.
        private _changeDelta: number = 0;

        // The cursor we use to navigate through and retrieve nodes and tokens from the old tree.
        private _oldSourceUnitCursor: SyntaxCursor;

        constructor(oldSourceUnit: SourceUnitSyntax,
                    changeRanges: TextChangeRange[],
                    newText: ISimpleText,
                    languageVersion: LanguageVersion,
                    stringTable: Collections.StringTable) {
            this._oldSourceUnitCursor = new SyntaxCursor(oldSourceUnit);

            // In general supporting multiple individual edits is just not that important.  So we 
            // just collapse this all down to a single range to make the code here easier.  The only
            // time this could be problematic would be if the user made a ton of discontinuous edits.
            // For example, doing a column select on a *large* section of a code.  If this is a 
            // problem, we can always update this code to handle multiple changes.
            this._changeRange = IncrementalParserSource.extendToAffectedRange(
                TextChangeRange.collapse(changeRanges),
                oldSourceUnit);

            // The old tree's length, plus whatever length change was caused by the edit better 
            // equal the new text's length!
            Debug.assert((oldSourceUnit.fullWidth() - this._changeRange.span().length() + this._changeRange.newLength()) === newText.length());

            // Set up a scanner so that we can scan tokens out of the new text.
            this._normalParserSource = new NormalParserSource(newText, languageVersion, stringTable);
        }

        private static extendToAffectedRange(changeRange:TextChangeRange,
                                             sourceUnit: SourceUnitSyntax): TextChangeRange {
            // Consider the following code:
            //      void foo() { /; }
            //
            // If the text changes with an insertion of / just before the semicolon then we end up with:
            //      void foo() { //; }
            //
            // If we were to just use the changeRange a is, then we would not rescan the { token 
            // (as it does not intersect hte actual original change range).  Because an edit may
            // change the token touching it, we actually need to look back *at least* one token so
            // that the prior token sees that change.  
            //
            // Note: i believe (outside of regex tokens) max lookahead is just one token for 
            // TypeScript.  However, if this turns out to be wrong, we may have to increase how much
            // futher we look back. 
            //
            // Note: lookahead handling for regex characters is handled specially in during 
            // incremental parsing, and does not need to be handled here.

            var maxLookahead = 1;

            var start = changeRange.span().start();

            // the first iteration aligns us with the change start. subsequent iteration move us to
            // the left by maxLookahead tokens.  We only need to do this as long as we're not at the
            // start of the tree.
            for (var i = 0; start > 0 && i <= maxLookahead; i++) {
                var token = sourceUnit.findToken(start);

                Debug.assert(token.kind() !== SyntaxKind.None);
                Debug.assert(token.kind() === SyntaxKind.EndOfFileToken || token.fullWidth() > 0);

                var position = token.fullStart();

                start = MathPrototype.max(0, position - 1);
            }

            var finalSpan = TextSpan.fromBounds(start, changeRange.span().end());
            var finalLength = changeRange.newLength() + (changeRange.span().start() - start);

            return new TextChangeRange(finalSpan, finalLength);
        }

        public absolutePosition() {
            return this._normalParserSource.absolutePosition();
        }

        public previousToken() {
            return this._normalParserSource.previousToken();
        }

        private tokenDiagnostics(): SyntaxDiagnostic[] {
            return this._normalParserSource.tokenDiagnostics();
        }

        private getRewindPoint(): IParserRewindPoint {
            // Get a rewind point for our new text reader and for our old source unit cursor.
            var rewindPoint = this._normalParserSource.getRewindPoint();
            var oldSourceUnitCursorIndex = this._oldSourceUnitCursor.getAndPinCursorIndex();

            // Store where we were when the rewind point was created.
            rewindPoint.changeDelta = this._changeDelta;
            rewindPoint.changeRange = this._changeRange;
            rewindPoint.oldSourceUnitCursorIndex = oldSourceUnitCursorIndex;

            Debug.assert(rewindPoint.pinCount === this._oldSourceUnitCursor.pinCount());

            return rewindPoint;
        }

        private rewind(rewindPoint: IParserRewindPoint): void {
            // Restore our state to the values when the rewind point was created.
            this._changeRange = rewindPoint.changeRange;
            this._changeDelta = rewindPoint.changeDelta;
            this._oldSourceUnitCursor.rewindToPinnedCursorIndex(rewindPoint.oldSourceUnitCursorIndex);

            this._normalParserSource.rewind(rewindPoint);
        }

        private releaseRewindPoint(rewindPoint: IParserRewindPoint): void {
            // Release both the new text reader and the old text cursor.
            this._oldSourceUnitCursor.releaseAndUnpinCursorIndex(rewindPoint.oldSourceUnitCursorIndex);
            this._normalParserSource.releaseRewindPoint(rewindPoint);
        }

        private canReadFromOldSourceUnit() {
            // If we're currently pinned, then do not want to touch the cursor.  If we end up 
            // reading from the old source unit, we'll try to then set the position of the normal
            // parser source to an absolute position (in moveToNextToken).  Doing is unsupported
            // while the underlying source is pinned.
            if (this._normalParserSource.isPinned()) {
                return false;
            }

            // If our current absolute position is in the middle of the changed range in the new text
            // then we definitely can't read from the old source unit right now.
            if (this._changeRange !== null && this._changeRange.newSpan().intersectsWithPosition(this.absolutePosition())) {
                return false;
            }

            // First, try to sync up with the new text if we're behind.
            this.syncCursorToNewTextIfBehind();

            // Now, if we're synced up *and* we're not currently pinned in the new text scanner,
            // then we can read a node from the cursor.  If we're pinned in the scanner then we
            // can't read a node from the cursor because we will mess up the pinned scanner when
            // we try to move it forward past this node.
            return this._changeDelta === 0 &&
                   !this._oldSourceUnitCursor.isFinished();
        }
        
        public currentNode(): SyntaxNode {
            if (this.canReadFromOldSourceUnit()) {
                // Try to read a node.  If we can't then our caller will call back in and just try
                // to get a token.
                return this.tryGetNodeFromOldSourceUnit();
            }

            // Either we were ahead of the old text, or we were pinned.  No node can be read here.
            return null;
        }

        public currentToken(): ISyntaxToken {
            if (this.canReadFromOldSourceUnit()) {
                var token = this.tryGetTokenFromOldSourceUnit();
                if (token !== null) {
                    return token;
                }
            }

            // Either we couldn't read from the old source unit, or we weren't able to successfully
            // get a token from it.  In this case we need to read a token from the underlying text.
            return this._normalParserSource.currentToken();
        }

        public currentTokenAllowingRegularExpression(): ISyntaxToken {
            // Just delegate to the underlying source to handle this.
            return this._normalParserSource.currentTokenAllowingRegularExpression();
        }

        private syncCursorToNewTextIfBehind() {
            while (true) {
                if (this._oldSourceUnitCursor.isFinished()) {
                    // Can't sync up if the cursor is finished.
                    break;
                }

                if (this._changeDelta >= 0) {
                    // Nothing to do if we're synced up or ahead of the text.
                    break;
                }

                // We're behind in the original tree.  Throw out a node or token in an attempt to 
                // catch up to the position we're at in the new text.

                var currentElement = this._oldSourceUnitCursor.currentElement();

                // If we're pointing at a node, and that node's width is less than our delta,
                // then we can just skip that node.  Otherwise, if we're pointing at a node
                // whose width is greater than the delta, then crumble it and try again.
                // Otherwise, we must be pointing at a token.  Just skip it and try again.
                    
                if (currentElement.isNode() && (currentElement.fullWidth() > Math.abs(this._changeDelta))) {
                    // We were pointing at a node whose width was more than changeDelta.  Crumble the 
                    // node and try again.  Note: we haven't changed changeDelta.  So the callers loop
                    // will just repeat this until we get to a node or token that we can skip over.
                    this._oldSourceUnitCursor.moveToFirstChild();
                }
                else {
                    this._oldSourceUnitCursor.moveToNextSibling();

                    // Get our change delta closer to 0 as we skip past this item.
                    this._changeDelta += currentElement.fullWidth();

                    // If this was a node, then our changeDelta is 0 or negative.  If this was a 
                    // token, then we could still be negative (and we have to read another token),
                    // we could be zero (we're done), or we could be positive (we've moved ahead
                    // of the new text).  Only if we're negative will we continue looping.
                }
            }

            // At this point, we must be either:
            //   a) done with the cursor
            //   b) (ideally) caught up to the new text position.
            //   c) ahead of the new text position.
            // In case 'b' we can try to reuse a node from teh old tree.
            Debug.assert(this._oldSourceUnitCursor.isFinished() || this._changeDelta >= 0);
        }

        private intersectsWithChangeRangeSpanInOriginalText(start: number, length: number) {
            return this._changeRange !== null && this._changeRange.span().intersectsWith(start, length);
        }

        private tryGetNodeFromOldSourceUnit(): SyntaxNode {
            Debug.assert(this.canReadFromOldSourceUnit());

            // Keep moving the cursor down to the first node that is safe to return.  A node is 
            // safe to return if:
            //  a) it does not intersect the changed text.
            //  b) it does not contain skipped text.
            //  c) it does not have any zero width tokens in it.
            //  d) it does not have a regex token in it.
            //
            // TODO: we should also only be able to get a node if we're in the same 'strict' 
            // context we were in when we parsed the node.
            while (true) {
                var node = this._oldSourceUnitCursor.currentNode();
                if (node === null) {
                    // Couldn't even read a node, nothing to return.
                    return null;
                }

                if (!this.intersectsWithChangeRangeSpanInOriginalText(this.absolutePosition(), node.fullWidth())) {
                    // Didn't intersect with the change range.
                    if (!node.hasSkippedText() &&
                        !node.hasZeroWidthToken() &&
                        !node.hasRegularExpressionToken()) {

                        // Didn't contain anything that would make it unusable.  Awesome.  This is
                        // a node we can reuse.
                        return node;
                    }
                }

                // We couldn't use currentNode. Try to move to its first child (in case that's a 
                // node).  If it is we can try using that.  Otherwise we'll just bail out in the
                // next iteration of the loop.
                this._oldSourceUnitCursor.moveToFirstChild();
            }
        }

        private canReuseTokenFromOldSourceUnit(position: number, token: ISyntaxToken): bool {
            // A token is safe to return if:
            //  a) it does not intersect the changed text.
            //  b) it does not contain skipped text.
            //  c) it is not zero width.
            //  d) it is not a regex token.
            //  e) it is not a parser generated token.
            //
            // NOTE: It is safe to get a token regardless of what our strict context was/is.  That's 
            // because the strict context doesn't change what tokens are scanned, only how the 
            // parser reacts to them.

            if (token !== null) {
                if (!this.intersectsWithChangeRangeSpanInOriginalText(position, token.fullWidth())) {
                    // Didn't intersect with the change range.
                    if (!token.hasSkippedText() &&
                        token.width() > 0 &&
                        !SyntaxFacts.isAnyDivideOrRegularExpressionToken(token.tokenKind) &&
                        !SyntaxFacts.isParserGenerated(token.tokenKind)) {

                        // Didn't contain anything that would make it unusable.  Awesome.  This is
                        // a token we can reuse.
                        return true;
                    }
                }
            }

            return false;
        }

        private tryGetTokenFromOldSourceUnit(): ISyntaxToken {
            Debug.assert(this.canReadFromOldSourceUnit());

            // get the current token that the cursor is pointing at.
            var token = this._oldSourceUnitCursor.currentToken();

            return this.canReuseTokenFromOldSourceUnit(this.absolutePosition(), token) 
                ? token : null;
        }

        public peekToken(n: number): ISyntaxToken {
            if (this.canReadFromOldSourceUnit()) {
                var token = this.tryPeekTokenFromOldSourceUnit(n);
                if (token !== null) {
                    return token;
                }
            }

            // Couldn't peek this far in the old tree.  Get the token from the new text.
            return this._normalParserSource.peekToken(n);
        }

        private tryPeekTokenFromOldSourceUnit(n: number): ISyntaxToken {
            Debug.assert(this.canReadFromOldSourceUnit());

            // In order to peek the 'nth' token we need all the tokens up to that point.  That way
            // we know we know position that the nth token is at.  The position is necessary so 
            // that we can test if this token (or any that precede it cross the change range).
            var currentPosition = this.absolutePosition();
            for (var i = 0; i < n; i++) {
                var interimToken = this._oldSourceUnitCursor.peekToken(i);
                if (!this.canReuseTokenFromOldSourceUnit(currentPosition, interimToken)) {
                    return null;
                }

                currentPosition += interimToken.fullWidth();
            }

            var token = this._oldSourceUnitCursor.peekToken(n);
            return this.canReuseTokenFromOldSourceUnit(currentPosition, token) 
                ? token : null;
        }

        private moveToNextNode(): void {
            // A node could have only come from the old source unit cursor.  Update it and our 
            // current state.
            Debug.assert(this._changeDelta === 0);

            // Get the current node we were pointing at, and move to the next element.
            var currentElement = this._oldSourceUnitCursor.currentElement();
            var currentNode = this._oldSourceUnitCursor.currentNode();

            // We better still be pointing at the node.
            Debug.assert(currentElement === currentNode);
            this._oldSourceUnitCursor.moveToNextSibling();

            // Update the underlying source with where it should now be currently pointing, and 
            // what the previous token is before that position.
            var absolutePosition = this.absolutePosition() + currentNode.fullWidth();
            var previousToken = currentNode.lastToken();
            this._normalParserSource.resetToPosition(absolutePosition, previousToken);

            Debug.assert(previousToken !== null);
            Debug.assert(previousToken.width() > 0);

            if (this._changeRange !== null) {
                // If we still have a change range, then this node must have ended before the 
                // change range starts.  Thus, we don't need to call 'skipPastChanges'.
                Debug.assert(this.absolutePosition() < this._changeRange.span().start());
            }
        }

        private moveToNextToken(): void {
            // This token may have come from the old source unit, or from the new text.  Handle
            // both accordingly.
            var currentToken = this.currentToken();

            if (this._oldSourceUnitCursor.currentToken() === currentToken) {
                // The token came from the old source unit.  So our tree and text must be in sync.
                Debug.assert(this._changeDelta === 0);

                // Move the cursor past this token.
                this._oldSourceUnitCursor.moveToNextSibling();

                Debug.assert(!this._normalParserSource.isPinned());
                
                // Update the underlying source with where it should now be currently pointing, and 
                // what the previous token is before that position.  We don't need to do this when
                // the token came from the new text as the source will automatically be placed in
                // the right position.
                var absolutePosition = this.absolutePosition() + currentToken.fullWidth();
                var previousToken = currentToken;
                this._normalParserSource.resetToPosition(absolutePosition, previousToken);

                Debug.assert(previousToken !== null);
                Debug.assert(previousToken.width() > 0);

                if (this._changeRange !== null) {
                    // If we still have a change range, then this token must have ended before the 
                    // change range starts.  Thus, we don't need to call 'skipPastChanges'.
                    Debug.assert(this.absolutePosition() < this._changeRange.span().start());
                }
            }
            else {
                // the token came from the new text.  We have to update our delta appropriately.
                this._changeDelta -= currentToken.fullWidth();

                // Move our underlying source forward.
                this._normalParserSource.moveToNextToken();

                // Because we read a token from the new text, we may have moved ourselves past the
                // change range.  If we did, then we may also have to update our change delta to
                // compensate for the length change between the old and new text.
                if (this._changeRange !== null) {
                    // var changeEndInNewText = this._changeRange.span().start() + this._changeRange.newLength();
                    var changeRangeSpanInNewText = this._changeRange.newSpan();
                    if (this.absolutePosition() >= changeRangeSpanInNewText.end()) {
                        this._changeDelta += this._changeRange.newLength() - this._changeRange.span().length();
                        this._changeRange = null;
                    }
                }
            }
        }
    }

    // Contains the actual logic to parse typescript/javascript.  This is the code that generally
    // represents the logic necessary to handle all the language grammar constructs.  When the 
    // language changes, this should generally only be the place necessary to fix up.
    class ParserImpl {
        // Underlying source where we pull nodes and tokens from.
        private source: IParserSource;

        // Parsing options.
        private options: ParseOptions;

        // TODO: do we need to store/restore this when speculative parsing?  I don't think so.  The
        // parsing logic already handles storing/restoring this and should work properly even if we're
        // speculative parsing.
        private listParsingState: ListParsingState = 0;

        // Whether or not we are in strict parsing mode.  All that changes in strict parsing mode is
        // that some tokens that would be considered identifiers may be considered keywords.  When 
        // rewinding, we need to store and restore this as the mode may have changed.
        //
        // TODO: do we need to store/restore this when speculative parsing?  I don't think so.  The
        // parsing logic already handles storing/restoring this and should work properly even if we're
        // speculative parsing.
        private isInStrictMode: bool = false;

        // Current state of the parser.  If we need to rewind we will store and reset these values as
        // appropriate.

        // Diagnostics created when parsing invalid code.  Any diagnosics created when speculative 
        // parsing need to removed when rewinding.  To do this we store the count of diagnostics when 
        // we start speculative parsing.  And if we rewind, we restore this to the same count that we 
        // started at.
        private diagnostics: SyntaxDiagnostic[] = [];

        private factory: Syntax.IFactory = Syntax.normalModeFactory;

        constructor(source: IParserSource, options?: ParseOptions) {
            this.source = source;
            this.options = options;
        }

        private getRewindPoint(): IParserRewindPoint {
            var rewindPoint = this.source.getRewindPoint();

            rewindPoint.diagnosticsCount = this.diagnostics.length;

            // Values we keep around for debug asserting purposes.
            rewindPoint.isInStrictMode = this.isInStrictMode;
            rewindPoint.listParsingState = this.listParsingState;

            return rewindPoint;
        }

        private rewind(rewindPoint: IParserRewindPoint): void {
            this.source.rewind(rewindPoint);

            this.diagnostics.length = rewindPoint.diagnosticsCount;
        }

        private releaseRewindPoint(rewindPoint: IParserRewindPoint): void {
            Debug.assert(this.listParsingState === rewindPoint.listParsingState);
            Debug.assert(this.isInStrictMode === rewindPoint.isInStrictMode);

            this.source.releaseRewindPoint(rewindPoint);
        }

        private currentTokenStart(): number {
            return this.source.absolutePosition() + this.currentToken().leadingTriviaWidth();
        }

        private previousTokenStart(): number {
            if (this.previousToken() === null) {
                return 0;
            }

            return this.source.absolutePosition() -
                   this.previousToken().fullWidth() +
                   this.previousToken().leadingTriviaWidth();
        }

        private previousTokenEnd(): number {
            if (this.previousToken() === null) {
                return 0;
            }

            return this.previousTokenStart() + this.previousToken().width();
        }

        private currentNode(): SyntaxNode {
            var node = this.source.currentNode();

            // We can only reuse a node if it was parsed under the same strict mode that we're 
            // currently in.  i.e. if we originally parsed a node in non-strict mode, but then
            // the user added 'using strict' at hte top of the file, then we can't use that node
            // again as the presense of strict mode may cause us to parse the tokens in the file
            // differetly.
            //
            // Note: we *can* reuse tokens when the strict mode changes.  That's because tokens
            // are unaffected by strict mode.  It's just the parser will decide what to do with it
            // differently depending on what mode it is in.
            if (node === null || node.parsedInStrictMode() !== this.isInStrictMode) {
                return null;
            }

            return node;
        }

        private currentToken(): ISyntaxToken {
            return this.source.currentToken();
        }

        private currentTokenAllowingRegularExpression(): ISyntaxToken {
            return this.source.currentTokenAllowingRegularExpression();
        }

        private peekToken(n: number): ISyntaxToken {
            return this.source.peekToken(n);
        }

        private eatAnyToken(): ISyntaxToken {
            var token = this.currentToken();
            this.moveToNextToken();
            return token;
        }

        private moveToNextToken(): void {
            this.source.moveToNextToken();
        }

        private previousToken(): ISyntaxToken {
            return this.source.previousToken();
        }

        private eatNode(): SyntaxNode {
            var node = this.source.currentNode();
            this.source.moveToNextNode();
            return node;
        }

        //this method is called very frequently
        //we should keep it simple so that it can be inlined.
        private eatToken(kind: SyntaxKind): ISyntaxToken {
            // Assert disabled because it is actually expensive enugh to affect perf.
            Debug.assert(SyntaxFacts.isTokenKind(kind))

            var token = this.currentToken();
            if (token.tokenKind === kind) {
                this.moveToNextToken();
                return token;
            }

            //slow part of EatToken(SyntaxKind kind)
            return this.createMissingToken(kind, token);
        }

        // Eats the token if it is there.  Otherwise does nothing.  Will not report errors.
        private tryEatToken(kind: SyntaxKind): ISyntaxToken {
            if (this.currentToken().tokenKind === kind) {
                return this.eatToken(kind);
            }

            return null;
        }

        // Eats the keyword if it is there.  Otherwise does nothing.  Will not report errors.
        private tryEatKeyword(kind: SyntaxKind): ISyntaxToken {
            if (this.currentToken().tokenKind === kind) {
                return this.eatKeyword(kind);
            }

            return null;
        }

        private eatKeyword(kind: SyntaxKind): ISyntaxToken {
            Debug.assert(SyntaxFacts.isTokenKind(kind))

            var token = this.currentToken();
            if (token.tokenKind === kind) {
                this.moveToNextToken();
                return token;
            }

            //slow part of EatToken(SyntaxKind kind)
            return this.createMissingToken(kind, token);
        }

        // An identifier name is basically any word, even if that work is a reserved keyword.  so 
        // both 'foo' and 'return' are identifier names.  Note: a word is always an identifier or 
        // not regardless of the state of the parser.
        private static isIdentifierName(token: ISyntaxToken): bool {
            return SyntaxFacts.isIdentifierName(token.tokenKind);
        }

        // An identifier is basically any word, unless it is a reserved keyword.  so 'foo' is an 
        // identifier and 'return' is not.  Note: a word may or may not be an identifier depending 
        // on the state of the parser.  For example, 'yield' is an identifier *unless* the parser 
        // is in strict mode.
        private isIdentifier(token: ISyntaxToken): bool {
            var tokenKind = token.tokenKind;

            if (tokenKind === SyntaxKind.IdentifierName) {
                return true;
            }

            // Keywords are only identifiers if they're FutureReservedStrictWords and we're in 
            // strict mode.  *Or* if it's a typescript 'keyword'. 
            if (tokenKind >= SyntaxKind.FirstFutureReservedStrictKeyword) {
                if (tokenKind <= SyntaxKind.LastFutureReservedStrictKeyword) {
                    // Could be a keyword or identifier.  It's an identifier if we're not in strict
                    // mode.
                    return !this.isInStrictMode;
                }
                
                // If it's typescript keyword, then it's actually a javascript identifier.
                return tokenKind <= SyntaxKind.LastTypeScriptKeyword;
            }

            // Anything else is not an identifier.
            return false;
        }

        // This method should be called when the grammar calls for an *IdentifierName* and not an
        // *Identifier*.
        private eatIdentifierNameToken(): ISyntaxToken {
            var token = this.currentToken();
            if (ParserImpl.isIdentifierName(token)) {
                this.moveToNextToken();
                return token;
            }

            return this.createMissingToken(SyntaxKind.IdentifierName, token);
        }

        // This method should be called when the grammar calls for an *Identifier* and not an
        // *IdentifierName*.
        private eatIdentifierToken(): ISyntaxToken {
            var token = this.currentToken();
            if (this.isIdentifier(token)) {
                this.moveToNextToken();
                return token;
            }

            return this.createMissingToken(SyntaxKind.IdentifierName, token);
        }

        private canEatAutomaticSemicolon(allowWithoutNewLine: bool): bool {
            var token = this.currentToken();

            // An automatic semicolon is always allowed if we're at the end of the file.
            if (token.tokenKind === SyntaxKind.EndOfFileToken) {
                return true;
            }

            // Or if the next token is a close brace (regardless of which line it is on).
            if (token.tokenKind === SyntaxKind.CloseBraceToken) {
                return true;
            }

            if (allowWithoutNewLine) {
                return true;
            }

            // It is also allowed if there is a newline between the last token seen and the next one.
            if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                return true;
            }

            return false;
        }

        private canEatExplicitOrAutomaticSemicolon(allowWithoutNewline: bool): bool {
            var token = this.currentToken();

            if (token.tokenKind === SyntaxKind.SemicolonToken) {
                return true;
            }

            return this.canEatAutomaticSemicolon(allowWithoutNewline);
        }

        private eatExplicitOrAutomaticSemicolon(allowWithoutNewline: bool): ISyntaxToken {
            var token = this.currentToken();

            // If we see a semicolon, then we can definitely eat it.
            if (token.tokenKind === SyntaxKind.SemicolonToken) {
                return this.eatToken(SyntaxKind.SemicolonToken);
            }

            // Check if an automatic semicolon could go here.  If so, synthesize one.  However, if the
            // user has the option set to error on automatic semicolons, then add an error to that
            // token as well.
            if (this.canEatAutomaticSemicolon(allowWithoutNewline)) {
                // Note: the missing token needs to go between real tokens.  So we place it at the 
                // fullstart of the current token.
                var semicolonToken = Syntax.emptyToken(SyntaxKind.SemicolonToken);

                if (!this.options.allowAutomaticSemicolonInsertion()) {
                    // Report the missing semicolon at the end of the *previous* token.

                    this.addDiagnostic(
                        new SyntaxDiagnostic(this.previousTokenEnd(), 0, DiagnosticCode.Automatic_semicolon_insertion_not_allowed, null));
                }

                return semicolonToken;
            }

            // No semicolon could be consumed here at all.  Just call the standard eating function
            // so we get the token and the error for it.
            return this.eatToken(SyntaxKind.SemicolonToken);
        }

        private isKeyword(kind: SyntaxKind): bool {
            if (kind >= SyntaxKind.FirstKeyword) {
                if (kind <= SyntaxKind.LastFutureReservedKeyword) {
                    return true;
                }

                if (this.isInStrictMode) {
                    return kind <= SyntaxKind.LastFutureReservedStrictKeyword;
                }
            }

            return false;
        }

        private createMissingToken(expectedKind: SyntaxKind, actual: ISyntaxToken): ISyntaxToken {
            var diagnostic = this.getExpectedTokenDiagnostic(expectedKind, actual);
            this.addDiagnostic(diagnostic);

            // The missing token will be at the full start of the current token.  That way empty tokens
            // will always be between real tokens and not inside an actual token.
            return Syntax.emptyToken(expectedKind);
        }

        private getExpectedTokenDiagnostic(expectedKind: SyntaxKind, actual: ISyntaxToken): SyntaxDiagnostic {
            var token = this.currentToken();

            // They wanted something specific, just report that that token was missing.
            if (SyntaxFacts.isAnyKeyword(expectedKind) || SyntaxFacts.isAnyPunctuation(expectedKind)) {
                return new SyntaxDiagnostic(this.currentTokenStart(), token.width(), DiagnosticCode._0_expected, [SyntaxFacts.getText(expectedKind)]);
            }
            else {
                // They wanted an identifier.

                // If the user supplied a keyword, give them a specialized message.
                if (actual !== null && SyntaxFacts.isAnyKeyword(actual.tokenKind)) {
                    return new SyntaxDiagnostic(this.currentTokenStart(), token.width(), DiagnosticCode.Identifier_expected__0_is_a_keyword, [SyntaxFacts.getText(actual.tokenKind)]);
                }
                else {
                    // Otherwise just report that an identifier was expected.
                    return new SyntaxDiagnostic(this.currentTokenStart(), token.width(), DiagnosticCode.Identifier_expected, null);
                }
            }

            // throw Errors.notYetImplemented();
        }

        private static getPrecedence(expressionKind: SyntaxKind): ExpressionPrecedence {
            switch (expressionKind) {
                case SyntaxKind.CommaExpression:
                    return ExpressionPrecedence.CommaExpressionPrecedence;

                case SyntaxKind.AssignmentExpression:
                case SyntaxKind.AddAssignmentExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                case SyntaxKind.DivideAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                case SyntaxKind.SignedRightShiftAssignmentExpression:
                case SyntaxKind.UnsignedRightShiftAssignmentExpression:
                    return ExpressionPrecedence.AssignmentExpressionPrecedence;

                case SyntaxKind.ConditionalExpression:
                    return ExpressionPrecedence.ConditionalExpressionPrecedence;

                case SyntaxKind.LogicalOrExpression:
                    return ExpressionPrecedence.LogicalOrExpressionPrecedence;

                case SyntaxKind.LogicalAndExpression:
                    return ExpressionPrecedence.LogicalAndExpressionPrecedence;

                case SyntaxKind.BitwiseOrExpression:
                    return ExpressionPrecedence.BitwiseOrExpressionPrecedence;

                case SyntaxKind.BitwiseExclusiveOrExpression:
                    return ExpressionPrecedence.BitwiseExclusiveOrExpressionPrecedence;

                case SyntaxKind.BitwiseAndExpression:
                    return ExpressionPrecedence.BitwiseAndExpressionPrecedence;

                case SyntaxKind.EqualsWithTypeConversionExpression:
                case SyntaxKind.NotEqualsWithTypeConversionExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.NotEqualsExpression:
                    return ExpressionPrecedence.EqualityExpressionPrecedence;

                case SyntaxKind.LessThanExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.InstanceOfExpression:
                case SyntaxKind.InExpression:
                    return ExpressionPrecedence.RelationalExpressionPrecedence;

                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.SignedRightShiftExpression:
                case SyntaxKind.UnsignedRightShiftExpression:
                    return ExpressionPrecedence.ShiftExpressionPrecdence;

                case SyntaxKind.AddExpression:
                case SyntaxKind.SubtractExpression:
                    return ExpressionPrecedence.AdditiveExpressionPrecedence;

                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.ModuloExpression:
                    return ExpressionPrecedence.MultiplicativeExpressionPrecedence;

                case SyntaxKind.PlusExpression:
                case SyntaxKind.NegateExpression:
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.DeleteExpression:
                case SyntaxKind.TypeOfExpression:
                case SyntaxKind.VoidExpression:
                case SyntaxKind.PreIncrementExpression:
                case SyntaxKind.PreDecrementExpression:
                    return ExpressionPrecedence.UnaryExpressionPrecedence;
            }

            throw Errors.invalidOperation();
        }

        private static isDirectivePrologueElement(node: SyntaxNode): bool {
            if (node.kind() === SyntaxKind.ExpressionStatement) {
                var expressionStatement = <ExpressionStatementSyntax>node;
                var expression = expressionStatement.expression;

                if (expression.kind() === SyntaxKind.StringLiteral) {
                    return true;
                }
            }

            return false
        }

        private static isUseStrictDirective(node: SyntaxNode) {
            var expressionStatement = <ExpressionStatementSyntax>node;
            var stringLiteral = <ISyntaxToken>expressionStatement.expression;

            var text = stringLiteral.text();
            return text === '"use strict"' || text === "'use strict'";
        }
        
        private addSkippedTokenAfterNodeOrToken(nodeOrToken: ISyntaxNodeOrToken, skippedToken: ISyntaxToken): ISyntaxNodeOrToken {
            if (nodeOrToken.isToken()) {
                return this.addSkippedTokenAfterToken(<ISyntaxToken>nodeOrToken, skippedToken);
            }
            else if (nodeOrToken.isNode()) {
                return this.addSkippedTokenAfterNode(<SyntaxNode>nodeOrToken, skippedToken);
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private addSkippedTokenAfterNode(node: SyntaxNode, skippedToken: ISyntaxToken): SyntaxNode {
            var oldToken = node.lastToken();
            var newToken = this.addSkippedTokenAfterToken(oldToken, skippedToken);

            return node.replaceToken(oldToken, newToken);
        }

        private addSkippedTokensBeforeNode(node: SyntaxNode, skippedTokens: ISyntaxToken[]): SyntaxNode {
            if (skippedTokens.length > 0) {
                var oldToken = node.firstToken();
                var newToken = this.addSkippedTokensBeforeToken(oldToken, skippedTokens);

                return node.replaceToken(oldToken, newToken);
            }

            return node;
        }

        private addSkippedTokensBeforeToken(token: ISyntaxToken, skippedTokens: ISyntaxToken[]): ISyntaxToken {
            Debug.assert(token.fullWidth() > 0 || token.tokenKind === SyntaxKind.EndOfFileToken);
            Debug.assert(skippedTokens.length > 0);

            var leadingTrivia: ISyntaxTrivia[] = [];
            for (var i = 0, n = skippedTokens.length; i < n; i++) {
                this.addSkippedTokenToTriviaArray(leadingTrivia, skippedTokens[i]);
            }

            this.addTriviaTo(token.leadingTrivia(), leadingTrivia);

            // Don't need this array anymore.  Give it back so we can reuse it.
            this.returnArray(skippedTokens);
            return token.withLeadingTrivia(Syntax.triviaList(leadingTrivia));
        }

        private addSkippedTokensAfterToken(token: ISyntaxToken, skippedTokens: ISyntaxToken[]): ISyntaxToken {
            Debug.assert(token.fullWidth() > 0);
            if (skippedTokens.length === 0) {
                this.returnArray(skippedTokens);
                return token;
            }

            var trailingTrivia = token.trailingTrivia().toArray();

            for (var i = 0, n = skippedTokens.length; i < n; i++) {
                this.addSkippedTokenToTriviaArray(trailingTrivia, skippedTokens[i]);
            }

            // Don't need this array anymore.  Give it back so we can reuse it.
            this.returnArray(skippedTokens);
            return token.withTrailingTrivia(Syntax.triviaList(trailingTrivia));
        }

        private addSkippedTokenAfterToken(token: ISyntaxToken, skippedToken: ISyntaxToken): ISyntaxToken {
            Debug.assert(token.fullWidth() > 0);

            var trailingTrivia = token.trailingTrivia().toArray();
            this.addSkippedTokenToTriviaArray(trailingTrivia, skippedToken);

            return token.withTrailingTrivia(Syntax.triviaList(trailingTrivia));
        }

        private addSkippedTokenToTriviaArray(array: ISyntaxTrivia[], skippedToken: ISyntaxToken): void {
            Debug.assert(skippedToken.text().length > 0);
            
            // first, add the leading trivia of the skipped token to the array
            this.addTriviaTo(skippedToken.leadingTrivia(), array);

            // now, add the text of the token as skipped text to the trivia array.
            array.push(Syntax.trivia(SyntaxKind.SkippedTextTrivia, skippedToken.text()));

            // Finally, add the trailing trivia of the skipped token to the trivia array.
            this.addTriviaTo(skippedToken.trailingTrivia(), array);
        }

        private addTriviaTo(list: ISyntaxTriviaList, array: ISyntaxTrivia[]): void {
            for (var i = 0, n = list.count(); i < n; i++) {
                array.push(list.syntaxTriviaAt(i));
            }
        }

        public parseSyntaxTree(): SyntaxTree {
            var sourceUnit = this.parseSourceUnit();

            var allDiagnostics = this.source.tokenDiagnostics().concat(this.diagnostics);
            allDiagnostics.sort((a: SyntaxDiagnostic, b: SyntaxDiagnostic) => a.position() - b.position());

            return new SyntaxTree(sourceUnit, allDiagnostics);
        }

        private setStrictMode(isInStrictMode: bool) {
            this.isInStrictMode = isInStrictMode;
            this.factory = isInStrictMode ? Syntax.strictModeFactory : Syntax.normalModeFactory;
        }

        private parseSourceUnit(): SourceUnitSyntax {
            // Note: technically we don't need to save and restore this here.  After all, this the top
            // level parsing entrypoint.  So it will always start as false and be reset to false when the
            // loop ends.  However, for sake of symmetry and consistancy we do this.
            var savedIsInStrictMode = this.isInStrictMode;

            var result = this.parseSyntaxList(ListParsingState.SourceUnit_ModuleElements, ParserImpl.updateStrictModeState);
            var moduleElements = result.list;

            this.setStrictMode(savedIsInStrictMode);

            var sourceUnit = this.factory.sourceUnit(moduleElements, this.currentToken());
            sourceUnit = <SourceUnitSyntax>this.addSkippedTokensBeforeNode(sourceUnit, result.skippedTokens);

            return sourceUnit;
        }

        private static updateStrictModeState(parser: ParserImpl, items: any[]): void {
            if (!parser.isInStrictMode) {
                // Check if all the items are directive prologue elements.
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    if (!ParserImpl.isDirectivePrologueElement(item)) {
                        return;
                    }
                }

                parser.setStrictMode(ParserImpl.isUseStrictDirective(items[items.length - 1]));
            }
        }

        private isModuleElement(): bool {
            if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                return true;
            }

            return this.isImportDeclaration() ||
                   this.isModuleDeclaration() ||
                   this.isInterfaceDeclaration() ||
                   this.isClassDeclaration() ||
                   this.isEnumDeclaration() ||
                   this.isStatement();
        }
        
        private parseModuleElement(): IModuleElementSyntax {
            if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                return <IModuleElementSyntax>this.eatNode();
            }

            if (this.isImportDeclaration()) {
                return this.parseImportDeclaration();
            }
            else if (this.isModuleDeclaration()) {
                return this.parseModuleDeclaration();
            }
            else if (this.isInterfaceDeclaration()) {
                return this.parseInterfaceDeclaration();
            }
            else if (this.isClassDeclaration()) {
                return this.parseClassDeclaration();
            }
            else if (this.isEnumDeclaration()) {
                return this.parseEnumDeclaration();
            }
            else if (this.isStatement()) {
                return this.parseStatement();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private isImportDeclaration(): bool {
            // REVIEW: because 'import' is not a javascript keyword, we need to make sure that this is 
            // an actual import declaration.  As such, i check for "import id =" as that shouldn't 
            // match any other legal javascript construct.  However, we need to verify that this is
            // actually the case.
            return this.currentToken().tokenKind === SyntaxKind.ImportKeyword &&
                   ParserImpl.isIdentifierName(this.peekToken(1)) && 
                   this.peekToken(2).tokenKind === SyntaxKind.EqualsToken;
        }

        private parseImportDeclaration(): ImportDeclarationSyntax {
            Debug.assert(this.isImportDeclaration());

            var importKeyword = this.eatKeyword(SyntaxKind.ImportKeyword);
            var identifier = this.eatIdentifierToken();
            var equalsToken = this.eatToken(SyntaxKind.EqualsToken);
            var moduleReference = this.parseModuleReference();
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.importDeclaration(importKeyword, identifier, equalsToken, moduleReference, semicolonToken);
        }

        private parseModuleReference(): ModuleReferenceSyntax {
            if (this.isExternalModuleReference()) {
                return this.parseExternalModuleReference();
            }
            else {
                return this.parseModuleNameModuleReference();
            }
        }

        private isExternalModuleReference(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ModuleKeyword &&
                   this.peekToken(1).tokenKind === SyntaxKind.OpenParenToken;
        }

        private parseExternalModuleReference(): ExternalModuleReferenceSyntax {
            Debug.assert(this.isExternalModuleReference());

            var moduleKeyword = this.eatKeyword(SyntaxKind.ModuleKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var stringLiteral = this.eatToken(SyntaxKind.StringLiteral);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            return this.factory.externalModuleReference(moduleKeyword, openParenToken, stringLiteral, closeParenToken);
        }

        private parseModuleNameModuleReference(): ModuleNameModuleReferenceSyntax {
            var name = this.parseName();
            return this.factory.moduleNameModuleReference(name);
        }

        // NOTE: This will allow all identifier names.  Even the ones that are keywords.
        private parseIdentifierName(): INameSyntax {
            var identifierName = this.eatIdentifierNameToken();
            return identifierName;
        }

        private isName(): bool {
            return this.isIdentifier(this.currentToken());
        }

        private tryParseTypeArgumentList(inExpression: bool): TypeArgumentListSyntax {
            if (this.currentToken().kind() !== SyntaxKind.LessThanToken) {
                return null;
            }

            if (!inExpression) {
                // if we're not in an expression, this must be a type argument list.  Just parse
                // it out as such.
                var lessThanToken = this.eatToken(SyntaxKind.LessThanToken);
                Debug.assert(lessThanToken.fullWidth() > 0);

                var result = this.parseSeparatedSyntaxList(ListParsingState.TypeArgumentList_Types);
                var typeArguments = result.list;
                lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                var greaterThanToken = this.eatToken(SyntaxKind.GreaterThanToken);

                return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
            }

            // If we're in an expression, then we only want to consume this as a type argument list
            // if we're sure that it's a type arg list and not an arithmetic expression.

            var rewindPoint = this.getRewindPoint();
            try {
                // We've seen a '<'.  Try to parse it out as a type argument list.
                var lessThanToken = this.eatToken(SyntaxKind.LessThanToken);
                Debug.assert(lessThanToken.fullWidth() > 0);

                var result = this.parseSeparatedSyntaxList(ListParsingState.TypeArgumentList_Types);
                var typeArguments = result.list;
                lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                var greaterThanToken = this.eatToken(SyntaxKind.GreaterThanToken);

                // We're in a context where '<' could be the start of a type argument list, or part
                // of an arithmetic expression.  We'll presume it's the latter unless we see the '>'
                // and a following token that guarantees that it's supposed to be a type argument list.
                if (greaterThanToken.fullWidth() === 0 || !this.canFollowTypeArgumentListInExpression(this.currentToken().kind())) {
                    this.rewind(rewindPoint);
                    return null;
                }

                return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
            }
            finally {
                this.releaseRewindPoint(rewindPoint);
            }
        }

        private canFollowTypeArgumentListInExpression(kind: SyntaxKind): bool {
            switch (kind) {
                case SyntaxKind.OpenParenToken:                 // foo<x>(   
                case SyntaxKind.DotToken:                       // foo<x>.
                    // These two cases are the only cases where this token can legally follow a
                    // type argument list.  So we definitely want to treat this as a type arg list.

                case SyntaxKind.CloseParenToken:                // foo<x>)
                case SyntaxKind.CloseBracketToken:              // foo<x>]
                case SyntaxKind.ColonToken:                     // foo<x>:
                case SyntaxKind.SemicolonToken:                 // foo<x>;
                case SyntaxKind.CommaToken:                     // foo<x>,
                case SyntaxKind.QuestionToken:                  // foo<x>?
                case SyntaxKind.EqualsEqualsToken:              // foo<x> ==
                case SyntaxKind.EqualsEqualsEqualsToken:        // foo<x> ===
                case SyntaxKind.ExclamationEqualsToken:         // foo<x> !=
                case SyntaxKind.ExclamationEqualsEqualsToken:   // foo<x> !==
                case SyntaxKind.AmpersandAmpersandToken:        // foo<x> &&
                case SyntaxKind.BarBarToken:                    // foo<x> ||
                case SyntaxKind.CaretToken:                     // foo<x> ^
                case SyntaxKind.AmpersandToken:                 // foo<x> &
                case SyntaxKind.BarToken:                       // foo<x> |
                case SyntaxKind.CloseBraceToken:                // foo<x> }
                case SyntaxKind.EndOfFileToken:                 // foo<x>
                    // these cases can't legally follow a type arg list.  However, they're not legal 
                    // expressions either.  The user is probably in the middle of a generic type. So
                    // treat it as such.
                    return true;

                default:
                    // Anything else treat as an expression.
                    return false;
            }
        }

        private parseName(): INameSyntax {
            var shouldContinue = this.isIdentifier(this.currentToken());
            var current: INameSyntax = this.eatIdentifierToken();

            while (shouldContinue && this.currentToken().tokenKind === SyntaxKind.DotToken) {
                var dotToken = this.eatToken(SyntaxKind.DotToken);

                shouldContinue = ParserImpl.isIdentifierName(this.currentToken());
                var identifier = this.eatIdentifierNameToken();

                current = this.factory.qualifiedName(current, dotToken, identifier);
            }

            return current;
        }

        private isEnumDeclaration(): bool {
            if (this.currentToken().tokenKind === SyntaxKind.ExportKeyword &&
                this.peekToken(1).tokenKind === SyntaxKind.EnumKeyword) {
                return true;
            }

            return this.currentToken().tokenKind === SyntaxKind.EnumKeyword;
        }

        private parseEnumDeclaration(): EnumDeclarationSyntax {
            Debug.assert(this.isEnumDeclaration());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var enumKeyword = this.eatKeyword(SyntaxKind.EnumKeyword);
            var identifier = this.eatIdentifierToken();

            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);
            var variableDeclarators: ISeparatedSyntaxList = Syntax.emptySeparatedList;

            if (openBraceToken.width() > 0) {
                var result = this.parseSeparatedSyntaxList(ListParsingState.EnumDeclaration_VariableDeclarators);
                variableDeclarators = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);

            return this.factory.enumDeclaration(exportKeyword, enumKeyword, identifier,
                openBraceToken, variableDeclarators, closeBraceToken);
        }

        private isClassDeclaration(): bool {
            var token0 = this.currentToken();

            if (token0.tokenKind === SyntaxKind.ExportKeyword &&
                this.peekToken(1).tokenKind === SyntaxKind.ClassKeyword) {
                return true;
            }

            if (token0.tokenKind === SyntaxKind.DeclareKeyword &&
                this.peekToken(1).tokenKind === SyntaxKind.ClassKeyword) {
                return true;
            }

            return token0.tokenKind === SyntaxKind.ClassKeyword;
        }

        private parseClassDeclaration(): ClassDeclarationSyntax {
            Debug.assert(this.isClassDeclaration());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var declareKeyword = this.tryEatKeyword(SyntaxKind.DeclareKeyword);

            var classKeyword = this.eatKeyword(SyntaxKind.ClassKeyword);
            var identifier = this.eatIdentifierToken();
            var typeParameterList = this.parseOptionalTypeParameterList(/*requireCompleteTypeParameterList:*/ false);

            var extendsClause: ExtendsClauseSyntax = null;
            if (this.isExtendsClause()) {
                extendsClause = this.parseExtendsClause();
            }

            var implementsClause: ImplementsClauseSyntax = null;
            if (this.isImplementsClause()) {
                implementsClause = this.parseImplementsClause();
            }

            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);
            var classElements: ISyntaxList = Syntax.emptyList;

            if (openBraceToken.width() > 0) {
                var result = this.parseSyntaxList(ListParsingState.ClassDeclaration_ClassElements);

                classElements = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);
            return this.factory.classDeclaration(
                exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause,
                implementsClause, openBraceToken, classElements, closeBraceToken);
        }

        private isConstructorDeclaration(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ConstructorKeyword;
        }

        private isMemberAccessorDeclaration(): bool {
            var index = 0;

            if (this.currentToken().tokenKind === SyntaxKind.PublicKeyword ||
                this.currentToken().tokenKind === SyntaxKind.PrivateKeyword) {
                index++;
            }

            if (this.peekToken(index).tokenKind === SyntaxKind.StaticKeyword) {
                index++;
            }

            if (this.peekToken(index).tokenKind !== SyntaxKind.GetKeyword &&
                this.peekToken(index).tokenKind !== SyntaxKind.SetKeyword) {
                return false;
            }

            index++;
            return this.isIdentifier(this.peekToken(index));
        }

        private parseMemberAccessorDeclaration(): MemberAccessorDeclarationSyntax {
            Debug.assert(this.isMemberAccessorDeclaration());

            var publicOrPrivateKeyword: ISyntaxToken = null;
            if (this.currentToken().tokenKind === SyntaxKind.PublicKeyword ||
                this.currentToken().tokenKind === SyntaxKind.PrivateKeyword) {
                publicOrPrivateKeyword = this.eatAnyToken();
            }

            var staticKeyword = this.tryEatKeyword(SyntaxKind.StaticKeyword);

            if (this.currentToken().tokenKind === SyntaxKind.GetKeyword) {
                return this.parseGetMemberAccessorDeclaration(publicOrPrivateKeyword, staticKeyword);
            }
            else if (this.currentToken().tokenKind === SyntaxKind.SetKeyword) {
                return this.parseSetMemberAccessorDeclaration(publicOrPrivateKeyword, staticKeyword);
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private parseGetMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken,
                                                  staticKeyword: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.GetKeyword);

            var getKeyword = this.eatKeyword(SyntaxKind.GetKeyword);
            var identifier = this.eatIdentifierToken();
            var parameterList = this.parseParameterList();
            var typeAnnotation = this.parseOptionalTypeAnnotation();
            var block = this.parseBlock();

            return this.factory.getMemberAccessorDeclaration(
                publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block);
        }

        private parseSetMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken,
                                                  staticKeyword: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.SetKeyword);

            var setKeyword = this.eatKeyword(SyntaxKind.SetKeyword);
            var identifier = this.eatIdentifierToken();
            var parameterList = this.parseParameterList();
            var block = this.parseBlock();

            return this.factory.setMemberAccessorDeclaration(
                publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block);
        }

        private isMemberVariableDeclaration(): bool {
            var index = 0;

            if (this.currentToken().tokenKind === SyntaxKind.PublicKeyword ||
                this.currentToken().tokenKind === SyntaxKind.PrivateKeyword) {
                index++;

                // ERROR RECOVERY: 
                // If we're following by an close curly or EOF, then consider this the start of a
                // variable declaration.
                if (this.peekToken(index).tokenKind === SyntaxKind.CloseBraceToken ||
                    this.peekToken(index).tokenKind === SyntaxKind.EndOfFileToken) {
                    return true;
                }
            }

            if (this.peekToken(index).tokenKind === SyntaxKind.StaticKeyword) {
                index++;

                // ERROR RECOVERY: 
                // If we're following by an close curly or EOF, then consider this the start of a
                // variable declaration.
                if (this.peekToken(index).tokenKind === SyntaxKind.CloseBraceToken ||
                    this.peekToken(index).tokenKind === SyntaxKind.EndOfFileToken) {
                    return true;
                }
            }

            return this.isIdentifier(this.peekToken(index));
        }

        private isClassElement(): bool {
            if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                return true;
            }

            // Note: the order of these calls is important.  Specifically, isMemberVariableDeclaration
            // checks for a subset of the conditions of the previous two calls.
            return this.isConstructorDeclaration() ||
                   this.isMemberFunctionDeclaration() ||
                   this.isMemberAccessorDeclaration() ||
                   this.isMemberVariableDeclaration();
        }

        private parseConstructorDeclaration(): ConstructorDeclarationSyntax {
            Debug.assert(this.isConstructorDeclaration());

            var constructorKeyword = this.eatKeyword(SyntaxKind.ConstructorKeyword);
            var parameterList = this.parseParameterList();

            var semicolonToken: ISyntaxToken = null;
            var block: BlockSyntax = null;

            if (this.isBlock()) {
                block = this.parseBlock();
            }
            else {
                semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            }

            return this.factory.constructorDeclaration(constructorKeyword, parameterList, block, semicolonToken);
        }

        private isMemberFunctionDeclaration(): bool {
            var index = 0;

            var token0KeywordKind = this.currentToken().tokenKind;
            if (token0KeywordKind === SyntaxKind.PublicKeyword ||
                token0KeywordKind === SyntaxKind.PrivateKeyword) {
                index++;
            }

            if (this.peekToken(index).tokenKind === SyntaxKind.StaticKeyword) {
                index++;
            }

            return this.isFunctionSignature(index);
        }

        private parseMemberFunctionDeclaration(): MemberFunctionDeclarationSyntax {
            Debug.assert(this.isMemberFunctionDeclaration());

            var publicOrPrivateKeyword: ISyntaxToken = null;
            if (this.currentToken().tokenKind === SyntaxKind.PublicKeyword ||
                this.currentToken().tokenKind === SyntaxKind.PrivateKeyword) {
                publicOrPrivateKeyword = this.eatAnyToken();
            }

            var staticKeyword = this.tryEatKeyword(SyntaxKind.StaticKeyword);
            var functionSignature = this.parseFunctionSignature();

            var block: BlockSyntax = null;
            var semicolon: ISyntaxToken = null;

            if (this.isBlock()) {
                block = this.parseBlock();
            }
            else {
                semicolon = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            }

            return this.factory.memberFunctionDeclaration(publicOrPrivateKeyword, staticKeyword, functionSignature, block, semicolon);
        }

        private parseMemberVariableDeclaration(): MemberVariableDeclarationSyntax {
            Debug.assert(this.isMemberVariableDeclaration());

            var publicOrPrivateKeyword: ISyntaxToken = null;
            if (this.currentToken().tokenKind === SyntaxKind.PublicKeyword ||
                this.currentToken().tokenKind === SyntaxKind.PrivateKeyword) {
                publicOrPrivateKeyword = this.eatAnyToken();
            }

            var staticKeyword = this.tryEatKeyword(SyntaxKind.StaticKeyword);
            var variableDeclarator = this.parseVariableDeclarator(/*allowIn:*/ true);
            var semicolon = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.memberVariableDeclaration(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolon);
        }

        private parseClassElement(): IClassElementSyntax {
            Debug.assert(this.isClassElement());

            if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                return <IClassElementSyntax>this.eatNode();
            }

            if (this.isConstructorDeclaration()) {
                return this.parseConstructorDeclaration();
            }
            else if (this.isMemberFunctionDeclaration()) {
                return this.parseMemberFunctionDeclaration();
            }
            else if (this.isMemberAccessorDeclaration()) {
                return this.parseMemberAccessorDeclaration();
            }
            else if (this.isMemberVariableDeclaration()) {
                return this.parseMemberVariableDeclaration();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private isFunctionDeclaration(): bool {
            var token0KeywordKind = this.currentToken().tokenKind;
            if (token0KeywordKind === SyntaxKind.FunctionKeyword) {
                return true;
            }

            if (token0KeywordKind === SyntaxKind.ExportKeyword &&
                this.peekToken(1).tokenKind === SyntaxKind.FunctionKeyword) {
                return true;
            }

            return token0KeywordKind === SyntaxKind.DeclareKeyword &&
                   this.peekToken(1).tokenKind === SyntaxKind.FunctionKeyword;
        }

        private parseFunctionDeclaration(): FunctionDeclarationSyntax {
            Debug.assert(this.isFunctionDeclaration());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var declareKeyword = this.tryEatKeyword(SyntaxKind.DeclareKeyword);

            var functionKeyword = this.eatKeyword(SyntaxKind.FunctionKeyword);
            var functionSignature = this.parseFunctionSignature();

            var semicolonToken: ISyntaxToken = null;
            var block: BlockSyntax = null;

            if (this.isBlock()) {
                block = this.parseBlock();
            }
            else {
                semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            }

            return this.factory.functionDeclaration(exportKeyword, declareKeyword, functionKeyword, functionSignature, block, semicolonToken);
        }

        private isModuleDeclaration(): bool {
            var token0 = this.currentToken();

            // export module
            if (token0.tokenKind === SyntaxKind.ExportKeyword &&
                this.peekToken(1).tokenKind === SyntaxKind.ModuleKeyword) {
                return true;
            }

            // declare module
            if (token0.tokenKind === SyntaxKind.DeclareKeyword &&
                this.peekToken(1).tokenKind === SyntaxKind.ModuleKeyword) {
                return true;
            }

            // Module is not a javascript keyword.  So we need to use a bit of lookahead here to ensure
            // that we're actually looking at a module construct and not some javascript expression.
            if (token0.tokenKind === SyntaxKind.ModuleKeyword) {
                // module {
                var token1 = this.peekToken(1);
                if (token1.tokenKind === SyntaxKind.OpenBraceToken) {
                    return true;
                }

                if (ParserImpl.isIdentifierName(token1)) {
                    var token2 = this.peekToken(2);

                    // module id {
                    if (token2.tokenKind === SyntaxKind.OpenBraceToken) {
                        return true;
                    }

                    // module id.
                    if (token2.tokenKind === SyntaxKind.DotToken) {
                        return true;
                    }
                }
            }

            return false;
        }

        private parseModuleDeclaration(): ModuleDeclarationSyntax {
            Debug.assert(this.isModuleDeclaration());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var declareKeyword = this.tryEatKeyword(SyntaxKind.DeclareKeyword);
            var moduleKeyword = this.eatKeyword(SyntaxKind.ModuleKeyword);

            var moduleName: INameSyntax = null;
            var stringLiteral: ISyntaxToken = null;

            if (this.currentToken().tokenKind === SyntaxKind.StringLiteral) {
                stringLiteral = this.eatToken(SyntaxKind.StringLiteral);
            }
            else {
                moduleName = this.parseName();
            }

            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);

            var moduleElements: ISyntaxList = Syntax.emptyList;
            if (openBraceToken.width() > 0) {
                var result = this.parseSyntaxList(ListParsingState.ModuleDeclaration_ModuleElements);
                moduleElements = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);

            return this.factory.moduleDeclaration(
                exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral,
                openBraceToken, moduleElements, closeBraceToken);
        }

        private isInterfaceDeclaration(): bool {
            // export interface
            if (this.currentToken().tokenKind === SyntaxKind.ExportKeyword &&
                this.peekToken(1).tokenKind === SyntaxKind.InterfaceKeyword) {
                return true
            }

            // interface foo
            return this.currentToken().tokenKind === SyntaxKind.InterfaceKeyword &&
                   this.isIdentifier(this.peekToken(1));
        }

        private parseInterfaceDeclaration(): InterfaceDeclarationSyntax {
            Debug.assert(this.isInterfaceDeclaration());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var interfaceKeyword = this.eatKeyword(SyntaxKind.InterfaceKeyword);
            var identifier = this.eatIdentifierToken();
            var typeParameterList = this.parseOptionalTypeParameterList(/*requireCompleteTypeParameterList:*/ false);

            var extendsClause: ExtendsClauseSyntax = null;
            if (this.isExtendsClause()) {
                extendsClause = this.parseExtendsClause();
            }

            var objectType = this.parseObjectType();
            return this.factory.interfaceDeclaration(
                exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, objectType);
        }

        private parseObjectType(): ObjectTypeSyntax {
            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);

            var typeMembers: ISeparatedSyntaxList = Syntax.emptySeparatedList;
            if (openBraceToken.width() > 0) {
                var result = this.parseSeparatedSyntaxList(ListParsingState.ObjectType_TypeMembers);
                typeMembers = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);
            return this.factory.objectType(openBraceToken, typeMembers, closeBraceToken);
        }

        private isTypeMember(): bool {
            if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                return true;
            }

            return this.isCallSignature(/*tokenIndex:*/ 0) ||
                   this.isConstructSignature() ||
                   this.isIndexSignature() ||
                   this.isFunctionSignature(/*tokenIndex:*/ 0) ||
                   this.isPropertySignature();
        }

        private parseTypeMember(): TypeMemberSyntax {
            if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                return <TypeMemberSyntax>this.eatNode();
            }

            if (this.isCallSignature(/*tokenIndex:*/ 0)) {
                return this.parseCallSignature(/*requireCompleteTypeParameterList:*/ false);
            }
            else if (this.isConstructSignature()) {
                return this.parseConstructSignature();
            }
            else if (this.isIndexSignature()) {
                return this.parseIndexSignature();
            }
            else if (this.isFunctionSignature(/*tokenIndex:*/ 0)) {
                // Note: it is important that isFunctionSignature is called before isPropertySignature.
                // isPropertySignature checks for a subset of isFunctionSignature.
                return this.parseFunctionSignature();
            }
            else if (this.isPropertySignature()) {
                return this.parsePropertySignature();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private parseConstructSignature(): ConstructSignatureSyntax {
            Debug.assert(this.isConstructSignature());

            var newKeyword = this.eatKeyword(SyntaxKind.NewKeyword);
            var callSignature = this.parseCallSignature(/*requireCompleteTypeParameterList:*/ false);

            return this.factory.constructSignature(newKeyword, callSignature);
        }

        private parseIndexSignature(): IndexSignatureSyntax {
            Debug.assert(this.isIndexSignature());

            var openBracketToken = this.eatToken(SyntaxKind.OpenBracketToken);
            var parameter = this.parseParameter();
            var closeBracketToken = this.eatToken(SyntaxKind.CloseBracketToken);
            var typeAnnotation = this.parseOptionalTypeAnnotation();

            return this.factory.indexSignature(openBracketToken, parameter, closeBracketToken, typeAnnotation);
        }

        private parseFunctionSignature(): FunctionSignatureSyntax {
            var identifier = this.eatIdentifierToken();
            var questionToken = this.tryEatToken(SyntaxKind.QuestionToken);
            var callSignature = this.parseCallSignature(/*requireCompleteTypeParameterList:*/ false);

            return this.factory.functionSignature(identifier, questionToken, callSignature);
        }

        private parsePropertySignature(): PropertySignatureSyntax {
            Debug.assert(this.isPropertySignature());

            var identifier = this.eatIdentifierToken();
            var questionToken = this.tryEatToken(SyntaxKind.QuestionToken);
            var typeAnnotation = this.parseOptionalTypeAnnotation();

            return this.factory.propertySignature(identifier, questionToken, typeAnnotation);
        }

        private isCallSignature(tokenIndex: number): bool {
            var tokenKind = this.peekToken(tokenIndex).tokenKind;
            return tokenKind === SyntaxKind.OpenParenToken || tokenKind == SyntaxKind.LessThanToken;
        }

        private isConstructSignature(): bool {
            return this.currentToken().tokenKind === SyntaxKind.NewKeyword;
        }

        private isIndexSignature(): bool {
            return this.currentToken().tokenKind === SyntaxKind.OpenBracketToken;
        }

        private isFunctionSignature(tokenIndex: number): bool {
            if (this.isIdentifier(this.peekToken(tokenIndex))) {
                // id(
                if (this.isCallSignature(tokenIndex + 1)) {
                    return true;
                }

                // id?(
                if (this.peekToken(tokenIndex + 1).tokenKind === SyntaxKind.QuestionToken &&
                    this.isCallSignature(tokenIndex + 2)) {
                    return true;
                }
            }

            return false;
        }

        private isPropertySignature(): bool {
            // Note: identifiers also start function signatures.  So it's important that we call this
            // after we calll isFunctionSignature.
            return this.isIdentifier(this.currentToken());
        }

        private isExtendsClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ExtendsKeyword;
        }

        private parseExtendsClause(): ExtendsClauseSyntax {
            Debug.assert(this.isExtendsClause());

            var extendsKeyword = this.eatKeyword(SyntaxKind.ExtendsKeyword);
            Debug.assert(extendsKeyword.fullWidth() > 0);

            var result = this.parseSeparatedSyntaxList(ListParsingState.ExtendsOrImplementsClause_TypeNameList);
            var typeNames = result.list;
            extendsKeyword = this.addSkippedTokensAfterToken(extendsKeyword, result.skippedTokens);

            return this.factory.extendsClause(extendsKeyword, typeNames);
        }

        private isImplementsClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ImplementsKeyword;
        }

        private parseImplementsClause(): ImplementsClauseSyntax {
            Debug.assert(this.isImplementsClause());

            var implementsKeyword = this.eatKeyword(SyntaxKind.ImplementsKeyword);
            Debug.assert(implementsKeyword.fullWidth() > 0);

            var result = this.parseSeparatedSyntaxList(ListParsingState.ExtendsOrImplementsClause_TypeNameList);
            var typeNames = result.list;
            implementsKeyword = this.addSkippedTokensAfterToken(implementsKeyword, result.skippedTokens);

            return this.factory.implementsClause(implementsKeyword, typeNames);
        }

        private isStatement(): bool {
            if (this.currentNode() !== null && this.currentNode().isStatement()) {
                return true;
            }

            // ERROR RECOVERY
            switch (this.currentToken().tokenKind) {
                case SyntaxKind.PublicKeyword:
                case SyntaxKind.PrivateKeyword:
                case SyntaxKind.StaticKeyword:
                    // None of hte above are actually keywords.  And they might show up in a real
                    // statement (i.e. "public();").  However, if we can determine that they're
                    // parsable as a ClassElement then don't consider them a statement.  Note:
                    //
                    // It should not be possible for any class element that starts with public, private
                    // or static to be parsed as a statement.  So this is safe to do.
                    if (this.isClassElement()) {
                        return false;
                    }
            }

            return this.isVariableStatement() ||
                   this.isLabeledStatement() ||
                   this.isFunctionDeclaration() ||
                   this.isIfStatement() ||
                   this.isBlock() ||
                   this.isExpressionStatement() ||
                   this.isReturnStatement() ||
                   this.isSwitchStatement() ||
                   this.isThrowStatement() ||
                   this.isBreakStatement() ||
                   this.isContinueStatement() ||
                   this.isForOrForInStatement() ||
                   this.isEmptyStatement() ||
                   this.isWhileStatement() ||
                   this.isWithStatement() ||
                   this.isDoStatement() ||
                   this.isTryStatement() ||
                   this.isDebuggerStatement();
        }

        private parseStatement(): IStatementSyntax {
            if (this.currentNode() !== null && this.currentNode().isStatement()) {
                return <IStatementSyntax>this.eatNode();
            }

            if (this.isVariableStatement()) {
                return this.parseVariableStatement();
            }
            else if (this.isLabeledStatement()) {
                return this.parseLabeledStatement();
            }
            else if (this.isFunctionDeclaration()) {
                return this.parseFunctionDeclaration();
            }
            else if (this.isIfStatement()) {
                return this.parseIfStatement();
            }
            else if (this.isBlock()) {
                return this.parseBlock();
            }
            else if (this.isReturnStatement()) {
                return this.parseReturnStatement();
            }
            else if (this.isSwitchStatement()) {
                return this.parseSwitchStatement();
            }
            else if (this.isThrowStatement()) {
                return this.parseThrowStatement();
            }
            else if (this.isBreakStatement()) {
                return this.parseBreakStatement();
            }
            else if (this.isContinueStatement()) {
                return this.parseContinueStatement();
            }
            else if (this.isForOrForInStatement()) {
                return this.parseForOrForInStatement();
            }
            else if (this.isEmptyStatement()) {
                return this.parseEmptyStatement();
            }
            else if (this.isWhileStatement()) {
                return this.parseWhileStatement();
            }
            else if (this.isWithStatement()) {
                return this.parseWithStatement();
            }
            else if (this.isDoStatement()) {
                return this.parseDoStatement();
            }
            else if (this.isTryStatement()) {
                return this.parseTryStatement();
            }
            else if (this.isDebuggerStatement()) {
                return this.parseDebuggerStatement();
            }
            else {
                // Fall back to parsing this as expression statement.
                return this.parseExpressionStatement();
            }
        }

        private isDebuggerStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.DebuggerKeyword;
        }

        private parseDebuggerStatement(): DebuggerStatementSyntax {
            Debug.assert(this.isDebuggerStatement());

            var debuggerKeyword = this.eatKeyword(SyntaxKind.DebuggerKeyword);
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.debuggerStatement(debuggerKeyword, semicolonToken);
        }

        private isDoStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.DoKeyword;
        }

        private parseDoStatement(): DoStatementSyntax {
            Debug.assert(this.isDoStatement());

            var doKeyword = this.eatKeyword(SyntaxKind.DoKeyword);
            var statement = this.parseStatement();
            var whileKeyword = this.eatKeyword(SyntaxKind.WhileKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var condition = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html
            // 157 min --- All allen at wirfs-brock.com CONF --- "do{;}while(false)false" prohibited in 
            // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby
            //  do;while(0)x will have a semicolon inserted before x.
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ true);

            return this.factory.doStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
        }

        private isLabeledStatement(): bool {
            return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === SyntaxKind.ColonToken;
        }

        private parseLabeledStatement(): LabeledStatementSyntax {
            Debug.assert(this.isLabeledStatement());

            var identifier = this.eatIdentifierToken();
            var colonToken = this.eatToken(SyntaxKind.ColonToken);
            var statement = this.parseStatement();

            return this.factory.labeledStatement(identifier, colonToken, statement);
        }

        private isTryStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.TryKeyword;
        }

        private parseTryStatement(): TryStatementSyntax {
            Debug.assert(this.isTryStatement());

            var tryKeyword = this.eatKeyword(SyntaxKind.TryKeyword);

            var savedListParsingState = this.listParsingState;
            this.listParsingState |= ListParsingState.TryBlock_Statements;
            var block = this.parseBlock();
            this.listParsingState = savedListParsingState;

            var catchClause: CatchClauseSyntax = null;
            if (this.isCatchClause()) {
                catchClause = this.parseCatchClause();
            }

            // If we don't have a catch clause, then we must have a finally clause.  Try to parse
            // one out no matter what.
            var finallyClause: FinallyClauseSyntax = null;
            if (catchClause === null || this.isFinallyClause()) {
                finallyClause = this.parseFinallyClause();
            }

            return this.factory.tryStatement(tryKeyword, block, catchClause, finallyClause);
        }

        private isCatchClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CatchKeyword;
        }

        private parseCatchClause(): CatchClauseSyntax {
            Debug.assert(this.isCatchClause());

            var catchKeyword = this.eatKeyword(SyntaxKind.CatchKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var identifier = this.eatIdentifierToken();
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            var savedListParsingState = this.listParsingState;
            this.listParsingState |= ListParsingState.CatchBlock_Statements;
            var block = this.parseBlock();
            this.listParsingState = savedListParsingState;

            return this.factory.catchClause(catchKeyword, openParenToken, identifier, closeParenToken, block);
        }

        private isFinallyClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.FinallyKeyword;
        }

        private parseFinallyClause(): FinallyClauseSyntax {
            var finallyKeyword = this.eatKeyword(SyntaxKind.FinallyKeyword);
            var block = this.parseBlock();

            return this.factory.finallyClause(finallyKeyword, block);
        }

        private isWithStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.WithKeyword;
        }

        private parseWithStatement(): WithStatementSyntax {
            Debug.assert(this.isWithStatement());

            var withKeyword = this.eatKeyword(SyntaxKind.WithKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var condition = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var statement = this.parseStatement();

            return this.factory.withStatement(withKeyword, openParenToken, condition, closeParenToken, statement);
        }

        private isWhileStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.WhileKeyword;
        }

        private parseWhileStatement(): WhileStatementSyntax {
            Debug.assert(this.isWhileStatement());

            var whileKeyword = this.eatKeyword(SyntaxKind.WhileKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var condition = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var statement = this.parseStatement();

            return this.factory.whileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
        }

        private isEmptyStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.SemicolonToken;
        }

        private parseEmptyStatement(): EmptyStatementSyntax {
            Debug.assert(this.isEmptyStatement());

            var semicolonToken = this.eatToken(SyntaxKind.SemicolonToken);
            return this.factory.emptyStatement(semicolonToken);
        }

        private isForOrForInStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ForKeyword;
        }

        private parseForOrForInStatement(): BaseForStatementSyntax {
            Debug.assert(this.isForOrForInStatement());

            var forKeyword = this.eatKeyword(SyntaxKind.ForKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);

            var currentToken = this.currentToken();
            if (currentToken.tokenKind === SyntaxKind.VarKeyword) {
                // for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
                // for ( var VariableDeclarationNoIn in Expression ) Statement
                return this.parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken);
            }
            else if (currentToken.tokenKind === SyntaxKind.SemicolonToken) {
                // for ( ; Expressionopt ; Expressionopt ) Statement
                return this.parseForStatement(forKeyword, openParenToken);
            }
            else {
                // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
                // for ( LeftHandSideExpression in Expression ) Statement
                return this.parseForOrForInStatementWithInitializer(forKeyword, openParenToken);
            }
        }

        private parseForOrForInStatementWithVariableDeclaration(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken): BaseForStatementSyntax {
            Debug.assert(forKeyword.tokenKind === SyntaxKind.ForKeyword && openParenToken.tokenKind === SyntaxKind.OpenParenToken);
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.VarKeyword);

            // for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
            // for ( var VariableDeclarationNoIn in Expression ) Statement

            var variableDeclaration = this.parseVariableDeclaration(/*allowIn:*/ false);

            if (this.currentToken().tokenKind === SyntaxKind.InKeyword) {
                return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
            }

            return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
        }

        private parseForInStatementWithVariableDeclarationOrInitializer(
                forKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                variableDeclaration: VariableDeclarationSyntax,
                initializer: IExpressionSyntax): ForInStatementSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.InKeyword);

            // for ( var VariableDeclarationNoIn in Expression ) Statement
            var inKeyword = this.eatKeyword(SyntaxKind.InKeyword);
            var expression = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var statement = this.parseStatement();

            return this.factory.forInStatement(forKeyword, openParenToken, variableDeclaration,
                initializer, inKeyword, expression, closeParenToken, statement);
        }

        private parseForOrForInStatementWithInitializer(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken): BaseForStatementSyntax {
            Debug.assert(forKeyword.tokenKind === SyntaxKind.ForKeyword && openParenToken.tokenKind === SyntaxKind.OpenParenToken);

            // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
            // for ( LeftHandSideExpression in Expression ) Statement

            var initializer = this.parseExpression(/*allowIn:*/ false);
            if (this.currentToken().tokenKind === SyntaxKind.InKeyword) {
                return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            }
            else {
                return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            }
        }

        private parseForStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken): ForStatementSyntax {
            Debug.assert(forKeyword.tokenKind === SyntaxKind.ForKeyword && openParenToken.tokenKind === SyntaxKind.OpenParenToken);

            // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
            var initializer: IExpressionSyntax = null;

            if (this.currentToken().tokenKind !== SyntaxKind.SemicolonToken &&
                this.currentToken().tokenKind !== SyntaxKind.CloseParenToken &&
                this.currentToken().tokenKind !== SyntaxKind.EndOfFileToken) {
                initializer = this.parseExpression(/*allowIn:*/ false);
            }

            return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
        }

        private parseForStatementWithVariableDeclarationOrInitializer(
                forKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                variableDeclaration: VariableDeclarationSyntax,
                initializer: IExpressionSyntax): ForStatementSyntax {
            var firstSemicolonToken = this.eatToken(SyntaxKind.SemicolonToken);

            var condition: IExpressionSyntax = null;
            if (this.currentToken().tokenKind !== SyntaxKind.SemicolonToken &&
                this.currentToken().tokenKind !== SyntaxKind.CloseParenToken &&
                this.currentToken().tokenKind !== SyntaxKind.EndOfFileToken) {
                condition = this.parseExpression(/*allowIn:*/ true);
            }

            var secondSemicolonToken = this.eatToken(SyntaxKind.SemicolonToken);

            var incrementor: IExpressionSyntax = null;
            if (this.currentToken().tokenKind !== SyntaxKind.CloseParenToken &&
                this.currentToken().tokenKind !== SyntaxKind.EndOfFileToken) {
                incrementor = this.parseExpression(/*allowIn:*/ true);
            }

            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var statement = this.parseStatement();

            return this.factory.forStatement(forKeyword, openParenToken, variableDeclaration, initializer,
                firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement);
        }

        private isBreakStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.BreakKeyword;
        }

        private parseBreakStatement(): BreakStatementSyntax {
            Debug.assert(this.isBreakStatement());

            var breakKeyword = this.eatKeyword(SyntaxKind.BreakKeyword);

            // If there is no newline after the break keyword, then we can consume an optional 
            // identifier.
            var identifier: ISyntaxToken = null;
            if (!this.canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                if (this.isIdentifier(this.currentToken())) {
                    identifier = this.eatIdentifierToken();
                }
            }

            var semicolon = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            return this.factory.breakStatement(breakKeyword, identifier, semicolon);
        }

        private isContinueStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ContinueKeyword;
        }

        private parseContinueStatement(): ContinueStatementSyntax {
            Debug.assert(this.isContinueStatement());

            var continueKeyword = this.eatKeyword(SyntaxKind.ContinueKeyword);

            // If there is no newline after the break keyword, then we can consume an optional 
            // identifier.
            var identifier: ISyntaxToken = null;
            if (!this.canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                if (this.isIdentifier(this.currentToken())) {
                    identifier = this.eatIdentifierToken();
                }
            }

            var semicolon = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            return this.factory.continueStatement(continueKeyword, identifier, semicolon);
        }

        private isSwitchStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.SwitchKeyword;
        }

        private parseSwitchStatement() {
            Debug.assert(this.isSwitchStatement());

            var switchKeyword = this.eatKeyword(SyntaxKind.SwitchKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var expression = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);

            var switchClauses: ISyntaxList = Syntax.emptyList;
            if (openBraceToken.width() > 0) {
                var result = this.parseSyntaxList(ListParsingState.SwitchStatement_SwitchClauses);
                switchClauses = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);
            return this.factory.switchStatement(switchKeyword, openParenToken, expression,
                closeParenToken, openBraceToken, switchClauses, closeBraceToken);
        }

        private isCaseSwitchClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CaseKeyword;
        }

        private isDefaultSwitchClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.DefaultKeyword;
        }

        private isSwitchClause(): bool {
            if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                return true;
            }

            return this.isCaseSwitchClause() || this.isDefaultSwitchClause();
        }

        private parseSwitchClause(): SwitchClauseSyntax {
            Debug.assert(this.isSwitchClause());
            if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                return <SwitchClauseSyntax>this.eatNode();
            }

            if (this.isCaseSwitchClause()) {
                return this.parseCaseSwitchClause();
            }
            else if (this.isDefaultSwitchClause()) {
                return this.parseDefaultSwitchClause();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private parseCaseSwitchClause(): CaseSwitchClauseSyntax {
            Debug.assert(this.isCaseSwitchClause());

            var caseKeyword = this.eatKeyword(SyntaxKind.CaseKeyword);
            var expression = this.parseExpression(/*allowIn:*/ true);
            var colonToken = this.eatToken(SyntaxKind.ColonToken);
            var statements = Syntax.emptyList;

            // TODO: allow parsing of the list evne if there's no colon.  However, we have to make 
            // sure we add any skipped tokens to the right previous node or token.
            if (colonToken.fullWidth() > 0) {
                var result = this.parseSyntaxList(ListParsingState.SwitchClause_Statements);
                statements = result.list;
                colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
            }

            return this.factory.caseSwitchClause(caseKeyword, expression, colonToken, statements);
        }

        private parseDefaultSwitchClause(): DefaultSwitchClauseSyntax {
            Debug.assert(this.isDefaultSwitchClause());

            var defaultKeyword = this.eatKeyword(SyntaxKind.DefaultKeyword);
            var colonToken = this.eatToken(SyntaxKind.ColonToken);
            var statements = Syntax.emptyList;

            // TODO: Allow parsing witha colon here.  However, ensure that we attach any skipped 
            // tokens to the defaultKeyword.
            if (colonToken.fullWidth() > 0) {
                var result = this.parseSyntaxList(ListParsingState.SwitchClause_Statements);
                statements = result.list;
                colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
            }

            return this.factory.defaultSwitchClause(defaultKeyword, colonToken, statements);
        }

        private isThrowStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ThrowKeyword;
        }

        private parseThrowStatement(): ThrowStatementSyntax {
            Debug.assert(this.isThrowStatement());

            var throwKeyword = this.eatKeyword(SyntaxKind.ThrowKeyword);

            var expression: IExpressionSyntax = null;
            if (this.canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                // Because of automatic semicolon insertion, we need to report error if this 
                // throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'
                // directly as that might consume an expression on the following line.  
                var token = this.createMissingToken(SyntaxKind.IdentifierName, null);
                expression = token;
            }
            else {
                expression = this.parseExpression(/*allowIn:*/ true);
            }

            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.throwStatement(throwKeyword, expression, semicolonToken);
        }

        private isReturnStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ReturnKeyword;
        }

        private parseReturnStatement(): ReturnStatementSyntax {
            Debug.assert(this.isReturnStatement());

            var returnKeyword = this.eatKeyword(SyntaxKind.ReturnKeyword);

            var expression: IExpressionSyntax = null;
            if (!this.canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                expression = this.parseExpression(/*allowIn:*/ true);
            }

            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.returnStatement(returnKeyword, expression, semicolonToken);
        }

        private isExpressionStatement(): bool {
            // As per the gramar, neither { nor 'function' can start an expression statement.
            var currentToken = this.currentToken();

            var kind = currentToken.tokenKind;
            if (kind === SyntaxKind.OpenBraceToken || kind === SyntaxKind.FunctionKeyword) {
                return false;
            }

            return this.isExpression();
        }

        private isAssignmentOrOmittedExpression(): bool {
            if (this.currentToken().tokenKind === SyntaxKind.CommaToken) {
                return true;
            }

            return this.isExpression();
        }

        private parseAssignmentOrOmittedExpression(): IExpressionSyntax {
            Debug.assert(this.isAssignmentOrOmittedExpression());

            if (this.currentToken().tokenKind === SyntaxKind.CommaToken) {
                return this.factory.omittedExpression();
            }

            return this.parseAssignmentExpression(/*allowIn:*/ true);
        }

        private isExpression(): bool {
            var currentToken = this.currentToken();
            var kind = currentToken.tokenKind;

            switch (kind) {
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                    return true;

                case SyntaxKind.OpenBracketToken: // For array literals.
                case SyntaxKind.OpenParenToken: // For parenthesized expressions
                    return true;

                case SyntaxKind.LessThanToken: // For cast expressions.
                    return true;

                // Prefix unary expressions.
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.ExclamationToken:
                    return true;

                case SyntaxKind.OpenBraceToken: // For object type literal expressions.
                    return true;

                // ERROR TOLERANCE:
                // If we see a => then we know the user was probably trying to type in an arrow 
                // function.  So allow this as the start of an expression, knowing that when we 
                // actually try to parse it we'll report the missing identifier.
                case SyntaxKind.EqualsGreaterThanToken:
                    return true;

                case SyntaxKind.SlashToken:
                case SyntaxKind.SlashEqualsToken:
                    // Note: if we see a / or /= token then we always consider this an expression.  Why?
                    // Well, either that / or /= is actually a regular expression, in which case we're 
                    // definitely an expression.  Or, it's actually a divide.  In which case, we *still*
                    // want to think of ourself as an expression.  "But wait", you say.  '/' doesn't
                    // start an expression.  That's true.  BUt like the above check for =>, for error
                    // tolerance, we will consider ourselves in an expression.  We'll then parse out an
                    // missing identifier and then will consume the / token naturally as a binary 
                    // expression.
                    return true;

                case SyntaxKind.SuperKeyword:
                case SyntaxKind.ThisKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                    return true;

                case SyntaxKind.NewKeyword: // For object creation expressions.
                    return true;

                // Prefix unary expressions
                case SyntaxKind.DeleteKeyword:
                case SyntaxKind.VoidKeyword:
                case SyntaxKind.TypeOfKeyword:
                    return true;

                // For function expressions.
                case SyntaxKind.FunctionKeyword:
                    return true;
            }

            if (this.isIdentifier(this.currentToken())) {
                return true;
            }

            return false;
        }

        private parseExpressionStatement(): ExpressionStatementSyntax {
            var expression = this.parseExpression(/*allowIn:*/ true);

            var semicolon = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.expressionStatement(expression, semicolon);
        }

        private isIfStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.IfKeyword;
        }

        private parseIfStatement(): IfStatementSyntax {
            Debug.assert(this.isIfStatement());

            var ifKeyword = this.eatKeyword(SyntaxKind.IfKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var condition = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var statement = this.parseStatement();

            var elseClause: ElseClauseSyntax = null;
            if (this.isElseClause()) {
                elseClause = this.parseElseClause();
            }

            return this.factory.ifStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause);
        }

        private isElseClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ElseKeyword;
        }

        private parseElseClause(): ElseClauseSyntax {
            Debug.assert(this.isElseClause());

            var elseKeyword = this.eatKeyword(SyntaxKind.ElseKeyword);
            var statement = this.parseStatement();

            return this.factory.elseClause(elseKeyword, statement);
        }

        private isVariableStatement(): bool {
            var token0KeywordKind = this.currentToken().tokenKind;
            if (token0KeywordKind === SyntaxKind.VarKeyword) {
                return true;
            }

            if (token0KeywordKind === SyntaxKind.ExportKeyword &&
                this.peekToken(1).tokenKind === SyntaxKind.VarKeyword) {
                return true;
            }

            return token0KeywordKind === SyntaxKind.DeclareKeyword &&
                   this.peekToken(1).tokenKind === SyntaxKind.VarKeyword;
        }

        private parseVariableStatement(): VariableStatementSyntax {
            Debug.assert(this.isVariableStatement());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var declareKeyword = this.tryEatKeyword(SyntaxKind.DeclareKeyword);

            var variableDeclaration = this.parseVariableDeclaration(/*allowIn:*/ true);
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.variableStatement(exportKeyword, declareKeyword, variableDeclaration, semicolonToken);
        }

        private parseVariableDeclaration(allowIn: bool): VariableDeclarationSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.VarKeyword);

            var varKeyword = this.eatKeyword(SyntaxKind.VarKeyword);
            Debug.assert(varKeyword.fullWidth() > 0);

            var listParsingState = allowIn
                ? ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn
                : ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn;

            var result = this.parseSeparatedSyntaxList(listParsingState);
            var variableDeclarators = result.list;
            varKeyword = this.addSkippedTokensAfterToken(varKeyword, result.skippedTokens);

            return this.factory.variableDeclaration(varKeyword, variableDeclarators);
        }

        private isVariableDeclarator(): bool {
            if (this.currentNode() !== null && this.currentNode().kind() === SyntaxKind.VariableDeclarator) {
                return true;
            }

            return this.isIdentifier(this.currentToken());
        }

        private parseVariableDeclarator(allowIn: bool): VariableDeclaratorSyntax {
            if (this.currentNode() !== null && this.currentNode().kind() === SyntaxKind.VariableDeclarator) {
                return <VariableDeclaratorSyntax>this.eatNode();
            }

            var identifier = this.eatIdentifierToken();
            var equalsValueClause: EqualsValueClauseSyntax = null;
            var typeAnnotation: TypeAnnotationSyntax = null;

            if (identifier.width() > 0) {
                typeAnnotation = this.parseOptionalTypeAnnotation();

                if (this.isEqualsValueClause()) {
                    equalsValueClause = this.parseEqualsValuesClause(allowIn);
                }
            }

            return this.factory.variableDeclarator(identifier, typeAnnotation, equalsValueClause);
        }

        private isEqualsValueClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.EqualsToken;
        }

        private parseEqualsValuesClause(allowIn: bool): EqualsValueClauseSyntax {
            Debug.assert(this.isEqualsValueClause());

            var equalsToken = this.eatToken(SyntaxKind.EqualsToken);
            var value = this.parseAssignmentExpression(allowIn);

            return this.factory.equalsValueClause(equalsToken, value);
        }

        private parseExpression(allowIn: bool): IExpressionSyntax {
            return this.parseSubExpression(0, allowIn);
        }

        // Called when you need to parse an expression, but you do not want to allow 'CommaExpressions'.
        // i.e. if you have "var a = 1, b = 2" then when we parse '1' we want to parse with higher 
        // precedence than 'comma'.  Otherwise we'll get: "var a = (1, (b = 2))", instead of
        // "var a = (1), b = (2)");
        private parseAssignmentExpression(allowIn: bool): IExpressionSyntax {
            return this.parseSubExpression(ExpressionPrecedence.AssignmentExpressionPrecedence, allowIn);
        }

        private parseUnaryExpression(): IUnaryExpressionSyntax {
            var currentTokenKind = this.currentToken().tokenKind; 
            if (SyntaxFacts.isPrefixUnaryExpressionOperatorToken(currentTokenKind)) {
                var operatorKind = SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken(currentTokenKind);

                var operatorToken = this.eatAnyToken();

                var operand = this.parseUnaryExpression();
                return this.factory.prefixUnaryExpression(operatorKind, operatorToken, operand);
            }
            else {
                return this.parseTerm(/*allowInvocation*/ true, /*insideObjectCreation:*/ false);
            }
        }

        private parseSubExpression(precedence: ExpressionPrecedence, allowIn: bool): IExpressionSyntax {
            // Because unary expression have the highest precedence, we can always parse one, regardless 
            // of what precedence was passed in.
            var leftOperand: IExpressionSyntax = this.parseUnaryExpression();
            leftOperand = this.parseBinaryOrConditionalExpressions(precedence, allowIn, leftOperand);

            return leftOperand;
        }

        private parseBinaryOrConditionalExpressions(precedence: number, allowIn: bool, leftOperand: IExpressionSyntax): IExpressionSyntax {
            while (true) {
                // We either have a binary operator here, or we're finished.
                var token0 = this.currentToken();
                var token0Kind = token0.tokenKind;

                // Check for binary expressions.
                if (SyntaxFacts.isBinaryExpressionOperatorToken(token0Kind)) {
                    // also, if it's the 'in' operator, only allow if our caller allows it.
                    if (token0Kind === SyntaxKind.InKeyword && !allowIn) {
                        break;
                    }

                    // check for >= or >> or >>= or >>> or >>>=.
                    //
                    // These are not created by the scanner since we want the individual > tokens for
                    // generics.
                    var mergedToken = this.tryMergeBinaryExpressionTokens();
                    var tokenKind = mergedToken === null ? token0Kind : mergedToken.syntaxKind;

                    var binaryExpressionKind = SyntaxFacts.getBinaryExpressionFromOperatorToken(tokenKind);
                    var newPrecedence = ParserImpl.getPrecedence(binaryExpressionKind);

                    // All binary operators must have precedence > 0!
                    Debug.assert(newPrecedence > 0);

                    // Check the precedence to see if we should "take" this operator
                    if (newPrecedence < precedence) {
                        break;
                    }

                    // Same precedence, but not right-associative -- deal with this higher up in our stack "later"
                    if (newPrecedence === precedence && !this.isRightAssociative(binaryExpressionKind)) {
                        break;
                    }

                    // Precedence is okay, so we'll "take" this operator.  If we have a merged token, 
                    // then create a new synthesized token with all the operators combined.  In that 
                    // case make sure it has the right trivia associated with it.
                    var operatorToken = mergedToken === null
                        ? token0
                        : Syntax.token(mergedToken.syntaxKind)
                                .withLeadingTrivia(token0.leadingTrivia())
                                .withTrailingTrivia(this.peekToken(mergedToken.tokenCount - 1).trailingTrivia());

                    // Now skip the operator token we're on, or the tokens we merged.
                    var skipCount = mergedToken === null ? 1 : mergedToken.tokenCount;
                    for (var i = 0; i < skipCount; i++) {
                        this.eatAnyToken();
                    }

                    leftOperand = this.factory.binaryExpression(
                        binaryExpressionKind, leftOperand, operatorToken, this.parseSubExpression(newPrecedence, allowIn));
                    continue;
                }

                // Now check for conditional expression.
                // Only consume this as a ternary expression if our precedence is higher than the ternary 
                // level.  i.e. if we have "!f ? a : b" then we would not want to 
                // consume the "?" as part of "f" because the precedence of "!" is far too high.  However,
                // if we have: "x = f ? a : b", then we would want to consume the "?" as part of "f".
                //
                // Note: if we have "m = f ? x ? y : z : b, then we do want the second "?" to go with 'x'.
                if (token0Kind === SyntaxKind.QuestionToken && precedence <= ExpressionPrecedence.ConditionalExpressionPrecedence) {
                    var questionToken = this.eatToken(SyntaxKind.QuestionToken);

                    var whenTrueExpression = this.parseAssignmentExpression(allowIn);
                    var colon = this.eatToken(SyntaxKind.ColonToken);

                    var whenFalseExpression = this.parseAssignmentExpression(allowIn);
                    leftOperand = this.factory.conditionalExpression(
                        leftOperand, questionToken, whenTrueExpression, colon, whenFalseExpression);
                    continue;
                }

                // Not binary or ternary.  Nothing more to consume here.
                break;
            }

            return leftOperand;
        }

        private mergeTokensStorage: SyntaxKind[] = [];

        private tryMergeBinaryExpressionTokens(): { tokenCount: number; syntaxKind: SyntaxKind; } {
            var token0 = this.currentToken();

            // Only merge if we have a '>' token with no trailing trivia.
            if (token0.tokenKind === SyntaxKind.GreaterThanToken && !token0.hasTrailingTrivia()) {
                var storage = this.mergeTokensStorage;
                storage[0] = SyntaxKind.None;
                storage[1] = SyntaxKind.None;
                storage[2] = SyntaxKind.None;

                for (var i = 0; i < storage.length; i++) {
                    var nextToken = this.peekToken(i + 1);

                    // We can merge with the next token if it doesn't have any leading trivia.
                    if (!nextToken.hasLeadingTrivia()) {
                        storage[i] = nextToken.tokenKind;
                    }

                    // Stop merging additional tokens if this token has any trailing trivia.
                    if (nextToken.hasTrailingTrivia()) {
                        break;
                    }
                }

                if (storage[0] === SyntaxKind.GreaterThanToken) {
                    if (storage[1] === SyntaxKind.GreaterThanToken) {
                        if (storage[2] === SyntaxKind.EqualsToken) {
                            // >>>=
                            return { tokenCount: 4, syntaxKind: SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken };
                        }
                        else {
                            // >>>
                            return { tokenCount: 3, syntaxKind: SyntaxKind.GreaterThanGreaterThanGreaterThanToken };
                        }
                    }
                    else if (storage[1] === SyntaxKind.EqualsToken) {
                        // >>=
                        return { tokenCount: 3, syntaxKind: SyntaxKind.GreaterThanGreaterThanEqualsToken };
                    }
                    else {
                        // >>
                        return { tokenCount: 2, syntaxKind: SyntaxKind.GreaterThanGreaterThanToken };
                    }
                }
                else if (storage[0] === SyntaxKind.EqualsToken) {
                    // >=
                    return { tokenCount: 2, syntaxKind: SyntaxKind.GreaterThanEqualsToken };
                }
            }

            // Just use the normal logic as we're not merging the '>' with anything.
            return null;
        }

        private isRightAssociative(expressionKind: SyntaxKind): bool {
            switch (expressionKind) {
                case SyntaxKind.AssignmentExpression:
                case SyntaxKind.AddAssignmentExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                case SyntaxKind.DivideAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                case SyntaxKind.SignedRightShiftAssignmentExpression:
                case SyntaxKind.UnsignedRightShiftAssignmentExpression:
                    return true;
                default:
                    return false;
            }
        }

        private parseTerm(allowInvocation: bool, insideObjectCreation: bool): IUnaryExpressionSyntax {
            // NOTE: allowInvocation and insideObjectCreation are always the negation of the other.
            // We could remove one of them and just use the other.  However, i think this is much
            // easier to read and understand in this form.

            var term = this.parseTermWorker(insideObjectCreation);
            if (term === null) {
                // Nothing else worked, just try to consume an identifier so we report an error.
                return this.eatIdentifierToken();
            }

            return this.parsePostFixExpression(term, allowInvocation);
        }

        private parsePostFixExpression(expression: IUnaryExpressionSyntax, allowInvocation: bool): IUnaryExpressionSyntax {
            while (true) {
                var currentTokenKind = this.currentToken().tokenKind;
                switch (currentTokenKind) {
                    case SyntaxKind.OpenParenToken:
                        if (!allowInvocation) {
                            return expression;
                        }

                        expression = this.factory.invocationExpression(expression, this.parseArgumentList(/*typeArgumentList:*/ null));
                        continue;

                    case SyntaxKind.LessThanToken:
                        // See if this is the start of a generic invocation.  If so, consume it and
                        // keep checking for postfix expressions.  Otherwise, it's just a '<' that's 
                        // part of an arithmetic expression.  Break out so we consume it higher in the
                        // stack.
                        var argumentList = this.tryParseArgumentList();
                        if (argumentList !== null) {
                            expression = this.factory.invocationExpression(expression, argumentList);
                            continue;
                        }

                        break;

                    case SyntaxKind.OpenBracketToken:
                        expression = this.parseElementAccessExpression(expression);
                        continue;

                    case SyntaxKind.PlusPlusToken:
                    case SyntaxKind.MinusMinusToken:
                        // Because of automatic semicolon insertion, we should only consume the ++ or -- 
                        // if it is on the same line as the previous token.
                        if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                            break;
                        }

                        expression = this.factory.postfixUnaryExpression(
                            SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken(currentTokenKind), expression, this.eatAnyToken());
                        continue;

                    case SyntaxKind.DotToken:
                        expression = this.factory.memberAccessExpression(
                            expression, this.eatToken(SyntaxKind.DotToken), this.eatIdentifierNameToken());
                        continue;
                }

                return expression;
            }
        }

        private tryParseArgumentList(): ArgumentListSyntax {
            var typeArgumentList: TypeArgumentListSyntax = null;

            if (this.currentToken().tokenKind === SyntaxKind.LessThanToken) {
                // If we have a '<', then only parse this as a arugment list if the type arguments
                // are complete and we have an open paren.  if we don't, rewind and return nothing.
                var rewindPoint = this.getRewindPoint();
                try {
                    typeArgumentList = this.tryParseTypeArgumentList(/*inExpression:*/ true);
                    if (typeArgumentList === null || this.currentToken().tokenKind !== SyntaxKind.OpenParenToken) {
                        this.rewind(rewindPoint);
                        return null;
                    }
                }
                finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            }

            if (this.currentToken().tokenKind === SyntaxKind.OpenParenToken) {
                return this.parseArgumentList(typeArgumentList);
            }

            return null;
        }

        private parseArgumentList(typeArgumentList: TypeArgumentListSyntax): ArgumentListSyntax {
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var arguments = Syntax.emptySeparatedList;

            if (openParenToken.fullWidth() > 0) {
                var result = this.parseSeparatedSyntaxList(ListParsingState.ArgumentList_AssignmentExpressions);
                arguments = result.list;
                openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
            }

            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            return this.factory.argumentList(typeArgumentList, openParenToken, arguments, closeParenToken);
        }

        private parseElementAccessExpression(expression: IExpressionSyntax): ElementAccessExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.OpenBracketToken);

            var openBracketToken = this.eatToken(SyntaxKind.OpenBracketToken);
            var argumentExpression = this.parseExpression(/*allowIn:*/ true);
            var closeBracketToken = this.eatToken(SyntaxKind.CloseBracketToken);

            return this.factory.elementAccessExpression(expression, openBracketToken, argumentExpression, closeBracketToken);
        }

        private parseTermWorker(insideObjectCreation: bool): IUnaryExpressionSyntax {
            var currentToken = this.currentToken();

            if (insideObjectCreation) {
                // Note: if we have "new (expr..." then we want to parse that as "new (parenthesized expr)"
                // not as "new FunctionType".  This is because "new FunctionType" would look like:
                //
                //      new (Paramters) => type
                //
                // And this is just too confusing.  Plus, it is easy to work around.  They can just type:
                // "new { (Parameters): type }" instead
                //
                // Also, we disallow a ConstructorType inside an object creation expression.  Otherwise
                // we'd end up allowing: 
                //
                //      new new (Parameters) => Type.
                //
                // And this is just too confusing.  Plus, it is easy to work around.  They can just type:
                // "new { new (Parameters): ReturnType }" instead.

                if (this.isType(/*allowFunctionType:*/ false, /*allowConstructorType:*/ false)) {
                    // There's a lot of ambiguity in the language between typescript arrays, and javascript
                    // indexing.  For example, you can say: "new Foo[]".  In which case that new's up a foo 
                    // array.  Or you can say "new Foo[i]".  which accesses the i'th element of Foo and calls
                    // the construct operator on it. So, in this case, if we're parsing a 'new', we do allow
                    // seeing brackets, but only if they're *complete*.  
                    return this.parseType(/*requireCompleteArraySuffix:*/ true);
                }
            }

            // ERROR RECOVERY TWEAK:
            // If we see a standalone => try to parse it as an arrow function as that's likely what
            // the user intended to write.
            if (currentToken.tokenKind === SyntaxKind.EqualsGreaterThanToken) {
                return this.parseSimpleArrowFunctionExpression();
            }

            if (this.isIdentifier(currentToken)) {
                if (this.isSimpleArrowFunctionExpression()) {
                    return this.parseSimpleArrowFunctionExpression();
                }
                else {
                    var identifier = this.eatIdentifierToken();
                    return identifier;
                }
            }

            var currentTokenKind = currentToken.tokenKind;
            switch (currentTokenKind) {
                case SyntaxKind.ThisKeyword:
                    return this.parseThisExpression();

                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                    return this.parseLiteralExpression();

                case SyntaxKind.NullKeyword:
                    return this.parseLiteralExpression();

                case SyntaxKind.NewKeyword:
                    return this.parseObjectCreationExpression();

                case SyntaxKind.FunctionKeyword:
                    return this.parseFunctionExpression();

                case SyntaxKind.SuperKeyword:
                    return this.parseSuperExpression();

                case SyntaxKind.TypeOfKeyword:
                    return this.parseTypeOfExpression();

                case SyntaxKind.DeleteKeyword:
                    return this.parseDeleteExpression();

                case SyntaxKind.VoidKeyword:
                    return this.parseVoidExpression();

                case SyntaxKind.NumericLiteral:
                    return this.parseLiteralExpression();

                case SyntaxKind.RegularExpressionLiteral:
                    return this.parseLiteralExpression();

                case SyntaxKind.StringLiteral:
                    return this.parseLiteralExpression();

                case SyntaxKind.OpenBracketToken:
                    return this.parseArrayLiteralExpression();

                case SyntaxKind.OpenBraceToken:
                    return this.parseObjectLiteralExpression();

                case SyntaxKind.OpenParenToken:
                    return this.parseParenthesizedOrArrowFunctionExpression();

                case SyntaxKind.LessThanToken:
                    return this.parseCastOrArrowFunctionExpression();

                case SyntaxKind.SlashToken:
                case SyntaxKind.SlashEqualsToken:
                    // If we see a standalone / or /= and we're expecting a term, then try to reparse
                    // it as a regular expression.  If we succeed, then return that.  Otherwise, fall
                    // back and just return a missing identifier as usual.  We'll then form a binary
                    // expression out of of the / as usual.
                    var result = this.tryReparseDivideAsRegularExpression();
                    if (result !== null) {
                        return result;
                    }
                    break;
            }

            // Wasn't able to parse this as a term. 
            return null;
        }

        private tryReparseDivideAsRegularExpression(): IUnaryExpressionSyntax {
            // If we see a / or /= token, then that may actually be the start of a regex in certain 
            // contexts.

            var currentToken = this.currentToken();
            Debug.assert(SyntaxFacts.isAnyDivideToken(currentToken.tokenKind));

            // There are several contexts where we could never see a regex.  Don't even bother 
            // reinterpretting the / in these contexts.
            if (this.previousToken() !== null) {
                var previousTokenKind = this.previousToken().tokenKind;
                switch (previousTokenKind) {
                    case SyntaxKind.IdentifierName:
                        // Regular expressions can't follow identifiers.
                        return null;

                    // Regexs also can't follow certain keywords:
                    case SyntaxKind.ThisKeyword:
                    case SyntaxKind.TrueKeyword:
                    case SyntaxKind.FalseKeyword:
                        return null;

                    // A regular expression could follow other keywords.  i.e. "return /blah/;"
                    // TODO: be more specific about the keywords that a regex could follow.

                    case SyntaxKind.StringLiteral:
                    case SyntaxKind.NumericLiteral:
                    case SyntaxKind.RegularExpressionLiteral:
                    case SyntaxKind.PlusPlusToken:
                    case SyntaxKind.MinusMinusToken:
                    case SyntaxKind.CloseBracketToken:
                    case SyntaxKind.CloseBraceToken:
                        // A regular expression can't follow any of these.  It must be a divide. Note: this
                        // list *may* be incorrect (especially in the context of typescript).  We need to
                        // carefully review it.
                        return null;

                    // case SyntaxKind.CloseParenToken:
                    // It is tempting to say that if we have a slash after a close paren that it can't be 
                    // a regular expression.  after all, the normal case where we see that is "(1 + 2) / 3".
                    // However, it can appear in legal code.  Specifically:
                    //
                    //      for (...)
                    //          /regex/.Stuff...
                    //
                    // So we have to see if we can get a regular expression in that case.
                }
            }

            // Ok, from our quick lexical check, this could be a place where a regular expression could
            // go.  Now we have to do a bunch of work.  Ask the source to retrive the token at the 
            // current position again.  But this time allow it to retrieve it as a regular expression.
            currentToken = this.currentTokenAllowingRegularExpression();

            // Note: we *must* have gotten a /, /= or regular expression.  Or else something went *very*
            // wrong with our logic above.
            Debug.assert(SyntaxFacts.isAnyDivideOrRegularExpressionToken(currentToken.tokenKind));

            if (currentToken.tokenKind === SyntaxKind.SlashToken || currentToken.tokenKind === SyntaxKind.SlashEqualsToken) {
                // Still came back as a / or /=.   This is not a regular expression literal.
                return null;
            }
            else if (currentToken.tokenKind === SyntaxKind.RegularExpressionLiteral) {
                return this.parseLiteralExpression();
            }
            else {
                // Something *very* wrong happened.  This is an internal parser fault that we need 
                // to figure out and fix.
                throw Errors.invalidOperation();
            }
        }

        private parseTypeOfExpression(): TypeOfExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.TypeOfKeyword);

            var typeOfKeyword = this.eatKeyword(SyntaxKind.TypeOfKeyword);
            var expression = this.parseUnaryExpression();

            return this.factory.typeOfExpression(typeOfKeyword, expression);
        }

        private parseDeleteExpression(): DeleteExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.DeleteKeyword);

            var deleteKeyword = this.eatKeyword(SyntaxKind.DeleteKeyword);
            var expression = this.parseUnaryExpression();

            return this.factory.deleteExpression(deleteKeyword, expression);
        }

        private parseVoidExpression(): VoidExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.VoidKeyword);

            var voidKeyword = this.eatKeyword(SyntaxKind.VoidKeyword);
            var expression = this.parseUnaryExpression();

            return this.factory.voidExpression(voidKeyword, expression);
        }

        private parseSuperExpression(): IUnaryExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.SuperKeyword);

            var superKeyword = this.eatKeyword(SyntaxKind.SuperKeyword);
            return superKeyword;
        }

        private parseFunctionExpression(): FunctionExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.FunctionKeyword);

            var functionKeyword = this.eatKeyword(SyntaxKind.FunctionKeyword);
            var identifier: ISyntaxToken = null;

            if (this.isIdentifier(this.currentToken())) {
                identifier = this.eatIdentifierToken();
            }

            var callSignature = this.parseCallSignature(/*requireCompleteTypeParameterList:*/ false);
            var block = this.parseBlock();

            return this.factory.functionExpression(functionKeyword, identifier, callSignature, block);
        }

        private parseObjectCreationExpression(): ObjectCreationExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.NewKeyword);
            var newKeyword = this.eatKeyword(SyntaxKind.NewKeyword);

            // While parsing the sub term we don't want to allow invocations to be parsed.  that's because
            // we want "new Foo()" to parse as "new Foo()" (one node), not "new (Foo())".
            var expression = this.parseTerm(/*allowInvocation:*/ false, /*insideObjectCreation:*/ true);

            var argumentList = this.tryParseArgumentList();
            return this.factory.objectCreationExpression(newKeyword, expression, argumentList);
        }

        private parseCastOrArrowFunctionExpression(): IUnaryExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.LessThanToken);

            // We've got a '<'.  that could start a cast or an arrow function.  As it is highly
            // ambiguous, we need to check for enough data to indicate that's it's an arrow 
            // function.  Otherwise, we assume it's a cast.
            var rewindPoint = this.getRewindPoint();
            try {
                var arrowFunction = this.tryParseArrowFunctionExpression();
                if (arrowFunction !== null) {
                    return arrowFunction;
                }

                // wasn't an arrow function.  Try again as a cast expression.
                this.rewind(rewindPoint);
                return this.parseCastExpression();
            }
            finally {
                this.releaseRewindPoint(rewindPoint);
            }
        }
        
        private parseCastExpression(): CastExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.LessThanToken);

            var lessThanToken = this.eatToken(SyntaxKind.LessThanToken);
            var type = this.parseType(/*requireCompleteArraySuffix:*/ false);
            var greaterThanToken = this.eatToken(SyntaxKind.GreaterThanToken);
            var expression = this.parseUnaryExpression();

            return this.factory.castExpression(lessThanToken, type, greaterThanToken, expression);
        }

        private parseParenthesizedOrArrowFunctionExpression(): IUnaryExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.OpenParenToken);

            var result = this.tryParseArrowFunctionExpression();
            if (result !== null) {
                return result;
            }

            // Doesn't look like an arrow function, so parse this as a parenthesized expression.
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var expression = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            return this.factory.parenthesizedExpression(openParenToken, expression, closeParenToken);
        }

        private tryParseArrowFunctionExpression(): ArrowFunctionExpressionSyntax {
            var tokenKind = this.currentToken().tokenKind;
            Debug.assert(tokenKind === SyntaxKind.OpenParenToken || tokenKind === SyntaxKind.LessThanToken);

            // Because arrow functions and parenthesized expressions look similar, we have to check far
            // enough ahead to be sure we've actually got an arrow function. For example, both nodes can
            // start with:
            //    (a = b, c = d, ..., e = f).
            //So we effectively need infinite lookahead to decide which node we're in.
            //
            // First, check for things that definitely have enough information to let us know it's an
            // arrow function.

            if (this.isDefinitelyArrowFunctionExpression()) {
                // We have something like "()" or "(a) =>".  Definitely a lambda, so parse it
                // unilaterally as such.
                return this.parseParenthesizedArrowFunctionExpression(/*requiresArrow:*/ false);
            }

            // Now, look for cases where we're sure it's not an arrow function.  This will help save us
            // a costly parse.
            if (!this.isPossiblyArrowFunctionExpression()) {
                return null;
            }

            // Then, try to actually parse it as a arrow function, and only return if we see an => 
            var rewindPoint = this.getRewindPoint();
            try {
                var arrowFunction = this.parseParenthesizedArrowFunctionExpression(/*requiresArrow:*/ true);
                if (arrowFunction === null) {
                    this.rewind(rewindPoint);
                }
                return arrowFunction;
            }
            finally {
                this.releaseRewindPoint(rewindPoint);
            }
        }

        private parseParenthesizedArrowFunctionExpression(requireArrow: bool): ParenthesizedArrowFunctionExpressionSyntax {
            var currentToken = this.currentToken();
            Debug.assert(currentToken.tokenKind === SyntaxKind.OpenParenToken || currentToken.tokenKind === SyntaxKind.LessThanToken);

            var callSignature = this.parseCallSignature(/*requireCompleteTypeParameterList:*/ true);

            if (requireArrow && this.currentToken().tokenKind !== SyntaxKind.EqualsGreaterThanToken) {
                return null;
            }

            var equalsGreaterThanToken = this.eatToken(SyntaxKind.EqualsGreaterThanToken);
            var body = this.parseArrowFunctionBody();

            return this.factory.parenthesizedArrowFunctionExpression(callSignature, equalsGreaterThanToken, body);
        }

        private parseArrowFunctionBody(): ISyntaxNodeOrToken {
            if (this.isBlock()) {
                return this.parseBlock();
            }
            else {
                return this.parseAssignmentExpression(/*allowIn:*/ true);
            }
        }

        private isSimpleArrowFunctionExpression(): bool {
            // ERROR RECOVERY TWEAK:
            if (this.currentToken().tokenKind === SyntaxKind.EqualsGreaterThanToken) {
                return true;
            }

            return this.isIdentifier(this.currentToken()) &&
                   this.peekToken(1).tokenKind === SyntaxKind.EqualsGreaterThanToken;
        }

        private parseSimpleArrowFunctionExpression(): SimpleArrowFunctionExpressionSyntax {
            Debug.assert(this.isSimpleArrowFunctionExpression());

            var identifier = this.eatIdentifierToken();
            var equalsGreaterThanToken = this.eatToken(SyntaxKind.EqualsGreaterThanToken);
            var body = this.parseArrowFunctionBody();

            return this.factory.simpleArrowFunctionExpression(
                identifier, equalsGreaterThanToken, body);
        }

        private isBlock(): bool {
            return this.currentToken().tokenKind === SyntaxKind.OpenBraceToken;
        }

        private isDefinitelyArrowFunctionExpression(): bool {
            var token0 = this.currentToken();
            if (token0.tokenKind !== SyntaxKind.OpenParenToken) {
                // If it didn't start with an (, then it could be generic.  That's too complicated 
                // and we can't say it's 'definitely' an arrow function.             
                return false;
            }

            var token1 = this.peekToken(1);

            if (token1.tokenKind === SyntaxKind.CloseParenToken) {
                // ()
                // Definitely an arrow function.  Could never be a parenthesized expression.
                return true;
            }

            if (token1.tokenKind === SyntaxKind.DotDotDotToken) {
                // (...
                // Definitely an arrow function.  Could never be a parenthesized expression.
                return true;
            }

            if (!this.isIdentifier(token1)) {
                // All other arrow functions must start with (id
                // so this is definitely not an arrow function.
                return false;
            }

            // (id
            //
            // Lots of options here.  Check for things that make us certain it's an
            // arrow function.
            var token2 = this.peekToken(2);
            if (token2.tokenKind === SyntaxKind.ColonToken) {
                // (id:
                // Definitely an arrow function.  Could never be a parenthesized expression.
                return true;
            }

            var token3 = this.peekToken(3);
            if (token2.tokenKind === SyntaxKind.QuestionToken) {
                // (id?
                // Could be an arrow function, or a parenthesized conditional expression.

                // Check for the things that could only be arrow functions.
                if (token3.tokenKind === SyntaxKind.ColonToken ||
                    token3.tokenKind === SyntaxKind.CloseParenToken ||
                    token3.tokenKind === SyntaxKind.CommaToken) {
                    // (id?:
                    // (id?)
                    // (id?,
                    // These are the only cases where this could be an arrow function.
                    // And none of them can be parenthesized expression.
                    return true;
                }
            }

            if (token2.tokenKind === SyntaxKind.CloseParenToken) {
                // (id)
                // Could be an arrow function, or a parenthesized conditional expression.

                if (token3.tokenKind === SyntaxKind.EqualsGreaterThanToken) {
                    // (id) =>
                    // Definitely an arrow function.  Could not be a parenthesized expression.
                    return true;
                }

                // Note: "(id):" *looks* like it could be an arrow function.  However, it could
                // show up in:  "foo ? (id): 
                // So we can't return true here for that case.
            }

            // TODO: Add more cases if you're sure that there is enough information to know to 
            // parse this as an arrow function.  Note: be very careful here.

            // Anything else wasn't clear enough.  Try to parse the expression as an arrow function and bail out
            // if we fail.
            return false;
        }

        private isPossiblyArrowFunctionExpression(): bool {
            var token0 = this.currentToken();
            if (token0.tokenKind !== SyntaxKind.OpenParenToken) {
                // If it didn't start with an (, then it could be generic.  That's too complicated 
                // and we have to say it's possibly an arrow function.
                return true;
            }

            var token1 = this.peekToken(1);

            if (!this.isIdentifier(token1)) {
                // All other arrow functions must start with (id
                // so this is definitely not an arrow function.
                return false;
            }

            var token2 = this.peekToken(2);
            if (token2.tokenKind === SyntaxKind.EqualsToken) {
                // (id =
                //
                // This *could* be an arrow function.  i.e. (id = 0) => { }
                // Or it could be a parenthesized expression.  So we'll have to actually
                // try to parse it.
                return true;
            }

            if (token2.tokenKind === SyntaxKind.CommaToken) {
                // (id,

                // This *could* be an arrow function.  i.e. (id, id2) => { }
                // Or it could be a parenthesized expression (as javascript supports
                // the comma operator).  So we'll have to actually try to parse it.
                return true;
            }

            if (token2.tokenKind === SyntaxKind.CloseParenToken) {
                // (id)

                var token3 = this.peekToken(3);
                if (token3.tokenKind === SyntaxKind.ColonToken) {
                    // (id):
                    //
                    // This could be an arrow function. i.e. (id): number => { }
                    // Or it could be parenthesized exprssion: foo ? (id) :
                    // So we'll have to actually try to parse it.
                    return true;
                }
            }

            // Nothing else could be an arrow function.
            return false;
        }

        private parseObjectLiteralExpression(): ObjectLiteralExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.OpenBraceToken);

            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);
            Debug.assert(openBraceToken.fullWidth() > 0);

            var result = this.parseSeparatedSyntaxList(ListParsingState.ObjectLiteralExpression_PropertyAssignments);
            var propertyAssignments = result.list;
            openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);

            return this.factory.objectLiteralExpression(
                openBraceToken, propertyAssignments, closeBraceToken);
        }

        private parsePropertyAssignment(): PropertyAssignmentSyntax {
            Debug.assert(this.isPropertyAssignment(/*inErrorRecovery:*/ false));
            if (this.isGetAccessorPropertyAssignment()) {
                return this.parseGetAccessorPropertyAssignment();
            }
            else if (this.isSetAccessorPropertyAssignment()) {
                return this.parseSetAccessorPropertyAssignment();
            }
            else if (this.isSimplePropertyAssignment(/*inErrorRecovery:*/ false)) {
                return this.parseSimplePropertyAssignment();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private isPropertyAssignment(inErrorRecovery: bool): bool {
            return this.isGetAccessorPropertyAssignment() ||
                   this.isSetAccessorPropertyAssignment() ||
                   this.isSimplePropertyAssignment(inErrorRecovery);
        }

        private isGetAccessorPropertyAssignment(): bool {
            return this.currentToken().tokenKind === SyntaxKind.GetKeyword &&
                   this.isPropertyName(this.peekToken(1), /*inErrorRecovery:*/ false);
        }

        private parseGetAccessorPropertyAssignment(): GetAccessorPropertyAssignmentSyntax {
            Debug.assert(this.isGetAccessorPropertyAssignment());

            var getKeyword = this.eatKeyword(SyntaxKind.GetKeyword);
            var propertyName = this.eatAnyToken();
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var block = this.parseBlock();

            return this.factory.getAccessorPropertyAssignment(getKeyword, propertyName, openParenToken, closeParenToken, block);
        }

        private isSetAccessorPropertyAssignment(): bool {
            return this.currentToken().tokenKind === SyntaxKind.SetKeyword &&
                   this.isPropertyName(this.peekToken(1), /*inErrorRecovery:*/ false);
        }

        private parseSetAccessorPropertyAssignment(): SetAccessorPropertyAssignmentSyntax {
            Debug.assert(this.isSetAccessorPropertyAssignment());

            var setKeyword = this.eatKeyword(SyntaxKind.SetKeyword);
            var propertyName = this.eatAnyToken();
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var parameterName = this.eatIdentifierToken();
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var block = this.parseBlock();

            return this.factory.setAccessorPropertyAssignment(setKeyword, propertyName, openParenToken, parameterName, closeParenToken, block);
        }

        private isSimplePropertyAssignment(inErrorRecovery: bool): bool {
            return this.isPropertyName(this.currentToken(), inErrorRecovery);
        }

        private parseSimplePropertyAssignment(): SimplePropertyAssignmentSyntax {
            Debug.assert(this.isSimplePropertyAssignment(/*inErrorRecovery:*/ false));

            var propertyName = this.eatAnyToken();
            var colonToken = this.eatToken(SyntaxKind.ColonToken);
            var expression = this.parseAssignmentExpression(/*allowIn:*/ true);

            return this.factory.simplePropertyAssignment(propertyName, colonToken, expression);
        }

        private isPropertyName(token: ISyntaxToken, inErrorRecovery: bool): bool {
            // NOTE: we do *not* want to check "this.isIdentifier" here.  Any IdentifierName is 
            // allowed here, even reserved words like keywords.
            if (ParserImpl.isIdentifierName(token)) {
                // Except: if we're in error recovery, then we don't want to consider keywords. 
                // After all, if we have:
                //
                //      { a: 1
                //      return
                //
                // we don't want consider 'return' to be the next property in the object literal.
                if (inErrorRecovery) {
                    return this.isIdentifier(token);
                }
                else {
                    return true;
                }
            }

            switch (token.tokenKind) {
                case SyntaxKind.StringLiteral:
                case SyntaxKind.NumericLiteral:
                    return true;

                default:
                    return false;
            }
        }

        private parseArrayLiteralExpression(): ArrayLiteralExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.OpenBracketToken);

            var openBracketToken = this.eatToken(SyntaxKind.OpenBracketToken);
            Debug.assert(openBracketToken.fullWidth() > 0);

            var result = this.parseSeparatedSyntaxList(ListParsingState.ArrayLiteralExpression_AssignmentExpressions);
            var expressions = result.list;
            openBracketToken = this.addSkippedTokensAfterToken(openBracketToken, result.skippedTokens);

            var closeBracketToken = this.eatToken(SyntaxKind.CloseBracketToken);

            return this.factory.arrayLiteralExpression(openBracketToken, expressions, closeBracketToken);
        }

        private parseLiteralExpression(): IUnaryExpressionSyntax {
            // TODO: add appropriate asserts here.
            return this.eatAnyToken();
        }

        private parseThisExpression(): IUnaryExpressionSyntax {
            Debug.assert(this.currentToken().tokenKind === SyntaxKind.ThisKeyword);
            var thisKeyword = this.eatKeyword(SyntaxKind.ThisKeyword);
            return thisKeyword;
        }

        private parseBlock(): BlockSyntax {
            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);

            var statements: ISyntaxList = Syntax.emptyList;

            if (openBraceToken.width() > 0) {
                var savedIsInStrictMode = this.isInStrictMode;

                var result = this.parseSyntaxList(ListParsingState.Block_Statements, ParserImpl.updateStrictModeState);
                statements = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

                this.setStrictMode(savedIsInStrictMode);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);

            return this.factory.block(openBraceToken, statements, closeBraceToken);
        }

        private parseCallSignature(requireCompleteTypeParameterList: bool): CallSignatureSyntax {
            var typeParameterList = this.parseOptionalTypeParameterList(requireCompleteTypeParameterList);
            var parameterList = this.parseParameterList();
            var typeAnnotation = this.parseOptionalTypeAnnotation();

            return this.factory.callSignature(typeParameterList, parameterList, typeAnnotation);
        }

        private parseOptionalTypeParameterList(requireCompleteTypeParameterList: bool): TypeParameterListSyntax {
            if (this.currentToken().tokenKind !== SyntaxKind.LessThanToken) {
                return null;
            }

            var rewindPoint = this.getRewindPoint();
            try {
                var lessThanToken = this.eatToken(SyntaxKind.LessThanToken);
                Debug.assert(lessThanToken.fullWidth() > 0);
                
                var result = this.parseSeparatedSyntaxList(ListParsingState.TypeParameterList_TypeParameters);
                var typeParameterList = result.list;
                lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                var greaterThanToken = this.eatToken(SyntaxKind.GreaterThanToken);

                // return null if we were required to have a '>' token and we did not  have one.
                if (requireCompleteTypeParameterList && greaterThanToken.fullWidth() === 0) {
                    this.rewind(rewindPoint);
                    return null;
                }

                return this.factory.typeParameterList(lessThanToken, typeParameterList, greaterThanToken);
            }
            finally {
                this.releaseRewindPoint(rewindPoint);
            }
        }

        private isTypeParameter(): bool {
            return this.isIdentifier(this.currentToken());
        }
        
        private parseTypeParameter(): TypeParameterSyntax {
            Debug.assert(this.isTypeParameter());
            var identifier = this.eatIdentifierToken();
            var constraint = this.parseOptionalConstraint();

            return this.factory.typeParameter(identifier, constraint);
        }

        private parseOptionalConstraint(): ConstraintSyntax {
            if (this.currentToken().kind() !== SyntaxKind.ExtendsKeyword) {
                return null;
            }

            var extendsKeyword = this.eatKeyword(SyntaxKind.ExtendsKeyword);
            var type = this.parseType(/*requireCompleteArraySuffix:*/ false);

            return this.factory.constraint(extendsKeyword, type);
        }

        private parseParameterList(): ParameterListSyntax {
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var parameters: ISeparatedSyntaxList = Syntax.emptySeparatedList;

            if (openParenToken.width() > 0) {
                var result = this.parseSeparatedSyntaxList(ListParsingState.ParameterList_Parameters);
                parameters = result.list;
                openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
            }

            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            return this.factory.parameterList(openParenToken, parameters, closeParenToken);
        }

        private isTypeAnnotation(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ColonToken;
        }

        private parseOptionalTypeAnnotation(): TypeAnnotationSyntax {
            return this.isTypeAnnotation()
                ? this.parseTypeAnnotation()
                : null;
        }

        private parseTypeAnnotation(): TypeAnnotationSyntax {
            Debug.assert(this.isTypeAnnotation());

            var colonToken = this.eatToken(SyntaxKind.ColonToken);
            var type = this.parseType(/*requireCompleteArraySuffix:*/ false);

            return this.factory.typeAnnotation(colonToken, type);
        }

        private isType(allowFunctionType: bool, allowConstructorType: bool): bool {
            return this.isPredefinedType() ||
                   this.isTypeLiteral(allowFunctionType, allowConstructorType) ||
                   this.isName();
        }

        private parseType(requireCompleteArraySuffix: bool): ITypeSyntax {
            var type = this.parseNonArrayType();

            while (this.currentToken().tokenKind === SyntaxKind.OpenBracketToken) {
                if (requireCompleteArraySuffix && this.peekToken(1).tokenKind !== SyntaxKind.CloseBracketToken) {
                    break;
                }

                var openBracketToken = this.eatToken(SyntaxKind.OpenBracketToken);
                var closeBracketToken = this.eatToken(SyntaxKind.CloseBracketToken);

                type = this.factory.arrayType(type, openBracketToken, closeBracketToken);
            }

            return type;
        }

        private parseNonArrayType(): ITypeSyntax {
            if (this.isPredefinedType()) {
                return this.parsePredefinedType();
            }
            else if (this.isTypeLiteral(/*allowFunctionType:*/ true, /*allowConstructorType:*/ true)) {
                return this.parseTypeLiteral();
            }
            else {
                return this.parseNameOrGenericType();
            }
        }

        private parseNameOrGenericType(): ITypeSyntax {
            var name = this.parseName();
            var typeArgumentList = this.tryParseTypeArgumentList(/*inExpression:*/ false);

            return typeArgumentList === null
                ? name
                : this.factory.genericType(name, typeArgumentList);
        }

        private parseTypeLiteral(): ITypeSyntax {
            Debug.assert(this.isTypeLiteral(/*allowFunctionType:*/ true, /*allowConstructorType:*/ true));
            if (this.isObjectType()) {
                return this.parseObjectType();
            }
            else if (this.isFunctionType()) {
                return this.parseFunctionType();
            }
            else if (this.isConstructorType()) {
                return this.parseConstructorType();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private parseFunctionType(): FunctionTypeSyntax {
            Debug.assert(this.isFunctionType());

            var typeParameterList = this.parseOptionalTypeParameterList(/*requireCompleteTypeParameterList:*/ false);
            var parameterList = this.parseParameterList();
            var equalsGreaterThanToken = this.eatToken(SyntaxKind.EqualsGreaterThanToken);
            var returnType = this.parseType(/*requireCompleteArraySuffix:*/ false);

            return this.factory.functionType(typeParameterList, parameterList, equalsGreaterThanToken, returnType);
        }

        private parseConstructorType(): ConstructorTypeSyntax {
            Debug.assert(this.isConstructorType());

            var newKeyword = this.eatKeyword(SyntaxKind.NewKeyword);
            var parameterList = this.parseParameterList();
            var equalsGreaterThanToken = this.eatToken(SyntaxKind.EqualsGreaterThanToken);
            var type = this.parseType(/*requreCompleteArraySuffix:*/ false);

            return this.factory.constructorType(newKeyword, null, parameterList, equalsGreaterThanToken, type);
        }

        private isTypeLiteral(allowFunctionType: bool, allowConstructorType: bool): bool {
            if (this.isObjectType()) {
                return true;
            }

            if (allowFunctionType && this.isFunctionType()) {
                return true;
            }

            if (allowConstructorType && this.isConstructorType()) {
                return true;
            }

            return false;
        }

        private isObjectType(): bool {
            return this.currentToken().tokenKind === SyntaxKind.OpenBraceToken;
        }

        private isFunctionType(): bool {
            var tokenKind = this.currentToken().tokenKind;
            return tokenKind === SyntaxKind.OpenParenToken || tokenKind === SyntaxKind.LessThanToken;
        }

        private isConstructorType(): bool {
            return this.currentToken().tokenKind === SyntaxKind.NewKeyword;
        }

        private parsePredefinedType(): ITypeSyntax {
            Debug.assert(this.isPredefinedType());
            var keyword = this.eatAnyToken();
            return keyword;
        }

        private isPredefinedType(): bool {
            switch (this.currentToken().tokenKind) {
                case SyntaxKind.AnyKeyword:
                case SyntaxKind.NumberKeyword:
                case SyntaxKind.BooleanKeyword:
                case SyntaxKind.BoolKeyword:
                case SyntaxKind.StringKeyword:
                case SyntaxKind.VoidKeyword:
                    return true;
            }

            return false;
        }

        private isParameter(): bool {
            if (this.currentNode() !== null && this.currentNode().kind() === SyntaxKind.Parameter) {
                return true;
            }

            var token = this.currentToken();
            if (token.tokenKind === SyntaxKind.DotDotDotToken) {
                return true;
            }

            if (token.tokenKind === SyntaxKind.PublicKeyword ||
                token.tokenKind === SyntaxKind.PrivateKeyword) {
                return true;
            }

            return this.isIdentifier(token);
        }

        private parseParameter(): ParameterSyntax {
            if (this.currentNode() !== null && this.currentNode().kind() === SyntaxKind.Parameter) {
                return <ParameterSyntax>this.eatNode();
            }

            var dotDotDotToken = this.tryEatToken(SyntaxKind.DotDotDotToken);

            var publicOrPrivateToken: ISyntaxToken = null;
            if (this.currentToken().tokenKind === SyntaxKind.PublicKeyword ||
                this.currentToken().tokenKind === SyntaxKind.PrivateKeyword) {
                publicOrPrivateToken = this.eatAnyToken();
            }

            var identifier = this.eatIdentifierToken();
            var questionToken = this.tryEatToken(SyntaxKind.QuestionToken);
            var typeAnnotation = this.parseOptionalTypeAnnotation();

            var equalsValueClause: EqualsValueClauseSyntax = null;
            if (this.isEqualsValueClause()) {
                equalsValueClause = this.parseEqualsValuesClause(/*allowIn:*/ true);
            }

            return this.factory.parameter(
                dotDotDotToken, publicOrPrivateToken, identifier, questionToken, typeAnnotation, equalsValueClause);
        }

        private parseSyntaxList(currentListType: ListParsingState,
                                processItems: (parser: ParserImpl, items: any[]) => void = null): { skippedTokens: ISyntaxToken[]; list: ISyntaxList; } {
            var savedListParsingState = this.listParsingState;
            this.listParsingState |= currentListType;

            var result = this.parseSyntaxListWorker(currentListType, processItems);

            this.listParsingState = savedListParsingState;

            return result;
        }

        private parseSeparatedSyntaxList(currentListType: ListParsingState): { skippedTokens: ISyntaxToken[]; list: ISeparatedSyntaxList; } {
            var savedListParsingState = this.listParsingState;
            this.listParsingState |= currentListType;

            var result = this.parseSeparatedSyntaxListWorker(currentListType);

            this.listParsingState = savedListParsingState;

            return result;
        }

        // Returns true if we should abort parsing.
        private abortParsingListOrMoveToNextToken(currentListType: ListParsingState,
                                                  itemCount: number,
                                                  items: ISyntaxNodeOrToken[],
                                                  skippedTokens: ISyntaxToken[]): bool {
            // Ok.  We're at a token that is not a terminator for the list and wasn't the start of 
            // an item in the list. Definitely report an error for this token.
            this.reportUnexpectedTokenDiagnostic(currentListType);

            // Now, check if the token is a terminator for one our parent lists, or the start of an
            // item in one of our parent lists.  If so, we won't want to consume the token.  We've 
            // already reported the error, so just return to our caller so that a higher up 
            // production can consume it.
            for (var state = ListParsingState.LastListParsingState;
                 state >= ListParsingState.FirstListParsingState;
                 state >>= 1) {

                if ((this.listParsingState & state) !== 0) {
                    if (this.isExpectedListTerminator(state, itemCount) || this.isExpectedListItem(state, /*inErrorRecovery:*/ true)) {
                        // Abort parsing this list.
                        return true;
                    }
                }
            }

            // Otherwise, if none of the lists we're in can capture this token, then we need to 
            // unilaterally skip it.  Note: we've already reported an error above.
            var skippedToken = this.currentToken();

            // Consume this token and move onto the next item in the list.
            this.moveToNextToken();

            this.addSkippedTokenToList(items, skippedTokens, skippedToken);

            // Continue parsing this list.  Attach this token to whatever we've seen already.
            return false;
        }
        
        private addSkippedTokenToList(items: ISyntaxNodeOrToken[], skippedTokens: ISyntaxToken[], skippedToken: ISyntaxToken): void {
            // Now, add this skipped token to the last item we successfully parsed in the list.  Or
            // add it to the list of skipped tokens if we haven't parsed anything.  Our caller will
            // have to deal with them.
            for (var i = items.length - 1; i >= 0; i--) {
                var item = items[i];
                var lastToken = item.lastToken();
                if (lastToken.fullWidth() > 0) {
                    items[i] = this.addSkippedTokenAfterNodeOrToken(item, skippedToken);
                    return;
                }
            }
            
            // Didn't have anything in the list we could add to.  Add to the skipped items array
            // for our caller to handle.
            skippedTokens.push(skippedToken);
        }

        private tryParseExpectedListItem(currentListType: ListParsingState,
                                         inErrorRecovery: bool,
                                         items: ISyntaxElement[],
                                         processItems: (parser: ParserImpl, items: any[]) => void ): void {
            if (this.isExpectedListItem(currentListType, inErrorRecovery)) {
                var item = this.parseExpectedListItem(currentListType);
                Debug.assert(item !== null);

                items.push(item);

                if (processItems !== null) {
                    processItems(this, items);
                }
            }
        }

        private listIsTerminated(currentListType: ListParsingState, itemCount: number): bool {
            return this.isExpectedListTerminator(currentListType, itemCount) ||
                   this.currentToken().tokenKind === SyntaxKind.EndOfFileToken;
        }

        private arrayPool: any[][] = [];
        private getArray(): any[] {
            if (this.arrayPool.length > 0) {
                return this.arrayPool.pop();
            }

            return [];
        }

        private returnArray(array: any[]) {
            array .length = 0;
            this.arrayPool.push(array);
        }

        private parseSyntaxListWorker(currentListType: ListParsingState,
                                      processItems: (parser: ParserImpl, items: any[]) => void ): { skippedTokens: ISyntaxToken[]; list: ISyntaxList; } {
            var items: SyntaxNode[] = this.getArray();
            var skippedTokens: ISyntaxToken[] = this.getArray();

            while (true) {
                // Try to parse an item of the list.  If we fail then decide if we need to abort or 
                // continue parsing.
                var oldItemsCount = items.length;
                this.tryParseExpectedListItem(currentListType, /*inErrorRecovery:*/ false, items, processItems);

                var newItemsCount = items.length;
                if (newItemsCount === oldItemsCount) {
                    // We weren't able to parse out a list element.

                    // That may have been because the list is complete.  In that case, break out 
                    // and return the items we were able parse.
                    if (this.listIsTerminated(currentListType, newItemsCount)) {
                        break
                    }

                    // List wasn't complete and we didn't get an item.  Figure out if we should bail out
                    // or skip a token and continue.
                    var abort = this.abortParsingListOrMoveToNextToken(currentListType, newItemsCount, items, skippedTokens);
                    if (abort) {
                        break;
                    }
                }

                // We either parsed an element.  Or we failed to, but weren't at the end of the list
                // and didn't want to abort. Continue parsing elements.
            }

            var result = Syntax.list(items);

            // Can't return if it has more then 1 element.  In that case, the list will have been
            // copied into the SyntaxList.
            if (items.length <= 1) {
                this.returnArray(items);
            }

            return { skippedTokens: skippedTokens, list: result };
        }

        private parseSeparatedSyntaxListWorker(currentListType: ListParsingState): { skippedTokens: ISyntaxToken[]; list: ISeparatedSyntaxList; } {
            var items: ISyntaxNodeOrToken[] = this.getArray();
            var skippedTokens: ISyntaxToken[] = this.getArray();

            var allowAutomaticSemicolonInsertion = this.allowsAutomaticSemicolonInsertion(currentListType);
            var separatorKind = this.separatorKind(currentListType);

            var inErrorRecovery = false;
            var listWasTerminated = false;
            while (true) {
                // Try to parse an item of the list.  If we fail then decide if we need to abort or 
                // continue parsing.
                var oldItemsCount = items.length;
                Debug.assert(oldItemsCount % 2 === 0);
                this.tryParseExpectedListItem(currentListType, inErrorRecovery, items, null);
                
                var newItemsCount = items.length;
                if (newItemsCount === oldItemsCount) {
                    // We weren't able to parse out a list element.
                    Debug.assert(items === null || items.length % 2 === 0);
                    
                    // That may have been because the list is complete.  In that case, break out 
                    // and return the items we were able parse.
                    if (this.listIsTerminated(currentListType, newItemsCount)) {
                        listWasTerminated = true;
                        break;
                    }
                    
                    // List wasn't complete and we didn't get an item.  Figure out if we should bail out
                    // or skip a token and continue.
                    var abort = this.abortParsingListOrMoveToNextToken(currentListType, oldItemsCount, items, skippedTokens);
                    if (abort) {
                        break;
                    }
                    else {
                        // We just skipped a token.  We're now in error recovery mode.
                        inErrorRecovery = true;
                        continue;
                    }
                }

                Debug.assert(newItemsCount % 2 === 1);

                // We were able to successfully parse out a list item.  So we're no longer in error
                // recovery.
                inErrorRecovery = false;

                // Now, we have to see if we have a separator or not.  If we do have a separator
                // we've got to consume it and continue trying to parse list items.
                if (this.currentToken().tokenKind === separatorKind) {
                    // Consume the last separator and continue parsing list elements.
                    items.push(this.eatToken(separatorKind));
                    continue;
                }

                // We didn't see the expected separator.  There are two reasons this might happen.
                // First, we may actually be at the end of the list.  If we are, then we're done
                // parsing list elements.  
                if (this.listIsTerminated(currentListType, newItemsCount)) {
                    listWasTerminated = true;
                    break;
                }

                // Otherwise, it might be a case where we can parse out an implicit semicolon.

                // Note: it's important that we check this *after* the check above for
                // 'listIsTerminated'.  Consider the following case:
                //
                //      {
                //          a       // <-- just finished parsing 'a'
                //      }
                //
                // Automatic semicolon insertion rules state: "When, as the program is parsed from
                // left to right, a token (called the offending token) is encountered that is not 
                // allowed by any production of the grammar".  So we should only ever insert a 
                // semicolon if we couldn't consume something normally.  in the above case, we can
                // consume the '}' just fine.  So ASI doesn't apply.

                if (allowAutomaticSemicolonInsertion && this.canEatAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                    items.push(this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
                    Debug.assert(items.length % 2 === 0);
                    continue;
                }

                // We weren't at the end of the list.  And thre was no separator we could parse out.
                // Try parse the separator we expected, and continue parsing more list elements.
                // This time mark that we're in error recovery mode though.
                //
                // Note: trying to eat this token will emit the appropriate diagnostic.
                items.push(this.eatToken(separatorKind));

                // Now that we're in 'error recovery' mode we cantweak some parsing rules as 
                // appropriate.  For example, if we have:
                //
                //      var v = { a
                //      return
                //
                // Then we'll be missing the comma.  As such, we want to parse 'return' in a less
                // tolerant manner.  Normally 'return' could be a property in an object literal.
                // However, in error recovery mode, we do *not* want it to be.
                //
                // Continue trying to parse out list elements.
                inErrorRecovery = true;
            }

            // Now that we're done parsing, ensure the list is properly formed.
            var allowTrailingSeparator = this.allowsTrailingSeparator(currentListType);
            var requiresAtLeastOneItem = this.requiresAtLeastOneItem(currentListType);

            // If this list requires at least one argument, then report an error if we haven't 
            // gotten any.
            if (requiresAtLeastOneItem && items.length === 0) {
                this.reportUnexpectedTokenDiagnostic(currentListType);
            }
            else {
                // If the list ended with a trailing separator, and that's not allowed, then report
                // an error for it.  Only do this if the list was successfully terminated.  We don't
                // want to report multiple errors if we're missing the closing terminator and we 
                // have a trailing separator.
                if (listWasTerminated &&
                    !allowTrailingSeparator &&
                    items.length > 0 &&
                    items.length % 2 === 0 &&
                    items[items.length - 1] === this.previousToken()) {

                    this.addDiagnostic(new SyntaxDiagnostic(
                        this.previousTokenStart(), this.previousToken().width(), DiagnosticCode.Trailing_separator_not_allowed, null));
                }
            }
            
            var result = Syntax.separatedList(items);

            // Can't return if it has more then 1 element.  In that case, the list will have been
            // copied into the SyntaxList.
            if (items.length <= 1) {
                this.returnArray(items);
            }

            return { skippedTokens: skippedTokens, list: result };
        }

        private allowsTrailingSeparator(currentListType: ListParsingState): bool {
            switch (currentListType) {
                case ListParsingState.EnumDeclaration_VariableDeclarators:
                case ListParsingState.ObjectType_TypeMembers:
                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return true;

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                case ListParsingState.ArgumentList_AssignmentExpressions:
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                case ListParsingState.ParameterList_Parameters:
                    // TODO: It would be great to allow trailing separators for parameters.
                case ListParsingState.TypeArgumentList_Types:
                case ListParsingState.TypeParameterList_TypeParameters:
                    return false;

                case ListParsingState.SourceUnit_ModuleElements:
                case ListParsingState.ClassDeclaration_ClassElements:
                case ListParsingState.ModuleDeclaration_ModuleElements:
                case ListParsingState.SwitchStatement_SwitchClauses:
                case ListParsingState.SwitchClause_Statements:
                case ListParsingState.Block_Statements:
                default:
                    throw Errors.notYetImplemented();
            }
        }

        private requiresAtLeastOneItem(currentListType: ListParsingState): bool {
            switch (currentListType) {
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                case ListParsingState.TypeArgumentList_Types:
                case ListParsingState.TypeParameterList_TypeParameters:
                    return true;

                case ListParsingState.ObjectType_TypeMembers:
                case ListParsingState.EnumDeclaration_VariableDeclarators:
                case ListParsingState.ArgumentList_AssignmentExpressions:
                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                case ListParsingState.ParameterList_Parameters:
                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return false;

                case ListParsingState.SourceUnit_ModuleElements:
                case ListParsingState.ClassDeclaration_ClassElements:
                case ListParsingState.ModuleDeclaration_ModuleElements:
                case ListParsingState.SwitchStatement_SwitchClauses:
                case ListParsingState.SwitchClause_Statements:
                case ListParsingState.Block_Statements:
                default:
                    throw Errors.notYetImplemented();
            }
        }

        private allowsAutomaticSemicolonInsertion(currentListType: ListParsingState): bool {
            switch (currentListType) {
                case ListParsingState.ObjectType_TypeMembers:
                    return true;

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                case ListParsingState.EnumDeclaration_VariableDeclarators:
                case ListParsingState.ArgumentList_AssignmentExpressions:
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                case ListParsingState.ParameterList_Parameters:
                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                case ListParsingState.TypeArgumentList_Types:
                case ListParsingState.TypeParameterList_TypeParameters:
                    return false;

                case ListParsingState.SourceUnit_ModuleElements:
                case ListParsingState.ClassDeclaration_ClassElements:
                case ListParsingState.ModuleDeclaration_ModuleElements:
                case ListParsingState.SwitchStatement_SwitchClauses:
                case ListParsingState.SwitchClause_Statements:
                case ListParsingState.Block_Statements:
                default:
                    throw Errors.notYetImplemented();
            }
        }

        private separatorKind(currentListType: ListParsingState): SyntaxKind {
            switch (currentListType) {
                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                case ListParsingState.ArgumentList_AssignmentExpressions:
                case ListParsingState.EnumDeclaration_VariableDeclarators:
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                case ListParsingState.ParameterList_Parameters:
                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                case ListParsingState.TypeArgumentList_Types:
                case ListParsingState.TypeParameterList_TypeParameters:
                    return SyntaxKind.CommaToken;

                case ListParsingState.ObjectType_TypeMembers:
                    return SyntaxKind.SemicolonToken;

                case ListParsingState.SourceUnit_ModuleElements:
                case ListParsingState.ClassDeclaration_ClassElements:
                case ListParsingState.ModuleDeclaration_ModuleElements:
                case ListParsingState.SwitchStatement_SwitchClauses:
                case ListParsingState.SwitchClause_Statements:
                case ListParsingState.Block_Statements:
                default:
                    throw Errors.notYetImplemented();
            }
        }

        private reportUnexpectedTokenDiagnostic(listType: ListParsingState): void {
            var token = this.currentToken();

            var diagnostic = new SyntaxDiagnostic(
                this.currentTokenStart(), token.width(), DiagnosticCode.Unexpected_token__0_expected, [this.getExpectedListElementType(listType)]);
            this.addDiagnostic(diagnostic);
        }

        private addDiagnostic(diagnostic: SyntaxDiagnostic): void {
            // Except: if we already have a diagnostic for this position, don't report another one.
            if (this.diagnostics.length > 0 &&
                this.diagnostics[this.diagnostics.length - 1].position() === diagnostic.position()) {
                return;
            }

            this.diagnostics.push(diagnostic);
        }

        private isExpectedListTerminator(currentListType: ListParsingState, itemCount: number): bool {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return this.isExpectedSourceUnit_ModuleElementsTerminator();

                case ListParsingState.ClassDeclaration_ClassElements:
                    return this.isExpectedClassDeclaration_ClassElementsTerminator();

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return this.isExpectedModuleDeclaration_ModuleElementsTerminator();

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return this.isExpectedSwitchStatement_SwitchClausesTerminator();

                case ListParsingState.SwitchClause_Statements:
                    return this.isExpectedSwitchClause_StatementsTerminator();

                case ListParsingState.Block_Statements:
                    return this.isExpectedBlock_StatementsTerminator();

                case ListParsingState.TryBlock_Statements:
                    return this.isExpectedTryBlock_StatementsTerminator();

                case ListParsingState.CatchBlock_Statements:
                    return this.isExpectedCatchBlock_StatementsTerminator();

                case ListParsingState.EnumDeclaration_VariableDeclarators:
                    return this.isExpectedEnumDeclaration_VariableDeclaratorsTerminator();

                case ListParsingState.ObjectType_TypeMembers:
                    return this.isExpectedObjectType_TypeMembersTerminator();

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return this.isExpectedArgumentList_AssignmentExpressionsTerminator();

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                    return this.isExpectedExtendsOrImplementsClause_TypeNameListTerminator();

                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                    return this.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator(itemCount);

                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    return this.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator();

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return this.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator();

                case ListParsingState.ParameterList_Parameters:
                    return this.isExpectedParameterList_ParametersTerminator();

                case ListParsingState.TypeArgumentList_Types:
                    return this.isExpectedTypeArgumentList_TypesTerminator();

                case ListParsingState.TypeParameterList_TypeParameters:
                    return this.isExpectedTypeParameterList_TypeParametersTerminator();

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return this.isExpectedLiteralExpression_AssignmentExpressionsTerminator();

                default:
                    throw Errors.invalidOperation();
            }
        }

        private isExpectedSourceUnit_ModuleElementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.EndOfFileToken;
        }

        private isExpectedEnumDeclaration_VariableDeclaratorsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedModuleDeclaration_ModuleElementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedObjectType_TypeMembersTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedLiteralExpression_AssignmentExpressionsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBracketToken;
        }

        private isExpectedTypeArgumentList_TypesTerminator(): bool {
            var token = this.currentToken();
            if (token.tokenKind === SyntaxKind.GreaterThanToken) {
                return true;
            }

            // If we're at a token that can follow the type argument list, then we'll also consider
            // the list terminated.
            if (this.canFollowTypeArgumentListInExpression(token.tokenKind)) {
                return true;
            }

            // TODO: add more cases as necessary for error tolerance.
            return false;
        }

        private isExpectedTypeParameterList_TypeParametersTerminator(): bool {
            var token = this.currentToken();
            if (token.tokenKind === SyntaxKind.GreaterThanToken) {
                return true;
            }

            // These commonly follow type parameter lists.
            if (token.tokenKind === SyntaxKind.OpenParenToken ||
                token.tokenKind === SyntaxKind.OpenBraceToken ||
                token.tokenKind === SyntaxKind.ExtendsKeyword ||
                token.tokenKind === SyntaxKind.ImplementsKeyword) {
                return true;
            }

            // TODO: add more cases as necessary for error tolerance.
            return false;
        }

        private isExpectedParameterList_ParametersTerminator(): bool {
            var token = this.currentToken();
            if (token.tokenKind === SyntaxKind.CloseParenToken) {
                return true;
            }

            // We may also see a { in an error case.  i.e.:
            // function (a, b, c  {
            if (token.tokenKind === SyntaxKind.OpenBraceToken) {
                return true;
            }

            // We may also see a => in an error case.  i.e.:
            // (f: number => { ... }
            if (token.tokenKind === SyntaxKind.EqualsGreaterThanToken) {
                return true;
            }

            return false;
        }

        private isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator(): bool {
            // This is the case when we're parsing variable declarations in a for/for-in statement.
            if (this.currentToken().tokenKind === SyntaxKind.SemicolonToken ||
                this.currentToken().tokenKind === SyntaxKind.CloseParenToken) {
                return true;
            }

            if (this.currentToken().tokenKind === SyntaxKind.InKeyword) {
                return true;
            }

            return false;
        }

        private isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator(itemCount: number): bool {
            //// This is the case when we're parsing variable declarations in a variable statement.

            // If we just parsed a comma, then we can't terminate this list.  i.e.:
            //      var a = bar, // <-- just consumed the comma
            //          b = baz;
            if (this.previousToken().tokenKind === SyntaxKind.CommaToken) {
                return false;
            }

            // ERROR RECOVERY TWEAK:
            // For better error recovery, if we see a => then we just stop immediately.  We've got an
            // arrow function here and it's going to be veyr unlikely that we'll resynchronize and get
            // another variable declaration.
            if (this.currentToken().tokenKind === SyntaxKind.EqualsGreaterThanToken) {
                return true;
            }

            // We're done when we can eat a semicolon and we've parsed at least one item.
            return itemCount > 0 && this.canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
        }

        private isExpectedExtendsOrImplementsClause_TypeNameListTerminator(): bool {
            if (this.currentToken().tokenKind === SyntaxKind.ExtendsKeyword ||
                this.currentToken().tokenKind === SyntaxKind.ImplementsKeyword) {
                return true;
            }

            if (this.currentToken().tokenKind === SyntaxKind.OpenBraceToken ||
                this.currentToken().tokenKind === SyntaxKind.CloseBraceToken) {
                return true;
            }

            return false;
        }

        private isExpectedArgumentList_AssignmentExpressionsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseParenToken;
        }

        private isExpectedClassDeclaration_ClassElementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedSwitchStatement_SwitchClausesTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedSwitchClause_StatementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken ||
                   this.isSwitchClause();
        }

        private isExpectedBlock_StatementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedTryBlock_StatementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CatchKeyword ||
                   this.currentToken().tokenKind === SyntaxKind.FinallyKeyword;
        }

        private isExpectedCatchBlock_StatementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.FinallyKeyword;
        }

        private isExtendsOrImplementsClause(): bool {
            if (this.currentToken().tokenKind === SyntaxKind.ImplementsKeyword ||
                this.currentToken().tokenKind === SyntaxKind.ExtendsKeyword) {

                return this.isIdentifier(this.peekToken(1));
            }

            return false;
        }

        private isExtendsOrImplementsClauseTypeName(): bool {
            if (this.isName()) {
                // We want to make sure that the "extends" in "extends foo" or the "implements" in
                // "implements foo" is not considered a type name.
                return !this.isExtendsOrImplementsClause();
            }

            return false;
        }

        private isExpectedListItem(currentListType: ListParsingState, inErrorRecovery: bool): any {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return this.isModuleElement();

                case ListParsingState.ClassDeclaration_ClassElements:
                    return this.isClassElement();

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return this.isModuleElement();

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return this.isSwitchClause();

                case ListParsingState.SwitchClause_Statements:
                    return this.isStatement();

                case ListParsingState.Block_Statements:
                    return this.isStatement();

                case ListParsingState.TryBlock_Statements:
                case ListParsingState.CatchBlock_Statements:
                    // These two are special.  They're just augmentations of "Block_Statements" 
                    // used so we can abort out of the try block if we see a 'catch' or 'finally'
                    // keyword.  There are no additional list items that they add, so we just
                    // return 'false' here.
                    return false;

                case ListParsingState.EnumDeclaration_VariableDeclarators:
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    return this.isVariableDeclarator();

                case ListParsingState.ObjectType_TypeMembers:
                    return this.isTypeMember();

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return this.isExpression();

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                    return this.isExtendsOrImplementsClauseTypeName();

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return this.isPropertyAssignment(inErrorRecovery);

                case ListParsingState.ParameterList_Parameters:
                    return this.isParameter();

                case ListParsingState.TypeArgumentList_Types:
                    return this.isType(/*allowFunctionType:*/ true, /*allowConstructorType:*/ true);

                case ListParsingState.TypeParameterList_TypeParameters:
                    return this.isTypeParameter();

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return this.isAssignmentOrOmittedExpression();

                default:
                    throw Errors.invalidOperation();
            }
        }

        private parseExpectedListItem(currentListType: ListParsingState): ISyntaxNodeOrToken {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return this.parseModuleElement();

                case ListParsingState.ClassDeclaration_ClassElements:
                    return this.parseClassElement();

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return this.parseModuleElement();

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return this.parseSwitchClause();

                case ListParsingState.SwitchClause_Statements:
                    return this.parseStatement();

                case ListParsingState.Block_Statements:
                    return this.parseStatement();

                case ListParsingState.EnumDeclaration_VariableDeclarators:
                    return this.parseVariableDeclarator(/*allowIn:*/ true);

                case ListParsingState.ObjectType_TypeMembers:
                    return this.parseTypeMember();

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return this.parseAssignmentExpression(/*allowIn:*/ true);

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                    return this.parseNameOrGenericType();

                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                    return this.parseVariableDeclarator(/*allowIn:*/ true);

                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    return this.parseVariableDeclarator(/*allowIn:*/ false);

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return this.parsePropertyAssignment();

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return this.parseAssignmentOrOmittedExpression();

                case ListParsingState.ParameterList_Parameters:
                    return this.parseParameter();

                case ListParsingState.TypeArgumentList_Types:
                    return this.parseType(/*requireCompleteArraySuffix:*/ false);

                case ListParsingState.TypeParameterList_TypeParameters:
                    return this.parseTypeParameter();

                default:
                    throw Errors.invalidOperation();
            }
        }

        private getExpectedListElementType(currentListType: ListParsingState): string {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return Strings.module__class__interface__enum__import_or_statement;

                case ListParsingState.ClassDeclaration_ClassElements:
                    return Strings.constructor__function__accessor_or_variable;

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return Strings.module__class__interface__enum__import_or_statement;

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return Strings.case_or_default_clause;

                case ListParsingState.SwitchClause_Statements:
                    return Strings.statement;

                case ListParsingState.Block_Statements:
                    return Strings.statement;

                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                case ListParsingState.EnumDeclaration_VariableDeclarators:
                    return Strings.identifier;

                case ListParsingState.ObjectType_TypeMembers:
                    return Strings.call__construct__index__property_or_function_signature;

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return Strings.expression;

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                    return Strings.type_name;

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return Strings.property_or_accessor;

                case ListParsingState.ParameterList_Parameters:
                    return Strings.parameter;

                case ListParsingState.TypeArgumentList_Types:
                    return Strings.type;

                case ListParsingState.TypeParameterList_TypeParameters:
                    return Strings.type_parameter;

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return Strings.expression;

                default:
                    throw Errors.invalidOperation();
            }
        }
    }

    export function parse(text: ISimpleText,
                          languageVersion: LanguageVersion = LanguageVersion.EcmaScript5,
                          stringTable: Collections.StringTable = null,
                          options?: ParseOptions = null): SyntaxTree {
        var source = new NormalParserSource(text, languageVersion, stringTable);
        options = options || new ParseOptions();

        return new ParserImpl(source, options).parseSyntaxTree();
    }

    export function incrementalParse(oldSourceUnit: SourceUnitSyntax,
                                     textChangeRanges: TextChangeRange[],
                                     newText: ISimpleText,
                                     languageVersion: LanguageVersion = LanguageVersion.EcmaScript5,
                                     stringTable: Collections.StringTable = null,
                                     options?: ParseOptions = null): SyntaxTree {
        var source = new IncrementalParserSource(
            oldSourceUnit, textChangeRanges, newText, languageVersion, stringTable);
        options = options || new ParseOptions();

        return new ParserImpl(source, options).parseSyntaxTree();
    }
}
///<reference path='..\Core\ArrayUtilities.ts' />
///<reference path='CharacterCodes.ts' />
///<reference path='IText.ts' />
///<reference path='..\Core\StringUtilities.ts' />
///<reference path='..\Core\StringTable.ts' />

module TextFactory {
    function getLengthOfLineBreakSlow(text: IText, index: number, c: number): number {
        if (c === CharacterCodes.carriageReturn) {
            var next = index + 1;
            return (next < text.length()) && CharacterCodes.lineFeed === text.charCodeAt(next) ? 2 : 1;
        }
        else if (isAnyLineBreakCharacter(c)) {
            return 1;
        }
        else {
            return 0;
        }
    }

    function getLengthOfLineBreak(text: IText, index: number): number {
        var c = text.charCodeAt(index);

        // common case - ASCII & not a line break
        if (c > CharacterCodes.carriageReturn && c <= 127) {
            return 0;
        }

        return getLengthOfLineBreakSlow(text, index, c);
    }

    function isAnyLineBreakCharacter(c: number): bool {
        return c === CharacterCodes.lineFeed ||
               c === CharacterCodes.carriageReturn ||
               c === CharacterCodes.nextLine ||
               c === CharacterCodes.lineSeparator ||
               c === CharacterCodes.paragraphSeparator;
    }

    /// <summary>
    /// Return startLineBreak = index-1, lengthLineBreak = 2   if there is a \r\n at index-1
    /// Return startLineBreak = index,   lengthLineBreak = 1   if there is a 1-char newline at index
    /// Return startLineBreak = index+1, lengthLineBreak = 0   if there is no newline at index.
    /// </summary>
    function getStartAndLengthOfLineBreakEndingAt(
        text: IText, index: number, info: LinebreakInfo): void {

        var c = text.charCodeAt(index);
        if (c === CharacterCodes.lineFeed) {
            if (index > 0 && text.charCodeAt(index - 1) === CharacterCodes.carriageReturn) {
                // "\r\n" is the only 2-character line break.
                info.startPosition = index - 1;
                info.length = 2;
            }
            else {
                info.startPosition = index;
                info.length = 1;
            }
        }
        else if (isAnyLineBreakCharacter(c)) {
            info.startPosition = index;
            info.length = 1;
        }
        else {
            info.startPosition = index + 1;
            info.length = 0;
        }
    }

    class LinebreakInfo {
        constructor(public startPosition: number,
                     public length: number) {
        }
    }

    class TextLine implements ITextLine {
        private _text: IText = null;
        private _textSpan: TextSpan = null;
        private _lineBreakLength: number;
        private _lineNumber: number;

        constructor(text: IText, body: TextSpan, lineBreakLength: number, lineNumber: number) {
            Contract.throwIfNull(text);
            Contract.throwIfFalse(lineBreakLength >= 0);
            Contract.requires(lineNumber >= 0);
            this._text = text;
            this._textSpan = body;
            this._lineBreakLength = lineBreakLength;
            this._lineNumber = lineNumber;
        }

        public start(): number {
            return this._textSpan.start();
        }

        public end(): number {
            return this._textSpan.end();
        }

        public endIncludingLineBreak(): number {
            return this.end() + this._lineBreakLength;
        }

        public extent(): TextSpan {
            return this._textSpan;
        }

        public extentIncludingLineBreak(): TextSpan {
            return TextSpan.fromBounds(this.start(), this.endIncludingLineBreak());
        }

        public toString(): string {
            return this._text.toString(this._textSpan);
        }

        public lineNumber(): number {
            return this._lineNumber;
        }
    }

    class TextBase implements IText {
        /// <summary>
        /// The line start position of each line.
        /// </summary>
        private lazyLineStarts: number[] = null;

        /// <summary>
        /// The length of the text represented by <see cref="T:StringText"/>.
        /// </summary>
        public length(): number {
            throw Errors.abstract();
        }

        /// <summary>
        /// Returns a character at given position.
        /// </summary>
        /// <param name="position">The position to get the character from.</param>
        /// <returns>The character.</returns>
        /// <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
        /// greater than <see cref="T:"/> length.</exception>
        public charCodeAt(position: number): number {
            throw Errors.abstract();
        }

        checkSubSpan(span: TextSpan): void {
            if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                throw Errors.argumentOutOfRange("span");
            }
        }

        /// <summary>
        /// Provides a string representation of the StringText located within given span.
        /// </summary>
        /// <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        public toString(span?: TextSpan = null): string {
            throw Errors.abstract();
        }

        public subText(span: TextSpan): IText {
            this.checkSubSpan(span);

            return new SubText(this, span);
        }

        public substr(start: number, length: number, intern: bool): string {
            throw Errors.abstract();
        }

        /// <summary>
        /// Copy a range of characters from this IText to a destination array.
        /// </summary>
        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            throw Errors.abstract();
        }

        /// <summary>
        /// The length of the text represented by <see cref="T:StringText"/>.
        /// </summary>
        public lineCount(): number {
            return this.lineStarts().length;
        }

        /// <summary>
        /// The sequence of lines represented by <see cref="T:StringText"/>.
        /// </summary>
        public lines(): ITextLine[] {
            var lines: ITextLine[] = [];

            var length = this.lineCount();
            for (var i = 0; i < length; ++i) {
                lines[i] = this.getLineFromLineNumber(i);
            }

            return lines;
        }

        private lineStarts(): number[] {
            if (this.lazyLineStarts === null) {
                this.lazyLineStarts = this.parseLineStarts();
            }

            return this.lazyLineStarts;
        }

        private linebreakInfo = new LinebreakInfo(0, 0);
        public getLineFromLineNumber(lineNumber: number): ITextLine {
            var lineStarts = this.lineStarts();

            if (lineNumber < 0 || lineNumber >= lineStarts.length) {
                throw Errors.argumentOutOfRange("lineNumber");
            }

            var first = lineStarts[lineNumber];
            if (lineNumber === lineStarts.length - 1) {
                return new TextLine(this, new TextSpan(first, this.length() - first), 0, lineNumber);
            }
            else {
                getStartAndLengthOfLineBreakEndingAt(this, lineStarts[lineNumber + 1] - 1, this.linebreakInfo);
                return new TextLine(this, new TextSpan(first, this.linebreakInfo.startPosition - first), this.linebreakInfo.length, lineNumber);
            }

        }

        private lastLineFoundForPosition: ITextLine = null;
        public getLineFromPosition(position: number): ITextLine {
            // After asking about a location on a particular line
            // it is common to ask about other position in the same line again.
            // try to see if this is the case.
            var lastFound = this.lastLineFoundForPosition;
            if (lastFound !== null &&
                lastFound.start() <= position &&
                lastFound.endIncludingLineBreak() > position) {
                return lastFound;
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            var result = this.getLineFromLineNumber(lineNumber);
            this.lastLineFoundForPosition = result;
            return result;
        }

        public getLineNumberFromPosition(position: number): number {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }

            if (position === this.length()) {
                // this can happen when the user tried to get the line of items
                // that are at the absolute end of this text (i.e. the EndOfLine
                // token, or missing tokens that are at the end of the text).
                // In this case, we want the last line in the text.
                return this.lineCount() - 1;
            }

            // Binary search to find the right line
            var lineNumber = ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }

            return lineNumber;
        }

        public getLinePosition(position: number): LinePosition {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            return new LinePosition(lineNumber, position - this.lineStarts()[lineNumber]);
        }

        private parseLineStarts(): number[] {
            var length = this.length();

            // Corner case check
            if (0 === this.length()) {
                var result: number[] = [];
                result.push(0);
                return result;
            }

            var position = 0;
            var index = 0;
            var arrayBuilder: number[] = [];
            var lineNumber = 0;

            // The following loop goes through every character in the text. It is highly
            // performance critical, and thus inlines knowledge about common line breaks
            // and non-line breaks.
            while (index < length) {
                var c = this.charCodeAt(index);
                var lineBreakLength;

                // common case - ASCII & not a line break
                if (c > CharacterCodes.carriageReturn && c <= 127) {
                    index++;
                    continue;
                }
                else if (c === CharacterCodes.carriageReturn && index + 1 < length && this.charCodeAt(index + 1) === CharacterCodes.lineFeed) {
                    lineBreakLength = 2;
                }
                else if (c === CharacterCodes.lineFeed) {
                    lineBreakLength = 1;
                }
                else {
                    lineBreakLength = getLengthOfLineBreak(this, index);
                }

                if (0 === lineBreakLength) {
                    index++;
                }
                else {
                    arrayBuilder.push(position);
                    index += lineBreakLength;
                    position = index;
                    lineNumber++;
                }
            }

            // Create a start for the final line.  
            arrayBuilder.push(position);

            return arrayBuilder;
        }
    }

    /// <summary>
    /// An IText that represents a subrange of another IText.
    /// </summary>
    class SubText extends TextBase {
        private text: IText;
        private span: TextSpan;

        constructor(text: IText, span: TextSpan) {
            super();

            if (text === null) {
                throw Errors.argumentNull("text");
            }

            if (span.start() < 0 ||
                span.start() >= text.length() ||
                 span.end() < 0 ||
                 span.end() > text.length()) {
                throw Errors.argument("span");
            }

            this.text = text;
            this.span = span;
        }

        public length(): number {
            return this.span.length();
        }

        public charCodeAt(position: number): number {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }

            return this.text.charCodeAt(this.span.start() + position);
        }

        public subText(span: TextSpan): IText {
            this.checkSubSpan(span);

            return new SubText(this.text, this.getCompositeSpan(span.start(), span.length()));
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            var span = this.getCompositeSpan(sourceIndex, count);
            this.text.copyTo(span.start(), destination, destinationIndex, span.length());
        }

        private getCompositeSpan(start: number, length: number): TextSpan {
            var compositeStart = MathPrototype.min(this.text.length(), this.span.start() + start);
            var compositeEnd = MathPrototype.min(this.text.length(), compositeStart + length);
            return new TextSpan(compositeStart, compositeEnd - compositeStart);
        }
    }

    /// <summary>
    /// Implementation of IText based on a <see cref="T:System.String"/> input
    /// </summary>
    class StringText extends TextBase {
        /// <summary>
        /// Underlying string on which this IText instance is based
        /// </summary>
        private source: string = null;

        /// <summary>
        /// Initializes an instance of <see cref="T:StringText"/> with provided data.
        /// </summary>
        constructor(data: string) {
            super();

            if (data === null) {
                throw Errors.argumentNull("data");
            }

            this.source = data;
        }

        /// <summary>
        /// The length of the text represented by <see cref="T:StringText"/>.
        /// </summary>
        public length(): number {
            return this.source.length;
        }

        /// <summary>
        /// Returns a character at given position.
        /// </summary>
        /// <param name="position">The position to get the character from.</param>
        /// <returns>The character.</returns>
        /// <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
        /// greater than <see cref="T:"/> length.</exception>
        public charCodeAt(position: number): number {
            if (position < 0 || position >= this.source.length) {
                throw Errors.argumentOutOfRange("position");
            }

            return this.source.charCodeAt(position);
        }

        public substr(start: number, length: number, intern: bool) {
            return this.source.substr(start, length);
        }

        /// <summary>
        /// Provides a string representation of the StringText located within given span.
        /// </summary>
        /// <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        public toString(span?: TextSpan = null): string {
            if (span === null) {
                span = new TextSpan(0, this.length());
            }

            this.checkSubSpan(span);

            if (span.start() === 0 && span.length() === this.length()) {
                return this.source;
            }

            return this.source.substr(span.start(), span.length());
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            StringUtilities.copyTo(this.source, sourceIndex, destination, destinationIndex, count);
        }
    }

    var stringTable = Collections.createStringTable();



    /// <summary>
    /// An IText that represents a subrange of another IText.
    /// </summary>
    class SimpleSubText implements ISimpleText {
        private text: ISimpleText = null;
        private span: TextSpan = null;

        constructor(text: ISimpleText, span: TextSpan) {
            if (text === null) {
                throw Errors.argumentNull("text");
            }

            if (span.start() < 0 ||
                span.start() >= text.length() ||
                 span.end() < 0 ||
                 span.end() > text.length()) {
                throw Errors.argument("span");
            }

            this.text = text;
            this.span = span;
        }

        private checkSubSpan(span: TextSpan): void {
            if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                throw Errors.argumentOutOfRange("span");
            }
        }

        public length(): number {
            return this.span.length();
        }

        public subText(span: TextSpan): ISimpleText {
            this.checkSubSpan(span);

            return new SimpleSubText(this.text, this.getCompositeSpan(span.start(), span.length()));
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            var span = this.getCompositeSpan(sourceIndex, count);
            this.text.copyTo(span.start(), destination, destinationIndex, span.length());
        }

        public substr(start: number, length: number, intern: bool): string {
            var span = this.getCompositeSpan(start, length);
            return this.text.substr(span.start(), span.length(), intern);
        }

        private getCompositeSpan(start: number, length: number): TextSpan {
            var compositeStart = MathPrototype.min(this.text.length(), this.span.start() + start);
            var compositeEnd = MathPrototype.min(this.text.length(), compositeStart + length);
            return new TextSpan(compositeStart, compositeEnd - compositeStart);
        }
    }

    class SimpleStringText implements ISimpleText {
        constructor(private value: string) {
        }

        public length(): number {
            return this.value.length;
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            StringUtilities.copyTo(this.value, sourceIndex, destination, destinationIndex, count);
        }

        public substr(start: number, length: number, intern: bool): string {
            if (intern) {
                var array = ArrayUtilities.createArray(length, 0);
                this.copyTo(start, array, 0, length);
                return stringTable.addCharArray(array, 0, length);
            }

            return this.value.substr(start, length);
        }

        public subText(span: TextSpan): ISimpleText {
            return new SimpleSubText(this, span);
        }
    }

    export function createText(value: string): IText {
        return new StringText(value);
    }

    export function createSimpleText(value: string): ISimpleText {
        return new SimpleStringText(value);
    }

    export function createSimpleSubText(text: ISimpleText, span: TextSpan): ISimpleText {
        return new SimpleSubText(text, span);
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {
    export class DataMap {
        public map: any = {};

        public link(id: string, data: any) {
            this.map[id] = data;
        }

        public unlink(id: string) {
            this.map[id] = undefined;
        }

        //public unlinkChildren(ast:AST) {
        //    TypeScript.getAstWalkerFactory().walk(ast, (ast: AST, parent: AST): AST => { this.unlink(ast); });
        //}

        public read(id: string) {
            return this.map[id];
        }

        public flush() {
            this.map = {};
        }

        public unpatch() { return null; }
    }

    export class PatchedDataMap extends DataMap {
        public diffs: any = {};

        constructor(public parent: DataMap) {
            super();
        }

        public link(id: string, data: any) {
            this.diffs[id] = data;
        }

        public unlink(id: string) {
            this.diffs[id] = undefined;
        }

        public read(id: string) {

            var data = this.diffs[id];

            if (data) {
                return data;
            }

            return this.parent.read(id);
        }

        public flush() {
            this.diffs = {};
        }

        public unpatch() {
            this.flush();
            return this.parent;
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {

    export enum PullElementFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
        Optional = 1 << 8,
        Call = 1 << 9,
        Constructor = 1 << 10,
        Index = 1 << 11,
        Signature = 1 << 12,
        Enum = 1 << 13,
        FatArrow = 1 << 14,
        
        ClassConstructorVariable = 1 << 15,
        InitializedModule = 1 << 16,
        EnumVariable = 1 << 17,

        ImplicitVariable = ClassConstructorVariable | InitializedModule, /* | EnumVariable, */
    }

    export enum PullElementKind {
        None = 0,

        Script = 1,
        Global = 1 << 1,
        Primitive = 1 << 2,

        Container = 1 << 3,
        Class = 1 << 4,
        Interface = 1 << 5,
        DynamicModule = 1 << 6,
        Enum = 1 << 7,
        Array = 1 << 8,
        TypeAlias = 1 << 9,
        //TypeVariable = 1 << 10,

        Variable = 1 << 11,
        Parameter = 1 << 12,
        Property = 1 << 13,
        TypeParameter = 1 << 14,

        Function = 1 << 15,
        ConstructorMethod = 1 << 16,
        Method = 1 << 17,
        FunctionExpression = 1 << 18,

        GetAccessor = 1 << 19,
        SetAccessor = 1 << 20,

        CallSignature = 1 << 21,
        ConstructSignature = 1 << 22,
        IndexSignature = 1 << 23,
        
        ObjectType = 1 << 24,
        FunctionType = 1 << 25,
        ConstructorType = 1 << 26,

        SomeFunction = Function | ConstructorMethod | Method | FunctionExpression | GetAccessor | SetAccessor | CallSignature | ConstructSignature | IndexSignature,

        // Warning: SomeValue and SomeType (along with their constituents) must be disjoint
        SomeValue = Variable | Parameter | Property | SomeFunction,

        SomeType =  Script | Global | Primitive | Container | Class | Interface | DynamicModule | 
                    Enum | Array | TypeAlias | ObjectType | FunctionType | ConstructorType | TypeParameter,
        
        SomeSignature = CallSignature | ConstructSignature | IndexSignature,
    }

    export enum SymbolLinkKind {
        TypedAs,
        ContextuallyTypedAs,
        ProvidesInferredType,
        ArrayType,

        ArrayOf,

        PublicMember,
        PrivateMember,

        ConstructorMethod,

        Aliases,

        ContainedBy,

        Extends,
        Implements,

        Parameter,
        ReturnType,

        CallSignature,
        ConstructSignature,
        IndexSignature,

        TypeParameter,
        TypeArgument,
        TypeParameterSpecializedTo,
        SpecializedTo,
        TypeConstraint,
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript { 

    export var pullDeclID = 0;
    export var lastBoundPullDeclId = 0;

    export class DeclSpan {
        public minChar = 0;
        public limChar = 0;
    }

    export class PullDecl {
        private declType: PullElementKind;
        
        private declName: string;

        private symbol: PullSymbol = null;

        // use this to store the symbol for a parameter property
        private propertySymbol: PullSymbol = null;

        // use this to store the signature symbol for a function declaration
        private signatureSymbol: PullSignatureSymbol = null;
        
        private childDecls: PullDecl[] = [];
        private typeParameters: PullDecl[] = [];

        private childDeclTypeCache: any = new BlockIntrinsics();
        private childDeclValueCache: any = new BlockIntrinsics();
        private childDeclTypeParameterCache: any = new BlockIntrinsics();
        
        private declID = pullDeclID++;
        
        private declFlags: PullElementFlags = PullElementFlags.None;
        
        private span: DeclSpan;
        
        private scriptName: string;

        private errors: PullError[] = null;

        private parentDecl: PullDecl = null;

        // In the case of classes, initialized modules and enums, we need to track the implicit
        // value set to the constructor or instance type.  We can use this field to make sure that on
        // edits and updates we don't leak the val decl or symbol
        private synthesizedValDecl: PullDecl = null;

        constructor (declName: string, declType: PullElementKind, declFlags: PullElementFlags, span: DeclSpan, scriptName: string) {
            this.declName = declName;
            this.declType = declType;
            this.declFlags = declFlags;
            this.span = span;
            this.scriptName = scriptName;
        }

        public getDeclID() { return this.declID; }

        public getName() { return this.declName; }
        public getKind() { return this.declType}

        public setSymbol(symbol: PullSymbol) { this.symbol = symbol; }
        public getSymbol() { return this.symbol; }

        public setPropertySymbol(symbol: PullSymbol) { this.propertySymbol = symbol; }
        public getPropertySymbol() { return this.propertySymbol; }

        public setSignatureSymbol(signature: PullSignatureSymbol) { this.signatureSymbol = signature; }
        public getSignatureSymbol() { return this.signatureSymbol; }

        public getFlags() { return this.declFlags; }
        public setFlags(flags: PullElementFlags) { this.declFlags = flags; }
        
        public getSpan() { return this.span; }
        public setSpan(span: DeclSpan) { this.span = span; }
        
        public getScriptName() { return this.scriptName; }

        public setValueDecl(valDecl: PullDecl) { this.synthesizedValDecl = valDecl; }
        public getValueDecl() { return this.synthesizedValDecl; }

        public getParentDecl() {
            return this.parentDecl;
        }

        public addError(error: PullError) {
            if (!this.errors) {
                this.errors = [];
            }

            error.adjustOffset(this.span.minChar);

            this.errors[this.errors.length] = error;
        }

        public getErrors(): PullError[]{
            return this.errors;
        }

        public setErrors(errors: PullError[]) {
            this.errors = [];
            
            // adjust the spans as we parent the errors to the new decl
            for (var i = 0; i < errors.length; i++) {
                errors[i].adjustOffset(this.span.minChar);
                this.errors[this.errors.length] = errors[i];
            }
        }

        public resetErrors() {
            this.errors = [];
        }

        // returns 'true' if the child decl was successfully added
        // ('false' is returned if addIfDuplicate is false and there is a collision)
        public addChildDecl(childDecl: PullDecl, addIfDuplicate?=true) {
            // check if decl exists
            // merge if necessary
            var declName = childDecl.getName();

            if (!addIfDuplicate) { // PULLTODO: Check decl type?
                for (var i = 0; i < this.childDecls.length; i++) {
                    if (this.childDecls[i].getName() == declName) {
                        return false;
                    }
                }
            }

            if (childDecl.getKind() & PullElementKind.TypeParameter) {
                this.typeParameters[this.typeParameters.length] = childDecl;
            }
            else {
                this.childDecls[this.childDecls.length] = childDecl;
            }

            // add to the appropriate cache
            var cache = (childDecl.getKind() & PullElementKind.SomeType) ? (childDecl.getKind() & PullElementKind.TypeParameter) ? this.childDeclTypeParameterCache : this.childDeclTypeCache : this.childDeclValueCache;
            var cacheVal = <PullDecl[]>cache[declName];
            if (!cacheVal) {
                cacheVal = [];
            }
            cacheVal[cacheVal.length] = childDecl;

            cache[declName] = cacheVal;


            return true;
        }

        public findChildDecls(declName: string, declKind: PullElementKind): PullDecl[] {
            // find the decl with the optional type
            // if necessary, cache the decl
            // may be wise to return a chain of decls, or take a parent decl as a parameter
            var cache = (declKind & PullElementKind.SomeType) ? this.childDeclTypeCache : this.childDeclValueCache;
            var cacheVal = <PullDecl[]>cache[declName];

            if (cacheVal) {
                return cacheVal;
            }
            else {
                if (declKind & PullElementKind.SomeType) {
                    cacheVal = this.childDeclTypeParameterCache[declName];
                    
                    if (cacheVal) {
                        return cacheVal;
                    }                    
                }

                return [];
            }
        }

        public getChildDecls() { return this.childDecls; }
        public getTypeParameters() { return this.typeParameters; }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {

    export var pullSymbolID = 0
    export var lastBoundPullSymbolID = 0;

    export class PullSymbol {

        // private state
        private pullSymbolID = pullSymbolID++;

        private outgoingLinks: LinkList = new LinkList();
        private incomingLinks: LinkList = new LinkList();
        private declarations: LinkList = new LinkList();

        private name: string;

        private cachedDeclPath: string[];

        private declKind: PullElementKind;

        // caches - free these on invalidate
        private cachedContainerLink: PullSymbolLink = null;
        private cachedTypeLink: PullSymbolLink = null;

        private hasBeenResolved = false;

        private isOptional = false;

        public typeChangeUpdateVersion = -1;
        public addUpdateVersion = -1;
        public removeUpdateVersion = -1;

        // public surface area
        public getSymbolID() { return this.pullSymbolID; }

        public isType() {
            return (this.declKind & PullElementKind.SomeType) != 0;
        }

        public isSignature() {
            return (this.declKind & PullElementKind.SomeSignature) != 0;
        }

        public isArray() {
            return (this.declKind & PullElementKind.Array) != 0;
        }

        public isPrimitive() {
            return this.declKind == PullElementKind.Primitive;
        }

        constructor(name: string, declKind: PullElementKind) {
            this.name = name;
            this.declKind = declKind;
        }

        public getName() { return this.name; }

        public getKind() { return this.declKind; }
        public setKind(declType: PullElementKind) { this.declKind = declType; }

        public setIsOptional() { this.isOptional = true; }
        public getIsOptional() { return this.isOptional; }

        public setDeclPath(declPath: string[]) { this.cachedDeclPath = declPath; }
        public getDeclPath() { return this.cachedDeclPath; }

        // declaration methods
        public addDeclaration(decl: PullDecl) { this.declarations.addItem(decl); }

        public getDeclarations() { return <PullDecl[]>this.declarations.find(d => d); }

        public removeDeclaration(decl: PullDecl) { this.declarations.remove(d => d === decl); }

        public updateDeclarations(map: (item: PullDecl, context: any) => void , context: any) {
            this.declarations.update(map, context);
        }

        // link methods
        public addOutgoingLink(linkTo: PullSymbol, kind: SymbolLinkKind) {
            var link = new PullSymbolLink(this, linkTo, kind);
            this.outgoingLinks.addItem(link);
            linkTo.incomingLinks.addItem(link);

            return link;
        }

        public findOutgoingLinks(p: (psl: PullSymbolLink) => bool) {
            return <PullSymbolLink[]>this.outgoingLinks.find(p);
        }

        public findIncomingLinks(p: (psl: PullSymbolLink) => bool) {
            return <PullSymbolLink[]>this.incomingLinks.find(p);
        }

        public removeOutgoingLink(link: PullSymbolLink) {
            if (link) {
                this.outgoingLinks.remove(p => p === link);
                link.end.incomingLinks.remove(p => p === link);
            }
        }

        public updateOutgoingLinks(map: (item: PullSymbolLink, context: any) => void , context: any) {
            this.outgoingLinks.update(map, context);
        }

        public updateIncomingLinks(map: (item: PullSymbolLink, context: any) => void , context: any) {
            this.incomingLinks.update(map, context);
        }

        public setContainer(containerSymbol: PullTypeSymbol, relationshipKind: SymbolLinkKind) {
            //containerSymbol.addOutgoingLink(this, relationshipKind);

            var link = this.addOutgoingLink(containerSymbol, SymbolLinkKind.ContainedBy);
            this.cachedContainerLink = link;
        }

        public getContainer(): PullTypeSymbol {
            if (this.cachedContainerLink) {
                return <PullTypeSymbol>this.cachedContainerLink.end;
            }

            var containerList = this.findOutgoingLinks(link => link.kind == SymbolLinkKind.ContainedBy);

            if (containerList.length) {
                this.cachedContainerLink = containerList[0];
                return <PullTypeSymbol>this.cachedContainerLink.end;
            }

            return null;
        }

        public unsetContainer() {
            if (this.cachedContainerLink) {
                this.removeOutgoingLink(this.cachedContainerLink);
            }
            else {

                // PULLTODO: If we can guarantee that no link will exist without caching, we won't need to search
                var containerList = this.findOutgoingLinks(link => link.kind == SymbolLinkKind.ContainedBy);

                if (containerList.length) {
                    this.removeOutgoingLink(containerList[0]);
                }
            }

            this.invalidate();
        }

        public setType(typeRef: PullTypeSymbol) {

            // PULLTODO: Remove once we're certain that duplicate types can never be set
            //if (this.cachedTypeLink) {
            //    CompilerDiagnostics.Alert("Type '" + this.name + "' is having its type reset from '" + this.cachedTypeLink.end.getName() + "' to '" + typeRef.getName() + "'");
            //}

            var link = this.addOutgoingLink(typeRef, SymbolLinkKind.TypedAs);
            this.cachedTypeLink = link;
        }

        public getType(): PullTypeSymbol {
            if (this.cachedTypeLink) {
                return <PullTypeSymbol>this.cachedTypeLink.end;
            }

            var typeList = this.findOutgoingLinks(link => link.kind == SymbolLinkKind.TypedAs);

            if (typeList.length) {
                this.cachedTypeLink = typeList[0];
                return <PullTypeSymbol>this.cachedTypeLink.end;
            }

            return null;
        }

        public unsetType() {
            if (this.cachedTypeLink) {
                this.removeOutgoingLink(this.cachedTypeLink);
            }
            else {
                var typeList = this.findOutgoingLinks(link => link.kind == SymbolLinkKind.TypedAs);

                if (typeList.length) {
                    this.removeOutgoingLink(typeList[0]);
                }
            }

            this.invalidate();
        }

        public isTyped() {
            return this.getType() != null;
        }

        public setResolved() { this.hasBeenResolved = true; }
        public isResolved() { return this.hasBeenResolved; }

        // helper methods:
        // cacheInfo?

        // helper derived classes
        // PullClassSymbol
        // PullInterfaceSymbol
        // cache and convience methods
        public invalidate() {

            this.removeOutgoingLink(this.cachedContainerLink);
            this.removeOutgoingLink(this.cachedTypeLink);

            this.cachedContainerLink = null;

            this.hasBeenResolved = false;

            // reset the errors for its decl
            this.declarations.update((pullDecl: PullDecl) => pullDecl.resetErrors(), null);
        }

        public toString() {
            var str = this.name;

            var type = this.getType();

            if (type) {
                var typeName: string;
                if (type.isArray()) {
                    typeName = type.getElementType().getName() + "[]";
                }
                else {
                    typeName = type.getName();
                }
                str += ": " + typeName;
            }

            return this.name;
        }
    }

    // PULLTODO: Need a major cleanup of '[]' initializers!
    export class PullSignatureSymbol extends PullSymbol {
        private parameterLinks: PullSymbolLink[] = null;
        private typeParameterLinks: PullSymbolLink[] = null;

        private returnTypeLink: PullSymbolLink = null;

        private hasOptionalParam = false;
        private nonOptionalParamCount = 0;

        private specializationCache: any = {}

        constructor(kind: PullElementKind) {
            super("", kind);
        }

        public isDefinition() { return false; }
        public hasVariableParamList() { return this.hasOptionalParam; }

        public isGeneric() { return this.typeParameterLinks && this.typeParameterLinks.length != 0; }

        public addParameter(parameter: PullSymbol, isOptional = false) {
            if (!this.parameterLinks) {
                this.parameterLinks = [];
            }

            var link = this.addOutgoingLink(parameter, SymbolLinkKind.Parameter);
            this.parameterLinks[this.parameterLinks.length] = link;
            this.hasOptionalParam = isOptional;

            if (!isOptional) {
                this.nonOptionalParamCount++;
            }
        }

        public addSpecialization(signature: PullSignatureSymbol, typeArguments: PullTypeSymbol[]) {
            this.specializationCache[getIDForTypeSubstitutions(typeArguments)] = signature;
        }

        public getSpecialization(typeArguments): PullSignatureSymbol {
            var sig = <PullSignatureSymbol>this.specializationCache[getIDForTypeSubstitutions(typeArguments)];

            if (sig) {
                return sig;
            }

            return null;
        }

        public addTypeParameter(parameter: PullTypeParameterSymbol) {
            if (!this.typeParameterLinks) {
                this.typeParameterLinks = [];
            }

            var link = this.addOutgoingLink(parameter, SymbolLinkKind.TypeParameter);
            this.typeParameterLinks[this.typeParameterLinks.length] = link;
        }

        public getNonOptionalParameterCount() { return this.nonOptionalParamCount; }

        public setReturnType(returnType: PullTypeSymbol) {
            this.returnTypeLink = this.addOutgoingLink(returnType, SymbolLinkKind.ReturnType);
        }

        public getParameters() {
            var params: PullSymbol[] = [];

            if (this.parameterLinks) {
                for (var i = 0; i < this.parameterLinks.length; i++) {
                    params[params.length] = this.parameterLinks[i].end;
                }
            }

            return params;
        }

        public getTypeParameters() {
            var params: PullTypeParameterSymbol[] = [];

            if (this.typeParameterLinks) {
                for (var i = 0; i < this.typeParameterLinks.length; i++) {
                    params[params.length] = <PullTypeParameterSymbol>this.typeParameterLinks[i].end;
                }
            }

            return params;
        }

        public removeParameter(parameterSymbol: PullSymbol) {
            var paramLink: PullSymbolLink;

            if (this.parameterLinks) {
                for (var i = 0; i < this.parameterLinks.length; i++) {
                    if (parameterSymbol == this.parameterLinks[i].end) {
                        paramLink = this.parameterLinks[i];
                        this.removeOutgoingLink(paramLink);
                        break;
                    }
                }
            }

            this.invalidate();
        }

        public getReturnType(): PullTypeSymbol {
            if (this.returnTypeLink) {
                return <PullTypeSymbol> this.returnTypeLink.end;
            }
            else {
                var rtl = this.findOutgoingLinks((p) => p.kind == SymbolLinkKind.ReturnType);

                if (rtl.length) {
                    this.returnTypeLink = rtl[0];
                    return <PullTypeSymbol> this.returnTypeLink.end;
                }

                return null;
            }
        }

        // only the return type would change as a result of an invalidation
        // PULLTODO: Invalidate parameters?
        public invalidate() {
            this.removeOutgoingLink(this.returnTypeLink);
            this.returnTypeLink = null;

            this.parameterLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.Parameter);
            this.nonOptionalParamCount = 0;
            this.hasOptionalParam = false;

            // re-compute non-optional arg count, etc
            if (this.parameterLinks) {
                for (var i = 0; i < this.parameterLinks.length; i++) {
                    if (!this.parameterLinks[i].end.getIsOptional()) {
                        this.nonOptionalParamCount++;
                    }
                    else {
                        this.hasOptionalParam;
                        break;
                    }
                }
            }

            super.invalidate();
        }

        public toString() {
            var sigString = "(";
            var params = this.getParameters();
            var paramType: PullTypeSymbol;

            for (var i = 0; i < params.length; i++) {
                sigString += params[i].getName();

                paramType = params[i].getType();

                if (paramType) {
                    sigString += ": " + paramType.getName();
                }

                if (i < params.length - 1) {
                    sigString += ", ";
                }
            }
            sigString += ")";

            var returnType = this.getReturnType();

            if (returnType) {
                sigString += ": " + returnType.getName();
            }

            return sigString;
        }
    }

    export class PullTypeSymbol extends PullSymbol {
        private memberLinks: PullSymbolLink[] = null;
        private typeParameterLinks: PullSymbolLink[] = null;

        private memberNameCache: any = null;
        private memberTypeNameCache: any = null;
        private memberTypeParameterNameCache: any = null;
        private specializedTypeCache: any = null;

        private memberCache: PullSymbol[] = null;

        private implementedTypeLinks: PullSymbolLink[] = null;
        private extendedTypeLinks: PullSymbolLink[] = null;

        private callSignatureLinks: PullSymbolLink[] = null;
        private constructSignatureLinks: PullSymbolLink[] = null;
        private indexSignatureLinks: PullSymbolLink[] = null;

        private arrayType: PullTypeSymbol = null;

        private isSpecialized = false;
        private hasGenericSignature = false;

        public isType() { return true; }
        public isClass() { return false; }
        public hasMembers() { return this.memberLinks && this.memberLinks.length != 0; }
        public isFunction() { return false; }
        public isTypeParameter() { return false; }
        public isContainer() { return false; }

        public setIsSpecialized() { this.isSpecialized = true; }

        public getType() { return this; }

        public getArrayType() { return this.arrayType; }

        public getElementType(): PullTypeSymbol {
            var arrayOfLinks = this.findOutgoingLinks(link => link.kind == SymbolLinkKind.ArrayOf);
            
            if (arrayOfLinks.length) {
                return <PullTypeSymbol>arrayOfLinks[0].end;
            }

            return null;
        }
        public setArrayType(arrayType: PullTypeSymbol) {
            this.arrayType = arrayType;

            arrayType.addOutgoingLink(this, SymbolLinkKind.ArrayOf);
        }

        public addMember(memberSymbol: PullSymbol, linkKind: SymbolLinkKind) {

            var link = this.addOutgoingLink(memberSymbol, linkKind);

            memberSymbol.setContainer(this, linkKind);

            if (!this.memberNameCache) {
                this.memberNameCache = new BlockIntrinsics();
            }

            if (!this.memberLinks) {
                this.memberLinks = [];
            }

            if (!memberSymbol.isType()) {
                this.memberLinks[this.memberLinks.length] = link;

                if (!this.memberCache) {
                    this.memberCache = [];
                }
                this.memberCache[this.memberCache.length] = memberSymbol;

                if (!this.memberNameCache) {
                    this.memberNameCache = new BlockIntrinsics();
                }                
                this.memberNameCache[memberSymbol.getName()] = memberSymbol;
            }
            else {
                if ((<PullTypeSymbol>memberSymbol).isTypeParameter()) {
                    if (!this.typeParameterLinks) {
                        this.typeParameterLinks = [];
                    }
                    if (!this.memberTypeParameterNameCache) {
                        this.memberTypeParameterNameCache = new BlockIntrinsics();
                    }
                    this.typeParameterLinks[this.typeParameterLinks.length] = link;
                    this.memberTypeParameterNameCache[memberSymbol.getName()] = memberSymbol;
                }
                else {
                    if (!this.memberTypeNameCache) {
                        this.memberTypeNameCache = new BlockIntrinsics();
                    }
                    this.memberLinks[this.memberLinks.length] = link;
                    this.memberTypeNameCache[memberSymbol.getName()] = memberSymbol;
                    this.memberCache[this.memberCache.length] = memberSymbol;
                }
            }
        }

        public removeMember(memberSymbol: PullSymbol) {
            var memberLink: PullSymbolLink;
            var child: PullSymbol;

            var links = (memberSymbol.isType() && (<PullTypeSymbol>memberSymbol).isTypeParameter()) ? this.typeParameterLinks : this.memberLinks;

            if (links) {
                for (var i = 0; i < links.length; i++) {
                    if (memberSymbol == links[i].end) {
                        memberLink = links[i];
                        child = memberLink.end;
                        child.unsetContainer();
                        this.removeOutgoingLink(memberLink);
                        break;
                    }
                }
            }

            this.invalidate();
        }

        public getMembers(): PullSymbol[]{

            if (this.memberCache) {
                return this.memberCache;
            }
            else {
                var members: PullSymbol[] = [];

                if (this.memberLinks) {
                    for (var i = 0; i < this.memberLinks.length; i++) {
                        members[members.length] = this.memberLinks[i].end;
                    }
                }

                if (members.length) {
                    this.memberCache = members;
                }

                return members;
            }
        }

        public getTypeParameters(): PullTypeSymbol[] {
            var members: PullTypeSymbol[] = [];

            if (this.typeParameterLinks) {
                for (var i = 0; i < this.typeParameterLinks.length; i++) {
                    members[members.length] = <PullTypeSymbol>this.typeParameterLinks[i].end;
                }
            }

            return members;
        }

        public isGeneric(): bool { return (this.typeParameterLinks && this.typeParameterLinks.length != 0) || this.hasGenericSignature; }

        public addSpecialization(specializedVersionOfThisType: PullTypeSymbol, substitutingTypes: PullTypeSymbol[]): void {
            if (!this.specializedTypeCache) {
                this.specializedTypeCache = new BlockIntrinsics();
            }

            this.addOutgoingLink(specializedVersionOfThisType, SymbolLinkKind.SpecializedTo);

            this.specializedTypeCache[getIDForTypeSubstitutions(substitutingTypes)] = specializedVersionOfThisType;
        }

        public getSpecialization(substitutingTypes: PullTypeSymbol[]): PullTypeSymbol {
            if (!this.specializedTypeCache) {
                this.specializedTypeCache = new BlockIntrinsics();

                return null;
            }

            var specialization = <PullTypeSymbol>this.specializedTypeCache[getIDForTypeSubstitutions(substitutingTypes)];

            if (!specialization) {
                return null;
            }

            return specialization;
        }

        public addCallSignature(callSignature: PullSignatureSymbol) {

            if (!this.callSignatureLinks) {
                this.callSignatureLinks = [];
            }

            var link = this.addOutgoingLink(callSignature, SymbolLinkKind.CallSignature);
            this.callSignatureLinks[this.callSignatureLinks.length] = link;

            if (callSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        }

        public addCallSignatures(callSignatures: PullSignatureSymbol[]) {

            if (!this.callSignatureLinks) {
                this.callSignatureLinks = [];
            }

            for (var i = 0; i < callSignatures.length; i++) {
                this.addCallSignature(callSignatures[i]);
            }
        }

        public addConstructSignature(constructSignature: PullSignatureSymbol) {

            if (!this.constructSignatureLinks) {
                this.constructSignatureLinks = [];
            }

            var link = this.addOutgoingLink(constructSignature, SymbolLinkKind.ConstructSignature);
            this.constructSignatureLinks[this.constructSignatureLinks.length] = link;

            if (constructSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        }

        public addConstructSignatures(constructSignatures: PullSignatureSymbol[]) {

            if (!this.constructSignatureLinks) {
                this.constructSignatureLinks = [];
            }

            for (var i = 0; i < constructSignatures.length; i++) {
                this.addConstructSignature(constructSignatures[i]);
            }
        }

        public addIndexSignature(indexSignature: PullSignatureSymbol) {
            if (!this.indexSignatureLinks) {
                this.indexSignatureLinks = [];
            }

            var link = this.addOutgoingLink(indexSignature, SymbolLinkKind.IndexSignature);
            this.indexSignatureLinks[this.indexSignatureLinks.length] = link;

            if (indexSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        }

        public addIndexSignatures(indexSignatures: PullSignatureSymbol[]) {
            if (!this.indexSignatureLinks) {
                this.indexSignatureLinks = [];
            }

            for (var i = 0; i < indexSignatures.length; i++) {
                this.addIndexSignature(indexSignatures[i]);
            }
        }

        public getCallSignatures(): PullSignatureSymbol[] {
            var members: PullSymbol[] = [];

            if (this.callSignatureLinks) {
                for (var i = 0; i < this.callSignatureLinks.length; i++) {
                    members[members.length] = this.callSignatureLinks[i].end;
                }
            }

            return <PullSignatureSymbol[]>members;
        }

        public getConstructSignatures(): PullSignatureSymbol[] {
            var members: PullSymbol[] = [];

            if (this.constructSignatureLinks) {
                for (var i = 0; i < this.constructSignatureLinks.length; i++) {
                    members[members.length] = this.constructSignatureLinks[i].end;
                }
            }

            return <PullSignatureSymbol[]>members;
        }

        public getIndexSignatures(): PullSignatureSymbol[] {
            var members: PullSymbol[] = [];

            if (this.indexSignatureLinks) {
                for (var i = 0; i < this.indexSignatureLinks.length; i++) {
                    members[members.length] = this.indexSignatureLinks[i].end;
                }
            }

            return <PullSignatureSymbol[]>members;
        }

        public removeCallSignature(signature: PullSignatureSymbol, invalidate = true) {
            var signatureLink: PullSymbolLink;

            if (this.callSignatureLinks) {
                for (var i = 0; i < this.callSignatureLinks.length; i++) {
                    if (signature == this.callSignatureLinks[i].end) {
                        signatureLink = this.callSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }

            if (invalidate) {
                this.invalidate();
            }
        }

        public removeConstructSignature(signature: PullSignatureSymbol, invalidate = true) {
            var signatureLink: PullSymbolLink;

            if (this.constructSignatureLinks) {
                for (var i = 0; i < this.constructSignatureLinks.length; i++) {
                    if (signature == this.constructSignatureLinks[i].end) {
                        signatureLink = this.constructSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }

            if (invalidate) {
                this.invalidate();
            }
        }

        public removeIndexSignature(signature: PullSignatureSymbol, invalidate = true) {
            var signatureLink: PullSymbolLink;

            if (this.indexSignatureLinks) {
                for (var i = 0; i < this.indexSignatureLinks.length; i++) {
                    if (signature == this.indexSignatureLinks[i].end) {
                        signatureLink = this.indexSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }

            if (invalidate) {
                this.invalidate();
            }
        }

        public addImplementedType(interfaceType: PullTypeSymbol) {
            if (!this.implementedTypeLinks) {
                this.implementedTypeLinks = [];
            }

            var link = this.addOutgoingLink(interfaceType, SymbolLinkKind.Implements);
            this.implementedTypeLinks[this.implementedTypeLinks.length] = link;
        }

        public getImplementedTypes(): PullTypeSymbol[] {
            var members: PullSymbol[] = [];

            if (this.implementedTypeLinks) {
                for (var i = 0; i < this.implementedTypeLinks.length; i++) {
                    members[members.length] = this.implementedTypeLinks[i].end;
                }
            }

            return <PullTypeSymbol[]>members;
        }

        public removeImplementedType(implementedType: PullTypeSymbol) {
            var typeLink: PullSymbolLink;

            if (this.implementedTypeLinks) {
                for (var i = 0; i < this.implementedTypeLinks.length; i++) {
                    if (implementedType == this.implementedTypeLinks[i].end) {
                        typeLink = this.implementedTypeLinks[i];
                        this.removeOutgoingLink(typeLink);
                        break;
                    }
                }
            }

            this.invalidate();
        }

        public addExtendedType(extendedType: PullTypeSymbol) {
            if (!this.extendedTypeLinks) {
                this.extendedTypeLinks = [];
            }

            var link = this.addOutgoingLink(extendedType, SymbolLinkKind.Extends);
            this.extendedTypeLinks[this.extendedTypeLinks.length] = link;

            var parentMembers = extendedType.getMembers();

            // PULLTODO: Restrict member list to public properties only
            for (var i = 0; i < parentMembers.length; i++) {
                this.addMember(parentMembers[i], SymbolLinkKind.PublicMember);
            }
        }

        public getExtendedTypes(): PullTypeSymbol[] {
            var members: PullSymbol[] = [];

            if (this.extendedTypeLinks) {
                for (var i = 0; i < this.extendedTypeLinks.length; i++) {
                    members[members.length] = this.extendedTypeLinks[i].end;
                }
            }

            return <PullTypeSymbol[]>members;
        }

        public hasBase(potentialBase: PullTypeSymbol) {

            if (this == potentialBase) {
                return true;
            }

            var extendedTypes = this.getExtendedTypes();

            for (var i = 0; i < extendedTypes.length; i++) {
                if (extendedTypes[i].hasBase(potentialBase)) {
                    return true;
                }
            }

            return false;
        }

        public removeExtendedType(extendedType: PullTypeSymbol) {
            var typeLink: PullSymbolLink;

            if (this.extendedTypeLinks) {
                for (var i = 0; i < this.extendedTypeLinks.length; i++) {
                    if (extendedType == this.extendedTypeLinks[i].end) {
                        typeLink = this.extendedTypeLinks[i];
                        this.removeOutgoingLink(typeLink);
                        break;
                    }
                }
            }

            this.invalidate();
        }

        public findMember(name: string): PullSymbol {
            var memberSymbol: PullSymbol;

            if (!this.memberNameCache) {
                this.memberNameCache = new BlockIntrinsics();
                this.memberCache = [];

                if (this.memberLinks) {
                    for (var i = 0; i < this.memberLinks.length; i++) {
                        this.memberNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                        this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                    }
                }
            }

            memberSymbol = this.memberNameCache[name];

            if (memberSymbol) {
                return memberSymbol;
            }

            // check parents
            if (!memberSymbol && this.extendedTypeLinks) {

                for (var i = 0 ; i < this.extendedTypeLinks.length; i++) {
                    memberSymbol = (<PullTypeSymbol>this.extendedTypeLinks[i].end).findMember(name);

                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }

            if (!memberSymbol && this.implementedTypeLinks) {

                for (var i = 0 ; i < this.implementedTypeLinks.length; i++) {
                    memberSymbol = (<PullTypeSymbol>this.implementedTypeLinks[i].end).findMember(name);

                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }

            // when all else fails, look for a nested type name
            return this.findNestedType(name);
        }

        public findNestedType(name: string): PullTypeSymbol {
            var memberSymbol: PullTypeSymbol;

            if (!this.memberTypeNameCache) {
                this.memberTypeNameCache = new BlockIntrinsics();

                var setAll = false;

                if (!this.memberCache) {
                    this.memberCache = [];
                    setAll = true;
                }

                if (this.memberLinks) {
                    for (var i = 0; i < this.memberLinks.length; i++) {
                        if (this.memberLinks[i].end.isType()) {
                            this.memberTypeNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                            this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                        }
                        else if (setAll) {
                            this.memberNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                            this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                        }
                    }
                }
            }

            memberSymbol = this.memberTypeNameCache[name];

            return memberSymbol;
        }

        public findTypeParameter(name: string): PullTypeSymbol {
            var memberSymbol: PullTypeSymbol;

            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new BlockIntrinsics();

                if (this.typeParameterLinks) {
                    for (var i = 0; i < this.typeParameterLinks.length; i++) {
                        this.memberTypeParameterNameCache[this.typeParameterLinks[i].end.getName()] = this.typeParameterLinks[i].end;
                    }
                }
            }

            memberSymbol = this.memberTypeParameterNameCache[name];

            return memberSymbol;
        }

        public invalidate() {
            this.memberNameCache = null;
            this.memberCache = null;

            this.memberLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.PrivateMember ||
                                                              psl.kind == SymbolLinkKind.PublicMember);

            this.typeParameterLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.TypeParameter);

            this.callSignatureLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.CallSignature);

            this.constructSignatureLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.ConstructSignature);

            this.indexSignatureLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.IndexSignature);

            this.implementedTypeLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.Implements);

            this.extendedTypeLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.Extends);

            super.invalidate();
        }

        public toString() {
            var tstring = this.getName() + " { "
            var members = this.getMembers();
            var callSigs = this.getCallSignatures();
            var constructSigs = this.getConstructSignatures();
            var indexSigs = this.getIndexSignatures();

            for (var i = 0; i < members.length; i++) {
                tstring += members[i].toString();
                tstring += "; ";
            }

            for (i = 0; i < callSigs.length; i++) {
                tstring += callSigs[i].toString();
                tstring += "; ";
            }

            for (i = 0; i < constructSigs.length; i++) {
                tstring += "new " + constructSigs[i].toString();
                tstring += "; ";
            }

            for (i = 0; i < indexSigs.length; i++) {
                tstring += "[" + indexSigs[i].toString() + "]";
                tstring += "; ";
            }

            tstring += " }";
            return tstring;
        }
    }

    export class PullPrimitiveTypeSymbol extends PullTypeSymbol {
        constructor(name: string) {
            super(name, PullElementKind.Primitive);
        }

        public isResolved() { return true; }
        public invalidate() { }

        public toString() {
            return this.getName();
        }
    }

    // PULLTODO: Unify concepts of constructor method and container
    // type instance types
    export class PullClassTypeSymbol extends PullTypeSymbol {

        private constructorMethod: PullSymbol = null;

        constructor(name: string) {
            super(name, PullElementKind.Class);
        }

        public isClass() {
            return true;
        }

        public getConstructorMethod() {
            return this.constructorMethod;
        }

        public setConstructorMethod(constructorMethod: PullSymbol) {
            this.constructorMethod = constructorMethod;
        }

        public invalidate() {

            if (this.constructorMethod) {
                this.constructorMethod.invalidate();
            }

            super.invalidate();
        }
    }

    // represents the module "namespace" type
    export class PullContainerTypeSymbol extends PullTypeSymbol {
        public instanceSymbol: PullSymbol  = null;

        constructor(name: string) {
            super(name, PullElementKind.Container);
        }

        public isContainer() { return true; }

        public setInstanceSymbol(symbol: PullSymbol) {
            this.instanceSymbol = symbol;
        }

        public getInstanceSymbol(): PullSymbol {
            return this.instanceSymbol;
        }

        public invalidate() {
            if (this.instanceSymbol) {
                this.instanceSymbol.invalidate();
            }

            super.invalidate();
        }
    }

    export class PullDefinitionSignatureSymbol extends PullSignatureSymbol {
        public isDefinition() { return true; }
    }

    export class PullFunctionTypeSymbol extends PullTypeSymbol {
        private definitionSignature: PullDefinitionSignatureSymbol = null;

        constructor() {
            super("", PullElementKind.FunctionType);
        }

        public isFunction() { return true; }

        public invalidate(sweepForNewValues = false) {

            this.definitionSignature = null;

            super.invalidate();
        }

        public addSignature(signature: PullSignatureSymbol) {
            this.addCallSignature(signature);

            if (signature.isDefinition()) {
                this.definitionSignature = <PullDefinitionSignatureSymbol>signature;
            }
        }

        public getDefinitionSignature() { return this.definitionSignature; }
    }

    export class PullConstructorTypeSymbol extends PullTypeSymbol {
        private definitionSignature: PullDefinitionSignatureSymbol = null;

        constructor() {
            super("", PullElementKind.ConstructorType);
        }

        public isFunction() { return true; }
        public isConstructor() { return true; }

        public invalidate(sweepForNewValues = false) {

            this.definitionSignature = null;

            super.invalidate();
        }

        public addSignature(signature: PullSignatureSymbol) {
            this.addConstructSignature(signature);

            if (signature.isDefinition()) {
                this.definitionSignature = <PullDefinitionSignatureSymbol>signature;
            }
        }

        public addTypeParameter(typeParameter: PullTypeParameterSymbol) {

            this.addMember(typeParameter, SymbolLinkKind.TypeParameter);

            var constructSignatures = this.getConstructSignatures();

            for (var i = 0; i < constructSignatures.length; i++) {
                constructSignatures[i].addTypeParameter(typeParameter);
            }
        }

        public getDefinitionSignature() { return this.definitionSignature; }
    }

    export class PullTypeParameterSymbol extends PullTypeSymbol {
        private constraintLink: PullSymbolLink = null;

        constructor(name: string) {
            super(name, PullElementKind.TypeParameter);
        }

        public isTypeParameter() { return true; }

        public setConstraint(constraintType: PullTypeSymbol) {

            if (this.constraintLink) {
                this.removeOutgoingLink(this.constraintLink);
            }

            this.constraintLink = this.addOutgoingLink(constraintType, SymbolLinkKind.TypeConstraint);
        }

        public getConstraint(): PullTypeSymbol {
            if (this.constraintLink) {
                return <PullTypeSymbol>this.constraintLink.end;
            }

            return null;
        }

        public isGeneric() { return true; }

    }

    export class PullArrayTypeSymbol extends PullTypeSymbol {
        private elementType: PullTypeSymbol = null;

        public isArray() { return true; }
        public getElementType() { return this.elementType; }
        public isGeneric() { return true; }

        constructor() {
            super("Array", PullElementKind.Array);
        }

        public setElementType(type: PullTypeSymbol) {
            this.elementType = type;
        }

        public toString() {
            var elementTypeName = this.elementType ? this.elementType.getName() : "T";
            return "Array<" + elementTypeName + ">";
        }
    }

    // PULLTODO: This should be a part of the resolver class
    export function specializeToArrayType(typeToReplace: PullTypeSymbol, typeToSpecializeTo: PullTypeSymbol, resolver: PullTypeResolver, context: PullTypeResolutionContext) {

        var arrayInterfaceType = resolver.getCachedArrayType();

        // For the time-being, only specialize interface types
        // this way we can assume only public members and non-static methods
        if (!arrayInterfaceType || (arrayInterfaceType.getKind() & PullElementKind.Interface) == 0) {
            return null;
        }

        // PULLREVIEW: Accept both generic and non-generic arrays for now
        if (arrayInterfaceType.isGeneric()) {
            var enclosingDecl = arrayInterfaceType.getDeclarations()[0];
            return specializeType(arrayInterfaceType, [typeToSpecializeTo], resolver, enclosingDecl, context);
        }

        if (typeToSpecializeTo.getArrayType()) {
            return typeToSpecializeTo.getArrayType();
        }

        // PULLTODO: Recursive reference bug
        var newArrayType: PullTypeSymbol = new PullTypeSymbol(arrayInterfaceType.getName(), arrayInterfaceType.getKind() | PullElementKind.Array);
        newArrayType.addDeclaration(arrayInterfaceType.getDeclarations()[0]);

        typeToSpecializeTo.setArrayType(newArrayType);
        newArrayType.addOutgoingLink(typeToSpecializeTo, SymbolLinkKind.ArrayOf);

        var field: PullSymbol = null;
        var newField: PullSymbol = null;
        var fieldType: PullTypeSymbol = null;

        var method: PullSymbol = null;
        var methodType: PullFunctionTypeSymbol = null;
        var newMethod: PullSymbol = null;
        var newMethodType: PullFunctionTypeSymbol = null;

        var signatures: PullSignatureSymbol[] = null;
        var newSignature: PullSignatureSymbol = null;

        var parameters: PullSymbol[] = null;
        var newParameter: PullSymbol = null;
        var parameterType: PullTypeSymbol = null;

        var returnType: PullTypeSymbol = null;
        var newReturnType: PullTypeSymbol = null;

        var members = arrayInterfaceType.getMembers();

        for (var i = 0; i < members.length; i++) {
            resolver.resolveDeclaredSymbol(members[i], context);

            if (members[i].getKind() == PullElementKind.Method) { // must be a method
                method = <PullFunctionTypeSymbol> members[i];

                resolver.resolveDeclaredSymbol(method, context);

                methodType = <PullFunctionTypeSymbol>method.getType();

                newMethod = new PullSymbol(method.getName(), PullElementKind.Method);
                newMethodType = new PullFunctionTypeSymbol();
                newMethod.setType(newMethodType);

                newMethod.addDeclaration(method.getDeclarations()[0]);

                signatures = methodType.getCallSignatures();

                // specialize each signature
                for (var j = 0; j < signatures.length; j++) {

                    newSignature = new PullSignatureSymbol(PullElementKind.CallSignature);
                    newSignature.addDeclaration(signatures[j].getDeclarations[0]);

                    parameters = signatures[j].getParameters();
                    returnType = signatures[j].getReturnType();

                    if (returnType == typeToReplace) {
                        newSignature.setReturnType(typeToSpecializeTo);
                    }
                    else {
                        newSignature.setReturnType(returnType);
                    }

                    for (var k = 0; k < parameters.length; k++) {
                        newParameter = new PullSymbol(parameters[k].getName(), parameters[k].getKind());

                        parameterType = parameters[k].getType();

                        if (parameterType == typeToReplace) {
                            newParameter.setType(typeToSpecializeTo);
                        }
                        else {
                            newParameter.setType(parameterType);
                        }

                        newSignature.addParameter(newParameter);
                    }

                    newMethodType.addSignature(newSignature);
                }

                newArrayType.addMember(newMethod, SymbolLinkKind.PublicMember);
            }

            else { // must be a field
                field = members[i];

                newField = new PullSymbol(field.getName(), field.getKind());
                newField.addDeclaration(field.getDeclarations()[0]);

                fieldType = field.getType();

                if (fieldType == typeToReplace) {
                    newField.setType(typeToSpecializeTo);
                }
                else {
                    newField.setType(fieldType);
                }

                newArrayType.addMember(newField, SymbolLinkKind.PublicMember);
            }
        }
        newArrayType.addOutgoingLink(arrayInterfaceType, SymbolLinkKind.ArrayType);
        return newArrayType;
    }

    export function specializeType(typeToSpecialize: PullTypeSymbol, typeArguments: PullTypeSymbol[], resolver: PullTypeResolver, enclosingDecl: PullDecl, context: PullTypeResolutionContext, ast?: AST): PullTypeSymbol {

        var typeParameters = typeToSpecialize.getTypeParameters();

        var isArray = typeToSpecialize == resolver.getCachedArrayType() || typeToSpecialize.isArray();

        if (!typeParameters.length) {
            return typeToSpecialize;
        }

        if (!typeArguments.length) {
            for (var i = 0; i < typeParameters.length; i++) {
                typeArguments[typeArguments.length] = resolver.semanticInfoChain.anyTypeSymbol;
            }
        }

        var typeToReplace: PullTypeParameterSymbol = null;
        var typeConstraint: PullTypeSymbol = null;

        for (var iArg = 0; iArg < typeArguments.length; iArg++) {
            typeToReplace = <PullTypeParameterSymbol>typeParameters[iArg];

            typeConstraint = typeToReplace.getConstraint();

            // test specialization type for assignment compatibility with the constraint
            if (typeConstraint) {
                if (!resolver.sourceIsAssignableToTarget(typeArguments[iArg], typeConstraint, context)) {
                    if (ast) {
                        context.postError(ast.minChar, ast.getLength(), resolver.getUnitPath(), "Type '" + typeArguments[iArg].getName() + "' does not satisfy the constraint for type parameter '" + typeToReplace.getName() + "'", enclosingDecl);
                    }

                    return resolver.semanticInfoChain.anyTypeSymbol;
                }
            }
        }

        var newType: PullTypeSymbol = typeToSpecialize.getSpecialization(typeArguments);

        if (newType) {
            return newType;
        }

        newType = typeToSpecialize.isClass() ? new PullClassTypeSymbol(typeToSpecialize.getName()) :
                    isArray ? new PullArrayTypeSymbol() :
                        new PullTypeSymbol(typeToSpecialize.getName(), typeToSpecialize.getKind());
        newType.addDeclaration(typeToSpecialize.getDeclarations()[0]);

        typeToSpecialize.addSpecialization(newType, typeArguments);

        if (isArray) {
            (<PullArrayTypeSymbol>newType).setElementType(typeArguments[0]);
        }

        // create the type replacement map

        var typeReplacementMap: any = {};

        for (var i = 0; i < typeParameters.length; i++) {
            typeReplacementMap[typeParameters[i].getSymbolID().toString()] = typeArguments[i];
            newType.addMember(typeParameters[i], SymbolLinkKind.TypeParameter);
        }

        var callSignatures = typeToSpecialize.getCallSignatures();
        var constructSignatures = typeToSpecialize.getConstructSignatures();
        var indexSignatures = typeToSpecialize.getIndexSignatures();
        var members = typeToSpecialize.getMembers();

        // specialize call signatures
        var newSignature: PullSignatureSymbol;

        for (var i = 0; i < callSignatures.length; i++) {
            newSignature = specializeSignature(callSignatures[i], true, typeReplacementMap, typeArguments, resolver, enclosingDecl, context);

            if (!newSignature) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }

            newType.addCallSignature(newSignature);
        }

        // specialize construct signatures
        for (var i = 0; i < constructSignatures.length; i++) {
            newSignature = specializeSignature(constructSignatures[i], true, typeReplacementMap, typeArguments, resolver, enclosingDecl, context);

            if (!newSignature) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }

            newType.addConstructSignature(newSignature);
        }

        // specialize index signatures
        for (var i = 0; i < indexSignatures.length; i++) {
            newSignature = specializeSignature(indexSignatures[i], true, typeReplacementMap, typeArguments, resolver, enclosingDecl, context);

            if (!newSignature) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }

            newType.addIndexSignature(newSignature);
        }

        // specialize members

        var field: PullSymbol = null;
        var newField: PullSymbol = null;

        var fieldType: PullTypeSymbol = null;
        var newFieldType: PullTypeSymbol = null;
        var replacementType: PullTypeSymbol = null;

        var decl: PullDecl = null;
        var declAST: AST;
        var unitPath: string;

        for (var i = 0; i < members.length; i++) {
            field = members[i];

            resolver.resolveDeclaredSymbol(field, context);

            decl = field.getDeclarations()[0];

            newField = new PullSymbol(field.getName(), field.getKind());
            newField.addDeclaration(decl);

            fieldType = field.getType();

            replacementType = <PullTypeSymbol>typeReplacementMap[fieldType.getSymbolID().toString()];

            if (replacementType) {
                newField.setType(replacementType);
            }
            else {
                declAST = resolver.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());

                // re-resolve using the current replacements
                context.pushTypeSpecializationCache(typeReplacementMap);

                field.invalidate();

                unitPath = resolver.getUnitPath();
                resolver.setUnitPath(decl.getScriptName());
                resolver.resolveAST(declAST, false, enclosingDecl, context);
                resolver.setUnitPath(unitPath);

                context.popTypeSpecializationCache();

                newFieldType = field.getType();

                newField.setType(newFieldType);
            }

            newType.addMember(newField, (decl.getFlags() & PullElementFlags.Private) ? SymbolLinkKind.PrivateMember : SymbolLinkKind.PublicMember);
        }

        // specialize the constructor and statics, if need be
        if (typeToSpecialize.isClass()) {
            var constructorMethod = (<PullClassTypeSymbol>typeToSpecialize).getConstructorMethod();
            var newConstructorMethod = new PullSymbol(constructorMethod.getName(), PullElementKind.ConstructorMethod);
            var newConstructorType = specializeType(constructorMethod.getType(), typeArguments, resolver, enclosingDecl, context, ast);

            newConstructorMethod.setType(newConstructorType);

            (<PullClassTypeSymbol>newType).setConstructorMethod(newConstructorMethod);
        }

        return newType;
    }

    // PULLTODO: Replace typeReplacementMap with use of context
    export function specializeSignature(signature: PullSignatureSymbol,
        skipLocalTypeParameters: bool,
        typeReplacementMap: any,
        typeArguments: PullTypeSymbol[],
        resolver: PullTypeResolver,
        enclosingDecl: PullDecl,
        context: PullTypeResolutionContext,
        ast?: AST): PullSignatureSymbol {


        var newSignature = signature.getSpecialization(typeArguments);

        if (newSignature) {
            return newSignature;
        }

        newSignature = new PullSignatureSymbol(signature.getKind());
        newSignature.addDeclaration(signature.getDeclarations[0]);

        signature.addSpecialization(newSignature, typeArguments);

        var parameters = signature.getParameters();
        var typeParameters = signature.getTypeParameters();
        var returnType = signature.getReturnType();

        if (returnType.isGeneric()) {
            var newReturnElementType = returnType.isArray() ? (<PullArrayTypeSymbol>returnType).getElementType() : returnType;

            var replacementReturnType = <PullTypeSymbol>typeReplacementMap[newReturnElementType.getSymbolID().toString()];

            var newReturnType = specializeType(returnType, [replacementReturnType], resolver, enclosingDecl, context);

            newSignature.setReturnType(newReturnType);
        }
        else {
            newSignature.setReturnType(returnType);
        }

        var newParameter: PullSymbol;
        var newParameterType: PullTypeSymbol;
        var newParameterElementType: PullTypeSymbol;
        var parameterType: PullTypeSymbol;
        var replacementParameterType: PullTypeSymbol;
        var localTypeParameters: any = {};
        var typeToReplace: PullTypeParameterSymbol;
        var typeConstraint: PullTypeSymbol;

        for (var iArg = 0; iArg < typeArguments.length; iArg++) {
            typeToReplace = <PullTypeParameterSymbol>typeParameters[iArg];

            typeConstraint = typeToReplace.getConstraint();

            // test specialization type for assignment compatibility with the constraint
            if (typeConstraint) {
                if (!resolver.sourceIsAssignableToTarget(typeArguments[iArg], typeConstraint, context)) {
                    if (ast) {
                        context.postError(ast.minChar, ast.getLength(), resolver.getUnitPath(), "Type '" + typeArguments[iArg].getName() + "' does not satisfy the constraint for type parameter '" + typeToReplace.getName() + "'", enclosingDecl);
                    }

                    return null;
                    //typeArguments[iArg] = resolver.semanticInfoChain.anyTypeSymbol;
                }
            }
        }

        // if we specialize the signature recursive (through, say, the specialization of a method whilst specializing
        // its class), we need to prevent accidental specialization of type parameters that shadow type parameters in the
        // enclosing type.  (E.g., "class C<T> { public m<T>() {...} }" )
        if (skipLocalTypeParameters) {
            for (var i = 0; i < typeParameters.length; i++) {
                localTypeParameters[typeParameters[i].getName()] = true;
            }
        }

        for (var k = 0; k < parameters.length; k++) {
            newParameter = new PullSymbol(parameters[k].getName(), parameters[k].getKind());

            parameterType = parameters[k].getType();
            newParameterElementType = parameterType.isArray() ? (<PullArrayTypeSymbol>parameterType).getElementType() : parameterType;
            replacementParameterType = <PullTypeSymbol>typeReplacementMap[newParameterElementType.getSymbolID().toString()];

            if (!localTypeParameters[parameterType.getName()] && parameterType.isGeneric() && replacementParameterType) {
                newParameterType = specializeType(parameterType, [replacementParameterType], resolver, enclosingDecl, context);
                newParameter.setType(newParameterType);
            }
            else {
                newParameter.setType(parameterType);
            }

            newSignature.addParameter(newParameter);
        }

        return newSignature;
    }

    export function getIDForTypeSubstitutions(types: PullTypeSymbol[]): string {
        var substitution = "";

        for (var i = 0; i < types.length; i++) {
            substitution += types[i].getSymbolID().toString() + "#";
        }

        return substitution;
    }

}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {

    export class PullSymbolBindingContext {

        private parentChain: PullTypeSymbol[] = [];
        private declPath: string[] = [];
        public semanticInfo: SemanticInfo;
        public reBindingAfterChange = false;
        public startingDeclForRebind = pullDeclID; // note that this gets set on creation

        constructor (public semanticInfoChain: SemanticInfoChain, public scriptName: string, public useFidelity = false) {
            this.semanticInfo = this.semanticInfoChain.getUnit(this.scriptName);
        }

        public getParent(n=0): PullTypeSymbol { return this.parentChain ? this.parentChain[this.parentChain.length - 1 - n] : null; }
        public getDeclPath() { return this.declPath; }

        public pushParent(parentDecl: PullTypeSymbol) { 
            if (parentDecl) { 
                this.parentChain[this.parentChain.length] = parentDecl;
                this.declPath[this.declPath.length] = parentDecl.getName();
            } 
        }

        public popParent() {
            if (this.parentChain.length) {
                this.parentChain.length--;
                this.declPath.length--;
            }
        }
    }

    export var time_in_findSymbol = 0;

    export function findSymbolInContext(name: string, declKind: PullElementKind, context: PullSymbolBindingContext, typeLookupPath: string[]): PullSymbol {
        var startTime = new Date().getTime();
        var contextSymbolPath: string[] = context.getDeclPath();
        var nestedSymbolPath: string[] = [];
        var copyOfContextSymbolPath = [];
        var symbol: PullSymbol = null;

        // first, search within the given symbol path
        if (typeLookupPath.length) {

            for (var i = 0; i < typeLookupPath.length; i++) {
                nestedSymbolPath[nestedSymbolPath.length] = typeLookupPath[i];
            }

            nestedSymbolPath[nestedSymbolPath.length] = name;

            while (nestedSymbolPath.length >= 2) {
                symbol = context.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);

                if (symbol) {
                    var endTime = new Date().getTime();
                    time_in_findSymbol += endTime - startTime;
                    return symbol;
                }
                nestedSymbolPath.length -= 2;
                nestedSymbolPath[nestedSymbolPath.length] = name;
            }
        }

        // next, link back up to the enclosing context
        if (contextSymbolPath.length) {
            
            for (var i = 0; i < contextSymbolPath.length; i++) {
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i];
            }

            for (var i = 0; i < typeLookupPath.length; i++) {
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = typeLookupPath[i];
            }

            copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;

            while (copyOfContextSymbolPath.length >= 2) {
                symbol = context.semanticInfoChain.findSymbol(copyOfContextSymbolPath, declKind);

                if (symbol) {
                    var endTime = new Date().getTime();
                    time_in_findSymbol += endTime - startTime;
                    return symbol;
                }
                copyOfContextSymbolPath.length -= 2;
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
            }
        }

        // finally, try searching globally
        symbol = context.semanticInfoChain.findSymbol([name], declKind);

        var endTime = new Date().getTime();
        time_in_findSymbol += endTime - startTime;

        return symbol;
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {

    export class CandidateInferenceInfo {
        public typeParameter: PullTypeParameterSymbol = null;
        public isFixed = false;
        public inferenceCandidates: PullTypeSymbol[] = [];

        public addCandidate(candidate: PullTypeSymbol) {
            if (!this.isFixed) {
                this.inferenceCandidates[this.inferenceCandidates.length] = candidate;
            }
        }
    }

    export class ArgumentInferenceContext {
        public candidateCache: any = {};

        public getInferenceInfo(param: PullTypeParameterSymbol) {
            var info = <CandidateInferenceInfo>this.candidateCache[param.getSymbolID().toString()];

            if (!info) {
                info = new CandidateInferenceInfo();
                info.typeParameter = param;
                this.candidateCache[param.getSymbolID().toString()] = info;
            }

            return info;
        }

        public addCandidateForInference(param: PullTypeParameterSymbol, candidate: PullTypeSymbol, fix: bool) {
            var info = this.getInferenceInfo(param);

            if (candidate) {
                info.addCandidate(candidate);
            }

            if (!info.isFixed) {
                info.isFixed = fix;
            }
        }
        
        public getInferenceCandidates(): any[] {
            var inferenceCandidates: any[] = [];
            var info: CandidateInferenceInfo;
            var val;

            for (var infoKey in this.candidateCache) {
                info = <CandidateInferenceInfo>this.candidateCache[infoKey];

                for (var i = 0; i < info.inferenceCandidates.length; i++) {
                    val = {};
                    val[info.typeParameter.getSymbolID().toString()] = info.inferenceCandidates[i];
                    inferenceCandidates[inferenceCandidates.length] = val;
                }
            }

            return inferenceCandidates;
        }

        public inferArgumentTypes(resolver: PullTypeResolver, context: PullTypeResolutionContext): { results: { param: PullTypeParameterSymbol; type: PullTypeSymbol; }[]; unfit: bool; } {
            var info: CandidateInferenceInfo = null;

            var collection: IPullTypeCollection;

            var bestCommonType: PullTypeSymbol;

            var results: { param: PullTypeParameterSymbol; type: PullTypeSymbol; }[] = [];

            var unfit = false;

            for (var infoKey in this.candidateCache) {
                info = <CandidateInferenceInfo>this.candidateCache[infoKey];

                collection = {
                    getLength: () => { return info.inferenceCandidates.length; },
                    setTypeAtIndex: (index: number, type: PullTypeSymbol) => { },
                    getTypeAtIndex: (index: number) => {
                        return info.inferenceCandidates[index].getType();
                    }
                }

                bestCommonType = resolver.findBestCommonType(info.inferenceCandidates[0], null, collection, true, context, new TypeComparisonInfo());

                if (!bestCommonType) {
                    bestCommonType = resolver.semanticInfoChain.undefinedTypeSymbol;
                }

                if (bestCommonType == resolver.semanticInfoChain.undefinedTypeSymbol) {
                    unfit = true;
                }

                results[results.length] = { param: info.typeParameter, type: bestCommonType };
            }

            return { results: results, unfit: unfit };
        }
    }

    export class PullContextualTypeContext {

        public provisionallyTypedSymbols: PullSymbol[] = [];
        public provisionalErrors: PullError[] = [];
        
        constructor (public contextualType: PullTypeSymbol,
                     public provisional: bool,
                     public substitutions: any) { }

        public recordProvisionallyTypedSymbol(symbol: PullSymbol) {
            this.provisionallyTypedSymbols[this.provisionallyTypedSymbols.length] = symbol;
        }

        public invalidateProvisionallyTypedSymbols() {
            for (var i = 0; i < this.provisionallyTypedSymbols.length; i++) {
                this.provisionallyTypedSymbols[i].invalidate();
            }
        }

        public postError(error: PullError) {
            this.provisionalErrors[this.provisionalErrors.length] = error;
        }

        public hadProvisionalErrors() {
            return this.provisionalErrors.length > 0;
        }
    }

    export class PullTypeResolutionContext {
        private contextStack: PullContextualTypeContext[] = [];
        private typeSpecializationStack: any[] = [];

        public resolvingTypeReference = false;

        public resolveAggressively = false;

        public searchTypeSpace = false;
        
        public pushContextualType(type: PullTypeSymbol, provisional: bool, substitutions: any) {
            this.contextStack.push(new PullContextualTypeContext(type, provisional, substitutions));
        }
        
        public popContextualType(): PullContextualTypeContext {
            var tc = this.contextStack.pop();

            tc.invalidateProvisionallyTypedSymbols();

            return tc;
        }

        public findSubstitution(type: PullTypeSymbol) {
            var substitution: PullTypeSymbol = null;
            
            if (this.contextStack.length) {
                for (var i = this.contextStack.length - 1; i >= 0; i--) {
                    if (this.contextStack[i].substitutions) {
                        substitution = this.contextStack[i].substitutions[type.getSymbolID().toString()];

                        if (substitution) {
                            break;
                        }
                    }
                }
            }

            return substitution;
        }
        
        public getContextualType(): PullTypeSymbol {
            var context = !this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1];
            
            if (context) {
                var type = context.contextualType;
                
                // if it's a type parameter, return the upper bound
                if (type.isTypeParameter() && (<PullTypeParameterSymbol>type).getConstraint()) {
                    type = (<PullTypeParameterSymbol>type).getConstraint();
                }

                var substitution = this.findSubstitution(type);

                return substitution ? substitution : type;
            }
            
            return null;
        }
        
        public inProvisionalResolution() {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        }

        public setTypeInContext(symbol: PullSymbol, type: PullTypeSymbol) {
            var substitution: PullTypeSymbol = this.findSubstitution(type);

            symbol.setType(substitution ? substitution : type);

            if (this.contextStack.length && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].recordProvisionallyTypedSymbol(symbol);
            }
        }

        public pushTypeSpecializationCache(cache) {
            this.typeSpecializationStack[this.typeSpecializationStack.length] = cache;
        }

        public popTypeSpecializationCache() {
            if (this.typeSpecializationStack.length) {
                this.typeSpecializationStack.length--;
            }
        }

        public findSpecializationForType(type: PullTypeSymbol) {
            var specialization: PullTypeSymbol = null;

            for (var i = this.typeSpecializationStack.length - 1; i >= 0; i--) {
                specialization = (this.typeSpecializationStack[i])[type.getSymbolID().toString()];

                if (specialization) {
                    return specialization;
                }
            }

            return type;
        }

        public postError(offset: number, length: number, filename: string, message: string, enclosingDecl: PullDecl) {
            var error = new PullError(offset, length, filename, message);

            if (this.inProvisionalResolution()) {
                (this.contextStack[this.contextStack.length - 1]).postError(error);
            }
            else {
                enclosingDecl.addError(error);
            }
        }
    }

}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />


/*

Architectural TODO:

- More consistent use of PullSymbol subtyping.  (Basically, audit all return and param types)
- Move enclosing decl to pull resolution context

*/
module TypeScript {

    export interface IPullTypeCollection {
        // returns null when types are exhausted
        getLength(): number;
        setTypeAtIndex(index: number, type: PullTypeSymbol): void;
        getTypeAtIndex(index: number): PullTypeSymbol;
    }

    export interface IPullResolutionData {
        actuals: PullTypeSymbol[];
        exactCandidates: PullSignatureSymbol[];
        conversionCandidates: PullSignatureSymbol[];
        id: number;
    }

    export class PullResolutionDataCache {
        public cacheSize = 16;
        public rdCache: IPullResolutionData[] = [];
        public nextUp: number = 0;

        constructor () {
            for (var i = 0; i < this.cacheSize; i++) {
                this.rdCache[i] = {
                    actuals: <PullTypeSymbol[]>[],
                    exactCandidates: <PullSignatureSymbol[]>[],
                    conversionCandidates: <PullSignatureSymbol[]>[],
                    id: i
                };
            }
        }

        public getResolutionData(): IPullResolutionData {
            var rd: IPullResolutionData = null;

            if (this.nextUp < this.cacheSize) {
                rd = this.rdCache[this.nextUp];
            }

            if (rd == null) {
                this.cacheSize++;
                rd = {
                    actuals: <PullTypeSymbol[]>[],
                    exactCandidates: <PullSignatureSymbol[]>[],
                    conversionCandidates: <PullSignatureSymbol[]>[],
                    id: this.cacheSize
                };
                this.rdCache[this.cacheSize] = rd;
            }

            // cache operates as a stack - RD is always served up in-order
            this.nextUp++;

            return rd;
        }

        public returnResolutionData(rd: IPullResolutionData) {
            // Pop to save on array allocations, which are a bottleneck
            // REVIEW: On some VMs, Array.pop doesn't always pop the last value in the array
            rd.actuals.length = 0;
            rd.exactCandidates.length = 0;
            rd.conversionCandidates.length = 0;

            this.nextUp = rd.id;
        }
    }

    export interface PullApplicableSignature {
        signature: PullSignatureSymbol;
        hadProvisionalErrors: bool;
    }

    // The resolver associates types with a given AST
    export class PullTypeResolver {

        private cachedArrayInterfaceType: PullTypeSymbol = null;
        private cachedNumberInterfaceType: PullTypeSymbol = null;
        private cachedStringInterfaceType: PullTypeSymbol = null;
        private cachedBooleanInterfaceType: PullTypeSymbol = null;
        private cachedObjectInterfaceType: PullTypeSymbol = null;
        private cachedFunctionInterfaceType: PullTypeSymbol = null;
        private cachedIArgumentsInterfaceType: PullTypeSymbol = null;

        private assignableCache: any[] = <any>{};
        private subtypeCache: any[] = <any>{};
        private identicalCache: any[] = <any>{};

        private resolutionDataCache = new PullResolutionDataCache();

        private currentUnit: SemanticInfo = null;

        constructor (public semanticInfoChain: SemanticInfoChain, private unitPath: string) {
            this.cachedArrayInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Array", [], PullElementKind.Interface);
            this.cachedNumberInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Number", [], PullElementKind.Interface);
            this.cachedStringInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("String", [], PullElementKind.Interface);
            this.cachedBooleanInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Boolean", [], PullElementKind.Interface);
            this.cachedObjectInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Object", [], PullElementKind.Interface);
            this.cachedFunctionInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Function", [], PullElementKind.Interface);
            this.cachedIArgumentsInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("IArguments", [], PullElementKind.Interface);

            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        }

        public getUnitPath() { return this.unitPath; }
        
        public setUnitPath(unitPath: string) {
            this.unitPath = unitPath;

            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);    
        }

        private getDeclForAST(ast: AST, unitPath?: string) {
            return this.semanticInfoChain.getDeclForAST(ast, unitPath ? unitPath : this.unitPath);
        }

        public getSymbolForAST(ast: AST, unitPath?: string) {
            return this.semanticInfoChain.getSymbolForAST(ast, unitPath ? unitPath : this.unitPath);
        }

        public setSymbolForAST(ast: AST, typeSymbol: PullSymbol, unitPath?: string) {
            return this.semanticInfoChain.setSymbolForAST(ast, typeSymbol, unitPath ? unitPath : this.unitPath);
        }

        public getASTForSymbol(symbol: PullSymbol, unitPath?: string) {
            return this.semanticInfoChain.getASTForSymbol(symbol, unitPath ? unitPath : this.unitPath);
        }

        public getCachedArrayType() {
            return this.cachedArrayInterfaceType;
        }

        // returns a list of decls leading up to decl, inclusive
        // PULLTODO: Don't bother using spans - obtain cached Decls from syntax nodes
        public getPathToDecl(decl: PullDecl): PullDecl[] {

            if (!decl) {
                return [];
            }

            //var parentDecl: PullDecl = decl.getParentDecl();
            //var decls: PullDecl[] = [];

            //while (parentDecl) {
            //    decls[decls.length] = parentDecl;
            //    parentDecl = parentDecl.getParentDecl();
            //}

            //return decls;
            
            var decls: PullDecl[] = [];
            var searchDecls = this.semanticInfoChain.getUnit(decl.getScriptName()).getTopLevelDecls();
            
            var spanToFind = decl.getSpan();
            var candidateSpan: DeclSpan = null;
            var searchKinds = PullElementKind.SomeType | PullElementKind.SomeFunction;
            var found = false;

            while (true) {
                // Of the top-level decls, find the one to search off of
                found = false;
                for (var i = 0; i < searchDecls.length; i++) {
                    candidateSpan = searchDecls[i].getSpan();

                    if (spanToFind.minChar >= candidateSpan.minChar && spanToFind.limChar <= candidateSpan.limChar) {
                        if (searchDecls[i].getKind() & searchKinds) { // only consider types, which have scopes
                            //if (!(searchDecls[i].getKind() & PullElementKind.Script)) {
                                decls[decls.length] = searchDecls[i];
                            //}
                            searchDecls = searchDecls[i].getChildDecls();
                            found = true;
                        }
                    }
                }

                if (!found) {
                    break;
                }
            }

            // if the decl is a function expression, it would not have been parented during binding
            if (decls.length && (decl.getKind() & (PullElementKind.SomeFunction | 
                                                    PullElementKind.ObjectType | 
                                                    PullElementKind.FunctionType | 
                                                    PullElementKind.ConstructorType)) && 
                (decls[decls.length - 1] != decl)) {

                decls[decls.length] = decl;
            }

            return decls;
        }

        public getEnclosingDecl(decl: PullDecl): PullDecl {
            var declPath = this.getPathToDecl(decl);

            if (!declPath.length) {
                return null;
            }
            else if (declPath.length > 1 && declPath[declPath.length - 1] == decl) {
                return declPath[declPath.length - 2];
            }
            else {
                return declPath[declPath.length - 1];
            }
        }

        //  Given a path to a name, e.g. ["foo"] or ["Foo", "Baz", "bar"], find the associated symbol
        public findSymbolForPath(pathToName: string[], enclosingDecl: PullDecl, declKind: PullElementKind): PullSymbol {

            if (!pathToName.length) {
                return null;
            }

            var symbolName = pathToName[pathToName.length - 1];
            var contextDeclPath = this.getPathToDecl(enclosingDecl);

            var contextSymbolPath: string[] = [];
            var nestedSymbolPath: string[] = [];

            // first, search within the given symbol path
            // (copy path to name so as not to mutate the input array)
            for (var i = 0; i < pathToName.length; i++) {
                nestedSymbolPath[nestedSymbolPath.length] = pathToName[i];
            }

            var symbol: PullSymbol = null; 
        
            while (nestedSymbolPath.length >= 2) {
                symbol = this.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);

                if (symbol) {
                    return symbol;
                }
                nestedSymbolPath.length -= 2;
                nestedSymbolPath[nestedSymbolPath.length] = symbolName;
            }

            // next, try the enclosing context
            for (var i = 0; i < contextDeclPath.length; i++) {
                contextSymbolPath[contextSymbolPath.length] = contextDeclPath[i].getName();
            }

            for (var i = 0; i < pathToName.length; i++) {
                contextSymbolPath[contextSymbolPath.length] = pathToName[i];
            }

            while (contextSymbolPath.length >= 2) {
                symbol = this.semanticInfoChain.findSymbol(contextSymbolPath, declKind);

                if (symbol) {
                    return symbol;
                }
                contextSymbolPath.length -= 2;
                contextSymbolPath[contextSymbolPath.length] = symbolName;
            }

            // finally, try searching globally
            symbol = this.semanticInfoChain.findSymbol([symbolName], declKind);

            return symbol;
        }

        // search for an unqualified symbol name within a given decl path
        public getSymbolFromDeclPath(symbolName: string, declPath: PullDecl[], declSearchKind: PullElementKind): PullSymbol {
            var symbol: PullSymbol = null;

            // search backwards through the decl list
            //  - if the decl in question is a function, search its members
            //  - if the decl in question is a module, search the decl then the symbol
            //  - Otherwise, search globally

            var decl: PullDecl = null;
            var childDecls: PullDecl[];
            var declSymbol: PullTypeSymbol = null;
            var declMembers: PullSymbol[];
            var pathDeclKind: PullElementKind;

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.getKind();

                if (pathDeclKind & PullElementKind.Container) {
                    // first check locally
                    childDecls = decl.findChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }

                    // otherwise, check the members
                    declSymbol = <PullTypeSymbol>decl.getSymbol();
                    declMembers = declSymbol.getMembers();

                    var kind: PullElementKind;

                    for (var j = 0; j < declMembers.length; j++) {
                        // PULLTODO: declkind should equal declkind, or is it ok to just mask the value?
                        if (declMembers[j].getName() == symbolName) {
                            kind = declMembers[j].getKind();

                            if ((kind & declSearchKind) != 0) {
                                return declMembers[j];
                            }                         
                        }
                    }
                }
                else /*if (pathDeclKind & DeclKind.Function)*/ {
                    childDecls = decl.findChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }
                }
            }

            // otherwise, search globally
            symbol = this.semanticInfoChain.findSymbol([symbolName], declSearchKind);

            return symbol;
        }


        // Declaration Resolution

        public resolveDeclaration(declAST: AST, context: PullTypeResolutionContext): PullSymbol {
            switch (declAST.nodeType) {
                case NodeType.ModuleDeclaration:
                    return this.resolveModuleDeclaration(<ModuleDeclaration>declAST, context);
                case NodeType.InterfaceDeclaration:
                    return this.resolveInterfaceDeclaration(<TypeDeclaration>declAST, context);
                case NodeType.ClassDeclaration:
                    return this.resolveClassDeclaration(<ClassDeclaration>declAST, context);
                case NodeType.FuncDecl:
                    return this.resolveFunctionDeclaration(<FuncDecl>declAST, context);
                case NodeType.VarDecl:
                case NodeType.ArgDecl:
                    return this.resolveVariableDeclaration(<BoundDecl>declAST, context);

                case NodeType.TypeParameter:
                    return this.resolveTypeParameterDeclaration(<TypeParameter>declAST, context);
                default:
                    throw new Error("Invalid declaration type");
            }
        }

        // PULLTODO: VERY IMPORTANT
        // Right now, the assumption is that the declaration's parse tree is still in memory
        // we need to add a cache-in/cache-out mechanism so that we can break the dependency on in-memory ASTs
        public resolveDeclaredSymbol(symbol: PullSymbol, context: PullTypeResolutionContext) {

            if (!symbol || symbol.isResolved()) {
                return;
            }

            var thisUnit = this.unitPath;

            var decls = symbol.getDeclarations();

            // We want to walk and resolve all associated decls, so we can catch
            // cases like function overloads that may be spread across multiple
            // logical declarations
            for (var i = 0; i < decls.length; i++) {
                var decl = decls[i];
                
                var ast = this.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());

                this.setUnitPath(decl.getScriptName());
                this.resolveDeclaration(ast, context);
            }
            
            this.setUnitPath(thisUnit);
        }

        //
        // Resolve a module declaration
        //
        // The module and its members are pre-bound, so no further resolution is necessary
        //
        public resolveModuleDeclaration(ast: ModuleDeclaration, context: PullTypeResolutionContext): PullTypeSymbol {
            var declSymbol = <PullTypeSymbol>this.semanticInfoChain.getSymbolForAST(ast, this.unitPath);

            return declSymbol;
        }

        //
        // Resolve a class declaration
        //
        // A class's implements and extends lists are not pre-bound, so they must be bound here
        // Once bound, we can add the parent type's members to the class
        //
        public resolveClassDeclaration(classDeclAST: ClassDeclaration, context: PullTypeResolutionContext): PullTypeSymbol {
            var classDecl: PullDecl = this.getDeclForAST(classDeclAST);
            var enclosingDecl = this.getEnclosingDecl(classDecl);
            var classDeclSymbol = <PullClassTypeSymbol>classDecl.getSymbol();

            if (classDeclSymbol.isResolved()) {
                return classDeclSymbol;
            }
            
            if (classDeclAST.extendsList) {
                var parentType: PullTypeSymbol = null;
                for (var i = 0; i < classDeclAST.extendsList.members.length; i++) {
                    parentType = this.resolveTypeReference(new TypeReference(classDeclAST.extendsList.members[i], 0), enclosingDecl, context);
                    classDeclSymbol.addExtendedType(parentType);
                }
            }

            if (classDeclAST.implementsList) {
                var implementedType: PullTypeSymbol = null;
                for (var i = 0; i < classDeclAST.implementsList.members.length; i++) {
                    implementedType = this.resolveTypeReference(new TypeReference(classDeclAST.implementsList.members[i], 0), enclosingDecl, context);
                    classDeclSymbol.addImplementedType(implementedType);
                }
            }

            classDeclSymbol.setResolved();

            var classMembers = classDeclSymbol.getMembers();         
            var constructorMethod = classDeclSymbol.getConstructorMethod();
            var classTypeParameters = classDeclSymbol.getTypeParameters();

            if (constructorMethod) {
                this.resolveDeclaredSymbol(constructorMethod, context);
            }

            for (var i = 0; i < classMembers.length; i++) {
                this.resolveDeclaredSymbol(classMembers[i], context);
            }

            for (var i = 0; i < classTypeParameters.length; i++) {
                this.resolveDeclaredSymbol(classTypeParameters[i], context);
            }

            return classDeclSymbol;
        }

        public resolveInterfaceDeclaration(interfaceDeclAST: TypeDeclaration, context: PullTypeResolutionContext): PullTypeSymbol {
            var interfaceDecl: PullDecl = this.getDeclForAST(interfaceDeclAST);
            var enclosingDecl = this.getEnclosingDecl(interfaceDecl);
            var interfaceDeclSymbol = <PullTypeSymbol>interfaceDecl.getSymbol();

            if (interfaceDeclSymbol.isResolved()) {
                return interfaceDeclSymbol;
            }
            
            if (interfaceDeclAST.extendsList) {
                var parentType: PullTypeSymbol = null;
                for (var i = 0; i < interfaceDeclAST.extendsList.members.length; i++) {
                    parentType = this.resolveTypeReference(new TypeReference(interfaceDeclAST.extendsList.members[i], 0), enclosingDecl, context);
                    interfaceDeclSymbol.addExtendedType(parentType);
                }
            }

            if (interfaceDeclAST.implementsList) {
                var implementedType: PullTypeSymbol = null;
                for (var i = 0; i < interfaceDeclAST.implementsList.members.length; i++) {
                    implementedType = this.resolveTypeReference(new TypeReference(interfaceDeclAST.implementsList.members[i], 0), enclosingDecl, context);
                    interfaceDeclSymbol.addImplementedType(implementedType);
                }
            }

            interfaceDeclSymbol.setResolved();

            var interfaceMembers = interfaceDeclSymbol.getMembers();
            var interfaceTypeParameters = interfaceDeclSymbol.getTypeParameters();

            for (var i = 0; i < interfaceMembers.length; i++) {
                this.resolveDeclaredSymbol(interfaceMembers[i], context);
            }

            for (var i = 0; i < interfaceTypeParameters.length; i++) {
                this.resolveDeclaredSymbol(interfaceTypeParameters[i], context);
            }

            return interfaceDeclSymbol;
        }
        
        public resolveFunctionTypeSignature(funcDeclAST: FuncDecl, enclosingDecl : PullDecl, context: PullTypeResolutionContext): PullTypeSymbol {

            var funcDeclSymbol = <PullFunctionTypeSymbol>this.semanticInfoChain.getSymbolForAST(funcDeclAST, this.unitPath);

            if (!funcDeclSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new DeclCollectionContext(semanticInfo);

                declCollectionContext.scriptName = this.unitPath;

                getAstWalkerFactory().walk(funcDeclAST, preCollectDecls, postCollectDecls, null, declCollectionContext);

                var functionDecl = this.getDeclForAST(funcDeclAST);

                var binder = new PullSymbolBinder(this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                binder.bindFunctionTypeDeclarationToPullSymbol(functionDecl);

                funcDeclSymbol = <PullFunctionTypeSymbol>functionDecl.getSymbol();
            }

            var signature = funcDeclSymbol.getCallSignatures()[0];

            // resolve the return type annotation
            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeRef = <TypeReference>funcDeclAST.returnTypeAnnotation;
                var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, enclosingDecl, context);

                signature.setReturnType(returnTypeSymbol);
            }
            else {
                signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
            }
            
            // link parameters and resolve their annotations
            if (funcDeclAST.arguments) {
                for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    this.resolveFunctionTypeSignatureParameter(<ArgDecl>funcDeclAST.arguments.members[i], null, enclosingDecl, context);
                }
            }

            funcDeclSymbol.setResolved();

            return funcDeclSymbol;
        }

        public resolveFunctionTypeSignatureParameter(argDeclAST: ArgDecl, contextParam: PullSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            
            var paramSymbol = this.semanticInfoChain.getSymbolForAST(argDeclAST, this.unitPath);       

            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(<TypeReference>argDeclAST.typeExpr, enclosingDecl, context);
                
                context.setTypeInContext(paramSymbol,typeRef);
            } // PULLTODO: default values?
            else {
                if (contextParam) {
                    context.setTypeInContext(paramSymbol, contextParam.getType());
                }
                else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }

            paramSymbol.setResolved();
        }

        public resolveFunctionExpressionParameter(argDeclAST: ArgDecl, contextParam: PullSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            
            var paramSymbol = this.getSymbolForAST(argDeclAST);         
            
            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(<TypeReference>argDeclAST.typeExpr, enclosingDecl, context);

                context.setTypeInContext(paramSymbol,typeRef);
            } // PULLTODO: default values?
            else {
                if (contextParam) {
                    context.setTypeInContext(paramSymbol, contextParam.getType());
                }
                else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }

            paramSymbol.setResolved();
        }

        public resolveInterfaceTypeReference(interfaceDeclAST: NamedDeclaration, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullTypeSymbol {
            
            var interfaceSymbol = <PullTypeSymbol>this.semanticInfoChain.getSymbolForAST(interfaceDeclAST, this.unitPath);//new PullTypeSymbol("", PullElementKind.Interface);

            if (!interfaceSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new DeclCollectionContext(semanticInfo);

                declCollectionContext.scriptName = this.unitPath;

                getAstWalkerFactory().walk(interfaceDeclAST, preCollectDecls, postCollectDecls, null, declCollectionContext);

                var interfaceDecl = this.getDeclForAST(interfaceDeclAST);

                var binder = new PullSymbolBinder(this.semanticInfoChain);

                binder.setUnit(this.unitPath);
                binder.bindObjectTypeDeclarationToPullSymbol(interfaceDecl);

                interfaceSymbol = <PullFunctionTypeSymbol>interfaceDecl.getSymbol();
            }

            if (interfaceDeclAST.members) {

                var memberSymbol: PullSymbol = null;
                var typeMembers = <ASTList> interfaceDeclAST.members;

                for (var i = 0; i < typeMembers.members.length; i++) {
                    var memberSymbol = this.semanticInfoChain.getSymbolForAST(typeMembers.members[i], this.unitPath);

                    this.resolveDeclaredSymbol(memberSymbol, context);
                }
            }

            interfaceSymbol.setResolved();

            return interfaceSymbol;
        }

        public resolveTypeReference(typeRef: TypeReference, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullTypeSymbol {
            // the type reference can be
            // a name
            // a function
            // an interface
            // a dotted name
            // an array of any of the above

            if (!typeRef) {
                return null;
            }

            var typeDeclSymbol: PullTypeSymbol = null;
            var prevResolvingTypeReference = context.resolvingTypeReference;

            // a name
            if (typeRef.term.nodeType == NodeType.Name) {
                var typeName = <Identifier>typeRef.term;

                // if it's a known primitive name, cheat
                if (typeName.actualText == "any") {
                    typeDeclSymbol = this.semanticInfoChain.anyTypeSymbol;
                }
                else if (typeName.actualText == "string") {
                    typeDeclSymbol = this.semanticInfoChain.stringTypeSymbol;
                }                
                else if (typeName.actualText == "number") {
                    typeDeclSymbol = this.semanticInfoChain.numberTypeSymbol;
                }
                else if (typeName.actualText == "bool") {
                    typeDeclSymbol = this.semanticInfoChain.boolTypeSymbol;
                }
                else if (typeName.actualText == "null") {
                    typeDeclSymbol = this.semanticInfoChain.nullTypeSymbol;
                }
                else if (typeName.actualText == "undefined") {
                    typeDeclSymbol = this.semanticInfoChain.undefinedTypeSymbol;
                }
                else if (typeName.actualText == "void") {
                    typeDeclSymbol = this.semanticInfoChain.voidTypeSymbol;
                }
                else if (typeName.actualText == "_element") {
                    typeDeclSymbol = this.semanticInfoChain.elementTypeSymbol;
                }
                else {
                    context.resolvingTypeReference = true;

                    typeDeclSymbol = <PullTypeSymbol>this.resolveTypeNameExpression(typeName, enclosingDecl, context);

                    context.resolvingTypeReference = prevResolvingTypeReference;
                }

                if (!typeDeclSymbol) {
                    context.postError(typeName.minChar, typeName.getLength(), this.unitPath, "Could not find type '" + typeName.actualText + "'", enclosingDecl);
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }

            // a function
            else if (typeRef.term.nodeType == NodeType.FuncDecl) {

                typeDeclSymbol = this.resolveFunctionTypeSignature(<FuncDecl>typeRef.term, enclosingDecl, context);
            }

            // an interface
            else if (typeRef.term.nodeType == NodeType.InterfaceDeclaration) {

                typeDeclSymbol = this.resolveInterfaceTypeReference(<NamedDeclaration>typeRef.term, enclosingDecl, context);
            }
            else if (typeRef.term.nodeType == NodeType.GenericType) {
                typeDeclSymbol = this.resolveGenericTypeReference(<GenericType>typeRef.term, enclosingDecl, context);
            }


                // a dotted name
            else if (typeRef.term.nodeType == NodeType.Dot) {

                // assemble the dotted name path
                var dottedName = <BinaryExpression> typeRef.term;

                // find the decl
                var prevResolvingTypeReference = context.resolvingTypeReference;

                typeDeclSymbol = <PullTypeSymbol>this.resolveDottedTypeNameExpression(dottedName, enclosingDecl, context);

                context.resolvingTypeReference = prevResolvingTypeReference;

                if (!typeDeclSymbol) {
                    context.postError(dottedName.operand2.minChar, dottedName.operand2.getLength(), this.unitPath, "Could not find dotted type '" + (<Identifier>dottedName.operand2).actualText + "'", enclosingDecl);
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }

            if (!typeDeclSymbol) {
                context.postError(typeRef.term.minChar, typeRef.term.getLength(), this.unitPath, "Could not resolve type reference", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            // an array of any of the above
            // PULLTODO: Arity > 1
            if (typeRef.arrayCount) {

                var arraySymbol: PullTypeSymbol = typeDeclSymbol.getArrayType();

                // otherwise, create a new array symbol
                if (!arraySymbol) {                    
                    // for each member in the array interface symbol, substitute in the the typeDecl symbol for "_element"
                    
                    if (!this.cachedArrayInterfaceType) {
                        this.cachedArrayInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Array", this.getPathToDecl(enclosingDecl), PullElementKind.Interface);
                    }

                    arraySymbol = specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, typeDeclSymbol, this, context);

                    if (!arraySymbol) {
                        arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
            
                typeDeclSymbol = arraySymbol;
            }

            this.setSymbolForAST(typeRef, typeDeclSymbol);

            return typeDeclSymbol;
        }

        // Also resolves parameter declarations
        public resolveVariableDeclaration(varDecl: BoundDecl, context: PullTypeResolutionContext, enclosingDecl?:PullDecl): PullSymbol {
      
            var decl: PullDecl = this.getDeclForAST(varDecl);
            var declSymbol = decl.getSymbol();
            var declPropertySymbol = decl.getPropertySymbol();
            var hadError = false;

            if (declSymbol.isResolved()) {
                return declSymbol.getType();
            }

            // Does this have a type expression? If so, that's the type
            if (varDecl.typeExpr) {

                var typeExprSymbol = this.resolveTypeReference(<TypeReference>varDecl.typeExpr, enclosingDecl ? enclosingDecl : this.getEnclosingDecl(decl), context);

                if (!typeExprSymbol) {
                    context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, "Could not resolve type expression for variable '" + varDecl.id.actualText + "'", decl);
                     
                    declSymbol.setType(this.semanticInfoChain.anyTypeSymbol);

                    if (declPropertySymbol) {
                        declPropertySymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }

                    hadError = true;
                }
                else {

                    context.setTypeInContext(declSymbol, typeExprSymbol);

                    if (declPropertySymbol) {
                        declPropertySymbol.setType(typeExprSymbol);
                    }
                }
            }

            // Does it have an initializer? If so, typecheck and use that
            else if (varDecl.init) {

                var initExprSymbol = this.resolveStatementOrExpression(varDecl.init, false, enclosingDecl ? enclosingDecl : this.getEnclosingDecl(decl), context);

                if (!initExprSymbol) {
                    context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, "Could not resolve type of initializer expression for variable '" + varDecl.id.actualText + "'", decl);

                    context.setTypeInContext(declSymbol, this.semanticInfoChain.anyTypeSymbol);

                    if (declPropertySymbol) {
                        context.setTypeInContext(declPropertySymbol, this.semanticInfoChain.anyTypeSymbol);
                    }

                    hadError = true;
                }
                else {
                    context.setTypeInContext(declSymbol, initExprSymbol.getType());
                    initExprSymbol.addOutgoingLink(declSymbol, SymbolLinkKind.ProvidesInferredType);

                    if (declPropertySymbol) {
                        context.setTypeInContext(declPropertySymbol, initExprSymbol.getType());
                        initExprSymbol.addOutgoingLink(declPropertySymbol, SymbolLinkKind.ProvidesInferredType);
                    }
                }
            }

            // Otherwise, it's of type 'any'
            else {
                context.setTypeInContext(declSymbol, this.semanticInfoChain.anyTypeSymbol);
                if (declPropertySymbol) {
                    declPropertySymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                }
            }
            
            if (!hadError) {
                declSymbol.setResolved();
            }

            if (declPropertySymbol) {
                declPropertySymbol.setResolved();

                this.setSymbolForAST(varDecl, declPropertySymbol);
                this.setSymbolForAST(varDecl.id, declPropertySymbol);
            }    

            return declSymbol;
        }

        public resolveTypeParameterDeclaration(typeParameterAST: TypeParameter, context: PullTypeResolutionContext): PullTypeSymbol {
            var typeParameterDecl = this.getDeclForAST(typeParameterAST);
            var typeParameterSymbol = <PullTypeParameterSymbol>typeParameterDecl.getSymbol();

            if (typeParameterAST.constraint) {
                var constraintTypeSymbol = this.resolveTypeReference(<TypeReference>typeParameterAST.constraint, this.getEnclosingDecl(typeParameterDecl), context);

                if (!constraintTypeSymbol) {
                    context.postError(typeParameterAST.minChar, typeParameterAST.getLength(), this.unitPath, "Could not resolve constraint for type parameter '" + typeParameterDecl.getName() + "'", typeParameterDecl);
                }
                else if (constraintTypeSymbol.isTypeParameter() || constraintTypeSymbol.isPrimitive()) {
                    context.postError(typeParameterAST.constraint.minChar, typeParameterAST.constraint.getLength(), this.unitPath, "Type parameter constraints may not be type parameters or primitive types", typeParameterDecl);
                }
                else {
                    typeParameterSymbol.setConstraint(constraintTypeSymbol);
                }
            }

            typeParameterSymbol.setResolved();

            return typeParameterSymbol;
        }

        public resolveFunctionBodyReturnTypes(funcDeclAST: FuncDecl, signature: PullSignatureSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            var returnStatements: ReturnStatement[] = [];

            var preFindReturnExpressionTypes = function (ast: AST, parent: AST, walker: IAstWalker) {
                    var go = true;

                    switch (ast.nodeType) {
                        case NodeType.FuncDecl:
                            // don't recurse into a function decl - we don't want to confuse a nested
                            // return type with the top-level function's return type
                            go = false;
                            break;
                        case NodeType.Return:
                            var returnStatement: ReturnStatement = <ReturnStatement>ast;
                            returnStatements[returnStatements.length] = returnStatement;

                        default:
                            break;
                    }

                    walker.options.goChildren = go;
                    walker.options.goNextSibling = go;

                    return ast;
                }

            getAstWalkerFactory().walk(funcDeclAST.bod, preFindReturnExpressionTypes);

            if (!returnStatements.length) {
                signature.setReturnType(this.semanticInfoChain.voidTypeSymbol);
            }

            else {
                var returnExpressionSymbols: PullTypeSymbol[] = [];

                for (var i = 0; i < returnStatements.length; i++) {
                    if (returnStatements[i].returnExpression) {
                        returnExpressionSymbols[returnExpressionSymbols.length] = this.resolveStatementOrExpression(returnStatements[i].returnExpression, false, enclosingDecl, context).getType();
                    }
                }

                if (!returnExpressionSymbols.length) {
                    signature.setReturnType(this.semanticInfoChain.voidTypeSymbol);
                }
                else {

                    // combine return expression types for best common type
                    var collection: IPullTypeCollection = {
                            getLength: () => {return returnExpressionSymbols.length;},
                            setTypeAtIndex: (index: number, type: PullTypeSymbol) => { },
                            getTypeAtIndex: (index: number) => {
                                return returnExpressionSymbols[index].getType();
                            }
                    }
                    
                    var returnType = this.findBestCommonType(returnExpressionSymbols[0], null, collection, true, context, new TypeComparisonInfo());
                    
                    signature.setReturnType(returnType ? returnType : this.semanticInfoChain.anyTypeSymbol);

                    // link return expressions to signature type to denote inference
                    for (var i = 0; i < returnExpressionSymbols.length; i++) {
                        returnExpressionSymbols[i].addOutgoingLink(signature, SymbolLinkKind.ProvidesInferredType);
                    }
                }
            }
        }

        public resolveFunctionDeclaration(funcDeclAST: FuncDecl, context: PullTypeResolutionContext): PullSymbol {
      
            var funcDecl: PullDecl = this.getDeclForAST(funcDeclAST);

            var funcSymbol = <PullFunctionTypeSymbol>funcDecl.getSymbol();

            var signature: PullSignatureSymbol = funcDecl.getSignatureSymbol();

            var hadError = false;

            if (signature.isResolved()) {
                return funcSymbol;
            }

            if (signature) {
                
                // resolve parameter type annotations as necessary
                if (funcDeclAST.arguments) {
                    for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(<BoundDecl>funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }

                // resolve the return type annotation
                if (funcDeclAST.returnTypeAnnotation) {
                    var returnTypeRef = <TypeReference>funcDeclAST.returnTypeAnnotation;

                    // use the funcDecl for the enclosing decl, since we want to pick up any type parameters 
                    // on the function when resolving the return type
                    var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, funcDecl, context);

                    if (!returnTypeSymbol) {
                        context.postError(funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), this.unitPath, "Could not resolve return type reference for some reason...", funcDecl);
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);

                        hadError = true;
                    }
                    else {
                        signature.setReturnType(returnTypeSymbol);
                    }
                }

                    // if there's no return-type annotation
                    //     - if it's not a definition signature, set the return type to 'any'
                    //     - if it's a definition sigature, take the best common type of all return expressions
                else {
                    if (funcDeclAST.isSignature()) {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    }
                    else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, funcDecl, new PullTypeResolutionContext());
                    }
                }
                
                if (!hadError) {
                    signature.setResolved();
                }
            }

            // don't resolve anything here that's not relevant to the type of the function!

            return funcSymbol;
        }


        // Expression and statement Resolution

        // PULLTODORESOLUTION: Import statements
        // PULLTODORESOLUTION: Loop statements
        // PULLTODORESOLUTION: With blocks
        // PULLTODORESOLUTION: Switch statements
        // PULLTODORESOLUTION: if statements
        // PULLTODORESOLUTION: try/catch
        // PULLTODORESOLUTION: debugger statement
        // PULLTODORESOLUTION: Conditional expressions        
        // PULLTODORESOLUTION: Throw

        public resolveAST(ast: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            switch (ast.nodeType) {
                case NodeType.ModuleDeclaration:
                case NodeType.InterfaceDeclaration:
                case NodeType.ClassDeclaration:
                case NodeType.VarDecl:
                case NodeType.ArgDecl:
                    return this.resolveDeclaration(ast, context);

                case NodeType.FuncDecl:
                    if (isTypedAssignment) {
                        return this.resolveStatementOrExpression(ast, isTypedAssignment, enclosingDecl, context);
                    }
                    else {
                        return this.resolveDeclaration(ast, context);
                    }

                default:
                    return this.resolveStatementOrExpression(ast, isTypedAssignment, enclosingDecl, context);
            }
        }

        public resolveStatementOrExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext):PullSymbol {


            switch (expressionAST.nodeType) {
                case NodeType.Name:
                    if (context.searchTypeSpace) {
                        return this.resolveTypeNameExpression(<Identifier>expressionAST, enclosingDecl, context);
                    }
                    else {
                        return this.resolveNameExpression(<Identifier>expressionAST, enclosingDecl, context);
                    }
                case GenericType:
                    return this.resolveGenericTypeReference(<GenericType>expressionAST, enclosingDecl, context);
                case NodeType.Dot:
                    if (context.searchTypeSpace) {
                        return this.resolveDottedTypeNameExpression(<BinaryExpression>expressionAST, enclosingDecl, context);
                    }
                    else {
                        return this.resolveDottedNameExpression(<BinaryExpression>expressionAST, enclosingDecl, context);
                    }
                case NodeType.FuncDecl:
                    return this.resolveFunctionExpression(<FuncDecl>expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.ObjectLit:
                    return this.resolveObjectLiteralExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.ArrayLit:
                    return this.resolveArrayLiteralExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.This:
                    return this.resolveThisExpression(expressionAST, enclosingDecl, context);
                case NodeType.Super:
                    return this.resolveSuperExpression(expressionAST, enclosingDecl, context);

                case NodeType.Call:
                    return this.resolveCallExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.New:
                    return this.resolveNewExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.TypeAssertion:
                    return this.resolveTypeAssertionExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.TypeRef:
                    return this.resolveTypeReference(<TypeReference>expressionAST, enclosingDecl, context);

                // primitives
                case NodeType.NumberLit:
                    return this.semanticInfoChain.numberTypeSymbol;
                case NodeType.QString:
                    return this.semanticInfoChain.stringTypeSymbol;
                case NodeType.Null:
                    return this.semanticInfoChain.nullTypeSymbol;
                case NodeType.True:
                case NodeType.False:
                    return this.semanticInfoChain.boolTypeSymbol;
                case NodeType.Void:
                    return this.semanticInfoChain.voidTypeSymbol;

                // assignment
                case NodeType.Asg:
                    return this.resolveAssignmentStatement(expressionAST, isTypedAssignment, enclosingDecl, context);

                // boolean operations
                case NodeType.Not:
                case NodeType.LogNot:
                case NodeType.Ne:
                case NodeType.Eq:
                case NodeType.Eqv:
                case NodeType.NEqv:
                case NodeType.Lt:
                case NodeType.Le:
                case NodeType.Ge:
                case NodeType.Gt:
                    return this.semanticInfoChain.boolTypeSymbol;

                case NodeType.Add:
                case NodeType.Sub:
                case NodeType.Mul:
                case NodeType.Div:
                case NodeType.Mod:
                case NodeType.Or:
                case NodeType.And:
                case NodeType.AsgAdd:
                case NodeType.AsgSub:
                case NodeType.AsgMul:
                case NodeType.AsgDiv:
                case NodeType.AsgMod:
                case NodeType.AsgOr:
                case NodeType.AsgAnd:
                    return this.resolveArithmeticExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.Pos:
                case NodeType.Neg:
                case NodeType.IncPost:
                case NodeType.IncPre:
                case NodeType.DecPost:
                case NodeType.DecPre:
                    return this.semanticInfoChain.numberTypeSymbol;

                case NodeType.Lsh:
                case NodeType.Rsh:
                case NodeType.Rs2:
                case NodeType.AsgLsh:
                case NodeType.AsgRsh:
                case NodeType.AsgRs2:
                    return this.semanticInfoChain.numberTypeSymbol;

                case NodeType.Index:
                    return this.resolveIndexExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.LogOr:
                    return this.resolveLogicalOrExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case NodeType.LogAnd:
                    return this.resolveLogicalAndExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.Typeof:
                    return this.semanticInfoChain.stringTypeSymbol;
            }

            return this.semanticInfoChain.anyTypeSymbol;
        }

        public resolveNameExpression(nameAST: Identifier, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            
            var id = nameAST.actualText;

            var declPath = this.getPathToDecl(enclosingDecl);

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            var nameSymbol: PullSymbol = null

            nameSymbol = this.getSymbolFromDeclPath(id, declPath, PullElementKind.SomeValue);

            // PULLREVIEW: until further notice, search out for modules or enums
            if (!nameSymbol) {
                nameSymbol = this.getSymbolFromDeclPath(id, declPath, PullElementKind.SomeType);

                if (nameSymbol && nameSymbol.getKind() == PullElementKind.Interface) {
                    nameSymbol = null;
                }
            }

            if (!nameSymbol) {
                context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, "Could not find symbol '" + id + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            if (!nameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(nameSymbol, context);
            }

            return nameSymbol;
        }

        public resolveDottedNameExpression(dottedNameAST: BinaryExpression, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            
            // assemble the dotted name path
            var rhsName = (<Identifier>dottedNameAST.operand2).actualText;

            var lhs: PullSymbol = this.resolveStatementOrExpression(dottedNameAST.operand1, false, enclosingDecl, context);
            var lhsType = lhs.getType();

            if (lhsType == this.semanticInfoChain.anyTypeSymbol) {
                return lhsType;
            }

            if (!lhsType) {
                context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find enclosing symbol for dotted name '" + rhsName + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            // if we're resolving a type reference, we really only want to check the constructor type
            if (lhsType == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType) {
                lhsType = this.cachedNumberInterfaceType;
            }
            else if (lhsType == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType) {
                lhsType = this.cachedStringInterfaceType;
            }
            else if (lhsType == this.semanticInfoChain.boolTypeSymbol && this.cachedBooleanInterfaceType) {
                lhsType = this.cachedBooleanInterfaceType;
            }

            if (!lhsType.isResolved()) {
                this.resolveDeclaredSymbol(lhsType, context);
            }

            if (rhsName == "prototype" && lhsType.isClass()) {
                return lhsType;
            }

            // now for the name...
            var nameSymbol = lhsType.findMember(rhsName);

            if (!nameSymbol) {
                
                // could be a static
                if (lhsType.isClass()) {
                    lhsType = (<PullClassTypeSymbol>lhsType).getConstructorMethod().getType();

                    nameSymbol = lhsType.findMember(rhsName);
                }

                if (!nameSymbol) {
                    context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find dotted symbol name '" + rhsName + "'", enclosingDecl);
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }

            if (!nameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(nameSymbol, context);
            }

            return nameSymbol;
        }

        public resolveTypeNameExpression(nameAST: Identifier, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            
            var id = nameAST.actualText;

            var declPath = this.getPathToDecl(enclosingDecl);

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            var typeNameSymbol: PullTypeSymbol = null

            typeNameSymbol = <PullTypeSymbol>this.getSymbolFromDeclPath(id, declPath, PullElementKind.SomeType);

            if (!typeNameSymbol) {
                context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, "Could not find type '" + id + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            typeNameSymbol = context.findSpecializationForType(typeNameSymbol);

            if (!typeNameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(typeNameSymbol, context);
            }

            return typeNameSymbol;
        }

        public resolveGenericTypeReference(genericTypeAST: GenericType, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullTypeSymbol {
            var nameAST = <Identifier> genericTypeAST.name;
            var id = nameAST.actualText;

            var declPath = this.getPathToDecl(enclosingDecl);

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            var genericTypeSymbol: PullTypeSymbol = null

            genericTypeSymbol = <PullTypeSymbol>this.getSymbolFromDeclPath(id, declPath, PullElementKind.SomeType);

            if (!genericTypeSymbol) {
                context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, "Could not find generic type '" + id + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            if (!genericTypeSymbol.isResolved()) {
                this.resolveDeclaredSymbol(genericTypeSymbol, context);
            }

            // specialize the type arguments
            var typeArgs: PullTypeSymbol[] = [];
            var typeArg: PullTypeSymbol = null;

            if (genericTypeAST.typeArguments && genericTypeAST.typeArguments.members.length) {
                for (var i = 0; i < genericTypeAST.typeArguments.members.length; i++) {
                    typeArg = this.resolveTypeReference(<TypeReference>genericTypeAST.typeArguments.members[i], enclosingDecl, context);
                    typeArgs[i] = context.findSpecializationForType(typeArg);
                }
            }

            if (typeArgs.length && typeArgs.length != genericTypeSymbol.getTypeParameters().length) {
                context.postError(genericTypeAST.minChar, genericTypeAST.getLength(), this.unitPath, "Generic type '"+ genericTypeSymbol.getName() +"' expects " + genericTypeSymbol.getTypeParameters().length + " type arguments, but " + typeArgs.length + " arguments were supplied", enclosingDecl);

                return this.semanticInfoChain.anyTypeSymbol;
            }

            var specializedSymbol = specializeType(genericTypeSymbol, typeArgs, this, enclosingDecl, context, genericTypeAST);

            return specializedSymbol;
        }

        public resolveDottedTypeNameExpression(dottedNameAST: BinaryExpression, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            
            // assemble the dotted name path
            var rhsName = (<Identifier>dottedNameAST.operand2).actualText;

            var prevSearchTypeSpace = context.searchTypeSpace;
            context.searchTypeSpace = true;
            
            var lhs: PullSymbol = this.resolveStatementOrExpression(dottedNameAST.operand1, false, enclosingDecl, context);
            
            context.searchTypeSpace = prevSearchTypeSpace;
            
            var lhsType = lhs.getType();

            if (lhsType == this.semanticInfoChain.anyTypeSymbol) {
                return lhsType;
            }

            if (!lhsType) {
                context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find enclosing type for dotted type name '" + rhsName + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }


            // now for the name...
            var childTypeSymbol = lhsType.findNestedType(rhsName);

            if (!childTypeSymbol) {
                context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find dotted type name '" + rhsName + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            if (!childTypeSymbol.isResolved()) {
                this.resolveDeclaredSymbol(childTypeSymbol, context);
            }

            return childTypeSymbol;
        }

        public resolveFunctionExpression(funcDeclAST: FuncDecl, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
             
            var functionDecl = this.getDeclForAST(funcDeclAST);
            var funcDeclSymbol: PullSymbol = null;

            if (functionDecl) {
                funcDeclSymbol = functionDecl.getSymbol();
                if (funcDeclSymbol.isResolved()) {
                    return funcDeclSymbol;
                }
            }

            // if we have an assigning AST with a type, and the funcDecl has no parameter types or return type annotation
            // we'll contextually type it
            // otherwise, just process it as a normal function declaration
            
            var shouldContextuallyType = isTypedAssignment && !funcDeclAST.isParenthesized;
            
            var assigningFunctionTypeSymbol: PullFunctionTypeSymbol = null;
            var assigningFunctionSignature: PullSignatureSymbol = null;

            if (funcDeclAST.returnTypeAnnotation) {
                shouldContextuallyType = false;
            }

            if (shouldContextuallyType && funcDeclAST.arguments) {

                for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    if ((<ArgDecl>funcDeclAST.arguments.members[i]).typeExpr) {
                        shouldContextuallyType = false;
                        break;
                    }
                }
            }

            if (shouldContextuallyType) {

                assigningFunctionTypeSymbol = <PullFunctionTypeSymbol>context.getContextualType();

                this.resolveDeclaredSymbol(assigningFunctionTypeSymbol, context);

                if (assigningFunctionTypeSymbol) {
                    assigningFunctionSignature = assigningFunctionTypeSymbol.getCallSignatures()[0];
                }
            }

            // create a new function decl and symbol

            if (!funcDeclSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new DeclCollectionContext(semanticInfo);

                declCollectionContext.scriptName = this.unitPath;

                getAstWalkerFactory().walk(funcDeclAST, preCollectDecls, postCollectDecls, null, declCollectionContext);

                functionDecl = this.getDeclForAST(funcDeclAST);

                var binder = new PullSymbolBinder(this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                binder.bindFunctionExpressionToPullSymbol(functionDecl);

                funcDeclSymbol = <PullFunctionTypeSymbol>functionDecl.getSymbol();
            }

            var signature = funcDeclSymbol.getType().getCallSignatures()[0];

            // link parameters and resolve their annotations
            if (funcDeclAST.arguments) {

                var contextParams: PullSymbol[] = [];
                var contextParam: PullSymbol = null;

                if (assigningFunctionSignature) {
                    contextParams = assigningFunctionSignature.getParameters();
                }

                for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {

                    if (i < contextParams.length) {
                        contextParam = contextParams[i];
                    }

                    this.resolveFunctionExpressionParameter(<ArgDecl>funcDeclAST.arguments.members[i], contextParam, enclosingDecl, context);
                }
            }

            // resolve the return type annotation
            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeRef = <TypeReference>funcDeclAST.returnTypeAnnotation;
                var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, enclosingDecl, context);
                
                signature.setReturnType(returnTypeSymbol);
            }
            else {
                if (assigningFunctionSignature) {
                    var returnType = assigningFunctionSignature.getReturnType();

                    if (returnType) {
                        context.pushContextualType(returnType, context.inProvisionalResolution(), null);
                        //signature.setReturnType(returnType);
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, functionDecl, context);
                        context.popContextualType();
                    }
                    else {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    }
                }
                else {
                    this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, functionDecl, context);
                }
            }

            // set contextual type link
            if (assigningFunctionTypeSymbol) {
                funcDeclSymbol.addOutgoingLink(assigningFunctionTypeSymbol, SymbolLinkKind.ContextuallyTypedAs);
            }

            funcDeclSymbol.setResolved();

            return funcDeclSymbol;
        }

        // PULLTODO: Optimization: cache this for a given decl path
        public resolveThisExpression(ast: AST, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {

            if (!enclosingDecl) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var declPath = this.getPathToDecl(enclosingDecl);
            var decl: PullDecl;
            var classSymbol: PullClassTypeSymbol;

            // work back up the decl path, until you can find a class
            // PULLTODO: Obviously not completely correct, but this sufficiently unblocks testing of the pull model
            if (declPath.length) {
                for (var i = declPath.length - 1; i >= 0; i--) {
                    decl = declPath[i];

                    if (decl.getKind() == PullElementKind.Class) {
                        classSymbol = <PullClassTypeSymbol>decl.getSymbol();
                        
                        return classSymbol;
                    }
                }
            }
            
            return this.semanticInfoChain.anyTypeSymbol;
        }

        // PULLTODO: Optimization: cache this for a given decl path
        public resolveSuperExpression(ast: AST, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            if (!enclosingDecl) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var declPath = this.getPathToDecl(enclosingDecl);
            var decl: PullDecl;
            var declFlags: PullElementFlags;
            var classSymbol: PullClassTypeSymbol = null;

            // work back up the decl path, until you can find a class
            if (declPath.length) {
                for (var i = declPath.length - 1; i >= 0; i--) {
                    decl = declPath[i];
                    declFlags = decl.getFlags();

                    if (decl.getKind() == PullElementKind.FunctionExpression &&
                        !(declFlags & PullElementFlags.FatArrow)) {

                        break;
                    }
                    else if (declFlags & PullElementFlags.Static) {
                        break;
                    }
                    else if (decl.getKind() == PullElementKind.Class) {
                        classSymbol = <PullClassTypeSymbol>decl.getSymbol();
                        
                        break;
                    }
                }
            }

            if (classSymbol) {
                var parents = classSymbol.getExtendedTypes();

                if (parents.length) {
                    return parents[0];
                }
            }
            
            return this.semanticInfoChain.anyTypeSymbol;
        }

        // if there's no type annotation on the assigning AST, we need to create a type from each binary expression
        // in the object literal
        public resolveObjectLiteralExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            var typeSymbol: PullTypeSymbol = <PullTypeSymbol>this.getSymbolForAST(expressionAST);
            var span: DeclSpan;

            if (typeSymbol && typeSymbol.isResolved()) {
                return typeSymbol.getType();
            }

            // PULLTODO: Create a decl for the object literal

            // walk the members of the object literal,
            // create fields for each based on the value assigned in
            var objectLitAST = <UnaryExpression>expressionAST;

            span = new DeclSpan();

            span.minChar = objectLitAST.minChar;
            span.limChar = objectLitAST.limChar;

            var objectLitDecl = new PullDecl("", PullElementKind.ObjectType, PullElementFlags.None, span, this.unitPath);

            this.currentUnit.setDeclForAST(objectLitAST, objectLitDecl);
            this.currentUnit.setASTForDecl(objectLitDecl, objectLitAST);

            typeSymbol = new PullTypeSymbol("", PullElementKind.Interface);
            typeSymbol.addDeclaration(objectLitDecl);
            objectLitDecl.setSymbol(typeSymbol);
            
            var memberDecls = <ASTList>objectLitAST.operand;

            var contextualType: PullTypeSymbol = null;
            
            if (isTypedAssignment) {
                contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, context);
            }

            if (memberDecls) {
                var binex:BinaryExpression;
                var id:AST;
                var text: string;
                var idText: string;
                var memberSymbol: PullSymbol;
                var memberExprType: PullSymbol;
                var assigningSymbol: PullSymbol = null;
                var acceptedContextualType = false;

                for (var i = 0, len = memberDecls.members.length; i < len; i++) {
                    binex = <BinaryExpression>memberDecls.members[i];

                    id = binex.operand1;

                    if (id.nodeType == NodeType.Name) {
                        text = (<Identifier>id).text;
                    }
                    else if (id.nodeType == NodeType.QString) {
                        idText = (<StringLiteral>id).text;
                        text = idText.substring(1, idText.length - 1);
                    }
                    else {
                        return this.semanticInfoChain.anyTypeSymbol;
                    }

                    // PULLTODO: Collect these at decl collection time, add them to the var decl
                    span = new DeclSpan();
                    span.minChar = binex.minChar;
                    span.limChar = binex.limChar;

                    var decl = new PullDecl(text, PullElementKind.Property, PullElementFlags.Public, span, this.unitPath);

                    objectLitDecl.addChildDecl(decl);

                    this.semanticInfoChain.getUnit(this.unitPath).setDeclForAST(binex, decl);
                    this.semanticInfoChain.getUnit(this.unitPath).setASTForDecl(decl, binex);

                    memberSymbol = new PullSymbol(text, PullElementKind.Property);
                    
                    if (contextualType) {
                        assigningSymbol = contextualType.findMember(text);

                        if (assigningSymbol) {

                            this.resolveDeclaredSymbol(assigningSymbol, context);

                            context.pushContextualType(assigningSymbol.getType(), context.inProvisionalResolution(), null);

                            acceptedContextualType = true;
                        }
                    }

                    memberExprType = this.resolveStatementOrExpression(binex.operand2, assigningSymbol != null, enclosingDecl, context);

                    if (acceptedContextualType) {
                        context.popContextualType();
                        acceptedContextualType = false;
                    }
                    
                    context.setTypeInContext(memberSymbol, memberExprType.getType());

                    memberSymbol.setResolved();

                    this.setSymbolForAST(binex.operand1, memberSymbol);

                    typeSymbol.addMember(memberSymbol, SymbolLinkKind.PublicMember);
                }
            }

            typeSymbol.setResolved();

            this.setSymbolForAST(expressionAST, typeSymbol);

            return typeSymbol;
        }

        public resolveArrayLiteralExpression(expressionAST: AST, isTypedAssignment, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            var arrayLit = <UnaryExpression>expressionAST;

            var elements = <ASTList>arrayLit.operand;
            var elementType = this.semanticInfoChain.anyTypeSymbol;
            var elementTypes: PullTypeSymbol[] = [];
            var targetElementType: PullTypeSymbol = null;
            var comparisonInfo = new TypeComparisonInfo();
            comparisonInfo.onlyCaptureFirstError = true;

            // if the target type is an array type, extract the element type
            if (isTypedAssignment) {
                var contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, context);

                if (contextualType.isArray()) {
                    contextualType = contextualType.getElementType();
                }

                context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
            }

            if (elements) {

                for (var i = 0; i < elements.members.length; i++) {
                    elementTypes[elementTypes.length] = this.resolveStatementOrExpression(elements.members[i], isTypedAssignment, enclosingDecl, context).getType();                    
                }

                if (isTypedAssignment) {
                    context.popContextualType();
                }

                if (elementTypes.length) {
                    elementType = elementTypes[0];
                }

                var collection: IPullTypeCollection = {
                    getLength: () => { return elements.members.length; },
                    setTypeAtIndex: (index: number, type: PullTypeSymbol) => { elementTypes[index] = type; },
                    getTypeAtIndex: (index: number) => { return elementTypes[index]; }
                }

                elementType = this.findBestCommonType(elementType, targetElementType, collection, false, context, comparisonInfo);

                // if the array type is the undefined type, we should widen it to any
                // if it's of the null type, only widen it if it's not in a nested array element, so as not to 
                // short-circuit any checks for the best common type
                if (elementType == this.semanticInfoChain.undefinedTypeSymbol || elementType == this.semanticInfoChain.nullTypeSymbol) {
                    elementType = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            if (!elementType) {
                context.postError(expressionAST.minChar, expressionAST.getLength(), this.unitPath, "Incompatible types in array literal expression", enclosingDecl);

                elementType = this.semanticInfoChain.anyTypeSymbol;
            }
            else if (targetElementType) {
                // for the case of zero-length 'any' arrays, we still want to set the contextual type, if
                // need be
                if (this.sourceIsAssignableToTarget(elementType, targetElementType, context)) {
                    elementType = targetElementType;
                }
            }

            var arraySymbol = elementType.getArrayType();
         
            // ...But in case we haven't...
            if (!arraySymbol) {                    

                if (!this.cachedArrayInterfaceType) {
                    this.cachedArrayInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Array", this.getPathToDecl(enclosingDecl), PullElementKind.Interface);
                }

                arraySymbol = specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, elementType, this, context);

                if (!arraySymbol) {
                    arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            
            return arraySymbol;
        }

        public resolveIndexExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            var indexType = <PullTypeSymbol>this.resolveStatementOrExpression((<BinaryExpression>expressionAST).operand1, isTypedAssignment, enclosingDecl, context).getType();
            var elementType = indexType.getElementType();
            
            if (elementType) {
                return elementType;
            }
            
            return this.semanticInfoChain.anyTypeSymbol;
        }

        public resolveBitwiseOperator(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            var binex = <BinaryExpression>expressionAST;

            var leftType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context);
            var rightType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context);

            if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) &&
                this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                
                return this.semanticInfoChain.numberTypeSymbol;
            }
            else if ((leftType == this.semanticInfoChain.boolTypeSymbol) &&
                     (rightType == this.semanticInfoChain.boolTypeSymbol)) {
                
                return this.semanticInfoChain.boolTypeSymbol;
            }
            else if (leftType == this.semanticInfoChain.anyTypeSymbol) {
                if ((rightType == this.semanticInfoChain.anyTypeSymbol) ||
                    (rightType == this.semanticInfoChain.numberTypeSymbol) ||
                    (rightType == this.semanticInfoChain.boolTypeSymbol)) {

                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else if (rightType == this.semanticInfoChain.anyTypeSymbol) {
                if ((leftType == this.semanticInfoChain.numberTypeSymbol) ||
                    (leftType == this.semanticInfoChain.boolTypeSymbol)) {

                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }

            return this.semanticInfoChain.anyTypeSymbol;
        }

        public resolveArithmeticExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            var binex = <BinaryExpression>expressionAST;

            var leftType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context);
            var rightType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context);
            
            // PULLREVIEW: Eh?  I've preserved the logic from the current implementation, but it could use cleaning up
            if (this.isNullOrUndefinedType(leftType)) {
                leftType = rightType;
            }
            if (this.isNullOrUndefinedType(rightType)) {
                rightType = leftType;
            }

            leftType = this.widenType(leftType);
            rightType = this.widenType(rightType);

            if (expressionAST.nodeType == NodeType.Add || expressionAST.nodeType == NodeType.AsgAdd) {
                if (leftType == this.semanticInfoChain.stringTypeSymbol || rightType == this.semanticInfoChain.stringTypeSymbol) {
                    return this.semanticInfoChain.stringTypeSymbol;
                }
                else if (leftType == this.semanticInfoChain.numberTypeSymbol && rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else {
                    // could be an error
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else {
                if (leftType == this.semanticInfoChain.numberTypeSymbol && rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else if (leftType == this.semanticInfoChain.anyTypeSymbol || rightType == this.semanticInfoChain.anyTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else {
                    // error
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
        }

        public resolveLogicalOrExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            var binex = <BinaryExpression>expressionAST;

            var leftType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context);
            var rightType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context);
            
            if (leftType == this.semanticInfoChain.anyTypeSymbol || rightType == this.semanticInfoChain.anyTypeSymbol) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            else if (leftType == this.semanticInfoChain.boolTypeSymbol) {
                if (rightType == this.semanticInfoChain.boolTypeSymbol) {
                    return this.semanticInfoChain.boolTypeSymbol;
                }
                else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else if (leftType == this.semanticInfoChain.numberTypeSymbol) {
                if (rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else {
                    return this.semanticInfoChain.anyTypeSymbol
                }
            }
            else if (leftType == this.semanticInfoChain.stringTypeSymbol) {
                if (rightType == this.semanticInfoChain.stringTypeSymbol) {
                    return this.semanticInfoChain.stringTypeSymbol;
                }
                else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else if (this.sourceIsSubtypeOfTarget(leftType, rightType, context)) {
                return rightType;
            }
            else if (this.sourceIsSubtypeOfTarget(rightType, leftType, context)) {
                return leftType;
            }

            return this.semanticInfoChain.anyTypeSymbol;
        }

        public resolveLogicalAndExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            var binex = <BinaryExpression>expressionAST;

            var leftType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context);
            var rightType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context);
            
            return rightType;
        }

        public resolveCallExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            var callEx = <CallExpression>expressionAST;

            // resolve the target
            var targetSymbol = this.resolveStatementOrExpression(callEx.target, isTypedAssignment, enclosingDecl, context).getType();

            if (targetSymbol == this.semanticInfoChain.anyTypeSymbol) {
                return targetSymbol;
            }

            var isSuperCall = false;

            if (callEx.target.nodeType == NodeType.Super) {
                isSuperCall = true;
                targetSymbol = (<PullClassTypeSymbol>targetSymbol).getConstructorMethod().getType();
            }

            var signatures = isSuperCall ? (<PullFunctionTypeSymbol>targetSymbol).getConstructSignatures() : (<PullFunctionTypeSymbol>targetSymbol).getCallSignatures();

            var typeArgs: PullTypeSymbol[] = null;

            // resolve the type arguments, specializing if necessary
            if (callEx.typeArguments) {
                // specialize the type arguments
                typeArgs = [];

                var typeArg: PullTypeSymbol = null;

                if (callEx.typeArguments && callEx.typeArguments.members.length) {
                    for (var i = 0; i < callEx.typeArguments.members.length; i++) {
                        typeArg = this.resolveTypeReference(<TypeReference>callEx.typeArguments.members[i], enclosingDecl, context);
                        typeArgs[i] = context.findSpecializationForType(typeArg);
                    }
                }
            }

            // next, walk the available signatures
            // if any are generic, and we don't have type arguments, try to infer
            // otherwise, try to specialize to the type arguments above
            if (targetSymbol.isGeneric) {

                var resolvedSignatures: PullSignatureSymbol[] = [];
                var inferredTypeArgs: PullTypeSymbol[];
                var specializedSignature: PullSignatureSymbol;
                var typeParameters: PullTypeParameterSymbol[];
                var typeReplacementMap: any;

                for (var i = 0; i < signatures.length; i++) {
                    if (signatures[i].isGeneric()) {
                        if (typeArgs) {
                            inferredTypeArgs = typeArgs;
                        }
                        else {
                            inferredTypeArgs = this.inferArgumentTypesForSignature(signatures[i], callEx.arguments, new TypeComparisonInfo(), enclosingDecl, context);
                        }

                        // if we could infer Args, or we have type arguments, then attempt to specialize the signature
                        if (inferredTypeArgs) {
                            typeParameters = signatures[i].getTypeParameters();

                            if (inferredTypeArgs.length != typeParameters.length) {
                                continue;
                            }

                            typeReplacementMap = {};

                            for (var j = 0; j < typeParameters.length; j++) {
                                typeReplacementMap[typeParameters[j].getSymbolID().toString()] = inferredTypeArgs[j];
                            }

                            specializedSignature = specializeSignature(signatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);

                            if (specializedSignature) {
                                resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                            }
                        }
                    }
                    else {
                        resolvedSignatures[resolvedSignatures.length] = signatures[i];
                    }
                }
                // PULLTODO: Try to avoid copying here...
                signatures = resolvedSignatures;
            }

            // the target should be a function
            //if (!targetSymbol.isType()) {
            //    this.log("Attempting to call a non-function symbol");
            //    return this.semanticInfoChain.anyTypeSymbol;
            //}

            if (!signatures.length) {
                context.postError(expressionAST.minChar, expressionAST.getLength(), this.unitPath, "Attempting to call on a type with no call signatures", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var signature = signatures.length > 1 ? this.resolveOverloads(expressionAST, signatures, enclosingDecl, context) : signatures[0];

            if (!signature) {
                signature = signatures[0];
            }

            var returnType = signature.getReturnType();

            // contextually type arguments
            if (callEx.arguments) {
                var len = callEx.arguments.members.length;
                var params = signature.getParameters();
                var contextualType: PullTypeSymbol = null;
                    
                for (var i = 0; i < len; i++) {

                    if (params.length && i < params.length) {
                        contextualType = params[i].getType();
                    }
                    else if (params.length) {
                        contextualType = params[params.length - 1].getType();
                        if (contextualType.isArray()) {
                            contextualType = contextualType.getElementType();
                        }
                    }

                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                    }
                    
                    this.resolveStatementOrExpression(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }

            if (returnType) {
                return returnType;
            }
            else {
                return this.semanticInfoChain.anyTypeSymbol;
            }
        }

        public resolveNewExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            
            var callEx = <CallExpression>expressionAST;
            var returnType: PullTypeSymbol = null;

            // resolve the target
            var targetSymbol = this.resolveStatementOrExpression(callEx.target, isTypedAssignment, enclosingDecl, context);

            var targetTypeSymbol = targetSymbol.isType() ? <PullTypeSymbol>targetSymbol : targetSymbol.getType();

            // PULLREVIEW: In the case of a generic instantiation of a class type,
            // we'll have gotten a 'GenericType' node, which will be resolved as the class type and not
            // the constructor type.  In this case, set the targetTypeSymbol to the constructor type
            if (targetTypeSymbol.isClass()) {
                targetTypeSymbol = (<PullClassTypeSymbol>targetTypeSymbol).getConstructorMethod().getType();
            }

            if (targetTypeSymbol == this.semanticInfoChain.anyTypeSymbol) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var constructSignatures = targetTypeSymbol.getConstructSignatures();

            if (constructSignatures.length) {

                var signature = constructSignatures.length > 1 ? this.resolveOverloads(expressionAST, constructSignatures, enclosingDecl, context) : constructSignatures[0];

                // if we haven't been able to choose an overload, default to the first one
                if (!signature) {
                    signature = constructSignatures[0];
                }

                if (!returnType) {
                    returnType = signature.getReturnType();
                }

                // contextually type arguments
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    var params = signature.getParameters();
                    var contextualType: PullTypeSymbol = null;
                    
                    for (var i = 0; i < len; i++) {

                        if (params.length && i < params.length) {
                            contextualType = params[i].getType();
                        }
                        else if (params.length) {
                            contextualType = params[params.length - 1].getType();
                            if (contextualType.isArray()) {
                                contextualType = contextualType.getElementType();
                            }
                        }

                        if (contextualType) {
                            context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                        }
                    
                        this.resolveStatementOrExpression(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                        if (contextualType) {
                            context.popContextualType();
                            contextualType = null;
                        }
                    }
                }

                return returnType;
            }
            else if (targetTypeSymbol.isClass()) {

                // implicit constructor
                return returnType;
            }
            
            context.postError(expressionAST.minChar, expressionAST.getLength(), this.unitPath, "Invalid 'new' expression", enclosingDecl);

            return this.semanticInfoChain.anyTypeSymbol;

        }

        public resolveTypeAssertionExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            
            var assertionExpression = <UnaryExpression>expressionAST;
            var typeReference = this.resolveTypeReference(<TypeReference>assertionExpression.castTerm, enclosingDecl, context);
            
            // PULLTODO: We don't technically need to resolve the operand, since the type of the
            // expression is the type of the cast term.  Still, it makes life a bit easier for the LS
            if (context.resolveAggressively && !assertionExpression.operand.isParenthesized) {
                context.pushContextualType(typeReference, context.inProvisionalResolution(), null);
                    this.resolveStatementOrExpression(assertionExpression.operand, true, enclosingDecl, context);
                context.popContextualType();
            }

            return typeReference;
        }

        public resolveAssignmentStatement(statementAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            
            var binex = <BinaryExpression>statementAST;

            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();

            context.pushContextualType(leftType, context.inProvisionalResolution(), null);
            this.resolveStatementOrExpression(binex.operand2, true, enclosingDecl, context);
            context.popContextualType();

            return leftType;
        }

        public resolveBoundDecls(decl: PullDecl, context: PullTypeResolutionContext): void {
            
            if (!decl) {
                return;
            }

            switch (decl.getKind()) {
                case PullElementKind.Script:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.resolveBoundDecls(childDecls[i], context);
                    }
                    break;
                case PullElementKind.Container:
                    var moduleDecl = <ModuleDeclaration>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveModuleDeclaration(moduleDecl, context);
                    break;
                case PullElementKind.Interface:
                    var interfaceDecl = <TypeDeclaration>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveInterfaceDeclaration(interfaceDecl, context);
                    break;
                case PullElementKind.Class:
                    var classDecl = <ClassDeclaration>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveClassDeclaration(classDecl, context);
                    break;
                case PullElementKind.Method:
                case PullElementKind.Function:
                    var funcDecl = <FuncDecl>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveFunctionDeclaration(funcDecl, context);
                    break;
                case PullElementKind.Property:
                case PullElementKind.Variable:
                case PullElementKind.Parameter:
                    var varDecl = <BoundDecl>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);

                    // varDecl may be null if we're dealing with an implicit variable created for a class,
                    // module or enum
                    if (varDecl) {
                        this.resolveVariableDeclaration(varDecl, context);
                    }
                    break;
            }
        }

        // type relationships

        public mergeOrdered(a: PullTypeSymbol, b: PullTypeSymbol, acceptVoid: bool, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): PullTypeSymbol {
            if ((a == this.semanticInfoChain.anyTypeSymbol) || (b == this.semanticInfoChain.anyTypeSymbol)) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            else if (a == b) {
                return a;
            }
            else if ((b == this.semanticInfoChain.nullTypeSymbol) && a != this.semanticInfoChain.nullTypeSymbol) {
                return a;
            }
            else if ((a == this.semanticInfoChain.nullTypeSymbol) && (b != this.semanticInfoChain.nullTypeSymbol)) {
                return b;
            }
            else if (acceptVoid && (b == this.semanticInfoChain.voidTypeSymbol) && a != this.semanticInfoChain.voidTypeSymbol) {
                return a;
            }
            else if (acceptVoid && (a == this.semanticInfoChain.voidTypeSymbol) && (b != this.semanticInfoChain.voidTypeSymbol)) {
                return b;
            }
            else if ((b == this.semanticInfoChain.undefinedTypeSymbol) && a != this.semanticInfoChain.voidTypeSymbol) {
                return a;
            }
            else if ((a == this.semanticInfoChain.undefinedTypeSymbol) && (b != this.semanticInfoChain.undefinedTypeSymbol)) {
                return b;
            }
            else if (a.isTypeParameter() && !b.isTypeParameter()) {
                return b;
            }
            else if (!a.isTypeParameter() && b.isTypeParameter()) {
                return a;
            }
            else if (a.isArray() && b.isArray()) {
                if (a.getElementType() == b.getElementType()) {
                    return a;
                }
                else {
                    var mergedET = this.mergeOrdered(a.getElementType(), b.getElementType(), acceptVoid, context, comparisonInfo);
                    var mergedArrayType = mergedET.getArrayType();

                    if (!mergedArrayType) {
                        mergedArrayType = specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, mergedET, this, context);
                    }

                    return mergedArrayType;
                }
            }
            else if (this.sourceIsSubtypeOfTarget(a, b, context, comparisonInfo)) {
                return b;
            }
            else if (this.sourceIsSubtypeOfTarget(b, a, context, comparisonInfo)) {
                return a;
            }
            else {
                return this.semanticInfoChain.anyTypeSymbol;
            }
        }

        public widenType(type: PullTypeSymbol): PullTypeSymbol {
            if (type == this.semanticInfoChain.undefinedTypeSymbol ||
                type == this.semanticInfoChain.nullTypeSymbol) {

                return this.semanticInfoChain.anyTypeSymbol;
            }

            return type;
        }

        public isNullOrUndefinedType(type: PullTypeSymbol) {
            return  type == this.semanticInfoChain.nullTypeSymbol ||
                    type == this.semanticInfoChain.undefinedTypeSymbol;
        }

        public findBestCommonType(initialType: PullTypeSymbol, targetType: PullTypeSymbol, collection: IPullTypeCollection, acceptVoid:bool, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) {
            var i = 0;
            var len = collection.getLength();
            var nlastChecked = 0;
            var bestCommonType = initialType;

            if (targetType) {
                bestCommonType = bestCommonType ? this.mergeOrdered(bestCommonType, targetType, acceptVoid, context) : targetType;
            }

            // it's important that we set the convergence type here, and not in the loop,
            // since the first element considered may be the contextual type
            var convergenceType: PullTypeSymbol = bestCommonType;

            while (nlastChecked < len) {

                for (i = 0; i < len; i++) {

                    // no use in comparing a type against itself
                    if (i == nlastChecked) {
                        continue;
                    }

                    if (convergenceType && (bestCommonType = this.mergeOrdered(convergenceType, collection.getTypeAtIndex(i), acceptVoid, context, comparisonInfo))) {
                        convergenceType = bestCommonType;
                    }

                    if (bestCommonType == this.semanticInfoChain.anyTypeSymbol || bestCommonType == null) {
                        break;
                    }
                    else if (targetType) { // set the element type to the target type
                        collection.setTypeAtIndex(i, targetType);
                    }
                }

                // use the type if we've agreed upon it
                if (convergenceType && bestCommonType) {
                    break;
                }

                nlastChecked++;
                if (nlastChecked < len) {
                    convergenceType = collection.getTypeAtIndex(nlastChecked);
                }
            }

            return acceptVoid ? bestCommonType : (bestCommonType == this.semanticInfoChain.voidTypeSymbol ? null : bestCommonType);
        }

        // Type Identity

        public typesAreIdentical(t1: PullTypeSymbol, t2: PullTypeSymbol) {

            // This clause will cover both primitive types (since the type objects are shared),
            // as well as shared brands
            if (t1 == t2) {
                return true;
            }

            if (!t1 || !t2) {
                return false;
            }

            if (t1.isPrimitive() || t2.isPrimitive()) {
                return false;
            }

            if (t1.isClass()) {
                return false;
            }

            var comboId = (t2.getSymbolID() << 16) | t1.getSymbolID();

            if (this.identicalCache[comboId]) {
                return true;
            }

            // If one is an enum, and they're not the same type, they're not identical
            if ((t1.getKind() & PullElementKind.Enum) || (t2.getKind() & PullElementKind.Enum)) {
                return false;
            }

            if (t1.isArray() || t2.isArray()) {
                if (!(t1.isArray() && t2.isArray())) {
                    return false;
                }
                this.identicalCache[comboId] = false;
                var ret = this.typesAreIdentical(t1.getElementType(), t2.getElementType());
                if (ret) {
                    this.subtypeCache[comboId] = true;
                }
                else {
                    this.subtypeCache[comboId] = undefined;
                }

                return ret;
            }

            if (t1.isPrimitive() != t2.isPrimitive()) {
                return false;
            }

            this.identicalCache[comboId] = false;

            // properties are identical in name, optionality, and type
            if (t1.hasMembers() && t2.hasMembers()) {
                var t1Members = t1.getMembers();
                var t2Members = t2.getMembers();

                if (t1Members.length != t2Members.length) {
                    this.identicalCache[comboId] = undefined;
                    return false;
                }

                var t1MemberSymbol: PullSymbol = null;
                var t2MemberSymbol: PullSymbol = null;

                var t1MemberType: PullTypeSymbol = null;
                var t2MemberType: PullTypeSymbol = null;

                for (var iMember = 0; iMember < t1Members.length; iMember++) {

                    t1MemberSymbol = t1Members[iMember];
                    t2MemberSymbol = t2.findMember(t1MemberSymbol.getName());

                    if (t1MemberSymbol.getIsOptional() != t2MemberSymbol.getIsOptional()) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }

                    t1MemberType = t1MemberSymbol.getType();
                    t2MemberType = t2MemberSymbol.getType();

                    // catch the mutually recursive or cached cases
                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.getSymbolID() << 16) | t1MemberType.getSymbolID()] != undefined)) {
                        continue;
                    }

                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                }
            }
            else if (t1.hasMembers() || t2.hasMembers()) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            var t1CallSigs = t1.getCallSignatures();
            var t2CallSigs = t2.getCallSignatures();

            var t1ConstructSigs = t1.getConstructSignatures();
            var t2ConstructSigs = t2.getConstructSignatures();

            var t1IndexSigs = t1.getIndexSignatures();
            var t2IndexSigs = t2.getIndexSignatures();

            if (!this.signatureGroupsAreIdentical(t1CallSigs, t2CallSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1ConstructSigs, t2ConstructSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1IndexSigs, t2IndexSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            this.identicalCache[comboId] = true;
            return true;
        }

        public signatureGroupsAreIdentical(sg1: PullSignatureSymbol[], sg2: PullSignatureSymbol[]) {

            // covers the null case
            if (sg1 == sg2) {
                return true;
            }

            // covers the mixed-null case
            if (!sg1 || !sg2) {
                return false;
            }

            if (sg1.length != sg2.length) {
                return false;
            }

            var sig1: PullSignatureSymbol = null;
            var sig2: PullSignatureSymbol = null;
            var sigsMatch = false;

            // The signatures in the signature group may not be ordered...
            // REVIEW: Should definition signatures be required to be identical as well?
            for (var iSig1 = 0; iSig1 < sg1.length; iSig1++) {
                sig1 = sg1[iSig1];

                for (var iSig2 = 0; iSig2 < sg2.length; iSig2++) {
                    sig2 = sg2[iSig2];

                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }

                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }

                // no match found for a specific signature
                return false;
            }

            return true;
        }

        public signaturesAreIdentical(s1: PullSignatureSymbol, s2: PullSignatureSymbol) {

            if (s1.hasVariableParamList() != s2.hasVariableParamList()) {
                return false;
            }

            if (s1.getNonOptionalParameterCount() != s2.getNonOptionalParameterCount()) {
                return false;
            }

            var s1Params = s1.getParameters();
            var s2Params = s2.getParameters();

            if (s1Params.length != s2Params.length) {
                return false;
            }

            if (!this.typesAreIdentical(s1.getReturnType(), s2.getReturnType())) {
                return false;
            }

            for (var iParam = 0; iParam < s1Params.length; iParam++) {
                if (!this.typesAreIdentical(s1Params[iParam].getType(), s2Params[iParam].getType())) {
                    return false;
                }
            }

            return true;
        }

        // Assignment Compatibility and Subtyping

        public sourceIsSubtypeOfTarget(source: PullTypeSymbol, target: PullTypeSymbol, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, context, comparisonInfo); }
        public signatureGroupIsSubtypeOfTarget(sg1: PullSignatureSymbol[], sg2: PullSignatureSymbol[], context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, context, comparisonInfo); }
        public signatureIsSubtypeOfTarget(s1: PullSignatureSymbol, s2: PullSignatureSymbol, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, context, comparisonInfo); }
        
        public sourceIsAssignableToTarget(source: PullTypeSymbol, target: PullTypeSymbol, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, context, comparisonInfo); }
        public signatureGroupIsAssignableToTarget(sg1: PullSignatureSymbol[], sg2: PullSignatureSymbol[], context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, context, comparisonInfo); }
        public signatureIsAssignableToTarget(s1: PullSignatureSymbol, s2: PullSignatureSymbol, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, context, comparisonInfo); }

        public sourceIsRelatableToTarget(source: PullTypeSymbol, target: PullTypeSymbol, assignableTo: bool, comparisonCache: any, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo) {

            // REVIEW: Does this check even matter?
            //if (this.typesAreIdentical(source, target)) {
            //    return true;
            //}
            if (source == target) {
                return true;
            }

            // An error has already been reported in this case
            if (!(source && target)) {
                return true;
            }

            var comboId = (source.getSymbolID() << 16) | target.getSymbolID();

            // In the case of a 'false', we want to short-circuit a recursive typecheck
            if (comparisonCache[comboId] != undefined) {
                return true;
            }

            // this is one difference between subtyping and assignment compatibility
            if (assignableTo) {
                if (source == this.semanticInfoChain.anyTypeSymbol || target == this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }
            }
            else {
                // This is one difference between assignment compatibility and subtyping
                if (target == this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }
            }

            if (source == this.semanticInfoChain.undefinedTypeSymbol) {
                return true;
            }

            if ((source == this.semanticInfoChain.nullTypeSymbol) && (target != this.semanticInfoChain.undefinedTypeSymbol && target != this.semanticInfoChain.voidTypeSymbol)) {
                return true;
            }

            // REVIEW: enum types aren't explicitly covered in the spec
            if (target == this.semanticInfoChain.numberTypeSymbol && (source.getKind() & PullElementKind.Enum)) {
                return true;
            }
            if (source == this.semanticInfoChain.numberTypeSymbol && (target.getKind() & PullElementKind.Enum)) {
                return true;
            }
            if ((source.getKind() & PullElementKind.Enum) || (target.getKind() & PullElementKind.Enum)) {
                return false;
            }

            if (source.isArray() || target.isArray()) {
                if (!(source.isArray() && target.isArray())) {
                    return false;
                }
                comparisonCache[comboId] = false;
                var ret = this.sourceIsRelatableToTarget(source.getElementType(), target.getElementType(), assignableTo, comparisonCache, context, comparisonInfo);
                if (ret) {
                    comparisonCache[comboId] = true;
                }
                else {
                    comparisonCache[comboId] = undefined;
                }

                return ret;
            }

            // this check ensures that we only operate on object types from this point forward,
            // since the checks involving primitives occurred above
            if (source.isPrimitive() && target.isPrimitive()) {

                // we already know that they're not the same, and that neither is 'any'
                return false;
            }
            else if (source.isPrimitive() != target.isPrimitive()) {

                if (!target.isPrimitive()) {
                    if (source == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType) {
                        source = this.cachedNumberInterfaceType;
                    }
                    else if (source == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType) {
                        source = this.cachedStringInterfaceType;
                    }
                    else if (source == this.semanticInfoChain.boolTypeSymbol && this.cachedBooleanInterfaceType) {
                        source = this.cachedBooleanInterfaceType;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }

            comparisonCache[comboId] = false;

            if (source.hasBase(target)) {
                comparisonCache[comboId] = true;
                return true;
            }

            if (this.cachedObjectInterfaceType && target == this.cachedObjectInterfaceType) {
                return true;
            }

            if (this.cachedFunctionInterfaceType && (source.getCallSignatures().length || source.getConstructSignatures().length) && target == this.cachedFunctionInterfaceType) {
                return true;
            }

            // REVIEW: We should perhaps do this, though it wouldn't be quite right without generics support
            //if (this.typeFlow.arrayInterfaceType && (source.index) && target == this.typeFlow.arrayInterfaceType) {
            //    return true;
            //}

            // At this point, if the target is a class, but not the source or a parent of the source, bail
            if (target.isClass()) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (target.hasMembers() && source.hasMembers()) {
                var mProps = target.getMembers();
                var mProp: PullSymbol = null;
                var nProp: PullSymbol = null;
                var mPropType: PullTypeSymbol = null;
                var nPropType: PullTypeSymbol = null;

                for (var iMProp = 0; iMProp < mProps.length; iMProp++) {

                    mProp = mProps[iMProp];
                    nProp = source.findMember(mProp.getName());

                    // PULLTODO:
                    // methods do not have the "arguments" field
                    //if (mProp.getName() == "arguments" &&
                    //    this.cachedIArgumentsInterfaceType &&
                    //    (this.typeFlow.iargumentsInterfaceType.symbol.flags & SymbolFlags.CompilerGenerated) &&
                    //    mProp.kind() == SymbolKind.Variable &&
                    //    (<VariableSymbol>mProp).variable.typeLink.type == this.typeFlow.iargumentsInterfaceType) {
                    //    continue;
                    //}

                    if (!mProp.isResolved()) {
                        this.resolveDeclaredSymbol(mProp, context);
                    }

                    mPropType = mProp.getType();

                    if (!nProp) {
                        // If it's not present on the type in question, look for the property on 'Object'
                        if (this.cachedObjectInterfaceType) {
                            nProp = this.cachedObjectInterfaceType.findMember(mProp.getName());
                        }

                        if (!nProp) {
                            // Now, the property was not found on Object, but the type in question is a function, look
                            // for it on function
                            if (this.cachedFunctionInterfaceType && (mPropType.getCallSignatures().length || mPropType.getConstructSignatures().length)) {
                                nProp = this.cachedFunctionInterfaceType.findMember(mProp.getName());
                            }

                            // finally, check to see if the property is optional
                            if (!nProp) {
                                if (!(mProp.getIsOptional())) {
                                    comparisonCache[comboId] = undefined;
                                    if (comparisonInfo) { // only surface the first error
                                        comparisonInfo.flags |= TypeRelationshipFlags.RequiredPropertyIsMissing;
                                        comparisonInfo.addMessageToFront("Type '" + source.getName() + "' is missing property '" + mProp.getName() + "' from type '" + target.getName() + "'");
                                    }
                                    return false;
                                }
                                else {
                                    continue;
                                }
                            }
                        }
                    }

                    if (!nProp.isResolved()) {
                        this.resolveDeclaredSymbol(nProp, context);
                    }


                    nPropType = nProp.getType();

                    // catch the mutually recursive or cached cases
                    if (mPropType && nPropType && (comparisonCache[(nPropType.getSymbolID() << 16) | mPropType.getSymbolID()] != undefined)) {
                        continue;
                    }

                    if (!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, context, comparisonInfo)) {
                        comparisonCache[comboId] = undefined;
                        if (comparisonInfo) { // only surface the first error
                            comparisonInfo.flags |= TypeRelationshipFlags.IncompatiblePropertyTypes;
                            comparisonInfo.addMessageToFront("Types of property '" + mProp.getName() + "' of types '" + source.getName() + "' and '" + target.getName() + "' are incompatible");
                        }
                        return false;
                    }
                }
            }

            var sourceCallSigs = source.getCallSignatures();
            var targetCallSigs = target.getCallSignatures();

            var sourceConstructSigs = source.getConstructSignatures();
            var targetConstructSigs = target.getConstructSignatures();

            var sourceIndexSigs = source.getIndexSignatures();
            var targetIndexSigs = target.getIndexSignatures();

            // check signature groups
            if (sourceCallSigs.length || targetCallSigs.length) {
                if (!this.signatureGroupIsRelatableToTarget(sourceCallSigs, targetCallSigs, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (sourceCallSigs.length && targetCallSigs.length) {
                            comparisonInfo.addMessageToFront("Call signatures of types '" + source.getName() + "' and '" + target.getName() + "' are incompatible");
                        }
                        else {
                            var hasSig = targetCallSigs.length ? target.getName() : source.getName();
                            var lacksSig = !targetCallSigs.length ? target.getName() : source.getName();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a call signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            if (sourceConstructSigs.length || targetConstructSigs.length) {
                if (!this.signatureGroupIsRelatableToTarget(sourceConstructSigs, targetConstructSigs, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (sourceConstructSigs.length && targetConstructSigs.length) {
                            comparisonInfo.addMessageToFront("Construct signatures of types '" + source.getName() + "' and '" + target.getName() + "' are incompatible");
                        }
                        else {
                            var hasSig = targetConstructSigs.length ? target.getName() : source.getName();
                            var lacksSig = !targetConstructSigs.length ? target.getName() : source.getName();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a construct signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            if (targetIndexSigs.length) {
                var targetIndex = !targetIndexSigs.length && this.cachedObjectInterfaceType ? this.cachedObjectInterfaceType.getIndexSignatures() : targetIndexSigs;
                var sourceIndex = !sourceIndexSigs.length && this.cachedObjectInterfaceType ? this.cachedObjectInterfaceType.getIndexSignatures() : sourceIndexSigs;

                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.addMessageToFront("Index signatures of types '" + source.getName() + "' and '" + target.getName() + "' are incompatible");
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            comparisonCache[comboId] = true;
            return true;
        }

        // REVIEW: TypeChanges: Return an error context object so the user can get better diagnostic info
        public signatureGroupIsRelatableToTarget(sourceSG: PullSignatureSymbol[], targetSG: PullSignatureSymbol[], assignableTo: bool, comparisonCache: any, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) {
            if (sourceSG == targetSG) {
                return true;
            }

            if (!(sourceSG && targetSG)) {
                return false;
            }

            var mSig: PullSignatureSymbol = null;
            var nSig: PullSignatureSymbol = null;
            var foundMatch = false;

            for (var iMSig = 0; iMSig < targetSG.length; iMSig++) {
                mSig = targetSG[iMSig];

                for (var iNSig = 0; iNSig < sourceSG.length; iNSig++) {
                    nSig = sourceSG[iNSig];
                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, context, comparisonInfo)) {
                        foundMatch = true;
                        break;
                    }
                }

                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }

            return true;
        }

        public signatureIsRelatableToTarget(sourceSig: PullSignatureSymbol, targetSig: PullSignatureSymbol, assignableTo: bool, comparisonCache: any, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) {

            var sourceParameters = sourceSig.getParameters();
            var targetParameters = targetSig.getParameters();

            if (!sourceParameters.length || !targetParameters.length) {
                return false;
            }

            var targetVarArgCount = targetSig.hasVariableParamList() ? targetSig.getNonOptionalParameterCount() - 1 : targetSig.getNonOptionalParameterCount();
            var sourceVarArgCount = sourceSig.hasVariableParamList() ? sourceSig.getNonOptionalParameterCount() - 1 : sourceSig.getNonOptionalParameterCount();

            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableParamList()) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= TypeRelationshipFlags.SourceSignatureHasTooManyParameters;
                    comparisonInfo.addMessageToFront("Call signature expects " + targetVarArgCount + " or fewer parameters");
                }
                return false;
            }

            var sourceReturnType = sourceSig.getReturnType();
            var targetReturnType = targetSig.getReturnType();

            if (targetReturnType != this.semanticInfoChain.voidTypeSymbol) {
                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleReturnTypes;
                        // No need to print this one here - it's printed as part of the signature error in sourceIsRelatableToTarget
                        //comparisonInfo.addMessageToFront("Incompatible return types: '" + sourceReturnType.getTypeName() + "' and '" + targetReturnType.getTypeName() + "'");
                    }
                    return false;
                }
            }

            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableParamList()) ? targetVarArgCount : sourceVarArgCount;
            var sourceParamType: PullTypeSymbol = null;
            var targetParamType: PullTypeSymbol = null;
            var sourceParamName = "";
            var targetParamName = "";

            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {

                if (!sourceSig.hasVariableParamList || iSource < sourceVarArgCount) {
                    sourceParamType = sourceParameters[iSource].getType();
                    sourceParamName = sourceParameters[iSource].getName();
                }
                else if (iSource == sourceVarArgCount) {
                    sourceParamType = sourceParameters[iSource].getType();
                    if (sourceParamType.isArray()) {
                        sourceParamType = sourceParamType.getElementType();
                    }
                    sourceParamName = sourceParameters[iSource].getName();
                }

                if (iTarget < targetParameters.length && iTarget < targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].getType(); 
                    targetParamName = targetParameters[iTarget].getName();
                }
                else if (targetSig.hasVariableParamList && iTarget == targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].getType(); 
                    if (targetParamType.isArray()) {
                        targetParamType = targetParamType.getElementType();
                    }
                    targetParamName = targetParameters[iTarget].getName();
                }

                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, context, comparisonInfo) ||
                        this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, context, comparisonInfo))) {

                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleParameterTypes;
                    }
                    return false;
                }
            }
            return true;
        }

        // Overload resolution

        public resolveOverloads(application: AST, group: PullSignatureSymbol[], enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSignatureSymbol {
            var rd = this.resolutionDataCache.getResolutionData();
            var actuals = rd.actuals;
            var exactCandidates = rd.exactCandidates;
            var conversionCandidates = rd.conversionCandidates;
            var candidate: PullSignatureSymbol = null;
            var hasOverloads = group.length > 1;
            var comparisonInfo = new TypeComparisonInfo();
            var args: ASTList = null;
            var target: AST = null;
            var argSym: PullSymbol;

            if (application.nodeType == NodeType.Call || application.nodeType == NodeType.New) {
                var callEx = <CallExpression>application;
                
                args = callEx.arguments;
                target = callEx.target;

                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    
                    for (var i = 0; i < len; i++) {
                        argSym = this.resolveStatementOrExpression(callEx.arguments.members[i], false, enclosingDecl, context);
                        actuals[i] = argSym.getType();
                    }
                }
            }
            else if (application.nodeType == NodeType.Index) {
                var binExp = <BinaryExpression>application;
                target = binExp.operand1;
                args = new ASTList();
                args.members[0] = binExp.operand2;
                argSym = this.resolveStatementOrExpression(args.members[0], false, enclosingDecl, context);
                actuals[0] = argSym.getType();
            }

            var signature: PullSignatureSymbol;
            var returnType: PullTypeSymbol;

            for (var j = 0, groupLen = group.length; j < groupLen; j++) {
                signature = group[j];
                if (hasOverloads && signature.isDefinition()) {
                    continue;
                }

                returnType = signature.getReturnType();

                this.getCandidateSignatures(signature, actuals, exactCandidates, conversionCandidates, context, comparisonInfo);
            }
            if (exactCandidates.length == 0) {

                var applicableCandidates = this.getApplicableSignaturesFromCandidates(conversionCandidates, args, comparisonInfo, enclosingDecl, context);
                if (applicableCandidates.length > 0) {
                    var candidateInfo = this.findMostApplicableSignature(applicableCandidates, args, enclosingDecl, context);
                    if (candidateInfo.ambiguous) {
                        //this.errorReporter.simpleError(target, "Ambiguous call expression - could not choose overload");
                        context.postError(application.minChar, application.getLength(), this.unitPath, "Ambiguous call expression - could not choose overload", enclosingDecl);
                    }
                    candidate = candidateInfo.sig;
                }
                else {
                    var emsg = "Supplied parameters do not match any signature of call target";
                    if (comparisonInfo.message) {
                        //this.checker.errorReporter.simpleError(target, emsg + ":\n\t" + comparisonInfo.message);
                        context.postError(application.minChar, application.getLength(), this.unitPath, emsg + ":\n\t" + comparisonInfo.message, enclosingDecl);
                    }
                    else {
                        context.postError(application.minChar, application.getLength(), this.unitPath, emsg, enclosingDecl);
                        //this.checker.errorReporter.simpleError(target, emsg);
                    }
                }
            }
            else {
                if (exactCandidates.length > 1) {
                    var applicableSigs: PullApplicableSignature[] = [];
                    for (var i = 0; i < exactCandidates.length; i++) {
                        applicableSigs[i] = { signature: exactCandidates[i], hadProvisionalErrors: false };
                    }
                    var candidateInfo = this.findMostApplicableSignature(applicableSigs, args, enclosingDecl, context);
                    if (candidateInfo.ambiguous) {
                        //this.checker.errorReporter.simpleError(target, "Ambiguous call expression - could not choose overload");
                        context.postError(application.minChar, application.getLength(), this.unitPath, "Ambiguous call expression - could not choose overload", enclosingDecl);
                    }
                    candidate = candidateInfo.sig;
                }
                else {
                    candidate = exactCandidates[0];
                }
            }

            this.resolutionDataCache.returnResolutionData(rd);
            return candidate;
        }

        public getCandidateSignatures(signature: PullSignatureSymbol, actuals: PullTypeSymbol[], exactCandidates: PullSignatureSymbol[], conversionCandidates: PullSignatureSymbol[], context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo): void {
            var parameters = signature.getParameters();
            var lowerBound = signature.getNonOptionalParameterCount(); // required parameters
            var upperBound = parameters.length; // required and optional parameters
            var formalLen = lowerBound;
            var acceptable = false;

            if ((actuals.length >= lowerBound) && (signature.hasVariableParamList() || actuals.length <= upperBound)) {
                formalLen = (signature.hasVariableParamList() ? parameters.length : actuals.length);
                acceptable = true;
            }

            var repeatType: PullTypeSymbol = null;

            if (acceptable || signature.hasVariableParamList()) {
                // assumed structure here is checked when signature is formed
                if (signature.hasVariableParamList()) {
                    formalLen -= 1;
                    repeatType = parameters[formalLen].getType();
                    repeatType = repeatType.getElementType();
                    acceptable = actuals.length >= formalLen;
                }
                var len = actuals.length;

                var exact = acceptable;
                var convert = acceptable;

                var typeA: PullTypeSymbol;
                var typeB: PullTypeSymbol;

                for (var i = 0; i < len; i++) {

                    if (i < formalLen) {
                        typeA = parameters[i].getType();
                    }
                    else {
                        typeA = repeatType;
                    }

                    typeB = actuals[i];

                    if (!typeA || !typeB || !(this.typesAreIdentical(typeA, typeB))) {
                        exact = false;
                    }
                    // is the argument assignable to the parameter?
                    if (!this.sourceIsAssignableToTarget(typeB, typeA, context, comparisonInfo)) {
                        convert = false;
                    }
                    if (!(exact || convert)) {
                        break;
                    }
                }
                if (exact) {
                    exactCandidates[exactCandidates.length] = signature;
                }
                else if (convert && (exactCandidates.length == 0)) {
                    conversionCandidates[conversionCandidates.length] = signature;
                }
            }
        }

        public getApplicableSignaturesFromCandidates(candidateSignatures: PullSignatureSymbol[], 
                                        args: ASTList,
                                        comparisonInfo: TypeComparisonInfo,
                                        enclosingDecl: PullDecl,
                                        context: PullTypeResolutionContext): PullApplicableSignature[] {

            var applicableSigs: PullApplicableSignature[] = [];
            var memberType: PullTypeSymbol = null;
            var miss = false;
            var cxt: PullContextualTypeContext = null;
            var hadProvisionalErrors = false;

            var parameters: PullSymbol[];
            var signature: PullSignatureSymbol;
            var argSym: PullSymbol;

            for (var i = 0; i < candidateSignatures.length; i++) {
                miss = false;

                signature = candidateSignatures[i];
                parameters = signature.getParameters();

                for (var j = 0; j < args.members.length; j++) {

                    if (j >= parameters.length) {
                        continue;
                    }
                    memberType = parameters[j].getType();

                    // account for varargs
                    if (signature.hasVariableParamList() && (j >= signature.getNonOptionalParameterCount() - 1) && memberType.isArray()) {
                        memberType = memberType.getElementType();
                    }

                    if (memberType == this.semanticInfoChain.anyTypeSymbol) {
                        continue;
                    }
                    else if (args.members[j].nodeType == NodeType.FuncDecl) {
                        
                        if (this.cachedFunctionInterfaceType && memberType == this.cachedFunctionInterfaceType) {
                            continue;
                        }

                        argSym = this.resolveFunctionExpression(<FuncDecl>args.members[j], false, enclosingDecl, context);
                        
                        if (!this.canApplyContextualTypeToFunction(memberType, <FuncDecl>args.members[j], true)) {
                            // if it's just annotations that are blocking us, typecheck the function and add it to the list
                            if (this.canApplyContextualTypeToFunction(memberType, <FuncDecl>args.members[j], false)) {
                                if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                                    break;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        else { // if it can be contextually typed, try it out...
                            //argSym.invalidate();
                            context.pushContextualType(memberType, true, null);

                            argSym = this.resolveFunctionExpression(<FuncDecl>args.members[j], true, enclosingDecl, context);

                            if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                                if (comparisonInfo) {
                                    comparisonInfo.setMessage("Could not apply type '" + memberType.getName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                                }
                                miss = true;
                            }

                            cxt = context.popContextualType();
                            hadProvisionalErrors = cxt.hadProvisionalErrors();

                            //argSym.invalidate();

                            //this.resetProvisionalErrors();
                            if (miss) {
                                break;
                            }
                        }
                    }
                    else if (args.members[j].nodeType == NodeType.ObjectLit) {
                        // now actually attempt to typecheck as the contextual type
                        if (this.cachedObjectInterfaceType && memberType == this.cachedObjectInterfaceType) {
                            continue;
                        }
                        context.pushContextualType(memberType, true, null);
                        argSym = this.resolveObjectLiteralExpression(args.members[j], true, enclosingDecl, context);
                        

                        if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.getName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                            }
                            miss = true;
                        }

                        cxt = context.popContextualType();
                        hadProvisionalErrors = cxt.hadProvisionalErrors();
                        
                        //argSym.invalidate();

                        //this.resetProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    }
                    else if (args.members[j].nodeType == NodeType.ArrayLit) {
                        // attempt to contextually type the array literal
                        if (this.cachedArrayInterfaceType && memberType == this.cachedArrayInterfaceType) {
                            continue;
                        }
                        
                        context.pushContextualType(memberType, true, null);
                        argSym = this.resolveArrayLiteralExpression(args.members[j], true, enclosingDecl, context);
                        
                        if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.getName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                            }
                            break;
                        }

                        cxt = context.popContextualType();

                        hadProvisionalErrors = cxt.hadProvisionalErrors();

                        //argSym.invalidate();

                        if (miss) {
                            break;
                        }
                    }
                }

                if (j == args.members.length) {
                    applicableSigs[applicableSigs.length] = { signature: candidateSignatures[i], hadProvisionalErrors: hadProvisionalErrors };
                }
                hadProvisionalErrors = false;
            }

            return applicableSigs;
        }

        public findMostApplicableSignature(signatures: PullApplicableSignature[], args: ASTList, enclosingDecl: PullDecl, context: PullTypeResolutionContext): { sig: PullSignatureSymbol; ambiguous: bool; } {

            if (signatures.length == 1) {
                return { sig: signatures[0].signature, ambiguous: false };
            }

            var best: PullApplicableSignature = signatures[0];
            var Q: PullApplicableSignature = null;
            
            var AType: PullTypeSymbol = null;
            var PType: PullTypeSymbol = null;
            var QType: PullTypeSymbol = null;
            
            var ambiguous = false;

            var argSym: PullSymbol;

            var bestParams: PullSymbol[];
            var qParams: PullSymbol[];

            for (var qSig = 1; qSig < signatures.length; qSig++) {
                Q = signatures[qSig];
                var i = 0;

                // find the better conversion
                for (i = 0; args && i < args.members.length; i++) {

                    argSym = this.resolveStatementOrExpression(args.members[i], false, enclosingDecl, context);

                    AType = argSym.getType();

                    // invalidate the argument so that we may correctly resolve it later as part of the call expression
                    argSym.invalidate();

                    bestParams = best.signature.getParameters();
                    qParams = Q.signature.getParameters();

                    PType = i < bestParams.length ? bestParams[i].getType() : bestParams[bestParams.length - 1].getType().getElementType();
                    QType = i < qParams.length ? qParams[i].getType() : qParams[qParams.length - 1].getType().getElementType();

                    if (this.typesAreIdentical(PType, QType)) {
                        continue;
                    }
                    else if (this.typesAreIdentical(AType, PType)) {
                        break;
                    }
                    else if (this.typesAreIdentical(AType, QType)) {
                        best = Q;
                        break;
                    }
                    else if (this.sourceIsSubtypeOfTarget(PType, QType, context)) {
                        break;
                    }
                    else if (this.sourceIsSubtypeOfTarget(QType, PType, context)) {
                        best = Q;
                        break;
                    }
                    else if (Q.hadProvisionalErrors) {
                        break;
                    }
                    else if (best.hadProvisionalErrors) {
                        best = Q;
                        break;
                    }
                }

                if (!args || i == args.members.length) {
                    var collection: IPullTypeCollection = {
                        getLength: () => { return 2; },
                        setTypeAtIndex: (index: number, type: PullTypeSymbol) => { }, // no contextual typing here, so no need to do anything
                        getTypeAtIndex: (index: number) => { return index ? Q.signature.getReturnType() : best.signature.getReturnType(); } // we only want the "second" type - the "first" is skipped
                    }
                    var bct = this.findBestCommonType(best.signature.getReturnType(), null, collection, false, context);
                    ambiguous = !bct;
                }
                else {
                    ambiguous = false;
                }
            }

            return { sig: best.signature, ambiguous: ambiguous };
        }

        public canApplyContextualTypeToFunction(candidateType: PullTypeSymbol, funcDecl: FuncDecl, beStringent: bool): bool {

            // in these cases, we do not attempt to apply a contextual type
            //  RE: isInlineCallLiteral - if the call target is a function literal, we don't want to apply the target type
            //  to its body - instead, it should be applied to its return type
            if (funcDecl.isParenthesized ||
                funcDecl.isMethod() ||
                beStringent && funcDecl.returnTypeAnnotation ||
                funcDecl.isInlineCallLiteral) {
                return false;
            }

            beStringent = beStringent || (this.cachedFunctionInterfaceType == candidateType);

            // At this point, if we're not being stringent, there's no need to check for multiple call sigs
            // or count parameters - we just want to unblock typecheck
            if (!beStringent) {
                return true;
            }

            var signature = this.getSymbolForAST(funcDecl).getType().getCallSignatures()[0];
            var parameters = signature.getParameters();
            var paramLen = parameters.length;

            // Check that the argument declarations have no type annotations
            for (var i = 0; i < paramLen; i++) {
                var param = parameters[i];
                var argDecl = <ArgDecl>this.getASTForSymbol(param);

                // REVIEW: a valid typeExpr is a requirement for varargs,
                // so we may want to revise our invariant
                if (beStringent && argDecl.typeExpr) {
                    return false;
                }
            }

            if (candidateType.getConstructSignatures().length && candidateType.getCallSignatures().length) {
                return false;
            }

            var candidateSigs = candidateType.getConstructSignatures().length ? candidateType.getConstructSignatures() : candidateType.getCallSignatures();

            if (!candidateSigs || candidateSigs.length > 1) {
                return false;
            }

            // if we're here, the contextual type can be applied to the function
            return true;
        }

        public inferArgumentTypesForSignature(signature: PullSignatureSymbol,
                                                args: ASTList,
                                                comparisonInfo: TypeComparisonInfo,
                                                enclosingDecl: PullDecl,
                                                context: PullTypeResolutionContext): PullTypeSymbol[] {

            var cxt: PullContextualTypeContext = null;
            var hadProvisionalErrors = false;

            var argSym: PullSymbol;

            var parameters = signature.getParameters();
            var typeParameters = signature.getTypeParameters();
            var argContext = new ArgumentInferenceContext();

            var parameterType: PullTypeSymbol = null;

            // seed each type parameter with the undefined type, so that we can widen it to 'any'
            // if no inferences can be made
            for (var i = 0; i < typeParameters.length; i++) {
                argContext.addCandidateForInference(typeParameters[i], null, false);
            }

            var substitutions: any;
            var inferenceCandidates: PullTypeSymbol[];
            var inferenceCandidate: PullTypeSymbol;

            for (var i = 0; i < args.members.length; i++) {

                if (i >= parameters.length) {
                    break;
                }

                parameterType = parameters[i].getType();

                // account for varargs
                if (signature.hasVariableParamList() && (i >= signature.getNonOptionalParameterCount() - 1) && parameterType.isArray()) {
                    parameterType = parameterType.getElementType();
                }

                inferenceCandidates = argContext.getInferenceCandidates();
                substitutions = {};

                if (inferenceCandidates.length) {
                    for (var j = 0; j < inferenceCandidates.length; j++) {
                        
                        inferenceCandidate = inferenceCandidates[j];
                        
                        substitutions = inferenceCandidates[j];

                        context.pushContextualType(parameterType, true, substitutions);
                        argSym = this.resolveStatementOrExpression(args.members[i], true, enclosingDecl, context);

                        this.relateTypeToTypeParameters(argSym.getType(), parameterType, false, argContext, enclosingDecl, context);

                        cxt = context.popContextualType();
                        hadProvisionalErrors = cxt.hadProvisionalErrors();
                    }
                }
                else {
                    context.pushContextualType(parameterType, true, {});
                    argSym = this.resolveStatementOrExpression(args.members[i], true, enclosingDecl, context);

                    this.relateTypeToTypeParameters(argSym.getType(), parameterType, false, argContext, enclosingDecl, context);

                    cxt = context.popContextualType();
                    hadProvisionalErrors = cxt.hadProvisionalErrors();
                }
            }

            hadProvisionalErrors = false;

            var inferenceResults = argContext.inferArgumentTypes(this, context);
            

            if (inferenceResults.unfit) {
                return null;
            }

            var resultTypes: PullTypeSymbol[] = [];

            for (var i = 0; i < inferenceResults.results.length; i++) {
                resultTypes[resultTypes.length] = inferenceResults.results[i].type;
            }

            return resultTypes;
        }

        public relateTypeToTypeParameters(expressionType: PullTypeSymbol,
                                            parameterType: PullTypeSymbol,
                                            shouldFix: bool,
                                            argContext: ArgumentInferenceContext,
                                            enclosingDecl: PullDecl,
                                            context: PullTypeResolutionContext): void {

            if (parameterType == expressionType) {
                return;
            }

            if (parameterType.isTypeParameter()) {
                argContext.addCandidateForInference(<PullTypeParameterSymbol>parameterType, expressionType, shouldFix);
                return;
            }

            // if the expression and parameter type, with type arguments of 'any', are not assignment compatible, ignore
            var anyExpressionType = this.specializeTypeToAny(expressionType, enclosingDecl, context);
            var anyParameterType = this.specializeTypeToAny(parameterType, enclosingDecl, context);

            if (!this.sourceIsAssignableToTarget(anyExpressionType, anyParameterType, context)) {
                return;
            }

            if (expressionType.isArray() && parameterType.isArray()) {
                this.relateArrayTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);

                return;
            }
            
            this.relateObjectTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);
        }
        
        public relateFunctionSignatureToTypeParameters(expressionSignature: PullSignatureSymbol,
                                                        parameterSignature: PullSignatureSymbol,
                                                        argContext: ArgumentInferenceContext,
                                                        enclosingDecl: PullDecl,
                                                        context: PullTypeResolutionContext): void {
            // Sub in 'any' for type parameters

            var anyExpressionSignature = this.specializeSignatureToAny(expressionSignature, enclosingDecl, context);
            var anyParamExpressionSignature = this.specializeSignatureToAny(parameterSignature, enclosingDecl, context);

            if (!this.signatureIsAssignableToTarget(anyExpressionSignature, anyParamExpressionSignature, context)) {
                return;
            }

            var expressionParams = expressionSignature.getParameters();
            var expressionReturnType = expressionSignature.getReturnType();

            var parameterParams = parameterSignature.getParameters();
            var parameterReturnType = parameterSignature.getReturnType();

            var len = parameterParams.length < expressionParams.length ? parameterParams.length : expressionParams.length;

            for (var i = 0; i < len; i++) {
                this.relateTypeToTypeParameters(expressionParams[i].getType(), parameterParams[i].getType(), true, argContext, enclosingDecl, context);
            }

            this.relateTypeToTypeParameters(expressionReturnType, parameterReturnType, true, argContext, enclosingDecl, context);
        }

        public relateObjectTypeToTypeParameters(objectType: PullTypeSymbol,
                                                parameterType: PullTypeSymbol,
                                                shouldFix: bool,
                                                argContext: ArgumentInferenceContext,
                                                enclosingDecl: PullDecl,
                                                context: PullTypeResolutionContext): void {

            var parameterTypeMembers = parameterType.getMembers();
            var parameterSignatures: PullSignatureSymbol[];
            var parameterSignature: PullSignatureSymbol;

            var objectMember: PullSymbol;
            var objectSignatures: PullSignatureSymbol[];

            for (var i = 0; i < parameterTypeMembers.length; i++) {
                objectMember = objectType.findMember(parameterTypeMembers[i].getName());

                if (objectMember) {
                    this.relateTypeToTypeParameters(objectMember.getType(), parameterTypeMembers[i].getType(), shouldFix, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getCallSignatures();
            objectSignatures = objectType.getCallSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];
                
                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }                
            }

            parameterSignatures = parameterType.getConstructSignatures();
            objectSignatures = objectType.getConstructSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getIndexSignatures();
            objectSignatures = objectType.getIndexSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }            
        }

        public relateArrayTypeToTypeParameters(argArrayType: PullTypeSymbol,
                                                parameterArrayType: PullTypeSymbol,
                                                shouldFix: bool,
                                                argContext: ArgumentInferenceContext,
                                                enclosingDecl: PullDecl,
                                                context: PullTypeResolutionContext): void {

            var argElement = argArrayType.getElementType();
            var paramElement = parameterArrayType.getElementType();

            this.relateTypeToTypeParameters(argElement, paramElement, shouldFix, argContext, enclosingDecl, context);
        }

        public specializeTypeToAny(typeToSpecialize: PullTypeSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            return specializeType(typeToSpecialize, [], this, enclosingDecl, context);
        }

        public specializeSignatureToAny(signatureToSpecialize: PullSignatureSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            var typeParameters = signatureToSpecialize.getTypeParameters();
            var typeReplacementMap: any = {};
            var typeArguments: PullTypeSymbol[] = []; // PULLTODO - may be expensive, but easy to cache

            for (var i = 0; i < typeParameters.length; i++) {
                typeArguments[i] = this.semanticInfoChain.anyTypeSymbol;
                typeReplacementMap[typeParameters[i].getSymbolID().toString()] = typeArguments[i];
            }
            
            // no need to worry about returning 'null', since 'any' satisfies all constraints
            return specializeSignature(signatureToSpecialize, false, typeReplacementMap, typeArguments, this, enclosingDecl, context);
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {

    export function prePullTypeCheck(ast: AST, parent: AST, walker: IAstWalker): AST {

        var typeChecker: PullTypeChecker = walker.state;

        var go = false;

        if (ast.nodeType == NodeType.Script) {
            ast = typeChecker.typeCheckScript(<Script>ast);
            go = true;
        }
        if (ast.nodeType == NodeType.List) {
            go = true;
        }
        else if (ast.nodeType == NodeType.VarDecl) {
            ast = typeChecker.typeCheckBoundDecl(<BoundDecl>ast);
        }
        else if (ast.nodeType == NodeType.Asg) {
            ast = typeChecker.typeCheckAsgOperator(ast);
        }
        else if (ast.nodeType == NodeType.FuncDecl) {
            ast = typeChecker.typeCheckFunction(<FuncDecl>ast);
            go = true;
        }
        else if (ast.nodeType == NodeType.ClassDeclaration) {
            ast = typeChecker.typeCheckClass(<ClassDeclaration>ast);
            go = true;
        }
        else if (ast.nodeType == NodeType.InterfaceDeclaration) {
            ast = typeChecker.typeCheckInterface(<TypeDeclaration>ast);
            go = true;
        }
        else if (ast.nodeType == NodeType.ModuleDeclaration) {
            ast = typeChecker.typeCheckModule(<ModuleDeclaration>ast);
            go = true;
        }
        //else if (ast.nodeType == NodeType.This) {
        //    ast = typeChecker.typeCheckThis(ast);
        //}
        //else if (ast.nodeType == NodeType.Name) {
        //    ast = typeChecker.typeCheckName(ast);
        //}
        //else if (ast.nodeType == NodeType.ObjectLit) {
        //    ast = typeChecker.typeCheckObjectLit(<UnaryExpression>ast);
        //}
        //else if (ast.nodeType == NodeType.Return) {
        //    ast = typeChecker.typeCheckReturn(<ReturnStatement>ast);
        //}
        //else if (ast.nodeType == NodeType.New) {
        //    ast = typeChecker.typeCheckNew(ast);
        //}
        //else if (ast.nodeType == NodeType.Call) {
        //    ast = typeChecker.typeCheckCall(ast);
        //}

        walker.options.goChildren = go;
        return ast;
    }

    export class PullTypeChecker {

        public typingMap: DataMap = new DataMap();
        public errorMap: DataMap = new DataMap();
        public symbolTypeCheckStatusMap: DataMap = new DataMap();

        public semanticInfoChain: SemanticInfoChain;

        public resolver: PullTypeResolver = null;

        public context: PullTypeResolutionContext = new PullTypeResolutionContext();

        constructor (semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
        }

        public setUnit(unitPath: string) {
            this.resolver = new PullTypeResolver(this.semanticInfoChain, unitPath);
        }

        public typeCheck(ast: AST): AST {
            return ast;
        }

        public typeCheckScript(script: Script): Script {
            return script;
        }

        public typeCheckFunction(funcDecl: FuncDecl): FuncDecl {
            var sym = this.resolver.resolveFunctionDeclaration(funcDecl, this.context);
            return funcDecl;
        }

        public typeCheckClass(classDecl: ClassDeclaration): ClassDeclaration {
            var sym = this.resolver.resolveClassDeclaration(classDecl, this.context);
            return classDecl;
        }

        public typeCheckInterface(interfaceDecl: TypeDeclaration): TypeDeclaration {
            var sym = this.resolver.resolveInterfaceDeclaration(interfaceDecl, this.context);
            return interfaceDecl;
        }

        public typeCheckModule(moduleDecl: ModuleDeclaration): ModuleDeclaration {
            var sym = this.resolver.resolveModuleDeclaration(moduleDecl, this.context);
            return moduleDecl;
        }

        public typeCheckBoundDecl(varDecl: BoundDecl): BoundDecl {
            var sym = this.resolver.resolveVariableDeclaration(varDecl, this.context);
            return varDecl;
        }

        public typeCheckThis(ast: AST): AST {
            return ast;
        }

        public typeCheckName(ast: AST): AST {
            return ast;
        }

        public typeCheckAsgOperator(ast: AST): AST {
            return ast;
        }

        public typeCheckObjectLit(objectLit: UnaryExpression): UnaryExpression {
            return objectLit;
        }

        public typeCheckReturn(returnStmt: ReturnStatement): ReturnStatement {
            return returnStmt;
        }

        public typeCheckNew(ast: AST): AST {
            return ast;
        }

        public typeCheckCall(ast: AST): AST {
            return ast;
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {

    export enum PullDeclEdit {
        NoChanges,
        DeclAdded,
        DeclRemoved,
        DeclChanged,
    }


    export class PullDeclDiff {

        constructor(public oldDecl: PullDecl, public newDecl: PullDecl, public kind: PullDeclEdit) { }
    
    }

    export class PullDeclDiffer {

        /*
        What can change?

        - decl name
        - decl type
        - decl span
        - decl flags

        */

        // For now, just check for there/not there - we'll invalidate the inference symbols anyway
        // next up, we'll want to use this data to find the decl that changed
        public diffDecls(oldDecl: PullDecl, newDecl: PullDecl, diffs: PullDeclDiff[]) {
            // check the children
            var oldDeclChildren = oldDecl.getChildDecls();
            var newDeclChildren = newDecl.getChildDecls();
            var foundDecls: PullDecl[];
            var foundDiff = false;

            for (var i = 0; i < oldDeclChildren.length; i++) {
                foundDecls = newDecl.findChildDecls(oldDeclChildren[i].getName(), oldDeclChildren[i].getKind());

                if (!foundDecls.length) {
                    diffs[diffs.length] = new PullDeclDiff(oldDeclChildren[i], null, PullDeclEdit.DeclRemoved);
                    foundDiff = true;
                }
                else if (foundDecls.length == 1) { // just care about non-split entities for now
                    this.diffDecls(oldDeclChildren[i], foundDecls[0], diffs);
                }
            }

            for (var i = 0; i < newDeclChildren.length; i++) {
                foundDecls = oldDecl.findChildDecls(newDeclChildren[i].getName(), newDeclChildren[i].getKind());

                if (!foundDecls.length) {
                    diffs[diffs.length] = new PullDeclDiff(oldDecl, newDeclChildren[i], PullDeclEdit.DeclAdded);
                    foundDiff = true;
                }
            }

            if (!foundDiff) {
                newDecl.setErrors(oldDecl.getErrors());
            }
        }
    }


}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {

    // pull errors are declared at a specific offset from a given decl
    // adjustedOffset is set when the error is added to a decl

    export interface SemanticError {
        length: number;
        filename: string;
        message: string;

        adjustOffset(pos: number): void;
        getOffset(): number;
    }

    export class PullError implements SemanticError {
        private adjustedOffset: number;

        constructor(private offset: number, public length: number, public filename: string, public message: string) {
            this.adjustedOffset = offset;
        }

        public adjustOffset(pos: number) {
            this.adjustedOffset = this.offset + pos;
        }

        public getOffset() {
            return this.adjustedOffset;
        }
    }

    export function getErrorsFromEnclosingDecl(enclosingDecl: PullDecl, errors: SemanticError[]) {
        var declErrors = enclosingDecl.getErrors();

        if (declErrors) {
            for (var i = 0; i < declErrors.length; i++) {
                errors[errors.length] = declErrors[i];
            }
        }

        var childDecls = enclosingDecl.getChildDecls();

        for (var i = 0; i < childDecls.length; i++) {
            getErrorsFromEnclosingDecl(childDecls[i], errors);
        }
    }

    export class PullErrorReporter {

        public lineCol = { line: 0, col: 0 };
        public locationInfoCache: any = {};

        constructor(public textWriter: ITextWriter) {
        }

        public setUnits(units: LocationInfo[]) {
            this.locationInfoCache = {};

            for (var i = 0; i < units.length; i++) {
                this.locationInfoCache[units[i].filename] = units[i];
            }
        }

        public reportError(error: SemanticError) {
            var locationInfo = this.locationInfoCache[error.filename];

            if (locationInfo && locationInfo.lineMap) {
                getSourceLineColFromMap(this.lineCol, error.getOffset(), locationInfo.lineMap);

                this.textWriter.Write(locationInfo.filename + "(" + this.lineCol.line + "," + this.lineCol.col + "): ");
            }
            else {
                this.textWriter.Write(error.filename + "(0,0): ");
            }

            this.textWriter.WriteLine(error.message);
        }

        public reportErrors(errors: SemanticError[]) {
            for (var i = 0; i < errors.length; i++) {
                this.reportError(errors[i]);
            }
        }
    }
}
///<reference path='ArrayUtilities.ts' />
///<reference path='Hash.ts' />

module Collections {
    export var DefaultHashTableCapacity = 256;

    class HashTableEntry {
        constructor(public Key: any,
                    public Value: any,
                    public HashCode: number,
                    public Next: HashTableEntry) {
        }
    }

    export class HashTable {
        // TODO: figure out why the type checker dosn't like "HashTableEntry[]" here.
        private entries /*: HashTableEntry[]*/ = [];
        private count: number = 0;

        constructor(capacity: number,
                    private hash: (k: any) => number,
                    private equals: (k1: any, k2: any) => bool) {
            var size = Hash.getPrime(capacity);
            this.hash = hash;
            this.equals = equals;
            this.entries = ArrayUtilities.createArray(size);
        }

        // Maps 'key' to 'value' in this table.  Does not throw if 'key' is already in the table.
        public set(key: any, value: any) {
            this.addOrSet(key, value, /*throwOnExistingEntry:*/ false);
        }

        // Maps 'key' to 'value' in this table.  Throws if 'key' is already in the table.
        public add(key: any, value: any) {
            this.addOrSet(key, value, /*throwOnExistingEntry:*/ true);
        }

        public containsKey(key: any): bool {
            var hashCode = this.computeHashCode(key);
            var entry = this.findEntry(key, hashCode);
            return entry !== null;
        }

        public get (key: any): any {
            var hashCode = this.computeHashCode(key);
            var entry = this.findEntry(key, hashCode);

            return entry === null ? null : entry.Value;
        }

        private computeHashCode(key: any): number {
            var hashCode = this.hash === null
                ? key.hashCode()
                : this.hash(key);

            hashCode = hashCode & 0x7FFFFFFF;
            Debug.assert(hashCode > 0);

            return hashCode;
        }

        private addOrSet(key: any, value: any, throwOnExistingEntry: bool) {
            // Compute the hash for this key.  Also ensure that it's non negative.
            var hashCode = this.computeHashCode(key);

            var entry = this.findEntry(key, hashCode);
            if (entry !== null) {
                if (throwOnExistingEntry) {
                    throw Errors.argument('key', 'Key was already in table.');
                }

                entry.Key = key;
                entry.Value = value;
                return;
            }

            return this.addEntry(key, value, hashCode);
        }

        private findEntry(key: any, hashCode: number) /*: HashTableEntry*/ {
            for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                if (e.HashCode === hashCode) {
                    var equals = this.equals === null
                        ? key === e.Key
                        : this.equals(key, e.Key);

                    if (equals) {
                        return e;
                    }
                }
            }

            return null;
        }

        private addEntry(key: any, value: any, hashCode: number): any {
            var index = hashCode % this.entries.length;

            var e = new HashTableEntry(key, value, hashCode, this.entries[index]);

            this.entries[index] = e;

            // Right now we grow when we get a load factor of 1.  We're basically guaranteed to have had
            // a collision at that point.  Should we potentially change this to a lower load factor?  It
            // will require more space, but provide us with faster lookup.  We could potentially make this
            // configurable as well.
            if (this.count === this.entries.length) {
                this.grow();
            }

            this.count++;
            return e.Key;
        }

        //private dumpStats() {
        //    var standardOut = Environment.standardOut;

        //    standardOut.WriteLine("----------------------")
        //    standardOut.WriteLine("Hash table stats");
        //    standardOut.WriteLine("Count            : " + this.count);
        //    standardOut.WriteLine("Entries Length   : " + this.entries.length);

        //    var occupiedSlots = 0;
        //    for (var i = 0; i < this.entries.length; i++) {
        //        if (this.entries[i] !== null) {
        //            occupiedSlots++;
        //        }
        //    }

        //    standardOut.WriteLine("Occupied slots   : " + occupiedSlots);
        //    standardOut.WriteLine("Avg Length/Slot  : " + (this.count / occupiedSlots));
        //    standardOut.WriteLine("----------------------");
        //}

        private grow(): void {
            // this.dumpStats();

            var newSize = Hash.expandPrime(this.entries.length);

            var oldEntries = this.entries;
            var newEntries: HashTableEntry[] = ArrayUtilities.createArray(newSize);

            this.entries = newEntries;

            for (var i = 0; i < oldEntries.length; i++) {
                var e = oldEntries[i];

                while (e !== null) {
                    var newIndex = e.HashCode % newSize;
                    var tmp = e.Next;
                    e.Next = newEntries[newIndex];
                    newEntries[newIndex] = e;
                    e = tmp;
                }
            }

            // this.dumpStats();
        }
    }

    export function createHashTable(capacity: number = DefaultHashTableCapacity,
                                    hash: (k: any) => number = null,
                                    equals: (k1: any, k2: any) => bool = null): HashTable {
        return new HashTable(capacity, hash, equals);
    }

    var currentHashCode = 1;
    export function identityHashCode(value: any): number {
        if (value.__hash === undefined) {
            value.__hash = currentHashCode;
            currentHashCode++;
        }

        return value.__hash;
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />
///<reference path='..\Core\HashTable.ts' />
///<reference path='..\Syntax\ISyntaxElement.ts' />



module TypeScript {
    
    // per-file info on 
    //  decls
    //  bindings
    //  scopes

    // PULLTODO: Get rid of these
    export var declCacheHit = 0;
    export var declCacheMiss = 0;
    export var symbolCacheHit = 0;
    export var symbolCacheMiss = 0;

    export class SemanticInfo {
        private compilationUnitPath: string;  // the "file" this is associated with

        private topLevelDecls: PullDecl[] = [];
        
        private astDeclMap: DataMap = new DataMap();
        private declASTMap: DataMap = new DataMap();

        private syntaxElementDeclMap: DataMap = new DataMap();
        private declSyntaxElementMap: DataMap = new DataMap();
        
        private declSymbolMap: DataMap = new DataMap();
        
        private astSymbolMap: DataMap = new DataMap();
        private symbolASTMap: DataMap = new DataMap();

        private syntaxElementSymbolMap: DataMap = new DataMap();
        private symbolSyntaxElementMap: DataMap = new DataMap();

        constructor (compilationUnitPath: string, public locationInfo: LocationInfo = null) {
            this.compilationUnitPath = compilationUnitPath;
        }

        public addTopLevelDecl(decl: PullDecl) {
            this.topLevelDecls[this.topLevelDecls.length] = decl;
        }

        public getTopLevelDecls() { return this.topLevelDecls; }

        public getPath(): string { 
            return this.compilationUnitPath; 
        }

        public getDeclForAST(ast: AST): PullDecl { 
            return <PullDecl>this.astDeclMap.read(ast.getID().toString()); 
        }

        public setDeclForAST(ast: AST, decl: PullDecl): void {
            this.astDeclMap.link(ast.getID().toString(), decl);
        }

        public getASTForDecl(decl: PullDecl): AST {
            return <AST>this.declASTMap.read(decl.getDeclID().toString() + decl.getKind().toString());
        }

        public setASTForDecl(decl: PullDecl, ast: AST): void {
            this.declASTMap.link(decl.getDeclID().toString() + decl.getKind().toString(), ast);
        }

        public setSymbolForAST(ast: AST, symbol: PullSymbol): void {
            this.astSymbolMap.link(ast.getID().toString(), symbol);
            this.symbolASTMap.link(symbol.getSymbolID().toString(), ast) 
        }
        
        public getSymbolForAST(ast: AST): PullSymbol {
            return <PullSymbol>this.astSymbolMap.read(ast.getID().toString());
        }

        public getASTForSymbol(symbol: PullSymbol): AST {
            return <AST>this.symbolASTMap.read(symbol.getSymbolID().toString());
        }

        public getSyntaxElementForDecl(decl: PullDecl): ISyntaxElement {
            return <ISyntaxElement>this.declSyntaxElementMap.read(decl.getDeclID().toString() + decl.getKind().toString());
        }

        public setSyntaxElementForDecl(decl: PullDecl, syntaxElement: ISyntaxElement): void {
            this.declSyntaxElementMap.link(decl.getDeclID().toString() + decl.getKind().toString(), syntaxElement);
        }

        public getDeclForSyntaxElement(syntaxElement: ISyntaxElement): PullDecl {
            return <PullDecl>this.syntaxElementDeclMap.read(Collections.identityHashCode(syntaxElement).toString());
        }

        public setDeclForSyntaxElement(syntaxElement: ISyntaxElement, decl: PullDecl): void {
            this.syntaxElementDeclMap.link(Collections.identityHashCode(syntaxElement).toString(), decl);
        }

        public getSyntaxElementForSymbol(symbol: PullSymbol): ISyntaxElement {
            return <ISyntaxElement> this.symbolSyntaxElementMap.read(symbol.getSymbolID().toString());
        }

        public getSymbolForSyntaxElement(syntaxElement: ISyntaxElement): PullSymbol {
            return <PullSymbol>this.syntaxElementSymbolMap.read(Collections.identityHashCode(syntaxElement).toString());
        }

        public setSymbolForSyntaxElement(syntaxElement: ISyntaxElement, symbol: PullSymbol) {
            this.syntaxElementSymbolMap.link(Collections.identityHashCode(syntaxElement).toString(), symbol);
            this.symbolSyntaxElementMap.link(symbol.getSymbolID().toString(), syntaxElement);
        }

        public getErrors(semanticErrors: SemanticError[]) {
            for (var i = 0; i < this.topLevelDecls.length; i++) {
                getErrorsFromEnclosingDecl(this.topLevelDecls[i], semanticErrors);
            }
        }
    }

    export class SemanticInfoChain {
        public units: SemanticInfo[] = [new SemanticInfo("")];
        private declCache = <any>new BlockIntrinsics();
        private symbolCache = <any>new BlockIntrinsics();
        private unitCache = <any>new BlockIntrinsics();

        public anyTypeSymbol: PullTypeSymbol = null;
        public boolTypeSymbol: PullTypeSymbol = null;
        public numberTypeSymbol: PullTypeSymbol = null;
        public stringTypeSymbol: PullTypeSymbol = null;
        public nullTypeSymbol: PullTypeSymbol = null;
        public undefinedTypeSymbol: PullTypeSymbol = null;
        public elementTypeSymbol: PullTypeSymbol = null;
        public voidTypeSymbol: PullTypeSymbol = null;

        public addPrimitive(name: string, globalDecl: PullDecl) {
            var span = new DeclSpan();
            var decl = new PullDecl(name, PullElementKind.Primitive, PullElementFlags.None, span, "");
            var symbol = new PullPrimitiveTypeSymbol(name);

            symbol.addDeclaration(decl);
            decl.setSymbol(symbol);

            symbol.setResolved();

            globalDecl.addChildDecl(decl);

            return symbol;
        }

        constructor () {
            var span = new DeclSpan();
            var globalDecl = new PullDecl("", PullElementKind.Global, PullElementFlags.None, span, "");
            var globalInfo = this.units[0];
            globalInfo.addTopLevelDecl(globalDecl);
            
            // add primitive types
            this.anyTypeSymbol = this.addPrimitive("any", globalDecl);
            this.boolTypeSymbol = this.addPrimitive("bool", globalDecl);
            this.numberTypeSymbol = this.addPrimitive("number", globalDecl);
            this.stringTypeSymbol = this.addPrimitive("string", globalDecl);
            this.nullTypeSymbol = this.addPrimitive("null", globalDecl);
            this.undefinedTypeSymbol = this.addPrimitive("undefined", globalDecl);
            this.voidTypeSymbol = this.addPrimitive("void", globalDecl);
            this.elementTypeSymbol = this.addPrimitive("_element", globalDecl);
        }

        public addUnit(unit: SemanticInfo) {
            this.units[this.units.length] = unit;
            this.unitCache[unit.getPath()] = unit;
        }

        public getUnit(compilationUnitPath: string) {
            for (var i = 0; i < this.units.length; i++) {
                if (this.units[i].getPath() == compilationUnitPath) {
                    return this.units[i];
                }
            }

            return null;
        }

        // PULLTODO: compilationUnitPath is only really there for debug purposes
        public updateUnit(oldUnit: SemanticInfo, newUnit: SemanticInfo) {
            for (var i = 0; i < this.units.length; i++) {
                if (this.units[i] == oldUnit) {
                    this.units[i] = newUnit;
                    this.unitCache[oldUnit.getPath()] = newUnit;
                    return;
                }
            }
        }

        private collectAllTopLevelDecls() {
            var decls: PullDecl[] = [];
            var unitDecls: PullDecl[];

            for (var i = 0; i < this.units.length; i++) {
                unitDecls = this.units[i].getTopLevelDecls();
                for (var j = 0; j < unitDecls.length; j++) {
                    decls[decls.length] = unitDecls[j];
                }
            }

            return decls;
        }

        private getDeclPathCacheID(declPath: string[], declKind: PullElementKind) {
            var cacheID = "";
            
            for (var i = 0; i < declPath.length; i++) {
                cacheID += "#" + declPath[i];
            }

            return cacheID + "#" + declKind.toString();
        }

        // a decl path is a list of decls that reference the components of a declaration from the global scope down
        // E.g., string would be "['string']" and "A.B.C" would be "['A','B','C']"
        public findDecls(declPath: string[], declKind: PullElementKind): PullDecl[] {

            var cacheID = this.getDeclPathCacheID(declPath, declKind);

            if (declPath.length) {
                var cachedDecls = this.declCache[cacheID];

                if (cachedDecls && cachedDecls.length) {
                    declCacheHit++;
                    return <PullDecl[]> cachedDecls;
                }
            }

            declCacheMiss++;

            var declsToSearch = this.collectAllTopLevelDecls();

            var decls: PullDecl[] = [];
            var path: string;
            var foundDecls: PullDecl[] = [];
            var keepSearching = (declKind & PullElementKind.Container) || (declKind & PullElementKind.Interface);

            for (var i = 0; i < declPath.length; i++) {
                path = declPath[i];
                decls = [];

                for (var j = 0; j < declsToSearch.length; j++) {
                    foundDecls = declsToSearch[j].findChildDecls(path, (i == declPath.length - 1) ? declKind : PullElementKind.SomeType);

                    for (var k = 0; k < foundDecls.length; k++) {
                        decls[decls.length] = foundDecls[k];
                    }

                    // Unless we're searching for an interface or module, we've found the one true
                    // decl, so don't bother searching the rest of the top-level decls
                    if (foundDecls.length && !keepSearching) {
                        break;
                    }
                }

                declsToSearch = decls;

                if (!declsToSearch) {
                    break;
                }
            }

            if (decls.length) {
                this.declCache[cacheID] = decls;
            }

            return decls;
        }

        public findSymbol(declPath: string[], declType: PullElementKind): PullSymbol {

            var cacheID = this.getDeclPathCacheID(declPath, declType);

            if (declPath.length) {

                var cachedSymbol = this.symbolCache[cacheID];

                if (cachedSymbol) {
                    symbolCacheHit++;
                    return cachedSymbol;
                }
            }

            symbolCacheMiss++;

            // symbol wasn't cached, so get the decl
            var decls: PullDecl[] = this.findDecls(declPath, declType);
            var symbol: PullSymbol = null;

            if (decls.length) {
                var symbol = decls[0].getSymbol();

                if (symbol) {
                    this.symbolCache[cacheID] = symbol;
                }
            }

            return symbol;
        }

        public update(compilationUnitPath: string) {

            // PULLTODO: Be less aggressive about clearing the cache
            this.declCache = <any>new BlockIntrinsics();
            //this.symbolCache = <any>{};
            //this.unitCache[compilationUnitPath] = undefined;
        }

        public getDeclForAST(ast: AST, unitPath: string): PullDecl {
            var unit = <SemanticInfo>this.unitCache[unitPath];

            if (unit) {
                return unit.getDeclForAST(ast);
            }
            
            return null;
        }

        public getASTForDecl(decl: PullDecl, unitPath: string): AST {
            var unit = <SemanticInfo>this.unitCache[unitPath];

            if (unit) {
                return unit.getASTForDecl(decl);
            }
            
            return null;
        }

        public getSymbolForAST(ast: AST, unitPath: string) {
            var unit = <SemanticInfo>this.unitCache[unitPath];

            if (unit) {
                return unit.getSymbolForAST(ast);
            }
            
            return null;
        }

        public getASTForSymbol(symbol: PullSymbol, unitPath: string) {
            var unit = <SemanticInfo>this.unitCache[unitPath];

            if (unit) {
                return unit.getASTForSymbol(symbol);
            }
            
            return null;
        }

        public setSymbolForAST(ast: AST, typeSymbol: PullSymbol, unitPath: string) {
            var unit = <SemanticInfo>this.unitCache[unitPath];

            if (unit) {
                unit.setSymbolForAST(ast, typeSymbol);
            }
        }

        public removeSymbolFromCache(symbol: PullSymbol) {
            
            var path = symbol.getDeclPath();

            if (path) {
                var kind = (symbol.getKind() & PullElementKind.SomeType) != 0 ? PullElementKind.SomeType: PullElementKind.SomeValue;

                var kindID = this.getDeclPathCacheID(path, kind);
                var symID = this.getDeclPathCacheID(path, symbol.getKind());

                this.symbolCache[kindID] = undefined;
                this.symbolCache[symID] = undefined;
            }
        }

        public postErrors(): SemanticError[] {
            var errors: PullError[] = [];
            
            for (var i = 1; i < this.units.length; i++) {
                this.units[i].getErrors(errors);
            }

            return errors;
        }
    }
}
﻿///<reference path='SyntaxVisitor.generated.ts' />

class SyntaxWalker implements ISyntaxVisitor {
    public visitToken(token: ISyntaxToken): void {
    }

    public visitNode(node: SyntaxNode): void {
        node.accept(this);
    }

    public visitNodeOrToken(nodeOrToken: ISyntaxNodeOrToken): void {
        if (nodeOrToken.isToken()) { 
            this.visitToken(<ISyntaxToken>nodeOrToken);
        }
        else {
            this.visitNode(<SyntaxNode>nodeOrToken);
        }
    }

    private visitOptionalToken(token: ISyntaxToken): void {
        if (token === null) {
            return;
        }

        this.visitToken(token);
    }

    public visitOptionalNode(node: SyntaxNode): void {
        if (node === null) {
            return;
        }

        this.visitNode(node);
    }

    public visitOptionalNodeOrToken(nodeOrToken: ISyntaxNodeOrToken): void {
        if (nodeOrToken === null) {
            return;
        }

        this.visitNodeOrToken(nodeOrToken);
    }

    public visitList(list: ISyntaxList): void {
        for (var i = 0, n = list.childCount(); i < n; i++) {
           this.visitNodeOrToken(list.childAt(i));
        }
    }

    public visitSeparatedList(list: ISeparatedSyntaxList): void {
        for (var i = 0, n = list.childCount(); i < n; i++) {
            var item = list.childAt(i);
            this.visitNodeOrToken(item);
        }
    }

    public visitSourceUnit(node: SourceUnitSyntax): void {
        this.visitList(node.moduleElements);
        this.visitToken(node.endOfFileToken);
    }

    public visitExternalModuleReference(node: ExternalModuleReferenceSyntax): void {
        this.visitToken(node.moduleKeyword);
        this.visitToken(node.openParenToken);
        this.visitToken(node.stringLiteral);
        this.visitToken(node.closeParenToken);
    }

    public visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): void {
        this.visitNodeOrToken(node.moduleName);
    }

    public visitImportDeclaration(node: ImportDeclarationSyntax): void {
        this.visitToken(node.importKeyword);
        this.visitToken(node.identifier);
        this.visitToken(node.equalsToken);
        this.visitNode(node.moduleReference);
        this.visitToken(node.semicolonToken);
    }

    public visitClassDeclaration(node: ClassDeclarationSyntax): void {
        this.visitOptionalToken(node.exportKeyword);
        this.visitOptionalToken(node.declareKeyword);
        this.visitToken(node.classKeyword);
        this.visitToken(node.identifier);
        this.visitOptionalNode(node.typeParameterList);
        this.visitOptionalNode(node.extendsClause);
        this.visitOptionalNode(node.implementsClause);
        this.visitToken(node.openBraceToken);
        this.visitList(node.classElements);
        this.visitToken(node.closeBraceToken);
    }

    public visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): void {
        this.visitOptionalToken(node.exportKeyword);
        this.visitToken(node.interfaceKeyword);
        this.visitToken(node.identifier);
        this.visitOptionalNode(node.typeParameterList);
        this.visitOptionalNode(node.extendsClause);
        this.visitNode(node.body);
    }

    public visitExtendsClause(node: ExtendsClauseSyntax): void {
        this.visitToken(node.extendsKeyword);
        this.visitSeparatedList(node.typeNames);
    }

    public visitImplementsClause(node: ImplementsClauseSyntax): void {
        this.visitToken(node.implementsKeyword);
        this.visitSeparatedList(node.typeNames);
    }

    public visitModuleDeclaration(node: ModuleDeclarationSyntax): void {
        this.visitOptionalToken(node.exportKeyword);
        this.visitOptionalToken(node.declareKeyword);
        this.visitToken(node.moduleKeyword);
        this.visitOptionalNodeOrToken(node.moduleName);
        this.visitOptionalToken(node.stringLiteral);
        this.visitToken(node.openBraceToken);
        this.visitList(node.moduleElements);
        this.visitToken(node.closeBraceToken);
    }

    public visitFunctionDeclaration(node: FunctionDeclarationSyntax): void {
        this.visitOptionalToken(node.exportKeyword);
        this.visitOptionalToken(node.declareKeyword);
        this.visitToken(node.functionKeyword);
        this.visitNode(node.functionSignature);
        this.visitOptionalNode(node.block);
        this.visitOptionalToken(node.semicolonToken);
    }

    public visitVariableStatement(node: VariableStatementSyntax): void {
        this.visitOptionalToken(node.exportKeyword);
        this.visitOptionalToken(node.declareKeyword);
        this.visitNode(node.variableDeclaration);
        this.visitToken(node.semicolonToken);
    }

    public visitVariableDeclaration(node: VariableDeclarationSyntax): void {
        this.visitToken(node.varKeyword);
        this.visitSeparatedList(node.variableDeclarators);
    }

    public visitVariableDeclarator(node: VariableDeclaratorSyntax): void {
        this.visitToken(node.identifier);
        this.visitOptionalNode(node.typeAnnotation);
        this.visitOptionalNode(node.equalsValueClause);
    }

    public visitEqualsValueClause(node: EqualsValueClauseSyntax): void {
        this.visitToken(node.equalsToken);
        this.visitNodeOrToken(node.value);
    }

    public visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): void {
        this.visitToken(node.operatorToken);
        this.visitNodeOrToken(node.operand);
    }

    public visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): void {
        this.visitToken(node.openBracketToken);
        this.visitSeparatedList(node.expressions);
        this.visitToken(node.closeBracketToken);
    }

    public visitOmittedExpression(node: OmittedExpressionSyntax): void {
    }

    public visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): void {
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.closeParenToken);
    }

    public visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): void {
        this.visitToken(node.identifier);
        this.visitToken(node.equalsGreaterThanToken);
        this.visitNodeOrToken(node.body);
    }

    public visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): void {
        this.visitNode(node.callSignature);
        this.visitToken(node.equalsGreaterThanToken);
        this.visitNodeOrToken(node.body);
    }

    public visitQualifiedName(node: QualifiedNameSyntax): void {
        this.visitNodeOrToken(node.left);
        this.visitToken(node.dotToken);
        this.visitToken(node.right);
    }

    public visitTypeArgumentList(node: TypeArgumentListSyntax): void {
        this.visitToken(node.lessThanToken);
        this.visitSeparatedList(node.typeArguments);
        this.visitToken(node.greaterThanToken);
    }

    public visitConstructorType(node: ConstructorTypeSyntax): void {
        this.visitToken(node.newKeyword);
        this.visitOptionalNode(node.typeParameterList);
        this.visitNode(node.parameterList);
        this.visitToken(node.equalsGreaterThanToken);
        this.visitNodeOrToken(node.type);
    }

    public visitFunctionType(node: FunctionTypeSyntax): void {
        this.visitOptionalNode(node.typeParameterList);
        this.visitNode(node.parameterList);
        this.visitToken(node.equalsGreaterThanToken);
        this.visitNodeOrToken(node.type);
    }

    public visitObjectType(node: ObjectTypeSyntax): void {
        this.visitToken(node.openBraceToken);
        this.visitSeparatedList(node.typeMembers);
        this.visitToken(node.closeBraceToken);
    }

    public visitArrayType(node: ArrayTypeSyntax): void {
        this.visitNodeOrToken(node.type);
        this.visitToken(node.openBracketToken);
        this.visitToken(node.closeBracketToken);
    }

    public visitGenericType(node: GenericTypeSyntax): void {
        this.visitNodeOrToken(node.name);
        this.visitNode(node.typeArgumentList);
    }

    public visitTypeAnnotation(node: TypeAnnotationSyntax): void {
        this.visitToken(node.colonToken);
        this.visitNodeOrToken(node.type);
    }

    public visitBlock(node: BlockSyntax): void {
        this.visitToken(node.openBraceToken);
        this.visitList(node.statements);
        this.visitToken(node.closeBraceToken);
    }

    public visitParameter(node: ParameterSyntax): void {
        this.visitOptionalToken(node.dotDotDotToken);
        this.visitOptionalToken(node.publicOrPrivateKeyword);
        this.visitToken(node.identifier);
        this.visitOptionalToken(node.questionToken);
        this.visitOptionalNode(node.typeAnnotation);
        this.visitOptionalNode(node.equalsValueClause);
    }

    public visitMemberAccessExpression(node: MemberAccessExpressionSyntax): void {
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.dotToken);
        this.visitToken(node.name);
    }

    public visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): void {
        this.visitNodeOrToken(node.operand);
        this.visitToken(node.operatorToken);
    }

    public visitElementAccessExpression(node: ElementAccessExpressionSyntax): void {
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.openBracketToken);
        this.visitNodeOrToken(node.argumentExpression);
        this.visitToken(node.closeBracketToken);
    }

    public visitInvocationExpression(node: InvocationExpressionSyntax): void {
        this.visitNodeOrToken(node.expression);
        this.visitNode(node.argumentList);
    }

    public visitArgumentList(node: ArgumentListSyntax): void {
        this.visitOptionalNode(node.typeArgumentList);
        this.visitToken(node.openParenToken);
        this.visitSeparatedList(node.arguments);
        this.visitToken(node.closeParenToken);
    }

    public visitBinaryExpression(node: BinaryExpressionSyntax): void {
        this.visitNodeOrToken(node.left);
        this.visitToken(node.operatorToken);
        this.visitNodeOrToken(node.right);
    }

    public visitConditionalExpression(node: ConditionalExpressionSyntax): void {
        this.visitNodeOrToken(node.condition);
        this.visitToken(node.questionToken);
        this.visitNodeOrToken(node.whenTrue);
        this.visitToken(node.colonToken);
        this.visitNodeOrToken(node.whenFalse);
    }

    public visitConstructSignature(node: ConstructSignatureSyntax): void {
        this.visitToken(node.newKeyword);
        this.visitNode(node.callSignature);
    }

    public visitFunctionSignature(node: FunctionSignatureSyntax): void {
        this.visitToken(node.identifier);
        this.visitOptionalToken(node.questionToken);
        this.visitNode(node.callSignature);
    }

    public visitIndexSignature(node: IndexSignatureSyntax): void {
        this.visitToken(node.openBracketToken);
        this.visitNode(node.parameter);
        this.visitToken(node.closeBracketToken);
        this.visitOptionalNode(node.typeAnnotation);
    }

    public visitPropertySignature(node: PropertySignatureSyntax): void {
        this.visitToken(node.identifier);
        this.visitOptionalToken(node.questionToken);
        this.visitOptionalNode(node.typeAnnotation);
    }

    public visitParameterList(node: ParameterListSyntax): void {
        this.visitToken(node.openParenToken);
        this.visitSeparatedList(node.parameters);
        this.visitToken(node.closeParenToken);
    }

    public visitCallSignature(node: CallSignatureSyntax): void {
        this.visitOptionalNode(node.typeParameterList);
        this.visitNode(node.parameterList);
        this.visitOptionalNode(node.typeAnnotation);
    }

    public visitTypeParameterList(node: TypeParameterListSyntax): void {
        this.visitToken(node.lessThanToken);
        this.visitSeparatedList(node.typeParameters);
        this.visitToken(node.greaterThanToken);
    }

    public visitTypeParameter(node: TypeParameterSyntax): void {
        this.visitToken(node.identifier);
        this.visitOptionalNode(node.constraint);
    }

    public visitConstraint(node: ConstraintSyntax): void {
        this.visitToken(node.extendsKeyword);
        this.visitNodeOrToken(node.type);
    }

    public visitElseClause(node: ElseClauseSyntax): void {
        this.visitToken(node.elseKeyword);
        this.visitNodeOrToken(node.statement);
    }

    public visitIfStatement(node: IfStatementSyntax): void {
        this.visitToken(node.ifKeyword);
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.condition);
        this.visitToken(node.closeParenToken);
        this.visitNodeOrToken(node.statement);
        this.visitOptionalNode(node.elseClause);
    }

    public visitExpressionStatement(node: ExpressionStatementSyntax): void {
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.semicolonToken);
    }

    public visitConstructorDeclaration(node: ConstructorDeclarationSyntax): void {
        this.visitToken(node.constructorKeyword);
        this.visitNode(node.parameterList);
        this.visitOptionalNode(node.block);
        this.visitOptionalToken(node.semicolonToken);
    }

    public visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): void {
        this.visitOptionalToken(node.publicOrPrivateKeyword);
        this.visitOptionalToken(node.staticKeyword);
        this.visitNode(node.functionSignature);
        this.visitOptionalNode(node.block);
        this.visitOptionalToken(node.semicolonToken);
    }

    public visitGetMemberAccessorDeclaration(node: GetMemberAccessorDeclarationSyntax): void {
        this.visitOptionalToken(node.publicOrPrivateKeyword);
        this.visitOptionalToken(node.staticKeyword);
        this.visitToken(node.getKeyword);
        this.visitToken(node.identifier);
        this.visitNode(node.parameterList);
        this.visitOptionalNode(node.typeAnnotation);
        this.visitNode(node.block);
    }

    public visitSetMemberAccessorDeclaration(node: SetMemberAccessorDeclarationSyntax): void {
        this.visitOptionalToken(node.publicOrPrivateKeyword);
        this.visitOptionalToken(node.staticKeyword);
        this.visitToken(node.setKeyword);
        this.visitToken(node.identifier);
        this.visitNode(node.parameterList);
        this.visitNode(node.block);
    }

    public visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): void {
        this.visitOptionalToken(node.publicOrPrivateKeyword);
        this.visitOptionalToken(node.staticKeyword);
        this.visitNode(node.variableDeclarator);
        this.visitToken(node.semicolonToken);
    }

    public visitThrowStatement(node: ThrowStatementSyntax): void {
        this.visitToken(node.throwKeyword);
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.semicolonToken);
    }

    public visitReturnStatement(node: ReturnStatementSyntax): void {
        this.visitToken(node.returnKeyword);
        this.visitOptionalNodeOrToken(node.expression);
        this.visitToken(node.semicolonToken);
    }

    public visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): void {
        this.visitToken(node.newKeyword);
        this.visitNodeOrToken(node.expression);
        this.visitOptionalNode(node.argumentList);
    }

    public visitSwitchStatement(node: SwitchStatementSyntax): void {
        this.visitToken(node.switchKeyword);
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.closeParenToken);
        this.visitToken(node.openBraceToken);
        this.visitList(node.switchClauses);
        this.visitToken(node.closeBraceToken);
    }

    public visitCaseSwitchClause(node: CaseSwitchClauseSyntax): void {
        this.visitToken(node.caseKeyword);
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.colonToken);
        this.visitList(node.statements);
    }

    public visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): void {
        this.visitToken(node.defaultKeyword);
        this.visitToken(node.colonToken);
        this.visitList(node.statements);
    }

    public visitBreakStatement(node: BreakStatementSyntax): void {
        this.visitToken(node.breakKeyword);
        this.visitOptionalToken(node.identifier);
        this.visitToken(node.semicolonToken);
    }

    public visitContinueStatement(node: ContinueStatementSyntax): void {
        this.visitToken(node.continueKeyword);
        this.visitOptionalToken(node.identifier);
        this.visitToken(node.semicolonToken);
    }

    public visitForStatement(node: ForStatementSyntax): void {
        this.visitToken(node.forKeyword);
        this.visitToken(node.openParenToken);
        this.visitOptionalNode(node.variableDeclaration);
        this.visitOptionalNodeOrToken(node.initializer);
        this.visitToken(node.firstSemicolonToken);
        this.visitOptionalNodeOrToken(node.condition);
        this.visitToken(node.secondSemicolonToken);
        this.visitOptionalNodeOrToken(node.incrementor);
        this.visitToken(node.closeParenToken);
        this.visitNodeOrToken(node.statement);
    }

    public visitForInStatement(node: ForInStatementSyntax): void {
        this.visitToken(node.forKeyword);
        this.visitToken(node.openParenToken);
        this.visitOptionalNode(node.variableDeclaration);
        this.visitOptionalNodeOrToken(node.left);
        this.visitToken(node.inKeyword);
        this.visitNodeOrToken(node.expression);
        this.visitToken(node.closeParenToken);
        this.visitNodeOrToken(node.statement);
    }

    public visitWhileStatement(node: WhileStatementSyntax): void {
        this.visitToken(node.whileKeyword);
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.condition);
        this.visitToken(node.closeParenToken);
        this.visitNodeOrToken(node.statement);
    }

    public visitWithStatement(node: WithStatementSyntax): void {
        this.visitToken(node.withKeyword);
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.condition);
        this.visitToken(node.closeParenToken);
        this.visitNodeOrToken(node.statement);
    }

    public visitEnumDeclaration(node: EnumDeclarationSyntax): void {
        this.visitOptionalToken(node.exportKeyword);
        this.visitToken(node.enumKeyword);
        this.visitToken(node.identifier);
        this.visitToken(node.openBraceToken);
        this.visitSeparatedList(node.variableDeclarators);
        this.visitToken(node.closeBraceToken);
    }

    public visitCastExpression(node: CastExpressionSyntax): void {
        this.visitToken(node.lessThanToken);
        this.visitNodeOrToken(node.type);
        this.visitToken(node.greaterThanToken);
        this.visitNodeOrToken(node.expression);
    }

    public visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): void {
        this.visitToken(node.openBraceToken);
        this.visitSeparatedList(node.propertyAssignments);
        this.visitToken(node.closeBraceToken);
    }

    public visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): void {
        this.visitToken(node.propertyName);
        this.visitToken(node.colonToken);
        this.visitNodeOrToken(node.expression);
    }

    public visitGetAccessorPropertyAssignment(node: GetAccessorPropertyAssignmentSyntax): void {
        this.visitToken(node.getKeyword);
        this.visitToken(node.propertyName);
        this.visitToken(node.openParenToken);
        this.visitToken(node.closeParenToken);
        this.visitNode(node.block);
    }

    public visitSetAccessorPropertyAssignment(node: SetAccessorPropertyAssignmentSyntax): void {
        this.visitToken(node.setKeyword);
        this.visitToken(node.propertyName);
        this.visitToken(node.openParenToken);
        this.visitToken(node.parameterName);
        this.visitToken(node.closeParenToken);
        this.visitNode(node.block);
    }

    public visitFunctionExpression(node: FunctionExpressionSyntax): void {
        this.visitToken(node.functionKeyword);
        this.visitOptionalToken(node.identifier);
        this.visitNode(node.callSignature);
        this.visitNode(node.block);
    }

    public visitEmptyStatement(node: EmptyStatementSyntax): void {
        this.visitToken(node.semicolonToken);
    }

    public visitTryStatement(node: TryStatementSyntax): void {
        this.visitToken(node.tryKeyword);
        this.visitNode(node.block);
        this.visitOptionalNode(node.catchClause);
        this.visitOptionalNode(node.finallyClause);
    }

    public visitCatchClause(node: CatchClauseSyntax): void {
        this.visitToken(node.catchKeyword);
        this.visitToken(node.openParenToken);
        this.visitToken(node.identifier);
        this.visitToken(node.closeParenToken);
        this.visitNode(node.block);
    }

    public visitFinallyClause(node: FinallyClauseSyntax): void {
        this.visitToken(node.finallyKeyword);
        this.visitNode(node.block);
    }

    public visitLabeledStatement(node: LabeledStatementSyntax): void {
        this.visitToken(node.identifier);
        this.visitToken(node.colonToken);
        this.visitNodeOrToken(node.statement);
    }

    public visitDoStatement(node: DoStatementSyntax): void {
        this.visitToken(node.doKeyword);
        this.visitNodeOrToken(node.statement);
        this.visitToken(node.whileKeyword);
        this.visitToken(node.openParenToken);
        this.visitNodeOrToken(node.condition);
        this.visitToken(node.closeParenToken);
        this.visitToken(node.semicolonToken);
    }

    public visitTypeOfExpression(node: TypeOfExpressionSyntax): void {
        this.visitToken(node.typeOfKeyword);
        this.visitNodeOrToken(node.expression);
    }

    public visitDeleteExpression(node: DeleteExpressionSyntax): void {
        this.visitToken(node.deleteKeyword);
        this.visitNodeOrToken(node.expression);
    }

    public visitVoidExpression(node: VoidExpressionSyntax): void {
        this.visitToken(node.voidKeyword);
        this.visitNodeOrToken(node.expression);
    }

    public visitDebuggerStatement(node: DebuggerStatementSyntax): void {
        this.visitToken(node.debuggerKeyword);
        this.visitToken(node.semicolonToken);
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />
///<reference path='..\Syntax\SyntaxWalker.generated.ts' />

module TypeScript {

    export class DeclCollectionContext {

        public parentChain: PullDecl[] = [];

        constructor (public semanticInfo: SemanticInfo, public scriptName = "") {
        }

        public getParent() { return this.parentChain ? this.parentChain[this.parentChain.length - 1] : null; }

        public pushParent(parentDecl: PullDecl) { if (parentDecl) { this.parentChain[this.parentChain.length] = parentDecl; } }

        public popParent() { this.parentChain.length--; }

        public foundValueDecl = false;
    }

    export function preCollectImportDecls(ast: AST, parent: AST, context: DeclCollectionContext) {
        var importDecl = <ImportDeclaration>ast;
        var declFlags = PullElementFlags.None;
        var span = new DeclSpan();

        span.minChar = importDecl.minChar;

        span.limChar = importDecl.limChar

        var decl = new PullDecl(importDecl.id.actualText, PullElementKind.TypeAlias, declFlags, span, context.scriptName);

        context.getParent().addChildDecl(decl);

        context.semanticInfo.setDeclForAST(ast, decl);

        context.semanticInfo.setASTForDecl(decl, ast);

        return false;
    }

    export function preCollectModuleDecls(ast: AST, parent: AST, context: DeclCollectionContext) {
        var moduleDecl: ModuleDeclaration = <ModuleDeclaration>ast;
        var declFlags = PullElementFlags.None;
        var modName = (<Identifier>moduleDecl.name).text;
        var isDynamic = isQuoted(modName);
        var kind: PullElementKind = PullElementKind.Container;

        if (hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient)) {
            declFlags |= PullElementFlags.Ambient;
        }

        if (hasFlag(moduleDecl.modFlags, ModuleFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }

        if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsEnum)) {
            declFlags |= PullElementFlags.Enum;
            kind = PullElementKind.Enum;
        }
        else {
            kind = isDynamic ? PullElementKind.DynamicModule : PullElementKind.Container;
        }

        var span = new DeclSpan();

        span.minChar = moduleDecl.minChar;

        span.limChar = moduleDecl.limChar;

        var decl = new PullDecl(modName, kind, declFlags, span, context.scriptName);

        context.getParent().addChildDecl(decl);

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(ast, decl);

        context.semanticInfo.setASTForDecl(decl,ast);

        return true;
    }

    export function preCollectClassDecls(ast: AST, parent: AST, context: DeclCollectionContext) {
        var classDecl = <ClassDeclaration>ast;
        var declFlags = PullElementFlags.None;
        var constructorDeclKind = PullElementKind.Variable;

        if (hasFlag(classDecl.varFlags, VarFlags.Ambient)) {
            declFlags |= PullElementFlags.Ambient;
        }

        if (hasFlag(classDecl.varFlags, VarFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
            constructorDeclKind = PullElementKind.Property;
        }

        var span = new DeclSpan();

        span.minChar = classDecl.minChar;

        span.limChar = classDecl.limChar;

        var decl = new PullDecl(classDecl.name.text, PullElementKind.Class, declFlags, span, context.scriptName);
        
        var constructorDecl = new PullDecl(classDecl.name.text, constructorDeclKind, declFlags | PullElementFlags.ClassConstructorVariable, span, context.scriptName);

        decl.setValueDecl(constructorDecl);

        context.getParent().addChildDecl(decl);
        context.getParent().addChildDecl(constructorDecl);

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(ast, decl);

        context.semanticInfo.setASTForDecl(decl, ast);

        return true;
    }

    export function createInferfaceDeclaration(interfaceDecl: InterfaceDeclaration, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;

        if (hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }

        var span = new DeclSpan();

        span.minChar = interfaceDecl.minChar;

        span.limChar = interfaceDecl.limChar;

        var decl = new PullDecl(interfaceDecl.name.text, PullElementKind.Interface, declFlags, span, context.scriptName);

        var parent = context.getParent();

        // if we're collecting a decl for a type annotation, we don't want to add the decl to the parent scope
        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);

        return true;    
    }

    export function createObjectTypeDeclaration(interfaceDecl: InterfaceDeclaration, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;

        if (hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }

        var span = new DeclSpan();

        span.minChar = interfaceDecl.minChar;

        span.limChar = interfaceDecl.limChar;

        var decl = new PullDecl("", PullElementKind.ObjectType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        // if we're collecting a decl for a type annotation, we don't want to add the decl to the parent scope
        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);

        return true;        
    }

    export function preCollectInterfaceDecls(ast: AST, parent: AST, context: DeclCollectionContext) {

        var interfaceDecl = <InterfaceDeclaration>ast;
        var declFlags = PullElementFlags.None;

        // PULLTODO
        //if (ast.flags & ASTFlags.TypeReference) {
        //    return createObjectTypeDeclaration(interfaceDecl, context);
        //}

        if (hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }

        var span = new DeclSpan();

        span.minChar = interfaceDecl.minChar;

        span.limChar = interfaceDecl.limChar;

        var decl = new PullDecl(interfaceDecl.name.text, PullElementKind.Interface, declFlags, span, context.scriptName);

        var parent = context.getParent();

        // if we're collecting a decl for a type annotation, we don't want to add the decl to the parent scope
        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl,ast);

        return true;
    }

    export function preCollectParameterDecl(ast: AST, parent: AST, context: DeclCollectionContext) {
        var argDecl = <BoundDecl>ast;
        var declFlags = PullElementFlags.None;

        if (hasFlag(argDecl.varFlags, VarFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }


        if (hasFlag(argDecl.flags, ASTFlags.OptionalName)) {
            declFlags |= PullElementFlags.Optional;
        }

        var span = new DeclSpan();

        span.minChar = argDecl.minChar;
        span.limChar = argDecl.limChar;

        var decl = new PullDecl(argDecl.id.text, PullElementKind.Parameter, declFlags, span, context.scriptName);

        context.getParent().addChildDecl(decl);

        // if it's a property type, we'll need to add it to the parent's parent as well
        if (hasFlag(argDecl.varFlags, VarFlags.Property)) {
            var propDecl = new PullDecl(argDecl.id.text, PullElementKind.Property, declFlags, span, context.scriptName);
            context.parentChain[context.parentChain.length - 2].addChildDecl(propDecl);
            context.semanticInfo.setASTForDecl(propDecl, ast);
            context.semanticInfo.setDeclForAST(ast, propDecl);
        }
        else {
            context.semanticInfo.setASTForDecl(decl,ast);
            context.semanticInfo.setDeclForAST(ast, decl);   
        }

        if (argDecl.typeExpr && 
            ((<TypeReference>argDecl.typeExpr).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>argDecl.typeExpr).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>argDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }
         
        return false;
    }

    export function preCollectTypeParameterDecl(ast: AST, parent: AST, context: DeclCollectionContext) {
        var typeParameterDecl = <TypeParameter>ast;
        var declFlags = PullElementFlags.None;

        var span = new DeclSpan();

        span.minChar = typeParameterDecl.minChar;
        span.limChar = typeParameterDecl.limChar;

        var decl = new PullDecl(typeParameterDecl.name.actualText, PullElementKind.TypeParameter, declFlags, span, context.scriptName);

        context.semanticInfo.setASTForDecl(decl, ast);
        context.semanticInfo.setDeclForAST(ast, decl);

        context.getParent().addChildDecl(decl);

        if (typeParameterDecl.constraint &&
            ((<TypeReference>typeParameterDecl.constraint).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>typeParameterDecl.constraint).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>typeParameterDecl.constraint).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // interface properties
    export function createPropertySignature(propertyDecl: VarDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Public;
        var declType = PullElementKind.Property;

        if (hasFlag(propertyDecl.id.flags, ASTFlags.OptionalName)) {
            declFlags |= PullElementFlags.Optional;
        }

        var span = new DeclSpan();

        span.minChar = propertyDecl.minChar;

        span.limChar = propertyDecl.limChar;

        var decl = new PullDecl(propertyDecl.id.text, declType, declFlags, span, context.scriptName);

        context.getParent().addChildDecl(decl);

        context.semanticInfo.setDeclForAST(propertyDecl, decl);

        context.semanticInfo.setASTForDecl(decl, propertyDecl);

        if (propertyDecl.typeExpr && 
            ((<TypeReference>propertyDecl.typeExpr).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>propertyDecl.typeExpr).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>propertyDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    // class member variables
    export function createMemberVariableDeclaration(memberDecl: VarDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Public;
        var declType = PullElementKind.Property;

        if (hasFlag(memberDecl.varFlags, VarFlags.Private)) {
            declFlags = PullElementFlags.Private;
        }

        if (hasFlag(memberDecl.varFlags, VarFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        var span = new DeclSpan();

        span.minChar = memberDecl.minChar;

        span.limChar = memberDecl.limChar;

        var decl = new PullDecl(memberDecl.id.text, declType, declFlags, span, context.scriptName);

        context.getParent().addChildDecl(decl);

        context.semanticInfo.setDeclForAST(memberDecl, decl);

        context.semanticInfo.setASTForDecl(decl, memberDecl);

        if (memberDecl.typeExpr && 
            ((<TypeReference>memberDecl.typeExpr).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>memberDecl.typeExpr).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>memberDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;    
    }

    export function createVariableDeclaration(varDecl: VarDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Variable;

        if (hasFlag(varDecl.varFlags, VarFlags.Ambient)) {
            declFlags |= PullElementFlags.Ambient;
        }

        if (hasFlag(varDecl.varFlags, VarFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }
        
        var span = new DeclSpan();

        span.minChar = varDecl.minChar;

        span.limChar = varDecl.limChar;

        var decl = new PullDecl(varDecl.id.text, declType, declFlags, span, context.scriptName);

        context.getParent().addChildDecl(decl);

        context.semanticInfo.setDeclForAST(varDecl, decl);

        context.semanticInfo.setASTForDecl(decl, varDecl);

        if (varDecl.typeExpr && 
            ((<TypeReference>varDecl.typeExpr).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>varDecl.typeExpr).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>varDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;    
    }

    export function preCollectVarDecls(ast: AST, parent: AST, context: DeclCollectionContext) {
        var varDecl = <VarDecl>ast;
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Variable;
        var isProperty = false;
        var isStatic = false;

        if (hasFlag(varDecl.varFlags, VarFlags.ClassProperty)) {
            return createMemberVariableDeclaration(varDecl, context);
        }
        else if (hasFlag(varDecl.varFlags, VarFlags.Property)) {
            return createPropertySignature(varDecl, context);
        }

        return createVariableDeclaration(varDecl, context);
    }

    // function type expressions
    export function createFunctionTypeDeclaration(functionTypeDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.FunctionType;

        var span = new DeclSpan();

        span.minChar = functionTypeDeclAST.minChar;
        span.limChar = functionTypeDeclAST.limChar;

        var decl = new PullDecl("", declType, declFlags, span, context.semanticInfo.getPath());

        // parent could be null if we're collecting decls for a lambda expression
        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(functionTypeDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, functionTypeDeclAST);

        if (functionTypeDeclAST.returnTypeAnnotation && 
            ((<TypeReference>functionTypeDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>functionTypeDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>functionTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // constructor types
    export function createConstructorTypeDeclaration(constructorTypeDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.ConstructorType;

        var span = new DeclSpan();

        span.minChar = constructorTypeDeclAST.minChar;
        span.limChar = constructorTypeDeclAST.limChar;

        var decl = new PullDecl("{new}", declType, declFlags, span, context.semanticInfo.getPath());

        // parent could be null if we're collecting decls for a lambda expression
        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(constructorTypeDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, constructorTypeDeclAST);

        if (constructorTypeDeclAST.returnTypeAnnotation && 
            ((<TypeReference>constructorTypeDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>constructorTypeDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>constructorTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // function declaration
    export function createFunctionDeclaration(funcDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Function;

        if (hasFlag(funcDeclAST.fncFlags, FncFlags.Ambient)) {
            declFlags |= PullElementFlags.Ambient;
        }

        if (hasFlag(funcDeclAST.fncFlags, FncFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }

        if (!funcDeclAST.bod) {
            declFlags |= PullElementFlags.Signature;
        }

        var span = new DeclSpan();

        span.minChar = funcDeclAST.minChar;
        span.limChar = funcDeclAST.limChar;

        var decl = new PullDecl(funcDeclAST.name.actualText, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(funcDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, funcDeclAST);

        if (funcDeclAST.returnTypeAnnotation && 
            ((<TypeReference>funcDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>funcDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>funcDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // function expression
    export function createFunctionExpressionDeclaration(functionExpressionDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.FunctionExpression;

        if (hasFlag(functionExpressionDeclAST.fncFlags, FncFlags.IsFatArrowFunction)) {
            declFlags |= PullElementFlags.FatArrow;
        }

        var span = new DeclSpan();

        span.minChar = functionExpressionDeclAST.minChar;
        span.limChar = functionExpressionDeclAST.limChar;

        var decl = new PullDecl("", declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(functionExpressionDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, functionExpressionDeclAST);

        if (functionExpressionDeclAST.returnTypeAnnotation && 
            ((<TypeReference>functionExpressionDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>functionExpressionDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>functionExpressionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;    
    }
    
    // methods
    export function createMemberFunctionDeclaration(memberFunctionDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Method;

        if (hasFlag(memberFunctionDeclAST.fncFlags, FncFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        if (hasFlag(memberFunctionDeclAST.fncFlags, FncFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }

        if (!memberFunctionDeclAST.bod) {
            declFlags |= PullElementFlags.Signature;
        }

        if (hasFlag(memberFunctionDeclAST.name.flags, ASTFlags.OptionalName)) {
            declFlags |= PullElementFlags.Optional;
        }

        var span = new DeclSpan();

        span.minChar = memberFunctionDeclAST.minChar;
        span.limChar = memberFunctionDeclAST.limChar;

        var decl = new PullDecl(memberFunctionDeclAST.name.actualText, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(memberFunctionDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, memberFunctionDeclAST);

        if (memberFunctionDeclAST.returnTypeAnnotation && 
            ((<TypeReference>memberFunctionDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>memberFunctionDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>memberFunctionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    
    // index signatures
    export function createIndexSignatureDeclaration(indexSignatureDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Signature | PullElementFlags.Index;
        var declType = PullElementKind.IndexSignature;

        var span = new DeclSpan();

        span.minChar = indexSignatureDeclAST.minChar;
        span.limChar = indexSignatureDeclAST.limChar;

        var decl = new PullDecl("[]", declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(indexSignatureDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, indexSignatureDeclAST);

        if (indexSignatureDeclAST.returnTypeAnnotation && 
            ((<TypeReference>indexSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>indexSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>indexSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;        
    }

    // call signatures
    export function createCallSignatureDeclaration(callSignatureDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Signature | PullElementFlags.Call;
        var declType = PullElementKind.CallSignature;

        var span = new DeclSpan();

        span.minChar = callSignatureDeclAST.minChar;
        span.limChar = callSignatureDeclAST.limChar;

        var decl = new PullDecl("()", declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(callSignatureDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, callSignatureDeclAST);

        if (callSignatureDeclAST.returnTypeAnnotation && 
            ((<TypeReference>callSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>callSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>callSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true; 
    }

    // construct signatures
    export function createConstructSignatureDeclaration(constructSignatureDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Signature | PullElementFlags.Call;
        var declType = PullElementKind.ConstructSignature;

        var span = new DeclSpan();

        span.minChar = constructSignatureDeclAST.minChar;
        span.limChar = constructSignatureDeclAST.limChar;

        var decl = new PullDecl("new", declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(constructSignatureDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, constructSignatureDeclAST);

        if (constructSignatureDeclAST.returnTypeAnnotation && 
            ((<TypeReference>constructSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>constructSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>constructSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // class constructors
    export function createClassConstructorDeclaration(constructorDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Constructor;
        var declType = PullElementKind.ConstructorMethod;

        if (!constructorDeclAST.bod) {
            declFlags |= PullElementFlags.Signature;
        }

        var span = new DeclSpan();

        span.minChar = constructorDeclAST.minChar;
        span.limChar = constructorDeclAST.limChar;

        var decl = new PullDecl(constructorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(constructorDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, constructorDeclAST);

        if (constructorDeclAST.returnTypeAnnotation && 
            ((<TypeReference>constructorDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>constructorDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>constructorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    export function createGetAccessorDeclaration(getAccessorDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Public;
        var declType = PullElementKind.GetAccessor;

        if (hasFlag(getAccessorDeclAST.fncFlags, FncFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        if (hasFlag(getAccessorDeclAST.name.flags, ASTFlags.OptionalName)) {
            declFlags |= PullElementFlags.Optional;
        }

        var span = new DeclSpan();

        span.minChar = getAccessorDeclAST.minChar;
        span.limChar = getAccessorDeclAST.limChar;

        var decl = new PullDecl(getAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(getAccessorDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, getAccessorDeclAST);

        if (getAccessorDeclAST.returnTypeAnnotation && 
            ((<TypeReference>getAccessorDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>getAccessorDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>getAccessorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;   
    }

    // set accessors
    export function createSetAccessorDeclaration(setAccessorDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Public;
        var declType = PullElementKind.SetAccessor;

        if (hasFlag(setAccessorDeclAST.fncFlags, FncFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        if (hasFlag(setAccessorDeclAST.name.flags, ASTFlags.OptionalName)) {
            declFlags |= PullElementFlags.Optional;
        }

        var span = new DeclSpan();

        span.minChar = setAccessorDeclAST.minChar;
        span.limChar = setAccessorDeclAST.limChar;

        var decl = new PullDecl(setAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(setAccessorDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, setAccessorDeclAST);

        return true;       
    }

    export function preCollectFuncDecls(ast: AST, parent: AST, context: DeclCollectionContext) {

        var funcDecl = <FuncDecl>ast;

        if (hasFlag(funcDecl.fncFlags, (FncFlags.IsFunctionExpression | FncFlags.IsFatArrowFunction))) {
            return createFunctionExpressionDeclaration(funcDecl, context);
        }
        else if (funcDecl.isConstructor) {
            return createClassConstructorDeclaration(funcDecl, context);
        }
        else if (funcDecl.isGetAccessor()) {
            return createGetAccessorDeclaration(funcDecl, context);
        }
        else if (funcDecl.isSetAccessor()) {
            return createSetAccessorDeclaration(funcDecl, context);
        }
        else if (hasFlag(funcDecl.fncFlags, FncFlags.ConstructMember)) {
            return hasFlag(funcDecl.flags, ASTFlags.TypeReference) ? 
                createConstructorTypeDeclaration(funcDecl, context) : 
                createConstructSignatureDeclaration(funcDecl, context);
        }
        else if (hasFlag(funcDecl.fncFlags, FncFlags.CallMember)) {
            return createCallSignatureDeclaration(funcDecl, context);
        }
        else if (hasFlag(funcDecl.fncFlags, FncFlags.IndexerMember)) {
            return createIndexSignatureDeclaration(funcDecl, context);
        }
        else if (hasFlag(funcDecl.flags, ASTFlags.TypeReference)) {
            return createFunctionTypeDeclaration(funcDecl, context);
        }
        else if (hasFlag(funcDecl.fncFlags, FncFlags.Method) ||
                 hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
            return createMemberFunctionDeclaration(funcDecl, context);
        }

        return createFunctionDeclaration(funcDecl, context);
    }

    export function preCollectDecls(ast: AST, parent: AST, walker: IAstWalker) {
        var context: DeclCollectionContext = walker.state;
        var go = false;

        if (ast.nodeType == NodeType.Script) {
            var script: Script = <Script>ast;
            var span = new DeclSpan();

            span.minChar = script.minChar;

            span.limChar = script.limChar;

            var decl = new PullDecl(context.scriptName, PullElementKind.Script, PullElementFlags.None, span, context.scriptName);

            context.pushParent(decl);

            go = true;
        }
        else if (ast.nodeType == NodeType.List) {
            go = true;
        }
        else if (ast.nodeType == NodeType.Block) {
            go = true;
        }
        else if (ast.nodeType == NodeType.ModuleDeclaration) {
            go = preCollectModuleDecls(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.ClassDeclaration) {
            go = preCollectClassDecls(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.InterfaceDeclaration) {
            go = preCollectInterfaceDecls(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.ArgDecl) {
            go = preCollectParameterDecl(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.VarDecl) {
            go = preCollectVarDecls(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.FuncDecl) {
            go = preCollectFuncDecls(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.ImportDeclaration) {
            go = preCollectImportDecls(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.TypeParameter) {
            go = preCollectTypeParameterDecl(ast, parent, context);
        }
        else if (ast.nodeType == NodeType.If) {
            go = true;
        }
        else if (ast.nodeType == NodeType.For) {
            go = true;
        }
        else if (ast.nodeType == NodeType.ForIn) {
            go = true;
        }
        else if (ast.nodeType == NodeType.While) {
            go = true;
        }
        else if (ast.nodeType == NodeType.DoWhile) {
            go = true;
        }
        else if (ast.nodeType == NodeType.Comma) {
            go = true;
        }
        else if (ast.nodeType == NodeType.Return) {
            // want to be able to bind lambdas in return positions
            go = true;
        }
        else if (ast.nodeType == NodeType.Switch || ast.nodeType == NodeType.Case) {
            go = true;
        }

            // call and 'new' expressions may contain lambdas with bindings...
        else if (ast.nodeType == NodeType.Call) {
            // want to be able to bind lambdas in return positions
            go = true;
        }
        else if (ast.nodeType == NodeType.New) {
            // want to be able to bind lambdas in return positions
            go = true;
        }

        walker.options.goChildren = go;

        return ast;
    }

    export function postCollectDecls(ast: AST, parent: AST, walker: IAstWalker) {
        var context: DeclCollectionContext = walker.state;
        var parentDecl: PullDecl;

        // Note that we never pop the Script - after the traversal, it should be the
        // one parent left in the context

        if (ast.nodeType == NodeType.ModuleDeclaration) {
            var thisModule = context.getParent();
            context.popParent();
            parentDecl = context.getParent();
            if (thisModule.getFlags() & PullElementFlags.InitializedModule) {
                if (parentDecl && parentDecl.getKind() == PullElementKind.Container) {
                    parentDecl.setFlags(parentDecl.getFlags() | PullElementFlags.InitializedModule);
                }

                // create the value decl
                var valueDecl = new PullDecl(thisModule.getName(), PullElementKind.Variable, thisModule.getFlags(), thisModule.getSpan(), context.scriptName);

                thisModule.setValueDecl(valueDecl);

                context.semanticInfo.setASTForDecl(valueDecl, ast);

                if (parentDecl) {
                    parentDecl.addChildDecl(valueDecl);
                }
            }
        }
        else if (ast.nodeType == NodeType.ClassDeclaration) {
            context.popParent();

            parentDecl = context.getParent();

            if (parentDecl && parentDecl.getKind() == PullElementKind.Container) {
                parentDecl.setFlags(parentDecl.getFlags() | PullElementFlags.InitializedModule);
            }
        }
        else if (ast.nodeType == NodeType.InterfaceDeclaration) {
            context.popParent();
        }
        else if (ast.nodeType == NodeType.FuncDecl) {
            context.popParent();
            
            parentDecl = context.getParent();

            if (parentDecl && parentDecl.getKind() == PullElementKind.Container) {
                parentDecl.setFlags(parentDecl.getFlags() | PullElementFlags.InitializedModule);
            }
        }
        else if (ast.nodeType == NodeType.VarDecl) { // PULLREVIEW: What if we just have a for loop in a module body?
            parentDecl = context.getParent();

            if (parentDecl && parentDecl.getKind() == PullElementKind.Container) {
                parentDecl.setFlags(parentDecl.getFlags() | PullElementFlags.InitializedModule);
            }
        }

        return ast;
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {
    export class PullSymbolBinder {

        private parentChain: PullTypeSymbol[] = [];
        private declPath: string[] = [];
        
        private staticClassMembers: PullSymbol[] = [];

        public semanticInfo: SemanticInfo;

        public reBindingAfterChange = false;
        public startingDeclForRebind = pullDeclID; // note that this gets set on creation
        public startingSymbolForRebind = pullSymbolID; // note that this gets set on creation

        constructor (public semanticInfoChain: SemanticInfoChain) {
        }

        public setUnit(fileName: string) {
            this.semanticInfo = this.semanticInfoChain.getUnit(fileName);
        }

        public getParent(returnInstanceType=false): PullTypeSymbol {
            var parent = this.parentChain ? this.parentChain[this.parentChain.length-1] : null;

            if (parent && parent.isContainer() && returnInstanceType) {
                parent = (<PullContainerTypeSymbol>parent).getInstanceSymbol().getType();
            }

            return parent;
        }

        public getDeclPath() { return this.declPath; }

        public pushParent(parentDecl: PullTypeSymbol) { 
            if (parentDecl) { 
                this.parentChain[this.parentChain.length] = parentDecl;
                this.declPath[this.declPath.length] = parentDecl.getName();
            } 
        }

        public popParent() {
            if (this.parentChain.length) {
                this.parentChain.length--;
                this.declPath.length--;
            }
        }

        public findSymbolInContext(name: string, declKind: PullElementKind, typeLookupPath: string[]): PullSymbol {
            var startTime = new Date().getTime();
            var contextSymbolPath: string[] = this.getDeclPath();
            var nestedSymbolPath: string[] = [];
            var copyOfContextSymbolPath = [];
            var symbol: PullSymbol = null;

            // first, search within the given symbol path
            if (typeLookupPath.length) {

                for (var i = 0; i < typeLookupPath.length; i++) {
                    nestedSymbolPath[nestedSymbolPath.length] = typeLookupPath[i];
                }

                nestedSymbolPath[nestedSymbolPath.length] = name;

                while (nestedSymbolPath.length >= 2) {
                    symbol = this.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);

                    if (symbol) {
                        var endTime = new Date().getTime();
                        time_in_findSymbol += endTime - startTime;

                        symbol.setDeclPath(nestedSymbolPath);

                        return symbol;
                    }
                    nestedSymbolPath.length -= 2;
                    nestedSymbolPath[nestedSymbolPath.length] = name;
                }
            }

            // next, link back up to the enclosing context
            if (contextSymbolPath.length) {
            
                for (var i = 0; i < contextSymbolPath.length; i++) {
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i];
                }

                for (var i = 0; i < typeLookupPath.length; i++) {
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = typeLookupPath[i];
                }

                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;

                while (copyOfContextSymbolPath.length >= 2) {
                    symbol = this.semanticInfoChain.findSymbol(copyOfContextSymbolPath, declKind);

                    if (symbol) {
                        var endTime = new Date().getTime();
                        time_in_findSymbol += endTime - startTime;

                        symbol.setDeclPath(copyOfContextSymbolPath);

                        return symbol;
                    }
                    copyOfContextSymbolPath.length -= 2;
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
                }
            }

            // finally, try searching globally
            symbol = this.semanticInfoChain.findSymbol([name], declKind);

            if (symbol) {
                symbol.setDeclPath([name]);
            }

            var endTime = new Date().getTime();
            time_in_findSymbol += endTime - startTime;

            return symbol;
        }

        //
        // decl binding
        //

        public bindModuleDeclarationToPullSymbol(moduleContainerDecl: PullDecl) {

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one
        
            var modName = moduleContainerDecl.getName();

            var moduleContainerTypeSymbol: PullContainerTypeSymbol = null;
            var moduleInstanceSymbol: PullSymbol = null;
            var moduleInstanceTypeSymbol: PullTypeSymbol = null;

            var moduleInstanceDecl: PullDecl = moduleContainerDecl.getValueDecl();

            var parent = this.getParent();
            var parentInstanceSymbol = this.getParent(true);

            var moduleAST = <ModuleDeclaration>this.semanticInfo.getASTForDecl(moduleContainerDecl);

            var createdNewSymbol = false;

            if (parent) {
                moduleContainerTypeSymbol = <PullContainerTypeSymbol>parent.findNestedType(modName);
            }
            else if (!(moduleContainerDecl.getFlags() & PullElementFlags.Exported)) {
                moduleContainerTypeSymbol = <PullContainerTypeSymbol>this.findSymbolInContext(modName, PullElementKind.SomeType, []);
            }

            if (moduleContainerTypeSymbol && moduleContainerTypeSymbol.getKind() != PullElementKind.Container) {
                // duplicate symbol error
                moduleContainerDecl.addError(new PullError(moduleAST.minChar, moduleAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(DiagnosticMessages.duplicateIdentifier_1, [modName])));

                moduleContainerTypeSymbol = null;
            }

            if (moduleContainerTypeSymbol) {
                moduleInstanceSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
            }
            else { 
                var moduleContainerTypeSymbol = new PullContainerTypeSymbol(modName);
                createdNewSymbol = true;

                if (moduleContainerDecl.getFlags() & PullElementFlags.InitializedModule) {
                    moduleInstanceTypeSymbol = new PullTypeSymbol(modName, PullElementKind.ObjectType);
                    moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);

                    // The instance symbol is further set up in bindVariableDeclaration
                    moduleInstanceSymbol = new PullSymbol(modName, PullElementKind.Variable);
                    moduleInstanceSymbol.setType(moduleInstanceTypeSymbol);

                    moduleContainerTypeSymbol.setInstanceSymbol(moduleInstanceSymbol);
                }
            }

            moduleContainerTypeSymbol.addDeclaration(moduleContainerDecl);
            moduleContainerDecl.setSymbol(moduleContainerTypeSymbol);

            this.semanticInfo.setSymbolForAST(moduleAST, moduleContainerTypeSymbol);
            this.semanticInfo.setSymbolForAST(moduleAST.name, moduleContainerTypeSymbol);
        
            if (createdNewSymbol) {

                if (parent) {
                    var linkKind = moduleContainerDecl.getFlags() & PullElementFlags.Exported ? SymbolLinkKind.PublicMember : SymbolLinkKind.PrivateMember;

                    if (linkKind == SymbolLinkKind.PublicMember) {
                        parent.addMember(moduleContainerTypeSymbol, linkKind);

                        if (moduleInstanceSymbol && parentInstanceSymbol && (parentInstanceSymbol != moduleInstanceSymbol)) {
                            parentInstanceSymbol.addMember(moduleInstanceSymbol, linkKind);
                        }
                    }
                    else {
                        moduleContainerTypeSymbol.addOutgoingLink(parent, SymbolLinkKind.ContainedBy);

                        if (moduleInstanceSymbol && parentInstanceSymbol && (parentInstanceSymbol != moduleInstanceSymbol)) {
                            moduleInstanceSymbol.addOutgoingLink(parentInstanceSymbol, SymbolLinkKind.ContainedBy);
                        }
                    }
                }
            }
            else if (this.reBindingAfterChange) {
                // clear out the old decls...
                var decls = moduleContainerTypeSymbol.getDeclarations();
                var scriptName = moduleContainerDecl.getScriptName();

                for (var i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        moduleContainerTypeSymbol.removeDeclaration(decls[i]);
                    }
                }

                if (moduleInstanceSymbol) {
                    decls = moduleInstanceSymbol.getDeclarations();

                    for (var i = 0; i < decls.length; i++) {
                        if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                            moduleInstanceSymbol.removeDeclaration(decls[i]);
                        }
                    }

                    moduleInstanceTypeSymbol = moduleInstanceSymbol.getType();

                    decls = moduleInstanceTypeSymbol.getDeclarations();

                    for (var i = 0; i < decls.length; i++) {
                        if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                            moduleInstanceTypeSymbol.removeDeclaration(decls[i]);
                        }
                    }

                    // add the current module decl to the declaration list, to make up for the ones we just deleted
                    moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);
                }
            }

            this.pushParent(moduleContainerTypeSymbol);

            var childDecls = moduleContainerDecl.getChildDecls();

            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();
        }

        // enums
        public bindEnumDeclarationToPullSymbol(enumDeclaration: PullDecl) {
            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one
        
            var enumName = enumDeclaration.getName();
            var enumSymbol = <PullTypeSymbol>this.findSymbolInContext(enumName, PullElementKind.Enum, []);

            var enumAST = <ModuleDeclaration>this.semanticInfo.getASTForDecl(enumDeclaration);
            var createdNewSymbol = false;
            var parent = this.getParent();

            if (parent) {
                enumSymbol = parent.findNestedType(enumName);
            }
            else if (!(enumDeclaration.getFlags() & PullElementFlags.Exported)) {
                enumSymbol = <PullTypeSymbol>this.findSymbolInContext(enumName, PullElementKind.SomeType, []);
            }

            if (enumSymbol && (enumSymbol.getKind() != PullElementKind.Enum || enumSymbol.getSymbolID() > this.startingSymbolForRebind)) {
                enumDeclaration.addError(new PullError(enumAST.minChar, enumAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(DiagnosticMessages.duplicateIdentifier_1, [enumName])));
                enumSymbol = null;
            }

            if (!enumSymbol) {
                enumSymbol = new PullTypeSymbol(enumName, PullElementKind.Enum);

                enumSymbol.addDeclaration(enumDeclaration);
                enumDeclaration.setSymbol(enumSymbol);

                createdNewSymbol = true;
            }

            enumSymbol.addDeclaration(enumDeclaration);
            enumDeclaration.setSymbol(enumSymbol);            
            
            this.semanticInfo.setSymbolForAST(enumAST, enumSymbol);
            this.semanticInfo.setSymbolForAST(enumAST.name, enumSymbol);
        
            if (createdNewSymbol) {
                var parent = this.getParent();

                if (parent) {
                    var linkKind = enumDeclaration.getFlags() & PullElementFlags.Exported ? SymbolLinkKind.PublicMember : SymbolLinkKind.PrivateMember;

                    if (linkKind == SymbolLinkKind.PublicMember) {
                        parent.addMember(enumSymbol, linkKind);
                    }
                    else {
                        enumSymbol.addOutgoingLink(parent, SymbolLinkKind.ContainedBy);
                    }
                }
            }
            else if (this.reBindingAfterChange) {
                // clear out the old decls...
                var decls = enumSymbol.getDeclarations();
                var scriptName = enumDeclaration.getScriptName();

                for (var i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        enumSymbol.removeDeclaration(decls[i]);
                    }
                }
            }

            this.pushParent(enumSymbol);

            var childDecls = enumDeclaration.getChildDecls();

            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();        
        }

        // classes
        public bindClassDeclarationToPullSymbol(classDecl: PullDecl) {

            var className = classDecl.getName();
            var classSymbol: PullClassTypeSymbol = null;

            var constructorSymbol: PullSymbol = null;
            var constructorTypeSymbol: PullConstructorTypeSymbol = null;

            var classAST = <ClassDeclaration>this.semanticInfo.getASTForDecl(classDecl);
            var parentHadSymbol = false;

            var parent = this.getParent();
            var cleanedPreviousDecls = false;

            if (parent) {
                classSymbol = <PullClassTypeSymbol>parent.findNestedType(className);
            }
            else if (!(classDecl.getFlags() & PullElementFlags.Exported)) {
                classSymbol = <PullClassTypeSymbol>this.findSymbolInContext(className, PullElementKind.SomeType, []);
            }

            if (classSymbol && (classSymbol.getKind() != PullElementKind.Class || (!this.reBindingAfterChange || classSymbol.getSymbolID() > this.startingSymbolForRebind))) {
                classDecl.addError(new PullError(classAST.minChar, classAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(DiagnosticMessages.duplicateIdentifier_1, [className])));
                classSymbol = null;
            }
            else if (classSymbol) {
                parentHadSymbol = true;
            }

            if (this.reBindingAfterChange && classSymbol) {

                // prune out-of-date decls
                var decls = classSymbol.getDeclarations();
                var scriptName = classDecl.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        classSymbol.removeDeclaration(decls[j]);
                    }
                }

                constructorSymbol = classSymbol.getConstructorMethod();

                decls = constructorSymbol.getDeclarations();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        constructorSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }
            }

            if (!parentHadSymbol) {
                classSymbol = new PullClassTypeSymbol(className);
            }        
        
            classSymbol.addDeclaration(classDecl);
            
            classDecl.setSymbol(classSymbol);

            this.semanticInfo.setSymbolForAST(classAST, classSymbol);
            this.semanticInfo.setSymbolForAST(classAST.name, classSymbol);
        
            if (parent && !parentHadSymbol) {
                var linkKind = classDecl.getFlags() & PullElementFlags.Exported ? SymbolLinkKind.PublicMember : SymbolLinkKind.PrivateMember;

                if (linkKind == SymbolLinkKind.PublicMember) {
                    parent.addMember(classSymbol, linkKind);
                }
                else {
                    classSymbol.addOutgoingLink(parent, SymbolLinkKind.ContainedBy);
                }
            }

            // PULLTODO: For now, remove stale signatures from the function type, but we want to be smarter about this when
            // incremental parsing comes online
            // PULLTODO: For now, classes should have none of these, though a pre-existing constructor might
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = classSymbol.getCallSignatures();
                var constructSigs = classSymbol.getConstructSignatures();
                var indexSigs = classSymbol.getIndexSignatures();

                for (var i = 0; i < callSigs.length; i++) {
                    classSymbol.removeCallSignature(callSigs[i], false);
                }
                for (var i = 0; i < constructSigs.length; i++) {
                    classSymbol.removeConstructSignature(constructSigs[i], false);
                }
                for (var i = 0; i < indexSigs.length; i++) {
                    classSymbol.removeIndexSignature(indexSigs[i], false);
                }

                constructorSymbol = classSymbol.getConstructorMethod();
                constructorTypeSymbol = <PullConstructorTypeSymbol>(constructorSymbol ? constructorSymbol.getType() : null);

                if (constructorTypeSymbol) {
                    constructSigs = constructorTypeSymbol.getConstructSignatures();

                    for (var i = 0; i < constructSigs.length; i++) {
                        constructorTypeSymbol.removeConstructSignature(constructSigs[i], false);
                    }
                }

                // just invalidate this once, so we don't pay the cost of rebuilding caches
                // for each signature removed
                classSymbol.invalidate();
            }

            this.pushParent(classSymbol);

            var childDecls = classDecl.getChildDecls();

            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();

            // create the default constructor symbol, if necessary

            // even if we've already tried to set these, we want to try again after we've walked the class members
            constructorSymbol = classSymbol.getConstructorMethod();
            constructorTypeSymbol = <PullConstructorTypeSymbol>(constructorSymbol ? constructorSymbol.getType() : null);

            if (!constructorSymbol) {
                constructorSymbol = new PullSymbol(className, PullElementKind.ConstructorMethod);
                constructorTypeSymbol = new PullConstructorTypeSymbol();

                constructorSymbol.setType(constructorTypeSymbol);
                constructorSymbol.addDeclaration(classDecl);
                classSymbol.setConstructorMethod(constructorSymbol);
                
                var constructorSignature = new PullSignatureSymbol(PullElementKind.ConstructSignature);
                constructorSignature.setReturnType(classSymbol);
                constructorTypeSymbol.addSignature(constructorSignature);
            }

            //constructorTypeSymbol = <PullConstructorTypeSymbol>constructorSymbol.getType();

            // bind statics to the constructor symbol
            if (this.staticClassMembers.length) {
                var member: PullSymbol;
                var isPrivate = false;
                var decls: PullDecl[];
                
                for (var i = 0; i < this.staticClassMembers.length; i++) {

                    member = this.staticClassMembers[i];
                    decls = member.getDeclarations();
                    isPrivate = (decls[0].getFlags() & PullElementFlags.Private) != 0;

                    constructorTypeSymbol.addMember(member, isPrivate ? SymbolLinkKind.PrivateMember : SymbolLinkKind.PublicMember);
                }

                this.staticClassMembers.length = 0;
            }

            var typeParameters = classDecl.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);

                classSymbol.addMember(typeParameter, SymbolLinkKind.TypeParameter);
                constructorTypeSymbol.addTypeParameter(typeParameter);
            }
        }

        // interfaces
        public bindInterfaceDeclarationToPullSymbol(interfaceDecl: PullDecl) {

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one
            var interfaceName = interfaceDecl.getName();
            var interfaceSymbol: PullTypeSymbol = <PullTypeSymbol>this.findSymbolInContext(interfaceName, PullElementKind.SomeType, []);

            var interfaceAST = <TypeDeclaration>this.semanticInfo.getASTForDecl(interfaceDecl);
            var createdNewSymbol = false;
            var parent = this.getParent();

            if (parent) {
                interfaceSymbol = parent.findNestedType(interfaceName);
            }
            else if (!(interfaceDecl.getFlags() & PullElementFlags.Exported)) {
                interfaceSymbol = <PullClassTypeSymbol>this.findSymbolInContext(interfaceName, PullElementKind.SomeType, []);
            }

            if (interfaceSymbol && (interfaceSymbol.getKind() != PullElementKind.Interface)) {
                interfaceDecl.addError(new PullError(interfaceAST.minChar, interfaceAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(DiagnosticMessages.duplicateIdentifier_1, [interfaceName])));
                interfaceSymbol = null;
            }

            if (!interfaceSymbol) {
                interfaceSymbol = new PullTypeSymbol(interfaceName, PullElementKind.Interface);
                createdNewSymbol = true;
            }

            interfaceSymbol.addDeclaration(interfaceDecl);
            interfaceDecl.setSymbol(interfaceSymbol);

            this.semanticInfo.setSymbolForAST(interfaceAST, interfaceSymbol);
            this.semanticInfo.setSymbolForAST(interfaceAST.name, interfaceSymbol);

            if (createdNewSymbol) {

                if (parent) {
                    var linkKind = interfaceDecl.getFlags() & PullElementFlags.Exported ? SymbolLinkKind.PublicMember : SymbolLinkKind.PrivateMember;
                
                    if (linkKind == SymbolLinkKind.PublicMember) {
                        parent.addMember(interfaceSymbol, linkKind);
                    }
                    else {
                        interfaceSymbol.addOutgoingLink(parent, SymbolLinkKind.ContainedBy);
                    }
                }
            }
            else if (this.reBindingAfterChange) {
                // clear out the old decls...
                var decls = interfaceSymbol.getDeclarations();
                var scriptName = interfaceDecl.getScriptName();

                for (var i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        interfaceSymbol.removeDeclaration(decls[i]);
                    }
                }
            }

            this.pushParent(interfaceSymbol);

            var childDecls = interfaceDecl.getChildDecls();

            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();

            var typeParameters = interfaceDecl.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
                interfaceSymbol.addMember(typeParameter, SymbolLinkKind.TypeParameter);
            }
        }

        public bindObjectTypeDeclarationToPullSymbol(objectDecl: PullDecl) {
            var objectSymbolAST: AST = this.semanticInfo.getASTForDecl(objectDecl);

            var objectSymbol = new PullTypeSymbol("{}", PullElementKind.ObjectType);

            objectSymbol.addDeclaration(objectDecl);
            objectDecl.setSymbol(objectSymbol);

            this.semanticInfo.setSymbolForAST(objectSymbolAST, objectSymbol);        

            this.pushParent(objectSymbol);

            var childDecls = objectDecl.getChildDecls();

            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();

            var typeParameters = objectDecl.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
                objectSymbol.addMember(typeParameter, SymbolLinkKind.TypeParameter);
            }
        }

        public bindConstructorTypeDeclarationToPullSymbol(constructorTypeDeclaration: PullDecl) {
            var declKind = constructorTypeDeclaration.getKind();
            var declFlags = constructorTypeDeclaration.getFlags();
            var constructorTypeAST = this.semanticInfo.getASTForDecl(constructorTypeDeclaration);

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var constructorTypeSymbol = new PullConstructorTypeSymbol();
            
            constructorTypeDeclaration.setSymbol(constructorTypeSymbol);
            constructorTypeSymbol.addDeclaration(constructorTypeDeclaration);
            this.semanticInfo.setSymbolForAST(constructorTypeAST, constructorTypeSymbol);       

            var signature = new PullDefinitionSignatureSymbol(PullElementKind.ConstructSignature);

            signature.addDeclaration(constructorTypeDeclaration);
            constructorTypeDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(constructorTypeDeclaration), signature);

            // add the implicit construct member for this function type
            constructorTypeSymbol.addSignature(signature);

            var typeParameters = constructorTypeDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
                constructorTypeSymbol.addMember(typeParameter, SymbolLinkKind.TypeParameter);
            }
        }

        // variables
        public bindVariableDeclarationToPullSymbol(variableDeclaration: PullDecl) {
            var declFlags = variableDeclaration.getFlags();
            var declKind = variableDeclaration.getKind();
            var varDeclAST = <VarDecl>this.semanticInfo.getASTForDecl(variableDeclaration);

            var isExported = false;

            var linkKind = SymbolLinkKind.PrivateMember;

            var variableSymbol: PullSymbol = null;

            var declName = variableDeclaration.getName();

            var parentHadSymbol = false;

            var parent = this.getParent(true);

            // The code below accounts for the variable symbol being a type because
            // modules may create instance variables

            if (parent) {
                variableSymbol = parent.findMember(declName);
            }
            else if (!(variableDeclaration.getFlags() & PullElementFlags.Exported)) {
                variableSymbol = this.findSymbolInContext(declName, PullElementKind.SomeValue, []);
            }

            if (variableSymbol && !variableSymbol.isType()) {
                parentHadSymbol = true;
            }            

            if (variableSymbol && (variableSymbol.getSymbolID() > this.startingSymbolForRebind)) {

                // if it's an implicit variable, then this variable symbol will actually be a class constructor
                // or container type that was just defined, so we don't want to raise an error
                if ((declFlags & PullElementFlags.ImplicitVariable) == 0) {
                    variableDeclaration.addError(new PullError(varDeclAST.minChar, varDeclAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(DiagnosticMessages.duplicateIdentifier_1, [declName])));
                    variableSymbol = null;
                }
            }

            if (this.reBindingAfterChange && variableSymbol && !variableSymbol.isType()) {
   
                // prune out-of-date decls...
                var decls = variableSymbol.getDeclarations();
                var scriptName = variableDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        variableSymbol.removeDeclaration(decls[j]);
                    }
                }
            }

            if ((declFlags & PullElementFlags.ImplicitVariable) == 0) {
                if (!variableSymbol) {
                    variableSymbol = new PullSymbol(declName, declKind);
                }

                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);

                this.semanticInfo.setSymbolForAST(varDeclAST, variableSymbol);
                this.semanticInfo.setSymbolForAST(varDeclAST.id, variableSymbol);
            }
            else if (!parentHadSymbol) {

                if ((declFlags & PullElementFlags.ClassConstructorVariable)) {
                    // it's really an implicit class decl, so we need to set the type of the symbol to
                    // the constructor type
                    // Note that we would have already found the class symbol in the search above
                    var classTypeSymbol: PullClassTypeSymbol = <PullClassTypeSymbol>variableSymbol;

                    // PULLTODO: In both this case and the case below, we should have already received the
                    // class or module symbol as the variableSymbol found above
                    if (parent) {
                        var members = parent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].getName() == declName) && (members[i].getKind() == PullElementKind.Class)) {
                                classTypeSymbol = <PullClassTypeSymbol>members[i];
                                break;
                            }
                        }
                    }

                    if (!classTypeSymbol) {
                        classTypeSymbol = <PullClassTypeSymbol>this.findSymbolInContext(declName, PullElementKind.SomeType, []);

                        if (classTypeSymbol && (classTypeSymbol.getKind() != PullElementKind.Class)) {
                            classTypeSymbol = null;
                        }
                    }

                    if (classTypeSymbol) {
                        variableSymbol = classTypeSymbol.getConstructorMethod();
                        variableDeclaration.setSymbol(variableSymbol);
                    }
                    else {
                        // PULLTODO: Raise an Error here
                        variableSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }
                }
                else if ((declFlags & PullElementFlags.InitializedModule)) {
                    var moduleContainerTypeSymbol: PullContainerTypeSymbol = null;
                    var moduleParent = this.getParent(false);
                    
                    if (moduleParent) {
                        var members = moduleParent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].getName() == declName) && (members[i].getKind() == PullElementKind.Container)) {
                                moduleContainerTypeSymbol = <PullContainerTypeSymbol>members[i];
                                break;
                            }
                        }
                    }

                    if (!moduleContainerTypeSymbol) {
                        moduleContainerTypeSymbol = <PullContainerTypeSymbol>this.findSymbolInContext(declName, PullElementKind.SomeType, []);

                        if (moduleContainerTypeSymbol && (moduleContainerTypeSymbol.getKind() != PullElementKind.Container)) {
                            moduleContainerTypeSymbol = null;
                        }
                    }

                    if (moduleContainerTypeSymbol) {
                        variableSymbol = moduleContainerTypeSymbol.getInstanceSymbol();

                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);
                        
                        // we added the variable to the parent when binding the module
                        parentHadSymbol = true;
                    }
                    else {
                        // PULLTODO: Raise an Error here
                        variableSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }
                }
            }

            if (parent && !parentHadSymbol) {

                if (declFlags & PullElementFlags.Exported) {
                    parent.addMember(variableSymbol, SymbolLinkKind.PublicMember);
                }
                else {
                    variableSymbol.addOutgoingLink(parent, SymbolLinkKind.ContainedBy);
                }
            }
        }

        // properties
        public bindPropertyDeclarationToPullSymbol(propertyDeclaration: PullDecl) {
            var declFlags = propertyDeclaration.getFlags();
            var declKind = propertyDeclaration.getKind();
            var propDeclAST = <VarDecl>this.semanticInfo.getASTForDecl(propertyDeclaration);
            
            var isStatic = false;
            var isOptional = false;

            var linkKind = SymbolLinkKind.PublicMember;

            var propertySymbol: PullSymbol = null;

            if (hasFlag(declFlags, PullElementFlags.Static)) {
                isStatic = true;
            }

            if (hasFlag(declFlags, PullElementFlags.Private)) {
                linkKind = SymbolLinkKind.PrivateMember;
            }

            if (hasFlag(declFlags, PullElementFlags.Optional)) {
                isOptional = true;
            }

            var declName = propertyDeclaration.getName();

            var parentHadSymbol = false;

            var parent = this.getParent(true);

            propertySymbol = parent.findMember(declName);

            if (propertySymbol && (!this.reBindingAfterChange || (propertySymbol.getSymbolID() > this.startingSymbolForRebind))) {
                propertyDeclaration.addError(new PullError(propDeclAST.minChar, propDeclAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(DiagnosticMessages.duplicateIdentifier_1, [declName])));

                propertySymbol = null;
            }

            if (propertySymbol) {
                parentHadSymbol = true;
            }

            if (this.reBindingAfterChange && propertySymbol) {

                // prune out-of-date decls...
                var decls = propertySymbol.getDeclarations();
                var scriptName = propertyDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        propertySymbol.removeDeclaration(decls[j]);
                    }
                }
            }

            if ((declFlags & PullElementFlags.ImplicitVariable) == 0) {
                if (!parentHadSymbol) {
                    propertySymbol = new PullSymbol(declName, declKind);
                }

                propertySymbol.addDeclaration(propertyDeclaration);
                propertyDeclaration.setSymbol(propertySymbol);

                this.semanticInfo.setSymbolForAST(propDeclAST, propertySymbol);
                this.semanticInfo.setSymbolForAST(propDeclAST.id, propertySymbol);
            }
            else {
                // it's really an implicit class decl, so we need to set the type of the symbol to
                // the constructor type
                var classTypeSymbol: PullClassTypeSymbol = null;

                if (parent) {
                    var members = parent.getMembers();

                    for (var i = 0; i < members.length; i++) {
                        if ((members[i].getName() == declName) && (members[i].getKind() == PullElementKind.Class)) {
                            classTypeSymbol = <PullClassTypeSymbol>members[i];
                            break;
                        }
                    }
                }
                
                if (!classTypeSymbol) {
                    classTypeSymbol = <PullClassTypeSymbol>this.findSymbolInContext(declName, PullElementKind.SomeType, []);

                    if (classTypeSymbol && (classTypeSymbol.getKind() != PullElementKind.Class)) {
                        classTypeSymbol = null;
                    }
                }

                if (classTypeSymbol) {
                    propertySymbol = classTypeSymbol.getConstructorMethod();
                    propertyDeclaration.setSymbol(propertySymbol);
                }
                else {
                    propertySymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                }
                
                propertySymbol.setResolved();
            }

            if (isOptional) {
                propertySymbol.setIsOptional();
            }

            if (parent && !parentHadSymbol) {
                if (parent.isClass()) {
                    var classTypeSymbol = <PullClassTypeSymbol>parent;
                    if (isStatic) {
                        this.staticClassMembers[this.staticClassMembers.length] = propertySymbol;
                    }
                    else {
                        classTypeSymbol.addMember(propertySymbol, linkKind);
                    }
                }
                else {
                    parent.addMember(propertySymbol, linkKind);
                }
            }
        }

        public bindImportDeclaration(importDeclaration: PullDecl) {
            var declFlags = importDeclaration.getFlags();
            var declKind = importDeclaration.getKind();
            var importDeclAST = <VarDecl>this.semanticInfo.getASTForDecl(importDeclaration);

            var isExported = false;

            var linkKind = SymbolLinkKind.PrivateMember;

            var importSymbol: PullSymbol = null;

            var declName = importDeclaration.getName();

            var parentHadSymbol = false;

            var parent = this.getParent(true);

            // The code below accounts for the variable symbol being a type because
            // modules may create instance variables

            if (parent) {
                importSymbol = parent.findMember(declName);
            }
            else if (!(importDeclaration.getFlags() & PullElementFlags.Exported)) {
                importSymbol = this.findSymbolInContext(declName, PullElementKind.SomeValue, []);
            }

            if (importSymbol) {
                parentHadSymbol = true;
            }

            if (importSymbol && (importSymbol.getSymbolID() > this.startingSymbolForRebind)) {

                // if it's an implicit variable, then this variable symbol will actually be a class constructor
                // or container type that was just defined, so we don't want to raise an error
                if ((declFlags & PullElementFlags.ImplicitVariable) == 0) {
                    importDeclaration.addError(new PullError(importDeclAST.minChar, importDeclAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(DiagnosticMessages.duplicateIdentifier_1, [declName])));
                    importSymbol = null;
                }
            }

            if (this.reBindingAfterChange && importSymbol) {

                // prune out-of-date decls...
                var decls = importSymbol.getDeclarations();
                var scriptName = importDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        importSymbol.removeDeclaration(decls[j]);
                    }
                }
            }

            if (!importSymbol) {
                importSymbol = new PullSymbol(declName, declKind);
            }

            importSymbol.addDeclaration(importDeclaration);
            importDeclaration.setSymbol(importSymbol);

            this.semanticInfo.setSymbolForAST(importDeclAST, importSymbol);
            this.semanticInfo.setSymbolForAST(importDeclAST.id, importSymbol);
            

            if (parent && !parentHadSymbol) {

                if (declFlags & PullElementFlags.Exported) {
                    parent.addMember(importSymbol, SymbolLinkKind.PublicMember);
                }
                else {
                    importSymbol.addOutgoingLink(parent, SymbolLinkKind.ContainedBy);
                }
            }
        }

        // parameters
        public bindParameterSymbols(funcDecl: FuncDecl, signatureSymbol: PullSignatureSymbol) {
            // create a symbol for each ast
            // if it's a property, add the symbol to the enclosing type's member list
            var parameters: PullSymbol[] = [];
            var decl: PullDecl = null;
            var argDecl: BoundDecl = null;
            var parameterSymbol: PullSymbol = null;
            var isProperty = false;
            var params: any = new BlockIntrinsics();

            if (funcDecl.arguments) {

                for (var i = 0; i < funcDecl.arguments.members.length; i++) {
                    argDecl = <BoundDecl>funcDecl.arguments.members[i];
                    decl = this.semanticInfo.getDeclForAST(argDecl);
                    isProperty = hasFlag(argDecl.varFlags, VarFlags.Property);
                    parameterSymbol = new PullSymbol(argDecl.id.actualText, PullElementKind.Variable);

                    if (params[argDecl.id.actualText]) {
                        decl.addError(new PullError(argDecl.minChar, argDecl.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(DiagnosticMessages.duplicateIdentifier_1, [argDecl.id.actualText])));
                    }
                    else {
                        params[argDecl.id.actualText] = true;
                    }
                
                    if (decl) {
                        parameterSymbol.addDeclaration(decl);
                        decl.setSymbol(parameterSymbol);
                    }
                    
                    this.semanticInfo.setSymbolForAST(argDecl, parameterSymbol);
                    this.semanticInfo.setSymbolForAST(argDecl.id, parameterSymbol);

                    signatureSymbol.addParameter(parameterSymbol);

                    // PULLREVIEW: Shouldn't need this, since parameters are created off of decl collection
                    // add a member to the parent type
                    //if (decl && isProperty) {
                    //    parameterSymbol = new PullSymbol(argDecl.id.actualText, PullElementKind.Field);

                    //    parameterSymbol.addDeclaration(decl);
                    //    decl.setPropertySymbol(parameterSymbol);

                    //    var linkKind = (decl.getDeclFlags() & PullElementFlags.Private) ? SymbolLinkKind.PrivateProperty : SymbolLinkKind.PublicProperty;
                    //    var parent = context.getParent(1);
                    //    if (parent.hasBrand()) {
                    //        (<PullClassSymbol>parent).getInstanceType().addMember(parameterSymbol, linkKind);
                    //    }
                    //    else {
                    //        // PULLTODO: I don't think we ever even take this branch...
                    //        parent.addMember(parameterSymbol, linkKind);
                    //    }
                    //}
                }
            }        
        }

        // function declarations
        public bindFunctionDeclarationToPullSymbol(functionDeclaration: PullDecl) {  
            var declKind = functionDeclaration.getKind();
            var declFlags = functionDeclaration.getFlags();
            var funcDeclAST = <FuncDecl>this.semanticInfo.getASTForDecl(functionDeclaration);

            var isExported = (declFlags & PullElementFlags.Exported) != 0;

            var funcName = functionDeclaration.getName();

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var isSignature: bool = (declFlags & PullElementFlags.Signature) != 0;

            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;

            // PULLREVIEW: On a re-bind, there's no need to search far-and-wide: just look in the parent's member list
            var functionSymbol: PullSymbol = null;
            var functionTypeSymbol: PullFunctionTypeSymbol = null;

            if (parent) {
                functionSymbol = parent.findMember(funcName);
            }
            else if (!(functionDeclaration.getFlags() & PullElementFlags.Exported)) {
                functionSymbol = this.findSymbolInContext(funcName, PullElementKind.SomeValue, []);
            }

            if (functionSymbol && functionSymbol.getKind() != PullElementKind.Function) {
                functionDeclaration.addError(new PullError(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(DiagnosticMessages.duplicateIdentifier_1, [funcName])));
                functionSymbol = null;
            }

            if (functionSymbol) {
                functionTypeSymbol = <PullFunctionTypeSymbol>functionSymbol.getType();
                parentHadSymbol = true;
            }
            
            if (this.reBindingAfterChange && functionSymbol) {

                // prune out-of-date decls...
                var decls = functionSymbol.getDeclarations();
                var scriptName = functionDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        functionSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }
            } 

            if (!functionSymbol) {
                // PULLTODO: Make sure that we properly flag signature decl types when collecting decls
                functionSymbol = new PullSymbol(funcName, PullElementKind.Function);
                functionTypeSymbol = new PullFunctionTypeSymbol();

                functionSymbol.setType(functionTypeSymbol);
            }

            functionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionDeclaration);
            
            this.semanticInfo.setSymbolForAST(funcDeclAST, functionSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST.name, functionSymbol);
        
            if (parent && !parentHadSymbol) {
                if (isExported) {
                    parent.addMember(functionSymbol, SymbolLinkKind.PublicMember);
                }
                else {
                    functionSymbol.addOutgoingLink(parent, SymbolLinkKind.ContainedBy);
                }
            }

            if (!isSignature) {
                this.pushParent(functionTypeSymbol);
            }

            // PULLTODO: For now, remove stale signatures from the function type, but we want to be smarter about this when
            // incremental parsing comes online
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = functionTypeSymbol.getCallSignatures();

                for (var i = 0; i < callSigs.length; i++) {
                    functionTypeSymbol.removeCallSignature(callSigs[i], false);
                }

                // just invalidate this once, so we don't pay the cost of rebuilding caches
                // for each signature removed
                functionSymbol.invalidate();
                functionTypeSymbol.invalidate();
            }

            var signature = isSignature ? new PullSignatureSymbol(PullElementKind.CallSignature) : new PullDefinitionSignatureSymbol(PullElementKind.CallSignature);
            
            signature.addDeclaration(functionDeclaration);
            functionDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(functionDeclaration), signature);

            var typeParameters = functionDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
                signature.addTypeParameter(typeParameter);
            }

            // add the implicit call member for this function type
            functionTypeSymbol.addSignature(signature);
        
            if (!isSignature) {
                var childDecls = functionDeclaration.getChildDecls();

                for (var i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }

                this.popParent();
            }
        }

        public bindFunctionExpressionToPullSymbol(functionExpressionDeclaration: PullDecl) {
            var declKind = functionExpressionDeclaration.getKind();
            var declFlags = functionExpressionDeclaration.getFlags();
            var funcExpAST = <FuncDecl>this.semanticInfo.getASTForDecl(functionExpressionDeclaration);

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var functionSymbol: PullSymbol = new PullSymbol(functionExpressionDeclaration.getName(), PullElementKind.Function);
            var functionTypeSymbol = new PullFunctionTypeSymbol();

            functionSymbol.setType(functionTypeSymbol);
            
            functionExpressionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionExpressionDeclaration);

            this.semanticInfo.setSymbolForAST(funcExpAST, functionSymbol);

            if (funcExpAST.name) {
                this.semanticInfo.setSymbolForAST(funcExpAST.name, functionSymbol);
            }
        
            this.pushParent(functionTypeSymbol);

            var signature = new PullDefinitionSignatureSymbol(PullElementKind.CallSignature);

            var typeParameters = functionExpressionDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
                signature.addTypeParameter(typeParameter);
            }

            signature.addDeclaration(functionExpressionDeclaration);
            functionExpressionDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(functionExpressionDeclaration), signature);

            // add the implicit call member for this function type
            functionTypeSymbol.addSignature(signature);
        
            var childDecls = functionExpressionDeclaration.getChildDecls();

            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();
        }

        public bindFunctionTypeDeclarationToPullSymbol(functionTypeDeclaration: PullDecl) {
            var declKind = functionTypeDeclaration.getKind();
            var declFlags = functionTypeDeclaration.getFlags();
            var funcTypeAST = this.semanticInfo.getASTForDecl(functionTypeDeclaration);

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var functionTypeSymbol = new PullFunctionTypeSymbol();
            
            functionTypeDeclaration.setSymbol(functionTypeSymbol);
            functionTypeSymbol.addDeclaration(functionTypeDeclaration);
            this.semanticInfo.setSymbolForAST(funcTypeAST, functionTypeSymbol);
        
            this.pushParent(functionTypeSymbol);

            var signature = new PullDefinitionSignatureSymbol(PullElementKind.CallSignature);

            var typeParameters = functionTypeDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
                signature.addTypeParameter(typeParameter);
            }

            signature.addDeclaration(functionTypeDeclaration);
            functionTypeDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(functionTypeDeclaration), signature);

            // add the implicit call member for this function type
            functionTypeSymbol.addSignature(signature);

            this.popParent();        
        }

        // method declarations
        public bindMethodDeclarationToPullSymbol(methodDeclaration: PullDecl) {
            var declKind = methodDeclaration.getKind();
            var declFlags = methodDeclaration.getFlags();
            var methodAST = <FuncDecl>this.semanticInfo.getASTForDecl(methodDeclaration);

            var isPrivate = (declFlags & PullElementFlags.Private) != 0;
            var isStatic = (declFlags & PullElementFlags.Static) != 0;

            var methodName = methodDeclaration.getName();

            var isSignature: bool = (declFlags & PullElementFlags.Signature) != 0;

            var parent = this.getParent(true);

            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;
            
            var methodSymbol: PullSymbol = null;
            var methodTypeSymbol: PullFunctionTypeSymbol = null;

            var linkKind = isPrivate ? SymbolLinkKind.PrivateMember : SymbolLinkKind.PublicMember;

            methodSymbol = parent.isClass() && isStatic && (<PullClassTypeSymbol>parent).getConstructorMethod() ? (<PullClassTypeSymbol>parent).getConstructorMethod().getType().findMember(methodName) : parent.findMember(methodName);

            if (methodSymbol && methodSymbol.getKind() != PullElementKind.Method) {
                methodDeclaration.addError(new PullError(methodAST.minChar, methodAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(DiagnosticMessages.duplicateIdentifier_1, [methodName])));
                methodSymbol = null;
            }

            if (methodSymbol) {
                methodTypeSymbol = <PullFunctionTypeSymbol>methodSymbol.getType();
                parentHadSymbol = true;
            }

            if (this.reBindingAfterChange && methodSymbol) {

                // prune out-of-date decls...
                var decls = methodSymbol.getDeclarations();
                var scriptName = methodDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        methodSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }
            }

            if (!methodSymbol) {
                // PULLTODO: Make sure that we properly flag signature decl types when collecting decls
                methodSymbol = new PullSymbol(methodName, PullElementKind.Method);
                methodTypeSymbol = new PullFunctionTypeSymbol();

                methodSymbol.setType(methodTypeSymbol);
            }

            methodDeclaration.setSymbol(methodSymbol);
            methodSymbol.addDeclaration(methodDeclaration);
            this.semanticInfo.setSymbolForAST(methodAST, methodSymbol);
            this.semanticInfo.setSymbolForAST(methodAST.name, methodSymbol);
        
            if (!parentHadSymbol) {

                if (isStatic) {
                    this.staticClassMembers[this.staticClassMembers.length] = methodSymbol;
                }
                else {
                    parent.addMember(methodSymbol, linkKind);
                }
            }

            if (!isSignature) {
                this.pushParent(methodTypeSymbol);
            }

            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = methodTypeSymbol.getCallSignatures();
                var constructSigs = methodTypeSymbol.getConstructSignatures();
                var indexSigs = methodTypeSymbol.getIndexSignatures();

                for (var i = 0; i < callSigs.length; i++) {
                    methodTypeSymbol.removeCallSignature(callSigs[i], false);
                }
                for (var i = 0; i < constructSigs.length; i++) {
                    methodTypeSymbol.removeConstructSignature(constructSigs[i], false);
                }
                for (var i = 0; i < indexSigs.length; i++) {
                    methodTypeSymbol.removeIndexSignature(indexSigs[i], false);
                }

                methodSymbol.invalidate();
                methodTypeSymbol.invalidate();
            }

            var sigKind = PullElementKind.CallSignature;

            var signature = isSignature ? new PullSignatureSymbol(sigKind) : new PullDefinitionSignatureSymbol(sigKind);

            var typeParameters = methodDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
                signature.addTypeParameter(typeParameter);
            }

            signature.addDeclaration(methodDeclaration);
            methodDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(methodDeclaration), signature);

            // add the implicit call member for this function type
            methodTypeSymbol.addSignature(signature);
        
            if (!isSignature) {
                var childDecls = methodDeclaration.getChildDecls();

                for (var i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }

                this.popParent();
            } 
        }

        // class constructor declarations
        public bindConstructorDeclarationToPullSymbol(constructorDeclaration: PullDecl) {
            var declKind = constructorDeclaration.getKind();
            var declFlags = constructorDeclaration.getFlags();
            var constructorAST = this.semanticInfo.getASTForDecl(constructorDeclaration);

            var constructorName = constructorDeclaration.getName();

            var isSignature: bool = (declFlags & PullElementFlags.Signature) != 0;

            var parent = <PullClassTypeSymbol>this.getParent(true);

            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;

            var constructorSymbol: PullSymbol = parent.getConstructorMethod();
            var constructorTypeSymbol: PullConstructorTypeSymbol = null;

            var linkKind = SymbolLinkKind.ConstructorMethod;

            if (constructorSymbol) {

                constructorTypeSymbol = <PullConstructorTypeSymbol>constructorSymbol.getType();

                if (this.reBindingAfterChange) {
                    // prune out-of-date decls...
                    var decls = constructorSymbol.getDeclarations();
                    var scriptName = constructorDeclaration.getScriptName();

                    for (var j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            constructorSymbol.removeDeclaration(decls[j]);

                            cleanedPreviousDecls = true;
                        }
                    }

                    constructorSymbol.invalidate();
                    constructorTypeSymbol.invalidate();
                }
            }

            if (!constructorSymbol) {
                constructorSymbol = new PullSymbol(constructorName, PullElementKind.ConstructorMethod);
                constructorTypeSymbol = new PullConstructorTypeSymbol();
            }

            // Even if we're reusing the symbol, it would have been cleared by the call to invalidate above
            parent.setConstructorMethod(constructorSymbol);
            constructorSymbol.setType(constructorTypeSymbol);

            constructorDeclaration.setSymbol(constructorSymbol);
            constructorSymbol.addDeclaration(constructorDeclaration);
            this.semanticInfo.setSymbolForAST(constructorAST, constructorSymbol);
       
            if (!isSignature) {
                this.pushParent(constructorTypeSymbol);
            }

            if (parentHadSymbol && cleanedPreviousDecls) {
                var constructSigs = constructorTypeSymbol.getConstructSignatures();

                for (var i = 0; i < constructSigs.length; i++) {
                    constructorTypeSymbol.removeConstructSignature(constructSigs[i]);
                }

                constructorSymbol.invalidate();
                constructorTypeSymbol.invalidate();
            }
            
            // add a call signature to the constructor method, and a construct signature to the parent class type
            var constructSignature = isSignature ? new PullSignatureSymbol(PullElementKind.ConstructSignature) : new PullDefinitionSignatureSymbol(PullElementKind.ConstructSignature);

            constructSignature.setReturnType(parent);

            // PULLREVIEW: A class constructor doesn't declare it's own type parameters
            //var typeParameters = constructorDeclaration.getTypeParameters();
            //var typeParameter: PullTypeParameterSymbol;

            //for (var i = 0; i < typeParameters.length; i++) {
            //    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
            //    typeParameter.addDeclaration(typeParameters[i]);
            //    typeParameters[i].setSymbol(typeParameter);
            //    constructSignature.addTypeParameter(typeParameter);
            //}

            constructSignature.addDeclaration(constructorDeclaration);
            constructorDeclaration.setSignatureSymbol(constructSignature);

            var constructorDeclAST = <FuncDecl>this.semanticInfo.getASTForDecl(constructorDeclaration);

            this.bindParameterSymbols(constructorDeclAST, constructSignature);

            constructorTypeSymbol.addSignature(constructSignature);
        
            if (!isSignature) {
                var childDecls = constructorDeclaration.getChildDecls();

                for (var i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }

                this.popParent();
            }
        }

        public bindConstructSignatureDeclarationToPullSymbol(constructSignatureDeclaration: PullDecl) {
            var parent = this.getParent(true);

            var constructSigs = parent.getConstructSignatures();

            for (var i = 0; i < constructSigs.length; i++) {
                parent.removeConstructSignature(constructSigs[i], false);
            }

            parent.invalidate();
            
            var constructSignature = new PullSignatureSymbol(PullElementKind.ConstructSignature);

            var typeParameters = constructSignatureDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
                constructSignature.addTypeParameter(typeParameter);
            }

            constructSignature.addDeclaration(constructSignatureDeclaration);
            constructSignatureDeclaration.setSignatureSymbol(constructSignature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(constructSignatureDeclaration), constructSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), constructSignature);

            parent.addConstructSignature(constructSignature); 
        }

        public bindCallSignatureDeclarationToPullSymbol(callSignatureDeclaration: PullDecl) {
            var parent = this.getParent(true);

            // PULLTODO: For now, remove stale signatures from the function type, but we want to be smarter about this when
            // incremental parsing comes online
            var callSigs = parent.getConstructSignatures();

            for (var i = 0; i < callSigs.length; i++) {
                parent.removeConstructSignature(callSigs[i], false);
            }

            parent.invalidate();
            
            var callSignature = new PullSignatureSymbol(PullElementKind.CallSignature);

            var typeParameters = callSignatureDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
                callSignature.addTypeParameter(typeParameter);
            }

            callSignature.addDeclaration(callSignatureDeclaration);
            callSignatureDeclaration.setSignatureSymbol(callSignature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(callSignatureDeclaration), callSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(callSignatureDeclaration), callSignature);

            parent.addCallSignature(callSignature);
        }

        public bindIndexSignatureDeclarationToPullSymbol(indexSignatureDeclaration: PullDecl) {
            var parent = this.getParent(true);

            var indexSigs = parent.getIndexSignatures();

            for (var i = 0; i < indexSigs.length; i++) {
                parent.removeIndexSignature(indexSigs[i], false);
            }

            parent.invalidate();
            
            var indexSignature = new PullSignatureSymbol(PullElementKind.IndexSignature);

            var typeParameters = indexSignatureDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
                indexSignature.addTypeParameter(typeParameter);
            }

            indexSignature.addDeclaration(indexSignatureDeclaration);
            indexSignatureDeclaration.setSignatureSymbol(indexSignature);
            
            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(indexSignatureDeclaration), indexSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), indexSignature);

            parent.addIndexSignature(indexSignature);        
        }

        // binding
        public bindDeclToPullSymbol(decl: PullDecl, rebind = false) {

            if (rebind) {
                this.startingDeclForRebind = lastBoundPullDeclId;
                this.startingSymbolForRebind = lastBoundPullSymbolID;
                this.reBindingAfterChange = true;
            }

            switch (decl.getKind()) {

                case PullElementKind.Script:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.bindDeclToPullSymbol(childDecls[i]);
                    }
                    break;

                case PullElementKind.Container:
                    this.bindModuleDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Interface:
                    this.bindInterfaceDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Class:
                    this.bindClassDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Function:
                    this.bindFunctionDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Variable:
                    this.bindVariableDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Property:
                    this.bindPropertyDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Method:
                    this.bindMethodDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ConstructorMethod:
                    this.bindConstructorDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.CallSignature:
                    this.bindCallSignatureDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ConstructSignature:
                    this.bindConstructSignatureDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.IndexSignature:
                    this.bindIndexSignatureDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Enum:
                    this.bindEnumDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.GetAccessor:
                    this.bindGetAccessorDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.SetAccessor:
                    this.bindSetAccessorDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ObjectType:
                    this.bindObjectTypeDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.FunctionType:
                    this.bindFunctionTypeDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ConstructorType:
                    this.bindConstructorTypeDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.FunctionExpression:
                    this.bindFunctionExpressionToPullSymbol(decl);
                    break;

                case PullElementKind.Parameter:
                    // parameters are bound by their enclosing function
                    break;

                default:
                    throw new Error("Unrecognized type declaration");
            }
        }

        public bindGetAccessorDeclarationToPullSymbol(getAccessorDeclaration: PullDecl) { }
        public bindSetAccessorDeclarationToPullSymbol(setAccessorDeclaration: PullDecl) { }
        
        public bindDeclsForUnit(filePath: string, rebind = false) {
            this.setUnit(filePath);

            var topLevelDecls = this.semanticInfo.getTopLevelDecls();

            for (var i = 0; i < topLevelDecls.length; i++) {
                this.bindDeclToPullSymbol(topLevelDecls[i], rebind);
            }
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {
    
    export var linkID = 0; // PULLTODO: Prune these if not in use

    export class IListItem {
        public next: IListItem = null;
        public prev: IListItem = null;

        constructor (public value: any) { }
    }

    export class LinkList {
        public head: IListItem = null;
        public last: IListItem = null;
        public length = 0;

        public addItem(item: any) {
            if (!this.head) {
                this.head = new IListItem(item);
                this.last = this.head;
                this.length++;
                return;
            }
            
            this.last.next = new IListItem(item);
            this.last.next.prev = this.last;
            this.last = this.last.next;

            this.length++;
        }

        // PULLTODO: Register callbacks for caching
        public find(p: (rn: any) => bool) {
            var node = this.head;
            var vals: any[] = [];

            while (node) {

                if (p(node.value)) {
                    vals[vals.length] = node.value;
                }
                node = node.next;
            }

            return vals;
        }

        public remove(p: (item: any) => bool) {
            var node = this.head;
            var prev: IListItem = null;
            var next: IListItem = null;

            while (node) {

                if (p(node.value)) {

                    if (node == this.head) {

                        if (this.last == this.head) {
                            this.last = null;
                        }

                        this.head = this.head.next;

                        if (this.head) {
                            this.head.prev = null;
                        }
                    }
                    else {
                        prev = node.prev;
                        next = node.next;
                        
                        if (prev) {
                            prev.next = next;
                        }
                        if (next) {
                            next.prev = prev;
                        }
                    }

                    this.length--;
                }
                node = node.next;
            }
        }

        public update(map: (item: any, context: any) => void, context: any ) {
            var node = this.head;

            while (node) {
                map(node.value, context);
                
                node = node.next;
            }
        }
    }

    export class PullSymbolLink {
        public id = linkID++;
        public data: any;
        constructor (public start: PullSymbol, public end: PullSymbol, public kind: SymbolLinkKind) { }
    }

    export enum GraphUpdateKind {
        NoUpdate,

        SymbolRemoved,
        SymbolAdded,

        TypeChanged,
    }

    export class PullSymbolUpdate {

        constructor(public updateKind: GraphUpdateKind, public symbolToUpdate: PullSymbol, public updater: PullSymbolGraphUpdater) { }

    }

    export class PullSymbolGraphUpdater {

        constructor (public semanticInfoChain: SemanticInfoChain) { }

        public updateVersion = 0;

        public removeDecl(declToRemove: PullDecl) {
            var declSymbol = declToRemove.getSymbol();

            if (declSymbol) {
                declSymbol.removeDeclaration(declToRemove);

                var decls = declSymbol.getDeclarations();

                if (!decls.length) {
                    this.removeSymbol(declSymbol);
                }
                else {
                    var childDecls = declToRemove.getChildDecls();

                    for (var i = 0; i < childDecls.length; i++) {
                        this.removeDecl(childDecls[i]);
                    }
                }

                this.semanticInfoChain.removeSymbolFromCache(declSymbol);
            }

            // if we're removing a class, enum, etc., remove the implicit
            // value decl as well
            var valDecl = declToRemove.getValueDecl();

            if (valDecl) {
                this.removeDecl(valDecl);
            }

            this.updateVersion++;
        }

        public addDecl(declToAdd: PullDecl) {
            // the decl has been bound to a symbol already, so we just need to trigger an update

            var symbolToAdd = declToAdd.getSymbol();

            this.addSymbol(symbolToAdd);

            this.updateVersion++;
        }

        // for now, remove all links - later on, see what happens if we leave stuff 'dangling'
        public removeSymbol(symbolToRemove: PullSymbol) {

            if (symbolToRemove.removeUpdateVersion == this.updateVersion) {
                return;
            }

            symbolToRemove.removeUpdateVersion = this.updateVersion;

            symbolToRemove.updateOutgoingLinks(propagateRemovalToOutgoingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolRemoved, symbolToRemove, this));

            symbolToRemove.updateIncomingLinks(propagateRemovalToIncomingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolRemoved, symbolToRemove, this));
        }
        
        public addSymbol(symbolToAdd: PullSymbol) {

            if (symbolToAdd.addUpdateVersion == this.updateVersion) {
                return;
            }

            symbolToAdd.addUpdateVersion = this.updateVersion;

            symbolToAdd.updateOutgoingLinks(propagateAdditionToOutgoingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolAdded, symbolToAdd, this));

            symbolToAdd.updateIncomingLinks(propagateAdditionToIncomingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolAdded, symbolToAdd, this));

        }

        public invalidateType(symbolWhoseTypeChanged: PullSymbol) {
            if (!symbolWhoseTypeChanged) {
                return;
            }

            if (symbolWhoseTypeChanged.typeChangeUpdateVersion == this.updateVersion) {
                return;
            }

            symbolWhoseTypeChanged.typeChangeUpdateVersion = this.updateVersion;

            symbolWhoseTypeChanged.unsetType();

            symbolWhoseTypeChanged.updateOutgoingLinks(propagateChangedTypeToOutgoingLinks, new PullSymbolUpdate(GraphUpdateKind.TypeChanged, symbolWhoseTypeChanged, this));
            
            symbolWhoseTypeChanged.updateIncomingLinks(propagateChangedTypeToIncomingLinks, new PullSymbolUpdate(GraphUpdateKind.TypeChanged, symbolWhoseTypeChanged, this));

        }
    }

    export function propagateRemovalToOutgoingLinks(link: PullSymbolLink, update: PullSymbolUpdate) { 
        
        var symbolToRemove = update.symbolToUpdate;
        var affectedSymbol = link.end;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {

            // if another type infers its type from this one, unset the link
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {

            // shouldn't affect the other type - we'd remove the parent type as an
            // incoming link
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            update.updater.removeSymbol(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            update.updater.removeSymbol(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            update.updater.removeSymbol(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            (<PullTypeSymbol>affectedSymbol).removeMember(symbolToRemove);
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            update.updater.removeSymbol(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            update.updater.invalidateType(affectedSymbol);
        }

        symbolToRemove.removeOutgoingLink(link);
    }

    export function propagateRemovalToIncomingLinks(link: PullSymbolLink, update: PullSymbolUpdate) { 
        var symbolToRemove = update.symbolToUpdate;
        var affectedSymbol = link.start;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayType) {
            update.updater.removeSymbol(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {
            update.updater.removeSymbol(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
    }

    export function propagateAdditionToOutgoingLinks(link: PullSymbolLink, update: PullSymbolUpdate) { 
        
        var symbolToAdd = update.symbolToUpdate;
        var affectedSymbol = link.end;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {
            // how could this happen?
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            // Don't invalidate the type in this case - we only care about
            // public properties
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            // Don't invalidate the type in this case - we only care about
            // public properties
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            // do nothing...
        }
    }

    export function propagateAdditionToIncomingLinks(link: PullSymbolLink, update: PullSymbolUpdate) { 
        var symbolToAdd = update.symbolToUpdate;
        var affectedSymbol = link.start;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {
            // shouldn't change anything...
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            // do nothing...
        }
    }

    export function propagateChangedTypeToOutgoingLinks(link: PullSymbolLink, update: PullSymbolUpdate) { 
        var symbolWhoseTypeChanged = update.symbolToUpdate;
        var affectedSymbol = link.start;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            // do nothing...
        }
    }

    export function propagateChangedTypeToIncomingLinks(link: PullSymbolLink, update: PullSymbolUpdate) { 
        var symbolWhoseTypeChanged = update.symbolToUpdate;
        var affectedSymbol = link.start;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            // do nothing...
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='..\typescript.ts' />

module TypeScript {

    export class PullEmitter extends Emitter {

        constructor(public checker: TypeChecker, public emittingFileName: string, public outfile: ITextWriter, public emitOptions: EmitOptions, public errorReporter: ErrorReporter, public semanticInfoChain: SemanticInfoChain) {
            super(checker, emittingFileName, outfile, emitOptions, errorReporter);
        }

        public setSourceMappings(mapper: SourceMapper) {
            this.allSourceMappers.push(mapper);
            this.sourceMapper = mapper;
        }

        public writeToOutput(s: string) {
            this.outfile.Write(s);
            // TODO: check s for newline
            this.emitState.column += s.length;
        }

        public writeToOutputTrimmable(s: string) {
            if (this.emitOptions.minWhitespace) {
                s = s.replace(/[\s]*/g, '');
            }
            this.writeToOutput(s);
        }

        public writeLineToOutput(s: string) {
            if (this.emitOptions.minWhitespace) {
                this.writeToOutput(s);
                var c = s.charCodeAt(s.length - 1);
                if (!((c == LexCodeSpace) || (c == LexCodeSMC) || (c == LexCodeLBR))) {
                    this.writeToOutput(' ');
                }
            }
            else {
                this.outfile.WriteLine(s);
                this.emitState.column = 0
                this.emitState.line++;
            }
        }

        public writeCaptureThisStatement(ast: AST) {
            this.emitIndent();
            this.recordSourceMappingStart(ast);
            this.writeToOutput(this.captureThisStmtString);
            this.recordSourceMappingEnd(ast);
            this.writeLineToOutput("");
        }

        public setInVarBlock(count: number) {
            this.varListCountStack[this.varListCountStack.length - 1] = count;
        }

        public setInObjectLiteral(val: bool): bool {
            var temp = this.emitState.inObjectLiteral;
            this.emitState.inObjectLiteral = val;
            return temp;
        }

        public setContainer(c: number): number {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        }

        private getIndentString() {
            if (this.emitOptions.minWhitespace) {
                return "";
            }
            else {
                return this.indenter.getIndent();
            }
        }

        public emitIndent() {
            this.writeToOutput(this.getIndentString());
        }

        public emitCommentInPlace(comment: Comment) {
            var text = comment.getText();
            var hadNewLine = false;

            if (comment.isBlockComment) {
                if (this.emitState.column == 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);

                if (text.length > 1 || comment.endsLine) {
                    for (var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingEnd(comment);
                    this.writeLineToOutput("");
                    hadNewLine = true;
                } else {
                    this.recordSourceMappingEnd(comment);
                }
            }
            else {
                if (this.emitState.column == 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingEnd(comment);
                this.writeLineToOutput("");
                hadNewLine = true;
            }

            if (hadNewLine) {
                this.emitIndent();
            }
            else {
                this.writeToOutput(" ");
            }
        }

        public emitParensAndCommentsInPlace(ast: AST, pre: bool) {
            var comments = pre ? ast.preComments : ast.postComments;

            // comments should be printed before the LParen, but after the RParen
            if (ast.isParenthesized && !pre) {
                this.writeToOutput(")");
            }
            if (this.emitOptions.emitComments && comments && comments.length != 0) {
                for (var i = 0; i < comments.length; i++) {
                    this.emitCommentInPlace(comments[i]);
                }
            }
            if (ast.isParenthesized && pre) {
                this.writeToOutput("(");
            }
        }

        // TODO: emit accessor pattern
        public emitObjectLiteral(content: ASTList) {
            this.writeLineToOutput("{");
            this.indenter.increaseIndent();
            var inObjectLiteral = this.setInObjectLiteral(true);
            this.emitJavascriptList(content, ",", TokenID.Comma, true, false, false);
            this.setInObjectLiteral(inObjectLiteral);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutput("}");
        }

        public emitArrayLiteral(content: ASTList) {
            this.writeToOutput("[");
            if (content) {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascriptList(content, ", ", TokenID.Comma, true, false, false);
                this.indenter.decreaseIndent();
                this.emitIndent();
            }
            this.writeToOutput("]");
        }

        public emitNew(target: AST, args: ASTList) {
            this.writeToOutput("new ");
            if (target.nodeType == NodeType.TypeRef) {
                var typeRef = <TypeReference>target;
                if (typeRef.arrayCount) {
                    this.writeToOutput("Array()");
                }
                else {
                    this.emitJavascript(typeRef.term, TokenID.Tilde, false);
                    this.writeToOutput("()");
                }
            }
            else {
                this.emitJavascript(target, TokenID.Tilde, false);
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(args);
            }
        }

        // PULLTODO
        private getConstantValue(init: AST): number {
            if (init) {
                if (init.nodeType === NodeType.NumberLit) {
                    var numLit = <NumberLiteral>init;
                    return numLit.value;
                }
                else if (init.nodeType === NodeType.Lsh) {
                    var binop = <BinaryExpression>init;
                    if (binop.operand1.nodeType === NodeType.NumberLit &&
                        binop.operand2.nodeType === NodeType.NumberLit) {
                        return (<NumberLiteral>binop.operand1).value << (<NumberLiteral>binop.operand2).value;
                    }
                }
                else if (init.nodeType === NodeType.Name) {
                    var ident = <Identifier>init;
                    if (ident.sym !== null && ident.sym.declAST.nodeType === NodeType.VarDecl) {
                        var varDecl = <VarDecl>ident.sym.declAST;
                        return this.getConstantValue(varDecl.init);
                    }
                }
            }

            return null;
        }

        // PULLTODO
        public tryEmitConstant(dotExpr: BinaryExpression) {
            if (!this.emitOptions.propagateConstants) {
                return false;
            }
            var propertyName = <Identifier>dotExpr.operand2;
            if (propertyName && propertyName.sym && propertyName.sym.isVariable()) {
                if (hasFlag(propertyName.sym.flags, SymbolFlags.Constant)) {
                    if (propertyName.sym.declAST) {
                        var boundDecl = <BoundDecl>propertyName.sym.declAST;
                        var value = this.getConstantValue(boundDecl.init);
                        if (value !== null) {
                            this.writeToOutput(value.toString());
                            var comment = " /* ";
                            comment += propertyName.actualText;
                            comment += " */ ";
                            this.writeToOutput(comment);
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        public emitCall(callNode: CallExpression, target: AST, args: ASTList) {
            if (!this.emitSuperCall(callNode)) {
                if (!hasFlag(callNode.flags, ASTFlags.ClassBaseConstructorCall)) {
                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {
                        this.writeToOutput("(");
                    }
                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {
                        this.writeToOutput("_super.call");
                    }
                    else {
                        this.emitJavascript(target, TokenID.OpenParen, false);
                    }
                    if (target.nodeType == NodeType.FuncDecl && !target.isParenthesized) {
                        this.writeToOutput(")");
                    }
                    this.recordSourceMappingStart(args);
                    this.writeToOutput("(");
                    if (callNode.target.nodeType == NodeType.Super && this.emitState.container == EmitContainer.Constructor) {
                        this.writeToOutput("this");
                        if (args && args.members.length) {
                            this.writeToOutput(", ");
                        }
                    }
                    this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);
                    this.writeToOutput(")");
                    this.recordSourceMappingEnd(args);
                }
                else {
                    this.indenter.decreaseIndent();
                    this.indenter.decreaseIndent();
                    var constructorCall = new ASTList();
                    constructorCall.members[0] = callNode;
                    this.emitConstructorCalls(constructorCall, this.thisClassNode);
                    this.indenter.increaseIndent();
                    this.indenter.increaseIndent();
                }
            }
        }

        // PULLTODO
        public emitConstructorCalls(bases: ASTList, classDecl: TypeDeclaration) {
            if (bases == null) {
                return;
            }
            var basesLen = bases.members.length;
            this.recordSourceMappingStart(classDecl);
            for (var i = 0; i < basesLen; i++) {
                var baseExpr = bases.members[i];
                var baseSymbol: Symbol = null;
                if (baseExpr.nodeType == NodeType.Call) {
                    baseSymbol = (<CallExpression>baseExpr).target.type.symbol;
                }
                else {
                    baseSymbol = baseExpr.type.symbol;
                }
                var baseName = baseSymbol.name;
                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {
                    baseName = baseSymbol.fullName();
                }
                if (baseExpr.nodeType == NodeType.Call) {
                    this.emitIndent();
                    this.writeToOutput("_super.call(this");
                    var args = (<CallExpression>baseExpr).arguments;
                    if (args && (args.members.length > 0)) {
                        this.writeToOutput(", ");
                        this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);
                    }
                    this.writeToOutput(")");
                }
                else {
                    if (baseExpr.type && (baseExpr.type.isClassInstance())) {
                        // parameterless constructor call;
                        this.emitIndent();
                        this.writeToOutput(classDecl.name.actualText + "._super.constructor");
                        //emitJavascript(baseExpr,TokenID.LParen,false);
                        this.writeToOutput(".call(this)");
                    }
                }
            }
            this.recordSourceMappingEnd(classDecl);
        }

        // PULLTODO
        public emitInnerFunction(funcDecl: FuncDecl, printName: bool, isMember: bool,
            bases: ASTList, hasSelfRef: bool, classDecl: TypeDeclaration) {
            /// REVIEW: The code below causes functions to get pushed to a newline in cases where they shouldn't
            /// such as: 
            ///     Foo.prototype.bar = 
            ///         function() {
            ///         };
            /// Once we start emitting comments, we should pull this code out to place on the outer context where the function
            /// is used.
            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {
            //    this.writeLineToOutput("");
            //    this.increaseIndent();
            //    emitIndent();
            //}

            var isClassConstructor = funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod);
            var hasNonObjectBaseType = isClassConstructor && hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseType) && !hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);
            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);

            // We have no way of knowing if the current function is used as an expression or a statement, so as to enusre that the emitted
            // JavaScript is always valid, add an extra parentheses for unparenthesized function expressions
            var shouldParenthesize = hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) && !funcDecl.isParenthesized && !funcDecl.isAccessor() && (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon));

            this.emitParensAndCommentsInPlace(funcDecl, true);
            if (shouldParenthesize) {
                this.writeToOutput("(");
            }
            this.recordSourceMappingStart(funcDecl);
            if (!(funcDecl.isAccessor() && (<FieldSymbol>funcDecl.accessorSymbol).isObjectLitField)) {
                this.writeToOutput("function ");
            }
            if (printName) {
                var id = funcDecl.getNameText();
                if (id && !funcDecl.isAccessor()) {
                    if (funcDecl.name) {
                        this.recordSourceMappingStart(funcDecl.name);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.name) {
                        this.recordSourceMappingEnd(funcDecl.name);
                    }
                }
            }

            this.writeToOutput("(");
            var argsLen = 0;
            var i = 0;
            var arg: ArgDecl;
            var defaultArgs: ArgDecl[] = [];
            if (funcDecl.arguments) {
                var tempContainer = this.setContainer(EmitContainer.Args);
                argsLen = funcDecl.arguments.members.length;
                var printLen = argsLen;
                if (funcDecl.variableArgList) {
                    printLen--;
                }
                for (i = 0; i < printLen; i++) {
                    arg = <ArgDecl>funcDecl.arguments.members[i];
                    if (arg.init) {
                        defaultArgs.push(arg);
                    }
                    this.emitJavascript(arg, TokenID.OpenParen, false);
                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                    }
                }
                this.setContainer(tempContainer);
            }
            this.writeLineToOutput(") {");

            if (funcDecl.isConstructor) {
                this.recordSourceMappingNameStart("constructor");
            } else if (funcDecl.isGetAccessor()) {
                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());
            } else if (funcDecl.isSetAccessor()) {
                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());
            } else {
                this.recordSourceMappingNameStart(funcDecl.getNameText());
            }
            this.indenter.increaseIndent();

            // set default args first
            for (i = 0; i < defaultArgs.length; i++) {
                var arg = defaultArgs[i];
                this.emitIndent();
                this.recordSourceMappingStart(arg);
                this.writeToOutput("if (typeof " + arg.id.actualText + " === \"undefined\") { ");//
                this.recordSourceMappingStart(arg.id);
                this.writeToOutput(arg.id.actualText);
                this.recordSourceMappingEnd(arg.id);
                this.writeToOutput(" = ");
                this.emitJavascript(arg.init, TokenID.OpenParen, false);
                this.writeLineToOutput("; }")
                this.recordSourceMappingEnd(arg);
            }

            if (funcDecl.isConstructor && ((<ClassDeclaration>funcDecl.classDecl).varFlags & VarFlags.MustCaptureThis)) {
                this.writeCaptureThisStatement(funcDecl);
            }

            if (funcDecl.isConstructor && !classPropertiesMustComeAfterSuperCall) {
                if (funcDecl.arguments) {
                    argsLen = funcDecl.arguments.members.length;
                    for (i = 0; i < argsLen; i++) {
                        arg = <ArgDecl>funcDecl.arguments.members[i];
                        if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {
                            this.emitIndent();
                            this.recordSourceMappingStart(arg);
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput("this." + arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeToOutput(" = ");
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput(arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeLineToOutput(";");
                            this.recordSourceMappingEnd(arg);
                        }
                    }
                }

                // For classes, the constructor needs to be explicitly called
                if (!hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
                    this.emitConstructorCalls(bases, classDecl);
                }
            }
            if (hasSelfRef) {
                this.writeCaptureThisStatement(funcDecl);
            }
            if (funcDecl.variableArgList) {
                argsLen = funcDecl.arguments.members.length;
                var lastArg = <ArgDecl>funcDecl.arguments.members[argsLen - 1];
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.recordSourceMappingStart(lastArg.id);
                this.writeToOutput(lastArg.id.actualText);
                this.recordSourceMappingEnd(lastArg.id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (")
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var _i = 0;");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput(" ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i < (arguments.length - " + (argsLen - 1) + ")");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput("; ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i++");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();

                this.recordSourceMappingStart(lastArg);
                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (argsLen - 1) + "];");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }

            // if it's a class, emit the uninitializedMembers, first emit the non-proto class body members
            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod) && !classPropertiesMustComeAfterSuperCall) {

                var nProps = (<ASTList>this.thisClassNode.members).members.length;

                for (var i = 0; i < nProps; i++) {
                    if ((<ASTList>this.thisClassNode.members).members[i].nodeType == NodeType.VarDecl) {
                        var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[i];
                        if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {
                            this.emitIndent();
                            this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);
                            this.writeLineToOutput("");
                        }
                    }
                }
                //this.writeLineToOutput("");
            }

            this.emitBareJavascriptStatements(funcDecl.bod, classPropertiesMustComeAfterSuperCall);

            this.indenter.decreaseIndent();
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl.endingToken);
            this.writeToOutput("}");

            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl.endingToken);
            this.recordSourceMappingEnd(funcDecl);

            if (shouldParenthesize) {
                this.writeToOutput(")");
            }

            // The extra call is to make sure the caller's funcDecl end is recorded, since caller wont be able to record it
            this.recordSourceMappingEnd(funcDecl);

            this.emitParensAndCommentsInPlace(funcDecl, false);

            if (!isMember &&
                //funcDecl.name != null &&
                !hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) &&
                (!hasFlag(funcDecl.fncFlags, FncFlags.Signature) || funcDecl.isConstructor)) {
                this.writeLineToOutput("");
            } else if (hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {
                if (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon)) {
                    // If either of these two flags are set, then the function expression is a statement. Terminate it.
                    this.writeLineToOutput(";");
                }
            }
            /// TODO: See the other part of this at the beginning of function
            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {
            //    this.decreaseIndent();
            //}           
        }

        // PULLTODO
        public emitJavascriptModule(moduleDecl: ModuleDeclaration) {
            var modName = moduleDecl.name.actualText;
            if (isTSFile(modName)) {
                moduleDecl.name.setText(modName.substring(0, modName.length - 3));
            }
            else if (isSTRFile(modName)) {
                moduleDecl.name.setText(modName.substring(0, modName.length - 4));
            }

            if (!hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient)) {
                var isDynamicMod = hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic);
                var prevOutFile = this.outfile;
                var prevOutFileName = this.emittingFileName;
                var prevAllSourceMappers = this.allSourceMappers;
                var prevSourceMapper = this.sourceMapper;
                var prevColumn = this.emitState.column;
                var prevLine = this.emitState.line;
                var temp = this.setContainer(EmitContainer.Module);
                var svModuleName = this.moduleName;
                var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);
                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;
                var isWholeFile = hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile);
                this.moduleName = moduleDecl.name.actualText;

                // prologue
                if (isDynamicMod) {
                    // create the new outfile for this module
                    var tsModFileName = stripQuotes(moduleDecl.name.actualText);
                    var modFilePath = trimModName(tsModFileName) + ".js";
                    modFilePath = this.emitOptions.mapOutputFileName(modFilePath, TypeScriptCompiler.mapToJSFileName);

                    if (this.emitOptions.ioHost) {
                        // Ensure that the slashes are normalized so that the comparison is fair
                        // REVIEW: Note that modFilePath is normalized to forward slashes in Parser.parse, so the 
                        // first call to switchToForwardSlashes is technically a no-op, but it will prevent us from
                        // regressing if the parser changes
                        if (switchToForwardSlashes(modFilePath) != switchToForwardSlashes(this.emittingFileName)) {
                            this.emittingFileName = modFilePath;
                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.emitComments && moduleDecl.containsUnicodeCharInComment);
                            this.outfile = this.createFile(this.emittingFileName, useUTF8InOutputfile);
                            if (prevSourceMapper != null) {
                                this.allSourceMappers = [];
                                var sourceMappingFile = this.createFile(this.emittingFileName + SourceMapper.MapFileExtension, false);
                                this.setSourceMappings(new TypeScript.SourceMapper(tsModFileName, this.emittingFileName, this.outfile, sourceMappingFile, this.errorReporter, this.emitOptions.emitFullSourceMapPath));
                                this.emitState.column = 0;
                                this.emitState.line = 0;
                            }
                        } else {
                            CompilerDiagnostics.assert(this.emitOptions.outputMany, "Cannot have dynamic modules compiling into single file");
                        }
                    }

                    this.setContainer(EmitContainer.DynamicModule); // discard the previous 'Module' container

                    this.recordSourceMappingStart(moduleDecl);
                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD
                        var dependencyList = "[\"require\", \"exports\"";
                        var importList = "require, exports";
                        var importStatement: ImportDeclaration = null;

                        // all dependencies are quoted
                        for (var i = 0; i < (<ModuleType>moduleDecl.mod).importedModules.length; i++) {
                            importStatement = (<ModuleType>moduleDecl.mod).importedModules[i]

                            // if the imported module is only used in a type position, do not add it as a requirement
                            if (importStatement.id.sym &&
                                !(<TypeSymbol>importStatement.id.sym).onlyReferencedAsTypeRef) {
                                if (i <= (<ModuleType>moduleDecl.mod).importedModules.length - 1) {
                                    dependencyList += ", ";
                                    importList += ", ";
                                }

                                importList += "__" + importStatement.id.actualText + "__";
                                dependencyList += importStatement.firstAliasedModToString();
                            }
                        }

                        // emit any potential amd dependencies
                        for (var i = 0; i < moduleDecl.amdDependencies.length; i++) {
                            dependencyList += ", \"" + moduleDecl.amdDependencies[i] + "\"";
                        }

                        dependencyList += "]";

                        this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                    }
                    else { // Node

                    }
                }
                else {

                    if (!isExported) {
                        this.recordSourceMappingStart(moduleDecl);
                        this.writeToOutput("var ");
                        this.recordSourceMappingStart(moduleDecl.name);
                        this.writeToOutput(this.moduleName);
                        this.recordSourceMappingEnd(moduleDecl.name);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(moduleDecl);
                        this.emitIndent();
                    }

                    this.writeToOutput("(");
                    this.recordSourceMappingStart(moduleDecl);
                    this.writeToOutput("function (");
                    this.recordSourceMappingStart(moduleDecl.name);
                    this.writeToOutput(this.moduleName);
                    this.recordSourceMappingEnd(moduleDecl.name);
                    this.writeLineToOutput(") {");
                }

                if (!isWholeFile) {
                    this.recordSourceMappingNameStart(this.moduleName);
                }

                // body - don't indent for Node
                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {
                    this.indenter.increaseIndent();
                }

                if (moduleDecl.modFlags & ModuleFlags.MustCaptureThis) {
                    this.writeCaptureThisStatement(moduleDecl);
                }

                this.emitJavascriptList(moduleDecl.members, null, TokenID.Semicolon, true, false, false);
                if (!isDynamicMod || moduleGenTarget == ModuleGenTarget.Asynchronous) {
                    this.indenter.decreaseIndent();
                }
                this.emitIndent();

                // epilogue
                if (isDynamicMod) {
                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) { // AMD
                        this.writeLineToOutput("})");
                    }
                    else { // Node
                    }
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl);

                    // close the module outfile, and restore the old one
                    if (this.outfile != prevOutFile) {
                        this.Close();
                        if (prevSourceMapper != null) {
                            this.allSourceMappers = prevAllSourceMappers;
                            this.sourceMapper = prevSourceMapper;
                            this.emitState.column = prevColumn;
                            this.emitState.line = prevLine;
                        }
                        this.outfile = prevOutFile;
                        this.emittingFileName = prevOutFileName;
                    }
                }
                else {
                    var containingMod: ModuleDeclaration = null;
                    if (moduleDecl.type && moduleDecl.type.symbol.container && moduleDecl.type.symbol.container.declAST) {
                        containingMod = <ModuleDeclaration>moduleDecl.type.symbol.container.declAST;
                    }
                    var parentIsDynamic = containingMod && hasFlag(containingMod.modFlags, ModuleFlags.IsDynamic);

                    this.recordSourceMappingStart(moduleDecl.endingToken);
                    if (temp == EmitContainer.Prog && isExported) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
                    }
                    else if (isExported || temp == EmitContainer.Prog) {
                        var dotMod = svModuleName != "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
                    }
                    else if (!isExported && temp != EmitContainer.Prog) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
                    }
                    else {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")();");
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                    this.writeLineToOutput("");
                    if (temp != EmitContainer.Prog && isExported) {
                        this.emitIndent();
                        this.recordSourceMappingStart(moduleDecl);
                        if (parentIsDynamic) {
                            this.writeLineToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                        } else {
                            this.writeLineToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                        }
                        this.recordSourceMappingEnd(moduleDecl);
                    }
                }

                this.setContainer(temp);
                this.moduleName = svModuleName;
                this.moduleDeclList.length--;
            }
        }

        public emitIndex(operand1: AST, operand2: AST) {
            var temp = this.setInObjectLiteral(false);
            this.emitJavascript(operand1, TokenID.Tilde, false);
            this.writeToOutput("[");
            this.emitJavascriptList(operand2, ", ", TokenID.Comma, false, false, false);
            this.writeToOutput("]");
            this.setInObjectLiteral(temp);
        }

        public emitStringLiteral(text: string) {
            // should preserve escape etc.
            // TODO: simplify object literal simple name
            this.writeToOutput(text);
        }

        // PULLTODO
        public emitJavascriptFunction(funcDecl: FuncDecl) {
            if (hasFlag(funcDecl.fncFlags, FncFlags.Signature) || funcDecl.isOverload) {
                return;
            }
            var temp: number;
            var tempFnc = this.thisFnc;
            this.thisFnc = funcDecl;

            if (funcDecl.isConstructor) {
                temp = this.setContainer(EmitContainer.Constructor);
            }
            else {
                temp = this.setContainer(EmitContainer.Function);
            }

            var bases: ASTList = null;
            var hasSelfRef = false;
            var funcName = funcDecl.getNameText();

            if ((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) &&
                ((temp != EmitContainer.Constructor) ||
                ((funcDecl.fncFlags & FncFlags.Method) == FncFlags.None))) {
                var tempLit = this.setInObjectLiteral(false);
                if (this.thisClassNode) {
                    bases = this.thisClassNode.extendsList;
                }
                hasSelfRef = Emitter.shouldCaptureThis(funcDecl);
                this.recordSourceMappingStart(funcDecl);
                if (hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) && funcDecl.type.symbol.container == this.checker.gloMod && !funcDecl.isConstructor) {
                    this.writeToOutput("this." + funcName + " = ");
                    this.emitInnerFunction(funcDecl, false, false, bases, hasSelfRef, this.thisClassNode);
                }
                else {
                    this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()), false, bases, hasSelfRef, this.thisClassNode);
                }
                this.setInObjectLiteral(tempLit);
            }
            this.setContainer(temp);
            this.thisFnc = tempFnc;

            if (!hasFlag(funcDecl.fncFlags, FncFlags.Signature)) {
                if (hasFlag(funcDecl.fncFlags, FncFlags.Static)) {
                    if (this.thisClassNode) {
                        if (funcDecl.isAccessor()) {
                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);
                        }
                        else {
                            this.emitIndent();
                            this.recordSourceMappingStart(funcDecl);
                            this.writeLineToOutput(this.thisClassNode.name.actualText + "." + funcName +
                                          " = " + funcName + ";");
                            this.recordSourceMappingEnd(funcDecl);
                        }
                    }
                }
                else if ((this.emitState.container == EmitContainer.Module || this.emitState.container == EmitContainer.DynamicModule) && hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported)) {
                    this.emitIndent();
                    var modName = this.emitState.container == EmitContainer.Module ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeLineToOutput(modName + "." + funcName +
                                      " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        }

        public emitAmbientVarDecl(varDecl: VarDecl) {
            if (varDecl.init) {
                this.emitParensAndCommentsInPlace(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                this.writeToOutput(" = ");
                this.emitJavascript(varDecl.init, TokenID.Comma, false);
                this.recordSourceMappingEnd(varDecl);
                this.writeToOutput(";");
                this.emitParensAndCommentsInPlace(varDecl, false);
            }
        }

        private varListCount(): number {
            return this.varListCountStack[this.varListCountStack.length - 1];
        }

        // Emits "var " if it is allowed
        private emitVarDeclVar() {
            // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var
            // If it is var list of form  var a = varList count will be 0
            if (this.varListCount() >= 0) {
                this.writeToOutput("var ");
                this.setInVarBlock(-this.varListCount());
            }
            return true;
        }

        private onEmitVar() {
            if (this.varListCount() > 0) {
                this.setInVarBlock(this.varListCount() - 1);
            }
            else if (this.varListCount() < 0) {
                this.setInVarBlock(this.varListCount() + 1);
            }
        }

        // PULLTODO
        public emitJavascriptVarDecl(varDecl: VarDecl, tokenId: TokenID) {
            if ((varDecl.varFlags & VarFlags.Ambient) == VarFlags.Ambient) {
                this.emitAmbientVarDecl(varDecl);
                this.onEmitVar();
            }
            else {
                var sym = varDecl.sym;
                var hasInitializer = (varDecl.init != null);
                this.emitParensAndCommentsInPlace(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                if (sym && sym.isMember() && sym.container &&
                    (sym.container.kind() == SymbolKind.Type)) {
                    var type = (<TypeSymbol>sym.container).type;
                    if (type.isClass() && (!hasFlag(sym.flags, SymbolFlags.ModuleMember))) {
                        // class
                        if (this.emitState.container != EmitContainer.Args) {
                            if (hasFlag(sym.flags, SymbolFlags.Static)) {
                                this.writeToOutput(sym.container.name + ".");
                            }
                            else {
                                this.writeToOutput("this.");
                            }
                        }
                    }
                    else if (type.hasImplementation()) {
                        // module
                        if (!hasFlag(sym.flags, SymbolFlags.Exported) && (sym.container == this.checker.gloMod || !hasFlag(sym.flags, SymbolFlags.Property))) {
                            this.emitVarDeclVar();
                        }
                        else if (hasFlag(varDecl.varFlags, VarFlags.LocalStatic)) {
                            this.writeToOutput(".");
                        }
                        else {
                            if (this.emitState.container == EmitContainer.DynamicModule) {
                                this.writeToOutput("exports.");
                            }
                            else {
                                this.writeToOutput(this.moduleName + ".");
                            }
                        }
                    }
                    else {
                        // function, constructor, method etc.
                        if (tokenId != TokenID.OpenParen) {
                            if (hasFlag(sym.flags, SymbolFlags.Exported) && sym.container == this.checker.gloMod) {
                                this.writeToOutput("this.");
                            }
                            else {
                                this.emitVarDeclVar();
                            }
                        }
                    }
                }
                else {
                    if (tokenId != TokenID.OpenParen) {
                        this.emitVarDeclVar();
                    }
                }
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                if (hasInitializer) {
                    this.writeToOutputTrimmable(" = ");

                    // Ensure we have a fresh var list count when recursing into the variable 
                    // initializer.  We don't want our current list of variables to affect how we
                    // emit nested variable lists.
                    this.varListCountStack.push(0);
                    this.emitJavascript(varDecl.init, TokenID.Comma, false);
                    this.varListCountStack.pop();
                }
                this.onEmitVar();
                if ((tokenId != TokenID.OpenParen)) {
                    if (this.varListCount() < 0) {
                        this.writeToOutput(", ");
                    } else if (tokenId != TokenID.For) {
                        this.writeToOutputTrimmable(";");
                    }
                }
                this.recordSourceMappingEnd(varDecl);
                this.emitParensAndCommentsInPlace(varDecl, false);
            }
        }

        public declEnclosed(moduleDecl: ModuleDeclaration): bool {
            if (moduleDecl == null) {
                return true;
            }
            for (var i = 0, len = this.moduleDeclList.length; i < len; i++) {
                if (this.moduleDeclList[i] == moduleDecl) {
                    return true;
                }
            }
            return false;
        }

        // PULLTODO
        public emitJavascriptName(name: Identifier, addThis: bool) {
            var sym = name.sym;
            this.emitParensAndCommentsInPlace(name, true);
            this.recordSourceMappingStart(name);
            if (!name.isMissing()) {
                if (addThis && (this.emitState.container != EmitContainer.Args) && sym) {
                    // TODO: flag global module with marker other than string name
                    if (sym.container && (sym.container.name != globalId)) {
                        if (hasFlag(sym.flags, SymbolFlags.Static) && (hasFlag(sym.flags, SymbolFlags.Property))) {
                            if (sym.declModule && hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {
                                this.writeToOutput("exports.");
                            }
                            else {
                                this.writeToOutput(sym.container.name + ".");
                            }
                        }
                        else if (sym.kind() == SymbolKind.Field) {
                            var fieldSym = <FieldSymbol>sym;
                            if (hasFlag(fieldSym.flags, SymbolFlags.ModuleMember)) {
                                if ((sym.container != this.checker.gloMod) && ((hasFlag(sym.flags, SymbolFlags.Property)) || hasFlag(sym.flags, SymbolFlags.Exported))) {
                                    if (hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {
                                        this.writeToOutput("exports.");
                                    }
                                    else {
                                        this.writeToOutput(sym.container.name + ".");
                                    }
                                }
                            }
                            else {
                                if (sym.isInstanceProperty()) {
                                    this.emitThis();
                                    this.writeToOutput(".");
                                }
                            }
                        }
                        else if (sym.kind() == SymbolKind.Type) {
                            if (sym.isInstanceProperty()) {
                                var typeSym = <TypeSymbol>sym;
                                var type = typeSym.type;
                                if (type.call && !hasFlag(sym.flags, SymbolFlags.ModuleMember)) {
                                    this.emitThis();
                                    this.writeToOutput(".");
                                }
                            }
                            else if ((sym.unitIndex != this.checker.locationInfo.unitIndex) || (!this.declEnclosed(sym.declModule))) {
                                this.writeToOutput(sym.container.name + ".")
                            }
                        }
                    }
                    else if (sym.container == this.checker.gloMod &&
                                hasFlag(sym.flags, SymbolFlags.Exported) &&
                                !hasFlag(sym.flags, SymbolFlags.Ambient) &&
                        // check that it's a not a member of an ambient module...
                                !((sym.isType() || sym.isMember()) &&
                                    sym.declModule &&
                                    hasFlag(sym.declModule.modFlags, ModuleFlags.Ambient)) &&
                                this.emitState.container == EmitContainer.Prog &&
                                sym.declAST.nodeType != NodeType.FuncDecl) {
                        this.writeToOutput("this.");
                    }
                }

                // If it's a dynamic module, we need to print the "require" invocation
                if (sym &&
                    sym.declAST &&
                    sym.declAST.nodeType == NodeType.ModuleDeclaration &&
                    (hasFlag((<ModuleDeclaration>sym.declAST).modFlags, ModuleFlags.IsDynamic))) {
                    var moduleDecl: ModuleDeclaration = <ModuleDeclaration>sym.declAST;

                    if (moduleGenTarget == ModuleGenTarget.Asynchronous) {
                        this.writeLineToOutput("__" + this.modAliasId + "__;");
                    }
                    else {
                        var modPath = name.actualText;//(<ModuleDecl>moduleDecl.mod.symbol.declAST).name.actualText;
                        var isAmbient = moduleDecl.mod.symbol.declAST && hasFlag((<ModuleDeclaration>moduleDecl.mod.symbol.declAST).modFlags, ModuleFlags.Ambient);
                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : quoteBaseName(modPath);
                        modPath = isAmbient ? modPath : (!isRelative(stripQuotes(modPath)) ? quoteStr("./" + stripQuotes(modPath)) : modPath);
                        this.writeToOutput("require(" + modPath + ")");
                    }
                }
                else {
                    this.writeToOutput(name.actualText);
                }
            }
            this.recordSourceMappingEnd(name);
            this.emitParensAndCommentsInPlace(name, false);
        }

        public emitJavascriptStatements(stmts: AST, emitEmptyBod: bool) {
            if (stmts) {
                if (stmts.nodeType != NodeType.Block) {
                    var hasContents = (stmts && (stmts.nodeType != NodeType.List || ((<ASTList>stmts).members.length > 0)));
                    if (emitEmptyBod || hasContents) {
                        var hasOnlyBlockStatement = ((stmts.nodeType == NodeType.Block) ||
                            ((stmts.nodeType == NodeType.List) && ((<ASTList>stmts).members.length == 1) && ((<ASTList>stmts).members[0].nodeType == NodeType.Block)));

                        this.recordSourceMappingStart(stmts);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput(" {");
                            this.indenter.increaseIndent();
                        }
                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, false);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput("");
                            this.indenter.decreaseIndent();
                            this.emitIndent();
                            this.writeToOutput("}");
                        }
                        this.recordSourceMappingEnd(stmts);
                    }
                }
                else {
                    this.emitJavascript(stmts, TokenID.Semicolon, true);
                }
            }
            else if (emitEmptyBod) {
                this.writeToOutput("{ }");
            }
        }

        public emitBareJavascriptStatements(stmts: AST, emitClassPropertiesAfterSuperCall: bool = false) {
            // just the statements without enclosing curly braces
            if (stmts.nodeType != NodeType.Block) {
                if (stmts.nodeType == NodeType.List) {
                    var stmtList = <ASTList>stmts;
                    if ((stmtList.members.length == 2) &&
                        (stmtList.members[0].nodeType == NodeType.Block) &&
                        (stmtList.members[1].nodeType == NodeType.EndCode)) {
                        this.emitJavascript(stmtList.members[0], TokenID.Semicolon, true);
                        this.writeLineToOutput("");
                    }
                    else {
                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, emitClassPropertiesAfterSuperCall);
                    }
                }
                else {
                    this.emitJavascript(stmts, TokenID.Semicolon, true);
                }
            }
            else {
                this.emitJavascript(stmts, TokenID.Semicolon, true);
            }
        }

        public recordSourceMappingNameStart(name: string) {
            if (this.sourceMapper) {
                var finalName = name;
                if (!name) {
                    finalName = "";
                } else if (this.sourceMapper.currentNameIndex.length > 0) {
                    finalName = this.sourceMapper.names[this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1]] + "." + name;
                }

                // We are currently not looking for duplicate but that is possible.
                this.sourceMapper.names.push(finalName);
                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);
            }
        }

        public recordSourceMappingNameEnd() {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        }

        public recordSourceMappingStart(ast: ASTSpan) {
            if (this.sourceMapper && isValidAstNode(ast)) {
                var lineCol = { line: -1, col: -1 };
                var sourceMapping = new SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;
                // REVIEW: check time consumed by this binary search (about two per leaf statement)
                getSourceLineColFromMap(lineCol, ast.minChar, this.checker.locationInfo.lineMap);
                sourceMapping.start.sourceColumn = lineCol.col;
                sourceMapping.start.sourceLine = lineCol.line;
                getSourceLineColFromMap(lineCol, ast.limChar, this.checker.locationInfo.lineMap);
                sourceMapping.end.sourceColumn = lineCol.col;
                sourceMapping.end.sourceLine = lineCol.line;
                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }
                // Set parent and child relationship
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
            }
        }

        public recordSourceMappingEnd(ast: ASTSpan) {
            if (this.sourceMapper && isValidAstNode(ast)) {
                // Pop source mapping childs
                this.sourceMapper.currentMappings.pop();

                // Get the last source mapping from sibling list = which is the one we are recording end for
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];

                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;
            }
        }

        public Close() {
            if (this.sourceMapper != null) {
                SourceMapper.EmitSourceMapping(this.allSourceMappers);
            }
                try {
                    // Closing files could result in exceptions, report them if they occur
                    this.outfile.Close();
                } catch (ex) {
                    this.errorReporter.emitterError(null, ex.message);
                }
        }

        public emitJavascriptList(ast: AST, delimiter: string, tokenId: TokenID, startLine: bool, onlyStatics: bool, emitClassPropertiesAfterSuperCall: bool = false, emitPrologue? = false, requiresExtendsBlock?: bool) {
            if (ast == null) {
                return;
            }
            else if (ast.nodeType != NodeType.List) {
                this.emitPrologue(emitPrologue);
                this.emitJavascript(ast, tokenId, startLine);
            }
            else {
                var list = <ASTList>ast;
                this.emitParensAndCommentsInPlace(ast, true);
                if (list.members.length == 0) {
                    this.emitParensAndCommentsInPlace(ast, false);
                    return;
                }

                var len = list.members.length;
                for (var i = 0; i < len; i++) {
                    if (emitPrologue) {
                        // If the list has Strict mode flags, emit prologue after first statement
                        // otherwise emit before first statement
                        if (i == 1 || !hasFlag(list.flags, ASTFlags.StrictMode)) {
                            this.emitPrologue(requiresExtendsBlock);
                            emitPrologue = false;
                        }
                    }

                    // In some circumstances, class property initializers must be emitted immediately after the 'super' constructor
                    // call which, in these cases, must be the first statement in the constructor body
                    if (i == 1 && emitClassPropertiesAfterSuperCall) {

                        // emit any parameter properties first
                        var constructorDecl = (<ClassDeclaration>this.thisClassNode).constructorDecl;

                        if (constructorDecl && constructorDecl.arguments) {
                            var argsLen = constructorDecl.arguments.members.length;
                            for (var iArg = 0; iArg < argsLen; iArg++) {
                                var arg = <BoundDecl>constructorDecl.arguments.members[iArg];
                                if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {
                                    this.emitIndent();
                                    this.recordSourceMappingStart(arg);
                                    this.recordSourceMappingStart(arg.id);
                                    this.writeToOutput("this." + arg.id.actualText);
                                    this.recordSourceMappingEnd(arg.id);
                                    this.writeToOutput(" = ");
                                    this.recordSourceMappingStart(arg.id);
                                    this.writeToOutput(arg.id.actualText);
                                    this.recordSourceMappingEnd(arg.id);
                                    this.writeLineToOutput(";");
                                    this.recordSourceMappingEnd(arg);
                                }
                            }
                        }

                        var nProps = (<ASTList>this.thisClassNode.members).members.length;

                        for (var iMember = 0; iMember < nProps; iMember++) {
                            if ((<ASTList>this.thisClassNode.members).members[iMember].nodeType == NodeType.VarDecl) {
                                var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[iMember];
                                if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {
                                    this.emitIndent();
                                    this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);
                                    this.writeLineToOutput("");
                                }
                            }
                        }
                    }

                    var emitNode = list.members[i];

                    var isStaticDecl =
                                (emitNode.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>emitNode).fncFlags, FncFlags.Static)) ||
                                (emitNode.nodeType == NodeType.VarDecl && hasFlag((<VarDecl>emitNode).varFlags, VarFlags.Static))

                    if (onlyStatics ? !isStaticDecl : isStaticDecl) {
                        continue;
                    }
                    this.emitJavascript(emitNode, tokenId, startLine);

                    if (delimiter && (i < (len - 1))) {
                        if (startLine) {
                            this.writeLineToOutput(delimiter);
                        }
                        else {
                            this.writeToOutput(delimiter);
                        }
                    }
                    else if (startLine &&
                             (emitNode.nodeType != NodeType.ModuleDeclaration) &&
                             (emitNode.nodeType != NodeType.InterfaceDeclaration) &&
                             (!((emitNode.nodeType == NodeType.VarDecl) &&
                                ((((<VarDecl>emitNode).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&
                                (((<VarDecl>emitNode).init) == null)) && this.varListCount() >= 0) &&
                             (emitNode.nodeType != NodeType.Block || (<Block>emitNode).isStatementBlock) &&
                             (emitNode.nodeType != NodeType.EndCode) &&
                             (emitNode.nodeType != NodeType.FuncDecl)) {
                        this.writeLineToOutput("");
                    }
                }
                this.emitParensAndCommentsInPlace(ast, false);
            }
        }

        // tokenId is the id the preceding token
        public emitJavascript(ast: AST, tokenId: TokenID, startLine: bool) {
            if (ast == null) {
                return;
            }

            // REVIEW: simplify rules for indenting
            if (startLine && (this.indenter.indentAmt > 0) && (ast.nodeType != NodeType.List) &&
                (ast.nodeType != NodeType.Block)) {
                if ((ast.nodeType != NodeType.InterfaceDeclaration) &&
                    (!((ast.nodeType == NodeType.VarDecl) &&
                       ((((<VarDecl>ast).varFlags) & VarFlags.Ambient) == VarFlags.Ambient) &&
                       (((<VarDecl>ast).init) == null)) && this.varListCount() >= 0) &&
                    (ast.nodeType != NodeType.EndCode) &&
                    ((ast.nodeType != NodeType.FuncDecl) ||
                     (this.emitState.container != EmitContainer.Constructor))) {
                    this.emitIndent();
                }
            }

            ast.emit(this, tokenId, startLine);

            if ((tokenId == TokenID.Semicolon) && (ast.nodeType < NodeType.GeneralNode)) {
                this.writeToOutput(";");
            }
        }

        public emitPropertyAccessor(funcDecl: FuncDecl, className: string, isProto: bool) {
            if (!(<FieldSymbol>funcDecl.accessorSymbol).hasBeenEmitted) {
                var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;
                this.emitIndent();
                this.recordSourceMappingStart(funcDecl);
                this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \"" : ", \"") + funcDecl.name.actualText + "\"" + ", {");
                this.indenter.increaseIndent();

                if (accessorSymbol.getter) {
                    var getter: FuncDecl = <FuncDecl>accessorSymbol.getter.declAST;

                    this.emitIndent();
                    this.recordSourceMappingStart(getter);
                    this.writeToOutput("get: ");
                    this.emitInnerFunction(getter, false, isProto, null, Emitter.shouldCaptureThis(getter), null);
                    this.writeLineToOutput(",");
                }

                if (accessorSymbol.setter) {
                    var setter: FuncDecl = <FuncDecl>accessorSymbol.setter.declAST;

                    this.emitIndent();
                    this.recordSourceMappingStart(setter);
                    this.writeToOutput("set: ");
                    this.emitInnerFunction(setter, false, isProto, null, Emitter.shouldCaptureThis(setter), null);
                    this.writeLineToOutput(",");
                }

                this.emitIndent();
                this.writeLineToOutput("enumerable: true,");
                this.emitIndent();
                this.writeLineToOutput("configurable: true");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("});");
                this.recordSourceMappingEnd(funcDecl);

                accessorSymbol.hasBeenEmitted = true;
            }
        }

        public emitPrototypeMember(member: AST, className: string) {
            if (member.nodeType == NodeType.FuncDecl) {
                var funcDecl = <FuncDecl>member;
                if (funcDecl.isAccessor()) {
                    this.emitPropertyAccessor(funcDecl, className, true);
                }
                else {
                    this.emitIndent();
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");
                    this.emitInnerFunction(funcDecl, false, true, null, Emitter.shouldCaptureThis(funcDecl), null);
                    this.writeLineToOutput(";");
                }
            }
            else if (member.nodeType == NodeType.VarDecl) {
                var varDecl = <VarDecl>member;

                if (varDecl.init) {
                    this.emitIndent();
                    this.recordSourceMappingStart(varDecl);
                    this.recordSourceMappingStart(varDecl.id);
                    this.writeToOutput(className + ".prototype." + varDecl.id.actualText);
                    this.recordSourceMappingEnd(varDecl.id);
                    this.writeToOutput(" = ");
                    this.emitJavascript(varDecl.init, TokenID.Equals, false);
                    this.recordSourceMappingEnd(varDecl);
                    this.writeLineToOutput(";");
                }
            }
        }

        // PULLTODO
        public emitAddBaseMethods(className: string, base: Type, classDecl: TypeDeclaration): void {
            if (base.members) {
                var baseSymbol = base.symbol;
                var baseName = baseSymbol.name;
                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {
                    baseName = baseSymbol.fullName();
                }
                base.members.allMembers.map(function (key, s, c) {
                    var sym = <Symbol>s;
                    if ((sym.kind() == SymbolKind.Type) && (<TypeSymbol>sym).type.call) {
                        this.recordSourceMappingStart(sym.declAST);
                        this.writeLineToOutput(className + ".prototype." + sym.name + " = " +
                                          baseName + ".prototype." + sym.name + ";");
                        this.recordSourceMappingEnd(sym.declAST);
                    }
                }, null);
            }
            if (base.extendsList) {
                for (var i = 0, len = base.extendsList.length; i < len; i++) {
                    this.emitAddBaseMethods(className, base.extendsList[i], classDecl);
                }
            }
        }

        // PULLTODO
        public emitJavascriptClass(classDecl: ClassDeclaration) {
            if (!hasFlag(classDecl.varFlags, VarFlags.Ambient)) {
                var svClassNode = this.thisClassNode;
                var i = 0;
                this.thisClassNode = classDecl;
                var className = classDecl.name.actualText;
                this.emitParensAndCommentsInPlace(classDecl, true);
                var temp = this.setContainer(EmitContainer.Class);

                this.recordSourceMappingStart(classDecl);
                if (hasFlag(classDecl.varFlags, VarFlags.Exported) && classDecl.type.symbol.container == this.checker.gloMod) {
                    this.writeToOutput("this." + className);
                }
                else {
                    this.writeToOutput("var " + className);
                }

                //if (hasFlag(classDecl.varFlags, VarFlags.Exported) && (temp == EmitContainer.Module || temp == EmitContainer.DynamicModule)) {
                //    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";
                //    this.writeToOutput(" = " + modName + "." + className);
                //}

                var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;
                var baseNameDecl: AST = null;
                var baseName: AST = null;

                if (hasBaseClass) {
                    this.writeLineToOutput(" = (function (_super) {");
                } else {
                    this.writeLineToOutput(" = (function () {");
                }

                this.recordSourceMappingNameStart(className);
                this.indenter.increaseIndent();

                if (hasBaseClass) {
                    baseNameDecl = classDecl.extendsList.members[0];
                    baseName = baseNameDecl.nodeType == NodeType.Call ? (<CallExpression>baseNameDecl).target : baseNameDecl;
                    this.emitIndent();
                    this.writeLineToOutput("__extends(" + className + ", _super);");
                }

                this.emitIndent();

                var constrDecl = classDecl.constructorDecl;

                // output constructor
                if (constrDecl) {
                    // declared constructor
                    this.emitJavascript(classDecl.constructorDecl, TokenID.OpenParen, false);

                }
                else {
                    var wroteProps = 0;

                    this.recordSourceMappingStart(classDecl);
                    // default constructor
                    this.indenter.increaseIndent();
                    this.writeToOutput("function " + classDecl.name.actualText + "() {");
                    this.recordSourceMappingNameStart("constructor");
                    if (hasBaseClass) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeLineToOutput("_super.apply(this, arguments);");
                        wroteProps++;
                    }

                    if (classDecl.varFlags & VarFlags.MustCaptureThis) {
                        this.writeCaptureThisStatement(classDecl);
                    }

                    var members = (<ASTList>this.thisClassNode.members).members

                    // output initialized properties
                    for (var i = 0; i < members.length; i++) {
                        if (members[i].nodeType == NodeType.VarDecl) {
                            var varDecl = <VarDecl>members[i];
                            if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {
                                this.writeLineToOutput("");
                                this.emitIndent();
                                this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);
                                wroteProps++;
                            }
                        }
                    }
                    if (wroteProps) {
                        this.writeLineToOutput("");
                        this.indenter.decreaseIndent();
                        this.emitIndent();
                        this.writeLineToOutput("}");
                    }
                    else {
                        this.writeLineToOutput(" }");
                        this.indenter.decreaseIndent();
                    }
                    this.recordSourceMappingNameEnd();
                    this.recordSourceMappingEnd(classDecl);
                }

                var membersLen = classDecl.members.members.length;
                for (var j = 0; j < membersLen; j++) {

                    var memberDecl: AST = classDecl.members.members[j];

                    if (memberDecl.nodeType == NodeType.FuncDecl) {
                        var fn = <FuncDecl>memberDecl;

                        if (hasFlag(fn.fncFlags, FncFlags.Method) && !fn.isSignature()) {
                            if (!hasFlag(fn.fncFlags, FncFlags.Static)) {
                                this.emitPrototypeMember(fn, className);
                            }
                            else { // static functions
                                if (fn.isAccessor()) {
                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);
                                }
                                else {
                                    this.emitIndent();
                                    this.recordSourceMappingStart(fn)
                                    this.writeToOutput(classDecl.name.actualText + "." + fn.name.actualText + " = ");
                                    this.emitInnerFunction(fn, (fn.name && !fn.name.isMissing()), true,
                                            null, Emitter.shouldCaptureThis(fn), null);
                                    this.writeLineToOutput(";");
                                }
                            }
                        }
                    }
                    else if (memberDecl.nodeType == NodeType.VarDecl) {
                        var varDecl = <VarDecl>memberDecl;
                        if (hasFlag(varDecl.varFlags, VarFlags.Static)) {

                            if (varDecl.init) {
                                // EMITREVIEW
                                this.emitIndent();
                                this.recordSourceMappingStart(varDecl);
                                this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");
                                this.emitJavascript(varDecl.init, TokenID.Equals, false);
                                // EMITREVIEW

                                this.writeLineToOutput(";");
                                this.recordSourceMappingEnd(varDecl);
                            }
                        }
                    }
                    else {
                        throw Error("We want to catch this");
                    }
                }

                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeLineToOutput("return " + className + ";");
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.recordSourceMappingStart(classDecl);
                this.writeToOutput(")(");
                if (hasBaseClass)
                    this.emitJavascript(baseName, TokenID.Tilde, false);
                this.writeToOutput(");");
                this.recordSourceMappingEnd(classDecl);

                if ((temp == EmitContainer.Module || temp == EmitContainer.DynamicModule) && hasFlag(classDecl.varFlags, VarFlags.Exported)) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = temp == EmitContainer.Module ? this.moduleName : "exports";
                    this.recordSourceMappingStart(classDecl);
                    this.writeToOutput(modName + "." + className + " = " + className + ";");
                    this.recordSourceMappingEnd(classDecl);
                }

                this.emitIndent();
                this.recordSourceMappingEnd(classDecl);
                this.emitParensAndCommentsInPlace(classDecl, false);
                this.setContainer(temp);
                this.thisClassNode = svClassNode;
            }
        }

        // PULLTODO
        public emitPrologue(reqInherits: bool) {
            if (!this.prologueEmitted) {
                if (reqInherits) {
                    this.prologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
                if (this.checker.mustCaptureGlobalThis) {
                    this.prologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        }

        public emitSuperReference() {
            this.writeToOutput("_super.prototype");
        }

        public emitSuperCall(callEx: CallExpression): bool {
            if (callEx.target.nodeType == NodeType.Dot) {
                var dotNode = <BinaryExpression>callEx.target;
                if (dotNode.operand1.nodeType == NodeType.Super) {
                    this.emitJavascript(dotNode, TokenID.OpenParen, false);
                    this.writeToOutput(".call(");
                    this.emitThis();
                    if (callEx.arguments && callEx.arguments.members.length > 0) {
                        this.writeToOutput(", ");
                        this.emitJavascriptList(callEx.arguments, ", ", TokenID.Comma, false, false, false);
                    }
                    this.writeToOutput(")");
                    return true;
                }
            }
            return false;
        }

        public emitThis() {
            if (this.thisFnc && !this.thisFnc.isMethod() && (!this.thisFnc.isConstructor)) {
                this.writeToOutput("_this");
            }
            else {
                this.writeToOutput("this");
            }
        }

        private static shouldCaptureThis(func: FuncDecl): bool {
            // Super calls use 'this' reference. If super call is in a lambda, 'this' value needs to be captured in the parent.
            return func.hasSelfReference() || func.hasSuperReferenceInFatArrowFunction();
        }

        private createFile(fileName: string, useUTF8: bool): ITextWriter {
                try {
                    return this.emitOptions.ioHost.createFile(fileName, useUTF8);
                } catch (ex) {
                    this.errorReporter.emitterError(null, ex.message);
                }
        }
    }
}
///<reference path='SyntaxWalker.generated.ts' />

///<reference path='..\Core\HashTable.ts' />
///<reference path='SyntaxToken.ts' />

interface ITokenInformation {
    previousToken: ISyntaxToken;
    nextToken: ISyntaxToken;
}

class SyntaxInformationMap extends SyntaxWalker {
    private tokenToInformation = Collections.createHashTable(Collections.DefaultHashTableCapacity, Collections.identityHashCode);
    private elementToPosition = Collections.createHashTable(Collections.DefaultHashTableCapacity, Collections.identityHashCode);

    private _previousToken = null;
    private _previousTokenInformation: ITokenInformation = null;
    private _currentPosition = 0;
    private _elementToParent = Collections.createHashTable(Collections.DefaultHashTableCapacity, Collections.identityHashCode);

    private _parentStack: SyntaxNode[] = [];

    constructor(private trackParents: bool, private trackPreviousToken: bool) {
        super();
        this._parentStack.push(null);
    }

    public static create(node: SyntaxNode, trackParents: bool, trackPreviousToken: bool): SyntaxInformationMap {
        var map = new SyntaxInformationMap(trackParents, trackPreviousToken);
        map.visitNode(node);
        return map;
    }

    private visitNode(node: SyntaxNode): void {
        this.trackParents && this._elementToParent.add(node, ArrayUtilities.last(this._parentStack));
        this.elementToPosition.add(node, this._currentPosition);

        this.trackParents && this._parentStack.push(node);
        super.visitNode(node);
        this.trackParents && this._parentStack.pop();
    }

    private visitToken(token: ISyntaxToken): void {
        this.trackParents && this._elementToParent.add(token, ArrayUtilities.last(this._parentStack));

        if (this.trackPreviousToken) {
            var tokenInformation: ITokenInformation = {
                previousToken: this._previousToken,
                nextToken: null
            };

            if (this._previousTokenInformation !== null) {
                this._previousTokenInformation.nextToken = token;
            }

            this._previousToken = token;
            this._previousTokenInformation = tokenInformation;

            this.tokenToInformation.add(token, tokenInformation);
        }

        this.elementToPosition.add(token, this._currentPosition);
        this._currentPosition += token.fullWidth();
    }

    public parent(element: ISyntaxElement): SyntaxNode {
        return this._elementToParent.get(element);
    }

    public fullStart(element: ISyntaxElement): number {
        return this.elementToPosition.get(element);
    }

    public start(element: ISyntaxElement): number {
        return this.fullStart(element) + element.leadingTriviaWidth();
    }

    public end(element: ISyntaxElement): number {
        return this.start(element) + element.width();
    }

    public previousToken(token: ISyntaxToken): ISyntaxToken {
        return this.tokenInformation(token).previousToken;
    }

    public tokenInformation(token: ISyntaxToken): ITokenInformation {
        return this.tokenToInformation.get(token);
    }

    public firstTokenInLineContainingToken(token: ISyntaxToken): ISyntaxToken {
        var current = token;
        while (true) {
            var information = this.tokenInformation(current);
            if (this.isFirstTokenInLineWorker(information)) {
                break;
            }

            current = information.previousToken;
        }

        return current;
    }

    public isFirstTokenInLine(token: ISyntaxToken): bool {
        var information = this.tokenInformation(token);
        return this.isFirstTokenInLineWorker(information);

    }

    private isFirstTokenInLineWorker(information: ITokenInformation): bool {
        return information.previousToken === null || information.previousToken.hasTrailingNewLine();
    }
}
/// <reference path='Syntax\SyntaxVisitor.generated.ts' />
/// <reference path='Syntax\SyntaxWalker.generated.ts' />
/// <reference path='Syntax\SyntaxInformationMap.ts' />
/// <reference path='ast.ts' />

module TypeScript {
    export class SyntaxPositionMap {
        private position = 0;
        private elementToPosition = Collections.createHashTable(2048, Collections.identityHashCode);

        constructor(node: SyntaxNode) {
            this.process(node);
        }

        private process(element: ISyntaxElement) {
            if (element !== null) {
                if (element.isToken()) {
                    this.elementToPosition.add(element, this.position);
                    this.position += element.fullWidth();
                }
                else {
                    if (element.isNode()) {
                        this.elementToPosition.add(element, this.position);
                    }

                    for (var i = 0, n = element.childCount(); i < n; i++) {
                        this.process(element.childAt(i));
                    }
                }
            }
        }

        public static create(node: SyntaxNode): SyntaxPositionMap {
            var map = new SyntaxPositionMap(node);
            return map;
        }
        
        public fullStart(element: ISyntaxElement): number {
            return this.elementToPosition.get(element);
        }

        public start(element: ISyntaxElement): number {
            return this.fullStart(element) + element.leadingTriviaWidth();
        }

        public end(element: ISyntaxElement): number {
            return this.start(element) + element.width();
        }

        public fullEnd(element: ISyntaxElement): number {
            return this.fullStart(element) + element.fullWidth();
        }
    }

    export class SyntaxTreeToAstVisitor implements ISyntaxVisitor {
        public static checkPositions = false;

        private nestingLevel = 0;
        private position = 0;

        private varLists: ASTList[] = [];
        private scopeLists: ASTList[] = [];
        private staticsLists: ASTList[] = [];

        private requiresExtendsBlock: bool = false;

        constructor(private syntaxPositionMap: SyntaxPositionMap,
                    private fileName: string,
                    private unitIndex: number) {
        }

        public static visit(sourceUnit: SourceUnitSyntax, fileName: string, unitIndex: number): Script {
            var map = checkPositions ? SyntaxPositionMap.create(sourceUnit) : null;
            var visitor = new SyntaxTreeToAstVisitor(map, fileName, unitIndex);
            return sourceUnit.accept(visitor);
        }

        private assertElementAtPosition(element: ISyntaxElement) {
            if (SyntaxTreeToAstVisitor.checkPositions) {
                Debug.assert(this.position === this.syntaxPositionMap.fullStart(element));
            }
        }

        private movePast(element: ISyntaxToken): void {
            if (element !== null) {
                this.assertElementAtPosition(element);
                this.position += element.fullWidth();
            }
        }

        private moveTo2(element1: ISyntaxNodeOrToken, element2: ISyntaxElement): void {
            if (element2 !== null) {
                this.position += Syntax.childOffset(element1, element2);
            }
        }

        private moveTo3(element1: ISyntaxNodeOrToken, element2: ISyntaxNodeOrToken, element3: ISyntaxNodeOrToken): void {
            this.moveTo2(element1, element2);
            this.moveTo2(element2, element3);
        }

        private setSpan(span: ASTSpan, start: number, end: number): void {
            span.minChar = start;
            span.limChar = end;
        }

        private hasEscapeSequence(token: ISyntaxToken): bool {
            // TODO: implement this.
            return false;
        }

        private valueText(token: ISyntaxToken): string {
            // TODO: handle unicode escapes here.
            return token.text();
        }

        private identifierFromToken(token: ISyntaxToken, isOptional: bool): Identifier {
            this.assertElementAtPosition(token);

            var result: Identifier = null;
            if (token.fullWidth() === 0) {
                result = new MissingIdentifier();
                result.flags |= ASTFlags.Error;
            }
            else {
                result = new Identifier(this.valueText(token), this.hasEscapeSequence(token));
            }

            if (isOptional) {
                result.flags |= ASTFlags.OptionalName;
            }

            this.setSpan(result, this.position, this.position + token.width());
            return result;
        }

        private visitSyntaxList(list: ISyntaxList): ASTList {
            var result = new ASTList();
            var start = this.position;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                result.append(list.childAt(i).accept(this));
            }

            this.setSpan(result, start, this.position);
            return result;
        }

        private visitSeparatedSyntaxList(list: ISeparatedSyntaxList): ASTList {
            var result = new ASTList();
            var start = this.position;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                if (i % 2 === 0) {
                    result.append(list.childAt(i).accept(this));
                }
                else {
                    this.movePast(<ISyntaxToken>list.childAt(i));
                }
            }

            this.setSpan(result, start, this.position);
            return result;
        }

        private createRef(text: string, hasEscapeSequence: bool, minChar: number): Identifier {
            var id = new Identifier(text, hasEscapeSequence);
            id.minChar = minChar;
            return id;
        }

        private pushDeclLists() {
            this.staticsLists.push(new ASTList());
            this.varLists.push(new ASTList());
            this.scopeLists.push(new ASTList());
        }

        private popDeclLists() {
            this.staticsLists.pop();
            this.varLists.pop();
            this.scopeLists.pop();
        }

        private topVarList() {
            return this.varLists[this.varLists.length - 1];
        }

        private topScopeList() {
            return this.scopeLists[this.scopeLists.length - 1];
        }

        private topStaticsList() {
            return this.staticsLists[this.staticsLists.length - 1];
        }

        private convertComment(trivia: ISyntaxTrivia): Comment {
            throw Errors.notYetImplemented();
        }

        private convertComments(triviaList: ISyntaxTriviaList): Comment[] {
            var result: Comment[] = [];

            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                if (trivia.isComment()) {
                    result.push(this.convertComment(trivia));
                }
            }

            return result;
        }

        private convertLeadingComments(token: ISyntaxToken): Comment[] {
            if (!token.hasLeadingComment()) {
                return null;
            }

            return this.convertComments(token.leadingTrivia());
        }

        private convertTrailingComments(token: ISyntaxToken): Comment[] {
            if (!token.hasTrailingComment()) {
                return null;
            }

            return this.convertComments(token.trailingTrivia());
        }

        private visitToken(token: ISyntaxToken): AST {
            this.assertElementAtPosition(token);

            var result: AST = null;

            if (token.kind() === SyntaxKind.ThisKeyword) {
                result = new AST(NodeType.This);
            }
            else if (token.kind() === SyntaxKind.SuperKeyword) {
                result = new AST(NodeType.Super);
            }
            else if (token.kind() === SyntaxKind.TrueKeyword) {
                result = new AST(NodeType.True);
            }
            else if (token.kind() === SyntaxKind.FalseKeyword) {
                result = new AST(NodeType.False);
            }
            else if (token.kind() === SyntaxKind.NullKeyword) {
                result = new AST(NodeType.Null);
            }
            else if (token.kind() === SyntaxKind.StringLiteral) {
                result = new StringLiteral(token.text());
            }
            else if (token.kind() === SyntaxKind.RegularExpressionLiteral) {
                result = new RegexLiteral(token.text());
            }
            else if (token.kind() === SyntaxKind.NumericLiteral) {
                var value = token.text().indexOf(".") > 0 ? parseFloat(token.text()) : parseInt(token.text());
                result = new NumberLiteral(value, token.text());
            }
            else {
                result = this.identifierFromToken(token, /*isOptional:*/ false);
            }

            this.setSpan(result, this.position, this.position + token.width());
            this.movePast(token);
            return result;
        }

        private hasTopLevelImportOrExport(node: SourceUnitSyntax): bool {
            // TODO: implement this.
            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var moduleElement = node.moduleElements.childAt(i);

                var firstToken = moduleElement.firstToken();
                if (firstToken !== null && firstToken.kind() === SyntaxKind.ExportKeyword) {
                    return true;
                }

                if (moduleElement.kind() === SyntaxKind.ImportDeclaration) {
                    var importDecl = <ImportDeclarationSyntax>moduleElement;
                    if (importDecl.moduleReference.kind() === SyntaxKind.ExternalModuleReference) {
                        return true;
                    }
                }
            }

            var firstToken = node.firstToken();
            if (firstToken.hasLeadingComment()) {
                var leadingTrivia = firstToken.leadingTrivia();
                for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
                    var trivia = leadingTrivia.syntaxTriviaAt(i);

                    if (trivia.isComment()) {
                        // var dependencyPath = getAdditionalDependencyPath(trivia.text());

                        //if (dependencyPath) {
                        //    this.amdDependencies.push(dependencyPath);
                        //}

                        if (getImplicitImport(trivia.fullText())) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        private visitSourceUnit(node: SourceUnitSyntax): Script {
            this.assertElementAtPosition(node);

            var start = this.position;
            var members;
            this.pushDeclLists();

            var isParsingDeclareFile = isDSTRFile(this.fileName) || isDTSFile(this.fileName);

            var bod = this.visitSyntaxList(node.moduleElements);

            var topLevelMod: ModuleDeclaration = null;
            if (moduleGenTarget != ModuleGenTarget.Local && this.hasTopLevelImportOrExport(node)) {
                var correctedFileName = switchToForwardSlashes(this.fileName);
                var id: Identifier = new Identifier(correctedFileName);
                topLevelMod = new ModuleDeclaration(id, bod, this.topVarList(), null);
                this.setSpan(topLevelMod, start, this.position);

                topLevelMod.modFlags |= ModuleFlags.IsDynamic;
                topLevelMod.modFlags |= ModuleFlags.IsWholeFile;
                topLevelMod.modFlags |= ModuleFlags.Exported;

                if (isParsingDeclareFile) {
                    topLevelMod.modFlags |= ModuleFlags.Ambient;
                }

                topLevelMod.prettyName = getPrettyName(correctedFileName);
                //topLevelMod.containsUnicodeChar = this.scanner.seenUnicodeChar;
                //topLevelMod.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;

                // topLevelMod.amdDependencies = this.amdDependencies;

                bod = new ASTList();
                this.setSpan(bod, start, this.position);
                bod.append(topLevelMod);
            }

            var result = new Script(this.topVarList(), this.topScopeList());
            this.setSpan(result, start, this.position);

            this.popDeclLists();

            result.bod = bod;
            result.locationInfo = new LocationInfo(this.fileName, null, this.unitIndex);
            result.topLevelMod = topLevelMod;
            result.isDeclareFile = isDSTRFile(this.fileName) || isDTSFile(this.fileName);
            result.requiresExtendsBlock = this.requiresExtendsBlock;

            return result;
        }

        private visitExternalModuleReference(node: ExternalModuleReferenceSyntax): any {
            this.assertElementAtPosition(node);
            this.moveTo2(node, node.stringLiteral);
            var result = this.identifierFromToken(node.stringLiteral, /*isOptional:*/ false);
            this.movePast(node.stringLiteral);
            this.movePast(node.closeParenToken);

            return result;
        }

        private visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): any {
            this.assertElementAtPosition(node);
            return node.moduleName.accept(this);
        }

        private visitClassDeclaration(node: ClassDeclarationSyntax): ClassDeclaration {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);

            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var extendsList = node.extendsClause ? node.extendsClause.accept(this) : new ASTList();
            var implementsList = node.implementsClause ? node.implementsClause.accept(this) : new ASTList();
            this.movePast(node.openBraceToken);
            var members = this.visitSyntaxList(node.classElements);
            this.movePast(node.closeBraceToken);

            this.requiresExtendsBlock = this.requiresExtendsBlock || !!node.extendsClause;

            var result = new ClassDeclaration(name, typeParameters, members, extendsList, implementsList);
            this.setSpan(result, start, this.position);

            if (node.exportKeyword) {
                result.varFlags |= VarFlags.Exported;
            }

            if (node.declareKeyword) {
                result.varFlags |= VarFlags.Ambient;
            }

            result.varFlags |= VarFlags.Class;

            for (var i = 0; i < members.members.length; i++) {
                var member = members.members[i];
                if (member.nodeType === NodeType.FuncDecl) {
                    var funcDecl = <FuncDecl>member;

                    if (funcDecl.isConstructor) {
                        funcDecl.name = name;
                        funcDecl.returnTypeAnnotation = new TypeReference(name, 0);
                        funcDecl.classDecl = result;

                        result.constructorDecl = funcDecl;
                    }
                }
            }

            var knownMemberNames: any = {};
            for (var i = 0, n = node.classElements.childCount(); i < n; i++) {
                var classElement = <IClassElementSyntax>node.classElements.childAt(i);

                if (classElement.kind() === SyntaxKind.MemberVariableDeclaration) {
                    var variableDeclaration = <MemberVariableDeclarationSyntax>classElement;
                    knownMemberNames[this.valueText(variableDeclaration.variableDeclarator.identifier)] = true;
                }
                else if (classElement.kind() === SyntaxKind.MemberFunctionDeclaration) {
                    var functionDeclaration = <MemberFunctionDeclarationSyntax>classElement;
                    knownMemberNames[this.valueText(functionDeclaration.functionSignature.identifier)] = true;
                }
            }

            result.knownMemberNames = knownMemberNames;

            return result;
        }

        private visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): InterfaceDeclaration {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var extendsList = node.extendsClause ? node.extendsClause.accept(this) : null;
            this.movePast(node.body.openBraceToken);
            var members = this.visitSeparatedSyntaxList(node.body.typeMembers);

            // Fix up interface method flags
            if (members.members) {
                for (var i = 0; i < members.members.length; i++) {
                    if (members.members[i].nodeType == NodeType.FuncDecl) {
                        (<FuncDecl>members.members[i]).fncFlags |= FncFlags.Method;
                        (<FuncDecl>members.members[i]).fncFlags |= FncFlags.Signature;
                    }
                }
            }

            this.movePast(node.body.closeBraceToken);

            var result = new InterfaceDeclaration(name, typeParameters, members, extendsList, null);
            this.setSpan(result, start, this.position);

            //if (node.publicOrPrivateKeyword) {
            //    result.varFlags |= VarFlags.Private;
            //}
            //if (hasFlag(modifiers, Modifiers.Public)) {
            //    result.varFlags |= VarFlags.Public;
            //}
            if (node.exportKeyword) {
                result.varFlags |= VarFlags.Exported;
            }

            return result;
        }

        private visitExtendsClause(node: ExtendsClauseSyntax): ASTList {
            this.assertElementAtPosition(node);

            var result = new ASTList();

            this.movePast(node.extendsKeyword);
            for (var i = 0, n = node.typeNames.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(<ISyntaxToken>node.typeNames.childAt(i));
                }
                else {
                    var type = this.visitType(node.typeNames.childAt(i));
                    if (type.nodeType === NodeType.TypeRef) {
                        type = (<TypeReference>type).term;
                    }

                    result.append(type);
                }
            }

            return result;
        }

        private visitImplementsClause(node: ImplementsClauseSyntax): ASTList {
            this.assertElementAtPosition(node);

            var result = new ASTList();

            this.movePast(node.implementsKeyword);
            for (var i = 0, n = node.typeNames.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(<ISyntaxToken>node.typeNames.childAt(i));
                }
                else {
                    var type = this.visitType(node.typeNames.childAt(i));
                    if (type.nodeType === NodeType.TypeRef) {
                        type = (<TypeReference>type).term;
                    }

                    result.append(type);
                }
            }

            return result;
        }

        private getModuleNames(node: ModuleDeclarationSyntax): Identifier[] {
            var result: Identifier[] = [];

            if (node.stringLiteral !== null) {
                result.push(this.identifierFromToken(node.stringLiteral, /*isOptional:*/false));
                this.movePast(node.stringLiteral);
            }
            else {
                this.getModuleNamesHelper(node.moduleName, result);
            }

            return result;
        }

        private getModuleNamesHelper(name: INameSyntax, result: Identifier[]): void {
            this.assertElementAtPosition(name);

            if (name.kind() === SyntaxKind.QualifiedName) {
                var qualifiedName = <QualifiedNameSyntax>name;
                this.getModuleNamesHelper(qualifiedName.left, result);
                this.movePast(qualifiedName.dotToken);
                result.push(this.identifierFromToken(qualifiedName.right, /*isOptional:*/ false));
                this.movePast(qualifiedName.right);
            }
            else {
                result.push(this.identifierFromToken(<ISyntaxToken>name, /*isOptional:*/ false));
                this.movePast(<ISyntaxToken>name);
            }
        }

        private visitModuleDeclaration(node: ModuleDeclarationSyntax): ModuleDeclaration {
            this.assertElementAtPosition(node);

            this.pushDeclLists();

            var start = this.position;
            this.movePast(node.exportKeyword);
            this.movePast(node.declareKeyword);
            this.movePast(node.moduleKeyword);
            var names = this.getModuleNames(node);
            this.movePast(node.openBraceToken);
            var members = this.visitSyntaxList(node.moduleElements);
            var closeBracePosition = this.position;
            this.movePast(node.closeBraceToken);

            var moduleDecl: ModuleDeclaration = null;
            for (var i = names.length - 1; i >= 0; i--) {
                var innerName = names[i];

                var closeBraceSpan = new ASTSpan();
                closeBraceSpan.minChar = closeBracePosition;
                closeBraceSpan.limChar = this.position;
                var moduleDecl = new ModuleDeclaration(innerName, members, this.topVarList(), closeBraceSpan);
                this.setSpan(moduleDecl, start, this.position);
                //innerDecl.preComments = preComments;

                //if (this.parsingDeclareFile || hasFlag(modifiers, Modifiers.Ambient)) {
                //    innerDecl.modFlags |= ModuleFlags.Ambient;
                //}

                // mark the inner module declarations as exported
                if (i) {
                    moduleDecl.modFlags |= ModuleFlags.Exported;
                }

                // REVIEW: will also possibly need to re-parent comments as well

                if (i === 0) {
                    this.popDeclLists();
                }

                members = new ASTList();
                members.append(moduleDecl);
            }

            if (node.declareKeyword) {
                moduleDecl.modFlags |= ModuleFlags.Ambient;
            }

            if (node.exportKeyword) {
                moduleDecl.modFlags |= ModuleFlags.Exported;
            }

            //if (hasFlag(modifiers, Modifiers.Exported)) {
            //    moduleDecl.modFlags |= ModuleFlags.Exported;
            //} else if (svAmbient) {
            //    this.reportAmbientElementNotExported(name);
            //}

            //if (isDynamicMod) {
            //    moduleDecl.modFlags |= ModuleFlags.IsDynamic;
            //}

            //this.ambientModule = svAmbient;

            //this.topLevel = svTopLevel;
            //moduleDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            //moduleDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            //moduleDecl.limChar = moduleBody.limChar;

            return moduleDecl;
        }

        private hasDotDotDotParameter(parameters: ISeparatedSyntaxList): bool {
            for (var i = 0, n = parameters.nonSeparatorCount(); i < n; i++) {
                if ((<ParameterSyntax>parameters.nonSeparatorAt(i)).dotDotDotToken) {
                    return true;
                }
            }

            return false;
        }

        private convertBlock(node: BlockSyntax): ASTList {
            if (!node) {
                return null;
            }

            this.movePast(node.openBraceToken);
            var statements = this.visitSyntaxList(node.statements);
            this.movePast(node.closeBraceToken);

            return statements;
        }

        private visitFunctionDeclaration(node: FunctionDeclarationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo3(node, node.functionSignature, node.functionSignature.identifier);
            var name = this.identifierFromToken(node.functionSignature.identifier, !!node.functionSignature.questionToken);

            this.movePast(node.functionSignature.identifier);
            this.movePast(node.functionSignature.questionToken);

            var typeParameters = node.functionSignature.callSignature.typeParameterList === null ? null : node.functionSignature.callSignature.typeParameterList.accept(this);
            var parameters = node.functionSignature.callSignature.parameterList.accept(this);

            var returnType = node.functionSignature.callSignature.typeAnnotation
                ? node.functionSignature.callSignature.typeAnnotation.accept(this)
                : null;

            this.pushDeclLists();

            var bod = this.convertBlock(node.block);
            if (bod) {
                bod.append(new EndCode());
            }

            this.movePast(node.semicolonToken);

            var funcDecl = new FuncDecl(name, bod, false, typeParameters, parameters, this.topVarList(),
                this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(funcDecl, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);

            funcDecl.variableArgList = this.hasDotDotDotParameter(node.functionSignature.callSignature.parameterList.parameters);
            funcDecl.returnTypeAnnotation = returnType;
            funcDecl.variableArgList = this.hasDotDotDotParameter(node.functionSignature.callSignature.parameterList.parameters);

            if (node.exportKeyword) {
                funcDecl.fncFlags |= FncFlags.Exported;
            }

            if (node.declareKeyword) {
                funcDecl.fncFlags |= FncFlags.Ambient;
            }

            if (node.semicolonToken) {
                funcDecl.fncFlags |= FncFlags.Signature;
            }

            return funcDecl;
        }

        private visitEnumDeclaration(enumDeclaration: EnumDeclarationSyntax): ModuleDeclaration {
            this.assertElementAtPosition(enumDeclaration);

            this.moveTo2(enumDeclaration, enumDeclaration.identifier);
            var name = this.identifierFromToken(enumDeclaration.identifier, /*isOptional:*/ false);
            this.movePast(enumDeclaration.identifier);

            this.pushDeclLists();

            this.movePast(enumDeclaration.openBraceToken);
            var members = new ASTList();

            var mapDecl = new VarDecl(new Identifier("_map"), 0);
            mapDecl.varFlags |= VarFlags.Exported;
            mapDecl.varFlags |= VarFlags.Private;

            // REVIEW: Is this still necessary?
            mapDecl.varFlags |= (VarFlags.Property | VarFlags.Public);
            mapDecl.init = new UnaryExpression(NodeType.ArrayLit, null);
            members.append(mapDecl);
            var lastValue: NumberLiteral = null;
            var memberNames: Identifier[] = [];
            var start = this.position;

            for (var i = 0, n = enumDeclaration.variableDeclarators.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(<ISyntaxToken>enumDeclaration.variableDeclarators.childAt(i));
                }
                else {
                    var variableDeclarator = <VariableDeclaratorSyntax>enumDeclaration.variableDeclarators.childAt(i);

                    var memberName: Identifier = this.identifierFromToken(variableDeclarator.identifier, /*isOptional:*/ false);
                    this.movePast(variableDeclarator.identifier);
                    var memberValue: AST = null;
                    var memberStart = this.position;

                    if (variableDeclarator.equalsValueClause !== null) {
                        memberValue = variableDeclarator.equalsValueClause.accept(this);
                        lastValue = <NumberLiteral>memberValue;
                    }
                    else {
                        if (lastValue == null) {
                            memberValue = new NumberLiteral(0, "0");
                            lastValue = <NumberLiteral>memberValue;
                        }
                        else {
                            var nextValue = lastValue.value + 1;
                            memberValue = new NumberLiteral(nextValue, nextValue.toString());
                            lastValue = <NumberLiteral>memberValue;
                        }
                        var map: BinaryExpression =
                            new BinaryExpression(NodeType.Asg,
                                                 new BinaryExpression(NodeType.Index,
                                                                      new Identifier("_map"),
                                                                      memberValue),
                                                 new StringLiteral('"' + memberName.actualText + '"'));
                        members.append(map);
                    }
                    var member = new VarDecl(memberName, this.nestingLevel);
                    member.init = memberValue;
                    // Note: Leave minChar, limChar as "-1" on typeExpr as this is a parsing artifact.
                    member.typeExpr = new TypeReference(this.createRef(name.actualText, name.hasEscapeSequence, -1), 0);
                    member.varFlags |= (VarFlags.Readonly | VarFlags.Property);
                    this.setSpan(member, memberStart, this.position);

                    if (memberValue.nodeType == NodeType.NumberLit) {
                        member.varFlags |= VarFlags.Constant;
                    }
                    else if (memberValue.nodeType === NodeType.Lsh) {
                        // If the initializer is of the form "value << value" then treat it as a constant
                        // as well.
                        var binop = <BinaryExpression>memberValue;
                        if (binop.operand1.nodeType === NodeType.NumberLit && binop.operand2.nodeType === NodeType.NumberLit) {
                            member.varFlags |= VarFlags.Constant;
                        }
                    }
                    else if (memberValue.nodeType === NodeType.Name) {
                        // If the initializer refers to an earlier enum value, then treat it as a constant
                        // as well.
                        var nameNode = <Identifier>memberValue;
                        for (var j = 0; j < memberNames.length; j++) {
                            var memberName = memberNames[j];
                            if (memberName.text === nameNode.text) {
                                member.varFlags |= VarFlags.Constant;
                                break;
                            }
                        }
                    }

                    members.append(member);
                    // all enum members are exported
                    member.varFlags |= VarFlags.Exported;
                }
            }

            this.movePast(enumDeclaration.closeBraceToken);

            var endingToken = new ASTSpan();
            var modDecl = new ModuleDeclaration(name, members, this.topVarList(), endingToken);
            modDecl.modFlags |= ModuleFlags.IsEnum;

            if (enumDeclaration.exportKeyword) {
                modDecl.modFlags |= ModuleFlags.Exported;
            }

            this.setSpan(modDecl, start, this.position);
            
            this.popDeclLists();

            return modDecl;
        }

        private visitImportDeclaration(node: ImportDeclarationSyntax): ImportDeclaration {
            this.assertElementAtPosition(node);

            this.moveTo2(node, node.identifier);

            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            this.movePast(node.equalsToken);
            var alias = node.moduleReference.accept(this);
            this.movePast(node.semicolonToken);

            var importDecl = new ImportDeclaration(name, alias);
            importDecl.isDynamicImport = node.moduleReference.kind() === SyntaxKind.ExternalModuleReference;

            return importDecl;
        }

        private visitVariableStatement(node: VariableStatementSyntax): AST {
            this.assertElementAtPosition(node);
            var start = this.position;

            this.moveTo2(node, node.variableDeclaration);
            var varList = node.variableDeclaration.accept(this);
            this.movePast(node.semicolonToken);

            if (varList.nodeType === NodeType.VarDecl) {
                varDecl = <VarDecl>varList;
                varList = new ASTList();
                varList.append(varDecl);
            }

            for (var i = 0, n = varList.members.length; i < n; i++) {
                var varDecl = <VarDecl>varList.members[i];

                if (node.exportKeyword) {
                    varDecl.varFlags |= VarFlags.Exported;
                }

                if (node.declareKeyword) {
                    varDecl.varFlags |= VarFlags.Ambient;
                }
            }

            if (node.variableDeclaration.variableDeclarators.nonSeparatorCount() === 1) {
                return varList.members[0];
            }
            else {
                var result = new Block(varList, /*isStatementBlock:*/ false);
                this.setSpan(result, start, this.position);

                return result;
            }
        }

        private visitVariableDeclaration(node: VariableDeclarationSyntax): AST {
            this.assertElementAtPosition(node);

            this.moveTo2(node, node.variableDeclarators);
            var variableDecls = this.visitSeparatedSyntaxList(node.variableDeclarators);

            for (var i = 0; i < variableDecls.members.length; i++) {
                (<BoundDecl>variableDecls.members[i]).nestingLevel = i;
            }

            if (variableDecls.members.length === 1) {
                return variableDecls.members[0];
            }

            return variableDecls;
        }

        private visitVariableDeclarator(node: VariableDeclaratorSyntax): VarDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;

            var result = new VarDecl(name, 0);
            this.setSpan(result, start, this.position);

            this.topVarList().append(result);

            result.typeExpr = typeExpr;
            result.init = init;
            if (init && init.nodeType == NodeType.FuncDecl) {
                var funcDecl = <FuncDecl>init;
                funcDecl.hint = name.actualText;
            }

            // TODO: more flags

            return result;
        }

        private visitEqualsValueClause(node: EqualsValueClauseSyntax): AST {
            this.assertElementAtPosition(node);

            this.movePast(node.equalsToken);
            return node.value.accept(this);
        }

        private getUnaryExpressionNodeType(kind: SyntaxKind): NodeType {
            switch (kind) {
                case SyntaxKind.PlusExpression: return NodeType.Pos;
                case SyntaxKind.NegateExpression: return NodeType.Neg;
                case SyntaxKind.BitwiseNotExpression: return NodeType.Not;
                case SyntaxKind.LogicalNotExpression: return NodeType.LogNot;
                case SyntaxKind.PreIncrementExpression: return NodeType.IncPre;
                case SyntaxKind.PreDecrementExpression: return NodeType.DecPre;
                default:
                    throw Errors.invalidOperation();
            }
        }

        private visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.operatorToken);
            var operand = node.operand.accept(this);

            var result = new UnaryExpression(this.getUnaryExpressionNodeType(node.kind()), operand);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.openBracketToken);
            var expressions = this.visitSeparatedSyntaxList(node.expressions);
            this.movePast(node.closeBracketToken);

            if (node.expressions.childCount() > 0 && node.expressions.childAt(node.expressions.childCount() - 1).kind() === SyntaxKind.CommaToken) {
                expressions.append(new AST(NodeType.EmptyExpr));
            }

            var result = new UnaryExpression(NodeType.ArrayLit, expressions);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitOmittedExpression(node: OmittedExpressionSyntax): any {
            this.assertElementAtPosition(node);

            var start = this.position;

            var result = new AST(NodeType.EmptyExpr);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): AST {
            this.assertElementAtPosition(node);

            this.movePast(node.openParenToken);
            var result = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            
            result.isParenthesized = true;

            return result;
        }

        private getArrowFunctionStatements(body: ISyntaxNodeOrToken): ASTList {
            var statements: ASTList = null;

            if (body.kind() === SyntaxKind.Block) {
                var block = <BlockSyntax>body;

                statements = this.convertBlock(block);
            }
            else {
                statements = new ASTList();

                var expr = body.accept(this);
                var retStmt = new ReturnStatement();
                retStmt.returnExpression = expr;

                statements.append(retStmt);
            }

            statements.append(new EndCode());

            return statements;
        }

        private visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            var identifier = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            this.movePast(node.equalsGreaterThanToken);

            var parameters = new ASTList();
            parameters.append(new ArgDecl(identifier));

            this.pushDeclLists();

            var statements = this.getArrowFunctionStatements(node.body);

            var result = new FuncDecl(null, statements, /*isConstructor:*/ false, null, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(result);

            result.returnTypeAnnotation = null;
            result.fncFlags |= FncFlags.IsFunctionExpression;
            result.fncFlags |= FncFlags.IsFatArrowFunction;

            return result;
        }

        private visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
            this.movePast(node.equalsGreaterThanToken);

            this.pushDeclLists();

            var statements = this.getArrowFunctionStatements(node.body);

            var result = new FuncDecl(null, statements, /*isConstructor:*/ false, typeParameters, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(result);

            result.returnTypeAnnotation = returnType;
            result.fncFlags |= FncFlags.IsFunctionExpression;
            result.fncFlags |= FncFlags.IsFatArrowFunction;
            result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);

            return result;
        }

        private visitType(type: ITypeSyntax): AST {
            this.assertElementAtPosition(type);

            if (type.isToken()) {
                var typeToken = <ISyntaxToken>type;

                var start = this.position;
                var identifier = this.identifierFromToken(typeToken, /*isOptional:*/ false);
                this.movePast(typeToken);

                var result = new TypeReference(identifier, 0);
                this.setSpan(result, start, this.position);

                return result;
            }
            else {
                return type.accept(this);
            }
        }

        private visitQualifiedName(node: QualifiedNameSyntax): TypeReference {
            this.assertElementAtPosition(node);

            var start = this.position;
            var left = this.visitType(node.left);
            this.movePast(node.dotToken);
            var right = this.identifierFromToken(node.right, /*isOptional:*/ false);
            this.movePast(node.right);

            if (left.nodeType === NodeType.TypeRef) {
                left = (<TypeReference>left).term;
            }

            var result = new BinaryExpression(NodeType.Dot, left, right);
            this.setSpan(result, start, this.position);

            return new TypeReference(result, 0);
        }

        private visitTypeArgumentList(node: TypeArgumentListSyntax): ASTList {
            this.assertElementAtPosition(node);

            var result = new ASTList();

            this.movePast(node.lessThanToken);
            for (var i = 0, n = node.typeArguments.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(<ISyntaxToken>node.typeArguments.childAt(i));
                }
                else {
                    result.append(this.visitType(node.typeArguments.childAt(i)));
                }
            }
            this.movePast(node.greaterThanToken);

            return result;
        }

        private visitConstructorType(node: ConstructorTypeSyntax): any {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.newKeyword);
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = node.type ? this.visitType(node.type) : null;

            var result = new FuncDecl(null, null, false, typeParameters, parameters, null, null, null, NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            result.returnTypeAnnotation = returnType;
            // funcDecl.variableArgList = variableArgList;
            result.fncFlags |= FncFlags.Signature;
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);

            result.fncFlags |= FncFlags.ConstructMember;
            result.flags |= ASTFlags.TypeReference;
            result.hint = "_construct";
            result.classDecl = null;

            var typeRef = new TypeReference(result, 0);
            this.setSpan(typeRef, start, this.position);

            return typeRef;
        }

        private visitFunctionType(node: FunctionTypeSyntax): TypeReference {
            this.assertElementAtPosition(node);

            var start = this.position;
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = node.type ? this.visitType(node.type) : null;

            var result = new FuncDecl(null, null, false, typeParameters, parameters, null, null, null, NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            result.returnTypeAnnotation = returnType;
            // funcDecl.variableArgList = variableArgList;
            result.fncFlags |= FncFlags.Signature;
            result.flags |= ASTFlags.TypeReference;
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);

            var typeRef = new TypeReference(result, 0);
            this.setSpan(typeRef, start, this.position);

            return typeRef;
        }

        private visitObjectType(node: ObjectTypeSyntax): TypeReference {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.openBraceToken);
            var typeMembers = this.visitSeparatedSyntaxList(node.typeMembers);
            this.movePast(node.closeBraceToken);

            var result = new InterfaceDeclaration(
                new Identifier("_anonymous"),
                null,
                typeMembers,
                null, null);

            result.flags |= ASTFlags.TypeReference;

            this.setSpan(result, start, this.position);
            
            var typeRef = new TypeReference(result, 0);
            this.setSpan(typeRef, start, this.position);

            return typeRef;
        }

        private visitArrayType(node: ArrayTypeSyntax): TypeReference {
            this.assertElementAtPosition(node);

            var start = this.position;
            var underlying = this.visitType(node.type);
            this.movePast(node.openBracketToken);
            this.movePast(node.closeBracketToken);

            var result: TypeReference = null;
            if (underlying.nodeType === NodeType.TypeRef) {
                result = <TypeReference>underlying;
                result.arrayCount++;
            }
            else {
                result = new TypeReference(underlying, 1);
            }
            
            result.flags |= ASTFlags.TypeReference;

            this.setSpan(result, start, this.position);

            return result;
        }

        private visitGenericType(node: GenericTypeSyntax): TypeReference {
            this.assertElementAtPosition(node);

            var underlying = this.visitType(node.name);
            var typeArguments = node.typeArgumentList.accept(this);

            if (underlying.nodeType === NodeType.TypeRef) {
                underlying = (<TypeReference>underlying).term;
            }

            var genericType = new GenericType(underlying, typeArguments);

            genericType.flags |= ASTFlags.TypeReference;

            return new TypeReference(genericType, 0);
        }

        private visitTypeAnnotation(node: TypeAnnotationSyntax): AST {
            this.assertElementAtPosition(node);

            this.movePast(node.colonToken);
            return this.visitType(node.type);
        }

        private visitBlock(node: BlockSyntax): Block {
            this.assertElementAtPosition(node);
            
            var start = this.position;
            var statements = this.convertBlock(node);

            var result = new Block(statements, /*isStatementBlock:*/ true);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitParameter(node: ParameterSyntax): ArgDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.identifier);
            var identifier = this.identifierFromToken(node.identifier, !!node.questionToken);
            this.movePast(node.identifier);
            this.movePast(node.questionToken);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;

            var result = new ArgDecl(identifier);
            this.setSpan(result, start, this.position);

            result.isOptional = !!node.questionToken;
            result.init = init;
            result.typeExpr = typeExpr;

            if (node.publicOrPrivateKeyword) {
                result.varFlags |= VarFlags.Property;

                if (node.publicOrPrivateKeyword.kind() === SyntaxKind.PublicKeyword) {
                    result.varFlags |= VarFlags.Public;
                }
                else {
                    result.varFlags |= VarFlags.Private;
                }
            }

            return result;
        }

        private visitMemberAccessExpression(node: MemberAccessExpressionSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var expression: AST = node.expression.accept(this);
            this.movePast(node.dotToken);
            var name = this.identifierFromToken(node.name, /*isOptional:*/ false);
            this.movePast(node.name);

            var result = new BinaryExpression(NodeType.Dot, expression, name);
            this.setSpan(result, start, this.position);

            expression.flags |= ASTFlags.DotLHS;

            return result;
        }

        private visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var operand = node.operand.accept(this);
            this.movePast(node.operatorToken);

            var result = new UnaryExpression(node.kind() === SyntaxKind.PostIncrementExpression ? NodeType.IncPost : NodeType.DecPost,
                operand);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitElementAccessExpression(node: ElementAccessExpressionSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var expression = node.expression.accept(this);
            this.movePast(node.openBracketToken);
            var argumentExpression = node.argumentExpression.accept(this);
            this.movePast(node.closeBracketToken);

            var result = new BinaryExpression(NodeType.Index, expression, argumentExpression);
            this.setSpan(result, start, this.position);

            return result;
        }

        private convertArgumentListArguments(node: ArgumentListSyntax): ASTList {
            if (node === null) {
                return null;
            }

            this.movePast(node.openParenToken);
            var result = this.visitSeparatedSyntaxList(node.arguments);
            this.movePast(node.closeParenToken);
            return result;
        }

        private visitInvocationExpression(node: InvocationExpressionSyntax): CallExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var expression = node.expression.accept(this);
            var typeArguments = node.argumentList.typeArgumentList !== null
                ? node.argumentList.typeArgumentList.accept(this)
                : null;
            var argumentList = this.convertArgumentListArguments(node.argumentList);

            var result = new CallExpression(NodeType.Call, expression, typeArguments, argumentList);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitArgumentList(node: ArgumentListSyntax): ASTList {
            // Processing argument lists should be handled from inside visitInvocationExpression or 
            // visitObjectCreationExpression.
            throw Errors.invalidOperation();
        }

        private getBinaryExpressionNodeType(node: BinaryExpressionSyntax): NodeType {
            switch (node.kind()) {
                case SyntaxKind.CommaExpression: return NodeType.Comma;
                case SyntaxKind.AssignmentExpression: return NodeType.Asg;
                case SyntaxKind.AddAssignmentExpression: return NodeType.AsgAdd;
                case SyntaxKind.SubtractAssignmentExpression: return NodeType.AsgSub;
                case SyntaxKind.MultiplyAssignmentExpression: return NodeType.AsgMul;
                case SyntaxKind.DivideAssignmentExpression: return NodeType.AsgDiv;
                case SyntaxKind.ModuloAssignmentExpression: return NodeType.AsgMod;
                case SyntaxKind.AndAssignmentExpression: return NodeType.AsgAnd;
                case SyntaxKind.ExclusiveOrAssignmentExpression: return NodeType.AsgXor;
                case SyntaxKind.OrAssignmentExpression: return NodeType.AsgOr;
                case SyntaxKind.LeftShiftAssignmentExpression: return NodeType.AsgLsh;
                case SyntaxKind.SignedRightShiftAssignmentExpression: return NodeType.AsgRsh;
                case SyntaxKind.UnsignedRightShiftAssignmentExpression: return NodeType.AsgRs2;
                case SyntaxKind.LogicalOrExpression: return NodeType.LogOr;
                case SyntaxKind.LogicalAndExpression: return NodeType.LogAnd;
                case SyntaxKind.BitwiseOrExpression: return NodeType.Or;
                case SyntaxKind.BitwiseExclusiveOrExpression: return NodeType.Xor;
                case SyntaxKind.BitwiseAndExpression: return NodeType.And;
                case SyntaxKind.EqualsWithTypeConversionExpression: return NodeType.Eq;
                case SyntaxKind.NotEqualsWithTypeConversionExpression: return NodeType.Ne;
                case SyntaxKind.EqualsExpression: return NodeType.Eqv;
                case SyntaxKind.NotEqualsExpression: return NodeType.NEqv;
                case SyntaxKind.LessThanExpression: return NodeType.Lt;
                case SyntaxKind.GreaterThanExpression: return NodeType.Gt;
                case SyntaxKind.LessThanOrEqualExpression: return NodeType.Le;
                case SyntaxKind.GreaterThanOrEqualExpression: return NodeType.Ge;
                case SyntaxKind.InstanceOfExpression: return NodeType.InstOf;
                case SyntaxKind.InExpression: return NodeType.In;
                case SyntaxKind.LeftShiftExpression: return NodeType.Lsh;
                case SyntaxKind.SignedRightShiftExpression: return NodeType.Rsh;
                case SyntaxKind.UnsignedRightShiftExpression: return NodeType.Rs2;
                case SyntaxKind.MultiplyExpression: return NodeType.Mul;
                case SyntaxKind.DivideExpression: return NodeType.Div;
                case SyntaxKind.ModuloExpression: return NodeType.Mod;
                case SyntaxKind.AddExpression: return NodeType.Add;
                case SyntaxKind.SubtractExpression: return NodeType.Sub;
            }

            throw Errors.invalidOperation();
        }

        private visitBinaryExpression(node: BinaryExpressionSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var nodeType = this.getBinaryExpressionNodeType(node);
            var left = node.left.accept(this);
            this.movePast(node.operatorToken);
            var right = node.right.accept(this);

            var result = new BinaryExpression(nodeType, left, right);
            this.setSpan(result, start, this.position);

            if (right.nodeType === NodeType.FuncDecl) {
                var id = left.nodeType === NodeType.Dot ? (<BinaryExpression>left).operand2 : left;
                var idHint: string = id.nodeType === NodeType.Name ? id.actualText : null;

                var funcDecl = <FuncDecl>right;
                funcDecl.hint = idHint;
            }

            return result;
        }

        private visitConditionalExpression(node: ConditionalExpressionSyntax): ConditionalExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var condition = node.condition.accept(this);
            this.movePast(node.questionToken);
            var whenTrue = node.whenTrue.accept(this);
            this.movePast(node.colonToken);
            var whenFalse = node.whenFalse.accept(this)

            var result = new ConditionalExpression(condition, whenTrue, whenFalse);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitConstructSignature(node: ConstructSignatureSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.newKeyword);
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var result = new FuncDecl(null, new ASTList(), /*isConstructor:*/ false, typeParameters, parameters, new ASTList(), new ASTList(), new ASTList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            result.returnTypeAnnotation = returnType;

            result.hint = "_construct";
            result.fncFlags |= FncFlags.ConstructMember;
            result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);

            var scopeList = this.topScopeList();
            scopeList.append(result);

            return result;
        }

        private visitFunctionSignature(node: FunctionSignatureSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            var name = this.identifierFromToken(node.identifier, !!node.questionToken);
            this.movePast(node.identifier);
            this.movePast(node.questionToken);

            var typeParameters = node.callSignature.typeParameterList ? node.callSignature.typeParameterList.accept(this) : null;
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var funcDecl = new FuncDecl(name, new ASTList(), false, typeParameters, parameters, new ASTList(), new ASTList(), new ASTList(), NodeType.FuncDecl);
            this.setSpan(funcDecl, start, this.position);

            funcDecl.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            funcDecl.returnTypeAnnotation = returnType;

            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);

            return funcDecl;
        }

        private visitIndexSignature(node: IndexSignatureSyntax): FuncDecl {
            this.assertElementAtPosition(node);
            /*
            public openBracketToken: ISyntaxToken,
                public parameter: ParameterSyntax,
                public closeBracketToken: ISyntaxToken,
                public typeAnnotation*/

            var start = this.position;
            this.movePast(node.openBracketToken);
            var parameter = node.parameter.accept(this);
            this.movePast(node.closeBracketToken);
            var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var name = new Identifier("__item");
            this.setSpan(name, start, start);   // 0 length name.

            var parameters = new ASTList();
            parameters.append(parameter);

            var result = new FuncDecl(name, new ASTList(), /*isConstructor:*/ false, null, parameters, new ASTList(), new ASTList(), new ASTList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            result.variableArgList = !!node.parameter.dotDotDotToken;
            result.returnTypeAnnotation = returnType;

            result.fncFlags |= FncFlags.IndexerMember;

            var scopeList = this.topScopeList();
            scopeList.append(result);

            return result;
        }

        private visitPropertySignature(node: PropertySignatureSyntax): VarDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            var name = this.identifierFromToken(node.identifier, !!node.questionToken);
            this.movePast(node.identifier);
            this.movePast(node.questionToken);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var result = new VarDecl(name, 0);
            this.setSpan(result, start, this.position);

            result.typeExpr = typeExpr;
            result.varFlags |= VarFlags.Property;

            return result;
        }

        private visitParameterList(node: ParameterListSyntax): ASTList {
            this.assertElementAtPosition(node);

            this.movePast(node.openParenToken);
            var result = this.visitSeparatedSyntaxList(node.parameters);
            this.movePast(node.closeParenToken);

            return result;
        }

        private visitCallSignature(node: CallSignatureSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var result = new FuncDecl(null, new ASTList(), /*isConstructor:*/ false, typeParameters, parameters, new ASTList(), new ASTList(), new ASTList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
            result.returnTypeAnnotation = returnType;

            result.hint = "_call";
            result.fncFlags |= FncFlags.CallMember;

            var scopeList = this.topScopeList();
            scopeList.append(result);

            return result;
        }

        private visitTypeParameterList(node: TypeParameterListSyntax): ASTList {
            this.assertElementAtPosition(node);

            this.movePast(node.lessThanToken);
            var result = this.visitSeparatedSyntaxList(node.typeParameters);
            this.movePast(node.greaterThanToken);

            return result;
        }

        private visitTypeParameter(node: TypeParameterSyntax): TypeParameter {
            this.assertElementAtPosition(node);

            var start = this.position;
            var identifier = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var constraint = node.constraint ? node.constraint.accept(this) : null;

            var result = new TypeParameter(identifier, constraint);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitConstraint(node: ConstraintSyntax): any {
            this.assertElementAtPosition(node);

            this.movePast(node.extendsKeyword);
            return this.visitType(node.type);
        }

        private visitIfStatement(node: IfStatementSyntax): IfStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var thenBod = node.statement.accept(this);
            var elseBod = node.elseClause ? node.elseClause.accept(this) : null;

            var result = new IfStatement(condition);
            this.setSpan(result, start, this.position);

            result.thenBod = thenBod;
            result.elseBod = elseBod;

            return result;
        }

        private visitElseClause(node: ElseClauseSyntax): Statement {
            this.assertElementAtPosition(node);

            this.movePast(node.elseKeyword);
            return node.statement.accept(this);
        }

        private visitExpressionStatement(node: ExpressionStatementSyntax): AST {
            this.assertElementAtPosition(node);

            var start = this.position;
            var expression = node.expression.accept(this);
            this.movePast(node.semicolonToken);

            var result = expression;
            this.setSpan(result, start, this.position);

            result.flags |= ASTFlags.IsStatement;

            return result;
        }

        private visitConstructorDeclaration(node: ConstructorDeclarationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.parameterList);
            var parameters = node.parameterList.accept(this);

            this.pushDeclLists();

            var statements = this.convertBlock(node.block);
            if (statements) {
                statements.append(new EndCode());
            }
            this.movePast(node.semicolonToken);

            var result = new FuncDecl(null, statements, /*isConstructor:*/ true, null, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(result);

            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
            // constructorFuncDecl.preComments = preComments;
            //if (requiresSignature && !isAmbient) {
            //    constructorFuncDecl.isOverload = true;
            //}

            // constructorFuncDecl.variableArgList = variableArgList;
            // this.currentClassDecl = null;

            //if (isAmbient) {
            //    constructorFuncDecl.fncFlags |= FncFlags.Ambient;
            //}

            if (node.semicolonToken) {
                result.fncFlags |= FncFlags.Signature;
            }

            //if (this.currentClassDefinition.constructorDecl) {
            //    if (!isAmbient && !this.currentClassDefinition.constructorDecl.isSignature() && !constructorFuncDecl.isSignature()) {
            //        this.reportParseError("Duplicate constructor definition");
            //    }
            //}

            //if (isAmbient || !constructorFuncDecl.isSignature()) {
            //    this.currentClassDefinition.constructorDecl = constructorFuncDecl;
            //}

            //// REVIEW: Should we have a separate flag for class constructors?  (Constructors are not methods)
            //constructorFuncDecl.fncFlags |= FncFlags.ClassMethod;

            //this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = constructorFuncDecl;

            //this.parsingClasvisisConstructorDefinition = false;

            return result;
        }

        private visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo3(node, node.functionSignature, node.functionSignature.identifier);
            var name = this.identifierFromToken(node.functionSignature.identifier, !!node.functionSignature.questionToken);

            this.movePast(node.functionSignature.identifier);
            this.movePast(node.functionSignature.questionToken);

            var typeParameters = node.functionSignature.callSignature.typeParameterList === null ? null : node.functionSignature.callSignature.typeParameterList.accept(this);
            var parameters = node.functionSignature.callSignature.parameterList.accept(this);
            var returnType = node.functionSignature.callSignature.typeAnnotation
                ? node.functionSignature.callSignature.typeAnnotation.accept(this)
                : null;

            this.pushDeclLists();

            var statements = this.convertBlock(node.block);
            if (statements) {
                statements.append(new EndCode());
            }
            this.movePast(node.semicolonToken);

            var result = new FuncDecl(name, statements, /*isConstructor:*/ false, typeParameters, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(result);

            result.variableArgList = this.hasDotDotDotParameter(node.functionSignature.callSignature.parameterList.parameters);
            result.returnTypeAnnotation = returnType;

            if (node.semicolonToken) {
                result.fncFlags |= FncFlags.Signature;
            }

            if (node.publicOrPrivateKeyword) {
                if (node.publicOrPrivateKeyword.kind() === SyntaxKind.PrivateKeyword) {
                    result.fncFlags |= FncFlags.Private;
                }
                else {
                    result.fncFlags |= FncFlags.Public;
                }
            }

            if (node.staticKeyword) {
                result.fncFlags |= FncFlags.Static;
            }

            result.fncFlags |= FncFlags.Method;

            return result;
        }

        private visitMemberAccessorDeclaration(node: MemberAccessorDeclarationSyntax, typeAnnotation: TypeAnnotationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var parameters = node.parameterList.accept(this);
            var returnType = typeAnnotation ? typeAnnotation.accept(this) : null;

            this.pushDeclLists();

            var statements = this.convertBlock(node.block);
            if (statements) {
                statements.append(new EndCode());
            }
            var result = new FuncDecl(name, statements, /*isConstructor:*/ false, null, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(result);

            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
            result.returnTypeAnnotation = returnType;

            if (node.publicOrPrivateKeyword) {
                if (node.publicOrPrivateKeyword.kind() === SyntaxKind.PrivateKeyword) {
                    result.fncFlags |= FncFlags.Private;
                }
                else {
                    result.fncFlags |= FncFlags.Public;
                }
            }

            if (node.staticKeyword) {
                result.fncFlags |= FncFlags.Static;
            }

            return result;
        }

        private visitGetMemberAccessorDeclaration(node: GetMemberAccessorDeclarationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var result = this.visitMemberAccessorDeclaration(node, node.typeAnnotation);

            result.fncFlags |= FncFlags.GetAccessor;
            result.hint = "get" + result.name.actualText;

            return result;
        }

        private visitSetMemberAccessorDeclaration(node: SetMemberAccessorDeclarationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var result = this.visitMemberAccessorDeclaration(node, null);

            result.fncFlags |= FncFlags.SetAccessor;
            result.hint = "set" + result.name.actualText;

            return result;
        }

        private visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): VarDecl {
            this.assertElementAtPosition(node);

            this.moveTo3(node, node.variableDeclarator, node.variableDeclarator.identifier);
            var name = this.identifierFromToken(node.variableDeclarator.identifier, /*isOptional:*/ false);
            this.movePast(node.variableDeclarator.identifier);
            var typeExpr = node.variableDeclarator.typeAnnotation ? node.variableDeclarator.typeAnnotation.accept(this) : null;
            var init = node.variableDeclarator.equalsValueClause ? node.variableDeclarator.equalsValueClause.accept(this) : null;
            this.movePast(node.semicolonToken);

            var varDecl = new VarDecl(name, 0);
            this.setSpan(varDecl, name.minChar, name.limChar);

            varDecl.typeExpr = typeExpr;
            varDecl.init = init;

            if (node.staticKeyword) {
                varDecl.varFlags |= VarFlags.Static;
            }

            if (node.publicOrPrivateKeyword) {
                if (node.publicOrPrivateKeyword.kind() === SyntaxKind.PrivateKeyword) {
                    varDecl.varFlags |= VarFlags.Private;
                }
                else {
                    varDecl.varFlags |= VarFlags.Public;
                }
            }

            varDecl.varFlags |= VarFlags.Property;

            // this.currentClassDefinition.knownMemberNames[text.actualText] = true;

            //if (!isDeclaredInConstructor) {
            //    this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = varDecl;
            //}

            // varDecl.postComments = this.parseComments();
            return varDecl;
        }

        private visitThrowStatement(node: ThrowStatementSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.throwKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.semicolonToken);

            var result = new UnaryExpression(NodeType.Throw, expression);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitReturnStatement(node: ReturnStatementSyntax): ReturnStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.returnKeyword);
            var expression = node.expression ? node.expression.accept(this) : null;
            this.movePast(node.semicolonToken);

            var result = new ReturnStatement();
            this.setSpan(result, start, this.position);

            result.returnExpression = expression;

            return result;
        }

        private visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): CallExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.newKeyword);
            var expression = node.expression.accept(this);
            var typeArgumentList = node.argumentList === null || node.argumentList.typeArgumentList === null ? null : node.argumentList.typeArgumentList.accept(this);
            var argumentList = this.convertArgumentListArguments(node.argumentList);

            var result = new CallExpression(NodeType.New, expression, typeArgumentList, argumentList);
            this.setSpan(result, start, this.position);

            if (expression.nodeType === NodeType.TypeRef) {
                var typeRef = <TypeReference>expression;

                if (typeRef.arrayCount === 0) {
                    var term = typeRef.term;
                    if (term.nodeType === NodeType.Dot || term.nodeType === NodeType.Name) {
                        expression = term;
                    }
                }
            }

            return result;
        }

        private visitSwitchStatement(node: SwitchStatementSyntax): SwitchStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.switchKeyword);
            this.movePast(node.openParenToken);
            var expression = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var closeParenPosition = this.position;
            this.movePast(node.openBraceToken);

            var result = new SwitchStatement(expression);
            this.setSpan(result, start, this.position);

            result.statement.minChar = start;
            result.statement.limChar = closeParenPosition;

            result.caseList = new ASTList()

            for (var i = 0, n = node.switchClauses.childCount(); i < n; i++) {
                var switchClause = node.switchClauses.childAt(i);
                var translated = switchClause.accept(this);

                if (switchClause.kind() === SyntaxKind.DefaultSwitchClause) {
                    result.defaultCase = translated;
                }

                result.caseList.append(translated);
            }

            this.movePast(node.closeBraceToken);

            return result;
        }

        private visitCaseSwitchClause(node: CaseSwitchClauseSyntax): CaseStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.caseKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);

            var result = new CaseStatement();
            this.setSpan(result, start, this.position);

            result.expr = expression;
            result.body = statements;

            return result;
        }

        private visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): CaseStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.defaultKeyword);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);

            var result = new CaseStatement();
            this.setSpan(result, start, this.position);

            result.body = statements;

            return result;
        }

        private visitBreakStatement(node: BreakStatementSyntax): Jump {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.breakKeyword);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);

            var result = new Jump(NodeType.Break);
            this.setSpan(result, start, this.position);

            if (node.identifier !== null) {
                result.target = this.valueText(node.identifier);
            }

            return result;
        }

        private visitContinueStatement(node: ContinueStatementSyntax): Jump {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.continueKeyword);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);

            var result = new Jump(NodeType.Continue);
            this.setSpan(result, start, this.position);

            if (node.identifier !== null) {
                result.target = this.valueText(node.identifier);
            }

            return result;
        }

        private visitForStatement(node: ForStatementSyntax): ForStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var init = node.variableDeclaration
                ? node.variableDeclaration.accept(this)
                : node.initializer
                    ? node.initializer.accept(this)
                    : null;
            this.movePast(node.firstSemicolonToken);
            var cond = node.condition ? node.condition.accept(this) : null;
            this.movePast(node.secondSemicolonToken);
            var incr = node.incrementor ? node.incrementor.accept(this) : null;
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);

            var result = new ForStatement(init);
            this.setSpan(result, start, this.position);

            result.cond = cond;
            result.incr = incr;
            result.body = body;

            return result;
        }

        private visitForInStatement(node: ForInStatementSyntax): ForInStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.left.accept(this);
            this.movePast(node.inKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);

            var result = new ForInStatement(init, expression);
            this.setSpan(result, start, this.position);

            result.body = body;

            return result;
        }

        private visitWhileStatement(node: WhileStatementSyntax): WhileStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);

            var result = new WhileStatement(condition);
            this.setSpan(result, start, this.position);

            result.body = statement;

            return result;
        }

        private visitWithStatement(node: WithStatementSyntax): WithStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);

            var result = new WithStatement(condition);
            this.setSpan(result, start, this.position);

            result.body = statement;

            return result;
        }

        private visitCastExpression(node: CastExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.lessThanToken);
            var castTerm = this.visitType(node.type);
            this.movePast(node.greaterThanToken);
            var expression = node.expression.accept(this);

            var result = new UnaryExpression(NodeType.TypeAssertion, expression);
            this.setSpan(result, start, this.position);

            result.castTerm = castTerm;

            return result;
        }

        private visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.openBraceToken);
            var propertyAssignments = this.visitSeparatedSyntaxList(node.propertyAssignments);
            this.movePast(node.closeBraceToken);

            var result = new UnaryExpression(NodeType.ObjectLit, propertyAssignments);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var left = node.propertyName.accept(this);
            this.movePast(node.colonToken);
            var right = node.expression.accept(this);

            var result = new BinaryExpression(NodeType.Member, left, right);
            this.setSpan(result, start, this.position);

            if (right.nodeType == NodeType.FuncDecl) {
                var funcDecl = <FuncDecl>right;
                funcDecl.hint = left.text;
            }

            return result;
        }

        private visitGetAccessorPropertyAssignment(node: GetAccessorPropertyAssignmentSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, /*isOptional:*/ false);
            this.movePast(node.propertyName);
            this.movePast(node.openParenToken);
            this.movePast(node.closeParenToken);

            this.pushDeclLists();

            var statements = this.convertBlock(node.block);
            statements.append(new EndCode());

            var funcDecl = new FuncDecl(name, statements, /*isConstructor:*/ false, null, new ASTList(), this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(funcDecl, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);

            funcDecl.fncFlags |= FncFlags.GetAccessor;
            funcDecl.fncFlags |= FncFlags.IsFunctionExpression;
            funcDecl.hint = "get" + node.propertyName.text();

            var result = new BinaryExpression(NodeType.Member, name, funcDecl);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitSetAccessorPropertyAssignment(node: SetAccessorPropertyAssignmentSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, /*isOptional:*/ false);
            this.movePast(node.propertyName);
            this.movePast(node.openParenToken);
            var parameterName = this.identifierFromToken(node.parameterName, /*isOptional:*/ false);
            this.movePast(node.parameterName);
            this.movePast(node.closeParenToken);

            var parameter = new ArgDecl(parameterName);
            this.setSpan(parameter, parameterName.minChar, parameter.limChar);

            var parameters = new ASTList();
            parameters.append(parameter);

            this.pushDeclLists();

            var statements = this.convertBlock(node.block);
            statements.append(new EndCode());

            var funcDecl = new FuncDecl(name, statements, /*isConstructor:*/ false, null, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(funcDecl, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);

            funcDecl.fncFlags |= FncFlags.SetAccessor;
            funcDecl.fncFlags |= FncFlags.IsFunctionExpression;
            funcDecl.hint = "set" + node.propertyName.text();

            var result = new BinaryExpression(NodeType.Member, name, funcDecl);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitFunctionExpression(node: FunctionExpressionSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.functionKeyword);
            var name = node.identifier === null ? null : this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation
                ? node.callSignature.typeAnnotation.accept(this)
                : null;

            this.pushDeclLists();

            var bod = this.convertBlock(node.block);
            if (bod) {
                bod.append(new EndCode());
            }

            var funcDecl = new FuncDecl(name, bod, false, typeParameters, parameters, this.topVarList(),
                this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(funcDecl, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);

            funcDecl.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            funcDecl.returnTypeAnnotation = returnType;
            funcDecl.fncFlags |= FncFlags.IsFunctionExpression;

            return funcDecl;
        }

        private visitEmptyStatement(node: EmptyStatementSyntax): AST {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.semicolonToken);

            var result = new AST(NodeType.Empty);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitTryStatement(node: TryStatementSyntax): AST {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.tryKeyword);
            var block = node.block.accept(this);

            var tryPart: AST = new Try(block);
            this.setSpan(tryPart, start, this.position);

            var tryCatch: TryCatch = null;
            if (node.catchClause !== null) {
                var catchBit = node.catchClause.accept(this);

                tryCatch = new TryCatch(<Try>tryPart, catchBit);
                this.setSpan(tryCatch, start, this.position);
            }

            if (node.finallyClause !== null) {
                if (tryCatch !== null) {
                    tryPart = tryCatch;
                }

                var finallyBit = node.finallyClause.accept(this);

                var result = new TryFinally(tryPart, finallyBit);
                this.setSpan(result, start, this.position);

                return result;
            }

            Debug.assert(tryCatch !== null);
            return tryCatch;
        }

        private visitCatchClause(node: CatchClauseSyntax): Catch {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.catchKeyword);
            this.movePast(node.openParenToken);
            var identifier = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            this.movePast(node.closeParenToken);
            var block = node.block.accept(this);

            var varDecl = new VarDecl(identifier, 0);
            this.setSpan(varDecl, identifier.minChar, identifier.limChar);

            var result = new Catch(varDecl, block);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitFinallyClause(node: FinallyClauseSyntax): Finally {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.finallyKeyword);
            var block = node.block.accept(this);

            var result = new Finally(block);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitLabeledStatement(node: LabeledStatementSyntax): LabeledStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            var identifier = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            this.movePast(node.colonToken);
            var statement = node.statement.accept(this);

            var labelList = new ASTList();
            labelList.append(new Label(identifier));

            var result = new LabeledStatement(labelList, statement);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitDoStatement(node: DoStatementSyntax): DoWhileStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.doKeyword);
            var statement = node.statement.accept(this);
            var whileAst = this.identifierFromToken(node.whileKeyword, /*isOptional:*/ false);
            this.movePast(node.whileKeyword);
            this.movePast(node.openParenToken);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            this.movePast(node.semicolonToken);

            var result = new DoWhileStatement();
            this.setSpan(result, start, this.position);

            result.whileAST = whileAst;
            result.cond = condition;
            result.body = statement;

            return result;
        }

        private visitTypeOfExpression(node: TypeOfExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.typeOfKeyword);
            var expression = node.expression.accept(this);

            var result = new UnaryExpression(NodeType.Typeof, expression);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitDeleteExpression(node: DeleteExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.deleteKeyword);
            var expression = node.expression.accept(this);

            var result = new UnaryExpression(NodeType.Delete, expression);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitVoidExpression(node: VoidExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.voidKeyword);
            var expression = node.expression.accept(this);

            var result = new UnaryExpression(NodeType.Void, expression);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitDebuggerStatement(node: DebuggerStatementSyntax): DebuggerStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.debuggerKeyword);
            this.movePast(node.semicolonToken);

            var result = new DebuggerStatement();
            this.setSpan(result, start, this.position);

            return result;
        }
    }
}
var global = <any>Function("return this").call(null);

module Clock {
    export var now: () => number;
    export var resolution: number;

    declare module WScript {
        export function InitializeProjection();
    }

    declare module TestUtilities {
        export function QueryPerformanceCounter(): number;
        export function QueryPerformanceFrequency(): number;
    }

    if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
        // Running in JSHost.
        global['WScript'].InitializeProjection();

        now = function () {
            return TestUtilities.QueryPerformanceCounter();
        }

        resolution = TestUtilities.QueryPerformanceFrequency();
    } else {
        now = function () {
            return Date.now();
        }

        resolution = 1000;
    }
}

class Timer {
    public startTime;
    public time = 0;

    public start() {
        this.time = 0;
        this.startTime = Clock.now();
    }

    public end() {
        // Set time to MS.
        this.time = (Clock.now() - this.startTime);
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
 
///<reference path='diagnostics.ts' />
///<reference path='flags.ts' />
///<reference path='nodeTypes.ts' />
///<reference path='hashTable.ts' />
///<reference path='ast.ts' />
///<reference path='astWalker.ts' />
///<reference path='astWalkerCallback.ts' />
///<reference path='astPath.ts' />
///<reference path='astLogger.ts' />
///<reference path='binder.ts' />
///<reference path='base64.ts' />
///<reference path='sourceMapping.ts' />
///<reference path='emitter.ts' />
///<reference path='errorReporter.ts' />
///<reference path='parser.ts' />
///<reference path='printContext.ts' />
///<reference path='scanner.ts' />
///<reference path='scopeAssignment.ts' />
///<reference path='scopeWalk.ts' />
///<reference path='signatures.ts' />
///<reference path='symbols.ts' />
///<reference path='symbolScope.ts' />
///<reference path='tokens.ts' />
///<reference path='typeChecker.ts' />
///<reference path='typeCollection.ts' />
///<reference path='typeFlow.ts' />
///<reference path='types.ts' />
///<reference path='pathUtils.ts' />
///<reference path='referenceResolution.ts' />
///<reference path='precompile.ts' />
///<reference path='incrementalParser.ts' />
///<reference path='declarationEmitter.ts' />
///<reference path='Syntax\ISyntaxNodeOrToken.ts' />
///<reference path='Syntax\Parser.ts' />
///<reference path='Text\TextFactory.ts' />
///<reference path='typecheck\dataMap.ts' />
///<reference path='typecheck\pullFlags.ts' />
///<reference path='typecheck\pullDecls.ts' />
///<reference path='typecheck\pullSymbols.ts' />
///<reference path='typecheck\pullSymbolBindingContext.ts' />
///<reference path='typecheck\pullTypeResolutionContext.ts' />
///<reference path='typecheck\pullTypeResolution.ts' />
///<reference path='typecheck\pullTypeChecker.ts' />
///<reference path='typecheck\pullDeclDiffer.ts' />
///<reference path='typecheck\pullSemanticInfo.ts' />
///<reference path='typecheck\pullDeclCollection.ts' />
///<reference path='typecheck\pullSymbolBinder.ts' />
///<reference path='typecheck\pullSymbolGraph.ts' />
///<reference path='typecheck\pullEmitter.ts' />
///<reference path='typecheck\pullErrors.ts' />
///<reference path='SyntaxTreeToAstVisitor.ts' />
///<reference path='resources.ts' />
///<reference path='resourceStrings.ts' />
///<reference path='Core\Timer.ts' />

module TypeScript {

    declare var IO;

    export enum UpdateUnitKind {
        Unknown,
        NoEdits,
        EditsInsideSingleScope,
    }

    export class ScriptEditRange {
        constructor (public minChar: number,
                     public limChar: number,
                     public delta: number) { }

        static unknown(): ScriptEditRange {
            return new ScriptEditRange(-1, -1, -1);
        }

        public isUnknown() {
            return this.minChar === -1 && this.limChar === -1 && this.delta === -1;
        }

        public containsPosition(pos: number) {
            return (this.minChar <= pos && pos < this.limChar)
                || (this.minChar <= pos && pos < this.limChar + this.delta);
        }

        public toString(): string {
            return "editRange(minChar=" + this.minChar + ", limChar=" + this.limChar + ", delta=" + this.delta + ")";
        }
    }

    export class UpdateUnitResult {
        constructor (public kind: UpdateUnitKind, public unitIndex: number, public script1: Script, public script2: Script) { }

        public scope1: AST = null;
        public scope2: AST = null;
        public editRange: ScriptEditRange = null;
        public parseErrors: ErrorEntry[] = [];

        static noEdits(unitIndex: number) {
            return new UpdateUnitResult(UpdateUnitKind.NoEdits, unitIndex, null, null);
        }

        static unknownEdits(script1: Script, script2: Script, parseErrors: ErrorEntry[]) {
            var result = new UpdateUnitResult(UpdateUnitKind.Unknown, script1.locationInfo.unitIndex, script1, script2);
            result.parseErrors = parseErrors;

            return result;
        }

        static singleScopeEdits(script1: Script, script2: Script, scope1: AST, scope2: AST, editRange: ScriptEditRange, parseErrors: ErrorEntry[]) {
            var result = new UpdateUnitResult(UpdateUnitKind.EditsInsideSingleScope, script1.locationInfo.unitIndex, script1, script2);
            result.scope1 = scope1;
            result.scope2 = scope2;
            result.editRange = editRange;
            result.parseErrors = parseErrors;
            return result;
        }
    }

    export class ErrorEntry {
        constructor (public unitIndex: number,
                    public minChar: number,
                    public limChar: number,
                    public message: string) { }
    }

    export var defaultSettings = new CompilationSettings();

    export interface EmitterIOHost {
        // function that can even create a folder structure if needed
        createFile(path: string, useUTF8?: bool): ITextWriter;

        // function to check if file exists on the disk
        fileExists(path: string): bool;

        // Function to check if the directory exists on the disk
        directoryExists(path: string): bool;

        // Resolves the path
        resolvePath(path: string): string;
    }

    export class TypeScriptCompiler {
        public parser = new Parser();
        public typeChecker: TypeChecker;
        public typeFlow: TypeFlow = null;
        public scripts = new ASTList();
        public units: LocationInfo[] = new LocationInfo[];
        public errorReporter: ErrorReporter;
        public pullErrorReporter: PullErrorReporter;

        public pullTypeChecker: PullTypeChecker = null;
        public semanticInfoChain: SemanticInfoChain = null;

        public persistentTypeState: PersistentGlobalTypeState;

        public emitSettings: EmitOptions;

        public syntaxTrees: SyntaxTree[] = [];



        constructor(public errorOutput: ITextWriter,
                    public logger: ILogger = new NullLogger(),
                    public settings: CompilationSettings = defaultSettings,
                    public diagnosticMessages: TypeScriptDiagnosticMessages = null) {
            this.errorReporter = new ErrorReporter(this.errorOutput);
            this.pullErrorReporter = new PullErrorReporter(this.errorOutput);
            this.persistentTypeState = new PersistentGlobalTypeState(this.errorReporter);
            this.errorReporter.parser = this.parser;
            this.initTypeChecker(this.errorOutput);

            this.parser.style_requireSemi = this.settings.styleSettings.requireSemi;
            this.parser.style_funcInLoop = this.settings.styleSettings.funcInLoop;
            this.parser.inferPropertiesFromThisAssignment = this.settings.inferPropertiesFromThisAssignment;
            this.emitSettings = new EmitOptions(this.settings);

            if (this.diagnosticMessages) {
                typescriptDiagnosticMessages = diagnosticMessages
            }

            codeGenTarget = settings.codeGenTarget;
        }

        public timeFunction(funcDescription: string, func: () => any): any {
            return TypeScript.timeFunction(this.logger, funcDescription, func);
        }

        public initTypeChecker(errorOutput: ITextWriter) {
            // The initial "refresh" initializes the persistent type state
            this.persistentTypeState.refreshPersistentState();
            this.typeChecker = new TypeChecker(this.persistentTypeState);
            this.typeChecker.errorReporter = this.errorReporter;

            // REVIEW: These properties should be moved out of the typeCheck object
            // ideally, CF should be a separate pass, independent of control flow
            this.typeChecker.checkControlFlow = this.settings.controlFlow;
            this.typeChecker.checkControlFlowUseDef = this.settings.controlFlowUseDef;
            this.typeChecker.printControlFlowGraph = this.settings.printControlFlow;

            this.typeChecker.errorsOnWith = this.settings.errorOnWith;
            this.typeChecker.styleSettings = this.settings.styleSettings;
            this.typeChecker.canCallDefinitionSignature = this.settings.canCallDefinitionSignature;

            this.errorReporter.checker = this.typeChecker;
            this.setErrorOutput(this.errorOutput);
        }

        public setErrorOutput(outerr) {
            this.errorOutput = outerr;
            this.errorReporter.setErrOut(outerr);
            this.parser.outfile = outerr;
        }

        public emitCommentsToOutput() {
            this.emitSettings = new EmitOptions(this.settings);
        }

        public setErrorCallback(fn: (minChar: number, charLen: number, message: string,
            unitIndex: number) =>void ) {
            this.parser.errorCallback = fn;
        }

        public updateUnit(prog: string, filename: string, setRecovery: bool) {
            return this.updateSourceUnit(new StringSourceText(prog), filename, setRecovery);
        }

        public updateSourceUnit(sourceText: ISourceText, filename: string, setRecovery: bool): bool {
            return this.timeFunction("updateSourceUnit(" + filename + ")", () => {
                var updateResult = this.partialUpdateUnit(sourceText, filename, setRecovery);
                return this.applyUpdateResult(updateResult);
            });
        }

        // Apply changes to compiler state.
        // Return "false" if the change is empty and nothing was updated.
        public applyUpdateResult(updateResult: UpdateUnitResult): bool {
            switch (updateResult.kind) {
                case UpdateUnitKind.NoEdits:
                    return false;

                case UpdateUnitKind.Unknown:
                    this.scripts.members[updateResult.unitIndex] = updateResult.script2;
                    this.units[updateResult.unitIndex] = updateResult.script2.locationInfo;
                    for (var i = 0, len = updateResult.parseErrors.length; i < len; i++) {
                        var e = updateResult.parseErrors[i];
                        if (this.parser.errorCallback) {
                            this.parser.errorCallback(e.minChar, e.limChar - e.minChar, e.message, e.unitIndex);
                        }
                    }
                    return true;

                case UpdateUnitKind.EditsInsideSingleScope:
                    new IncrementalParser(this.logger).mergeTrees(updateResult);
                    return true;
            }
        }

        public partialUpdateUnit(sourceText: ISourceText, filename: string, setRecovery: bool): UpdateUnitResult {
            return this.timeFunction("partialUpdateUnit(" + filename + ")", () => {
                for (var i = 0, len = this.units.length; i < len; i++) {
                    if (this.units[i].filename == filename) {
                        if ((<Script>this.scripts.members[i]).isResident) {
                            return UpdateUnitResult.noEdits(i);
                        }

                        if (setRecovery) {
                            this.parser.setErrorRecovery(null);
                        }

                        var updateResult: UpdateUnitResult;

                        // Capture parsing errors so that they are part of "updateResult"
                        var parseErrors: ErrorEntry[] = [];
                        var errorCapture = (minChar: number, charLen: number, message: string, unitIndex: number): void => {
                            parseErrors.push(new ErrorEntry(unitIndex, minChar, minChar + charLen, message));
                        };
                        var svErrorCallback = this.parser.errorCallback;
                        if (svErrorCallback)
                            this.parser.errorCallback = errorCapture;

                        var oldScript = <Script>this.scripts.members[i];
                        var newScript = this.parser.parse(sourceText, filename, i);

                        if (svErrorCallback)
                            this.parser.errorCallback = svErrorCallback;

                        updateResult = UpdateUnitResult.unknownEdits(oldScript, newScript, parseErrors);

                        return updateResult;
                    }
                }
                throw new Error("Unknown file \"" + filename + "\"");
            });
        }

        public addUnit(prog: string, filename: string, keepResident? = false, referencedFiles?: IFileReference[] = []): Script {
            return this.addSourceUnit(new StringSourceText(prog), filename, keepResident, referencedFiles);
        }

        private stringTable: Collections.StringTable = Collections.createStringTable();
        
        private typeCollectionTime = 0;

        public addSourceUnit(sourceText: ISourceText, filename: string, keepResident:bool, referencedFiles?: IFileReference[] = []): Script {
            return this.timeFunction("addSourceUnit(" + filename + ", " + keepResident + ")", () => {
                //if (filename.indexOf("getCompletionsAtPosition5") < 0) {
                //    return;
                //}

                var timer = new Timer();
                var sharedIndex = this.units.length;
                var reParsedScript: Script = null;
                
                if (!this.settings.useFidelity) {
                    timer.start();
                    var script: Script = this.parser.parse(sourceText, filename, sharedIndex, AllowedElements.Global);
                    timer.end();

                    reParsedScript = script;
                    
                    var oldParseTime = timer.time;

                    script.referencedFiles = referencedFiles;
                    script.isResident = keepResident;
                    this.persistentTypeState.setCollectionMode(keepResident ? TypeCheckCollectionMode.Resident : TypeCheckCollectionMode.Transient);
                }
                else {
                    var text = new TypeScript.SourceSimpleText(sourceText);

                    timer.start();
                    var syntaxTree = Parser1.parse(text, LanguageVersion.EcmaScript5, this.stringTable);
                    timer.end();

                    var newParseTime = timer.time;

                    if (true || syntaxTree.diagnostics().length === 0) {
                        try {
                            timer.start();
                            var script2: Script = SyntaxTreeToAstVisitor.visit(syntaxTree.sourceUnit(), filename, sharedIndex);
                            timer.end();

                            var translateTime = timer.time;

                            //if (filename.indexOf("lib.d.ts") >= 0) {
                            //    // IO.stdout.WriteLine("");
                            //    IO.stdout.WriteLine("Old - New - Translate: " + oldParseTime + "\t" + newParseTime + "\t" + translateTime);
                            //    // IO.stdout.WriteLine("    Diff %: " + ((newParseTime + translateTime) / oldParseTime));
                            //}

                            script2.referencedFiles = referencedFiles;
                            script2.isResident = keepResident;

                            reParsedScript = script2;
                             
                            // TypeScriptCompiler.compareObjects(script, script2);
                        } catch (e1) {
                            IO.stdout.WriteLine("Error converting: " + filename);
                            IO.stdout.WriteLine("\t" + e1.message);
                        }
                    }
                     
                    this.syntaxTrees.push(syntaxTree);
                }

                var index = this.units.length;
                this.units[index] = reParsedScript.locationInfo;

                if (!this.settings.usePull) {
                    var typeCollectionStart = new Date().getTime();
                    this.typeChecker.collectTypes(reParsedScript);
                    this.typeCollectionTime += (new Date().getTime()) - typeCollectionStart;
                }

                this.scripts.append(reParsedScript);

                return reParsedScript;
            });
        }

        private static compareObjects(obj1: any, obj2: any): void {
            if (obj1.alreadySeenObject) {
                // Prevent recursion.
                return;
            }
            obj1.alreadySeenObject = true;

            for (var name in obj1) {
                if (name === "limChar" ||
                    name === "minChar" ||
                    name === "astID" ||
                    name === "leftCurlyCount" ||
                    name === "rightCurlyCount" ||
                    name === "flags" ||
                    name === "varFlags" ||
                    name === "fncFlags" ||
                    name === "modFlags" ||
                    name === "nestingLevel" ||
                    name === "constructorNestingLevel" ||
                    name === "alreadySeenObject" ||
                    name === "containsUnicodeCharInComment" ||
                    name === "containsUnicodeChar" ||
                    name === "isOverload") {
                    continue; 
                }

                var value1 = obj1[name];
                if (value1) {
                    if (typeof value1 === 'number' ||
                        typeof value1 === 'string' ||
                        typeof value1 === 'boolean') {

                        var value2 = obj2[name];

                        if (typeof value1 !== typeof value2) {
                            throw new Error("Objects differed in type for key: " + name);
                        }

                        if (value1 !== value2) {
                            throw new Error("Objects differed in value for key: " + name);
                        }
                    }
                }
            }

            for (var name in obj1) {
                if (name === "preComments" ||
                    name === "postComments" ||
                    name === "docComments" ||
                    name === "sym" ||
                    name === "lineMap" ||
                    name === "resolvedTarget") {
                    continue;
                } 

                var value1 = obj1[name];
                if (value1) {
                    if (typeof value1 === 'object') {
                        var value2 = obj2[name];

                        if (typeof value1 !== typeof value2) {
                            throw new Error("Objects differed in type for key: " + name);
                        }

                        this.compareObjects(value1, value2);
                    }
                }
            }

            // obj1.alreadySeenObject = false;
        }

        public typeCheck() {
            return this.timeFunction("typeCheck()", () => {
                var binder = new Binder(this.typeChecker);
                this.typeChecker.units = this.units;
                binder.bind(this.typeChecker.globalScope, this.typeChecker.globals);
                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobals);
                binder.bind(this.typeChecker.globalScope, this.typeChecker.globalTypes);
                binder.bind(this.typeChecker.globalScope, this.typeChecker.ambientGlobalTypes);
                this.typeFlow = new TypeFlow(this.logger, this.typeChecker.globalScope, this.parser, this.typeChecker);
                var i = 0;
                var script: Script = null;
                var len = this.scripts.members.length;


                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Resident);
                // first, typecheck resident "lib" scripts, if necessary
                for (i = 0; i < len; i++) {
                    script = <Script>this.scripts.members[i];
                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }

                    this.typeFlow.assignScopes(script);
                    this.typeFlow.initLibs();
                }
                for (i = 0; i < len; i++) {
                    script = <Script>this.scripts.members[i];
                    if (!script.isResident || script.hasBeenTypeChecked) { continue; }

                    this.typeFlow.typeCheck(script);
                    script.hasBeenTypeChecked = true;
                }

                // next typecheck scripts that may change
                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);
                len = this.scripts.members.length;
                for (i = 0; i < len; i++) {
                    script = <Script>this.scripts.members[i];
                    if (script.isResident) { continue; }
                    this.typeFlow.assignScopes(script);
                    this.typeFlow.initLibs();
                }
                for (i = 0; i < len; i++) {
                    script = <Script>this.scripts.members[i];
                    if (script.isResident) { continue; }
                    this.typeFlow.typeCheck(script);
                }

                this.logger.log("Total type collection time: " + this.typeCollectionTime);

                return null;
            });
        }

        public cleanASTTypesForReTypeCheck(ast: AST) {
            function cleanASTType(ast: AST, parent: AST): AST {
                ast.type = null;
                                if (ast.nodeType == NodeType.VarDecl) {
                    var vardecl = <VarDecl>ast;
                    vardecl.sym = null;
                }
                else if (ast.nodeType == NodeType.ArgDecl) {
                    var argdecl = <ArgDecl>ast;
                    argdecl.sym = null;
                }
                else if (ast.nodeType == NodeType.Name) {
                    var name = <Identifier>ast;
                    name.sym = null;
                }
                else if (ast.nodeType == NodeType.FuncDecl) {
                    var funcdecl = <FuncDecl>ast;
                    funcdecl.signature = null;
                    funcdecl.freeVariables = new Symbol[]
                    funcdecl.symbols = null;
                    funcdecl.accessorSymbol = null;
                    funcdecl.scopeType = null;
                }
                else if (ast.nodeType == NodeType.ModuleDeclaration) {
                    var modDecl = <ModuleDeclaration>ast;
                    modDecl.mod = null;
                }
                else if (ast.nodeType == NodeType.With) {
                    (<WithStatement>ast).withSym = null;
                }
                else if (ast.nodeType == NodeType.Catch) {
                    (<Catch>ast).containedScope = null;
                }
                                else if (ast.nodeType === NodeType.Script) {
                                        (<Script>ast).externallyVisibleImportedSymbols = [];
                                }
                return ast;
            }
            TypeScript.getAstWalkerFactory().walk(ast, cleanASTType);
        }

        public cleanTypesForReTypeCheck() {
            return this.timeFunction("cleanTypesForReTypeCheck()", () => {
                for (var i = 0, len = this.scripts.members.length; i < len; i++) {
                    var script = this.scripts.members[i];
                    if ((<Script>script).isResident) {
                        continue;
                    }
                    this.cleanASTTypesForReTypeCheck(script);
                    this.typeChecker.collectTypes(script);
                }

                return null;
            });
        }

        // Return "true" if the incremental typecheck was successful
        // Return "false" if incremental typecheck failed, requiring a full typecheck
        public attemptIncrementalTypeCheck(updateResult: TypeScript.UpdateUnitResult): bool {
            return this.timeFunction("attemptIncrementalTypeCheck()", () => {
                // updateResult.kind == editsInsideFunction
                // updateResult.scope1 == old function
                // updateResult.scope2 == new function
                //REVIEW: What about typecheck errors? How do we replace the old ones with the new ones?
                return false;
            });
        }

        public reTypeCheck() {
            return this.timeFunction("reTypeCheck()", () => {
                CompilerDiagnostics.analysisPass++;
                this.initTypeChecker(this.errorOutput);
                this.persistentTypeState.setCollectionMode(TypeCheckCollectionMode.Transient);
                this.cleanTypesForReTypeCheck();
                return this.typeCheck();
            });
        }

        private isDynamicModuleCompilation() {
            for (var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = <Script>this.scripts.members[i];
                if (!script.isDeclareFile && script.topLevelMod != null) {
                    return true;
                }
            }
            return false;
        }

        private updateCommonDirectoryPath() {
            var commonComponents: string[] = [];
            var commonComponentsLength = -1;
            for (var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = <Script>this.scripts.members[i];
                if (script.emitRequired(this.emitSettings)) {
                    var fileName = script.locationInfo.filename;
                    var fileComponents = filePathComponents(fileName);
                    if (commonComponentsLength == -1) {
                        // First time at finding common path
                        // So common path = directory of file
                        commonComponents = fileComponents;
                        commonComponentsLength = commonComponents.length;
                    } else {
                        var updatedPath = false;
                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {
                            if (commonComponents[j] != fileComponents[j]) {
                                // The new components = 0 ... j -1
                                commonComponentsLength = j;
                                updatedPath = true;

                                if (j == 0) {
                                    // Its error to not have common path
                                    this.errorReporter.emitterError(null, "Cannot find the common subdirectory path for the input files");
                                    return;
                                }

                                break;
                            }
                        }

                        // If the fileComponent path completely matched and less than already found update the length
                        if (!updatedPath && fileComponents.length < commonComponentsLength) {
                            commonComponentsLength = fileComponents.length;
                        }
                    }
                }
            }

            this.emitSettings.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";
            if (this.emitSettings.outputOption.charAt(this.emitSettings.outputOption.length - 1) != "/") {
                this.emitSettings.outputOption += "/";
            }
        }

        public parseEmitOption(ioHost: EmitterIOHost) {
            this.emitSettings.ioHost = ioHost;
            if (this.emitSettings.outputOption == "") {
                this.emitSettings.outputMany = true;
                this.emitSettings.commonDirectoryPath = "";
                return;
            }

            this.emitSettings.outputOption = switchToForwardSlashes(this.emitSettings.ioHost.resolvePath(this.emitSettings.outputOption));

            // Determine if output options is directory or file
            if (this.emitSettings.ioHost.directoryExists(this.emitSettings.outputOption)) {
                // Existing directory
                this.emitSettings.outputMany = true;
            } else if (this.emitSettings.ioHost.fileExists(this.emitSettings.outputOption)) {
                // Existing file
                this.emitSettings.outputMany = false;
            }
            else {
                // New File/directory
                this.emitSettings.outputMany = !isJSFile(this.emitSettings.outputOption);
            }

            // Verify if options are correct
            if (this.isDynamicModuleCompilation() && !this.emitSettings.outputMany) {
                this.errorReporter.emitterError(null, "Cannot compile dynamic modules when emitting into single file");
            }

            // Parse the directory structure
            if (this.emitSettings.outputMany) {
                this.updateCommonDirectoryPath();
            }
        }

        public useUTF8ForFile(script: Script) {
            if (this.emitSettings.outputMany) {
                return this.outputScriptToUTF8(script);
            } else {
                return this.outputScriptsToUTF8(<Script[]>(this.scripts.members));
            }
        }

        static mapToDTSFileName(fileName: string, wholeFileNameReplaced: bool) {
            return getDeclareFilePath(fileName);
        }

        private canEmitDeclarations(script?: Script) {
            if (!this.settings.generateDeclarationFiles) {
                return false;
            }

            // If its already a declare file or is resident or does not contain body 
            if (!!script && (script.isDeclareFile || script.isResident || script.bod == null)) {
                return false;
            }

            return true;
        }

        public emitDeclarationsUnit(script: Script, reuseEmitter?: bool, declarationEmitter?: DeclarationEmitter) {
            if (!this.canEmitDeclarations(script)) {
                return null;
            }

            if (!declarationEmitter) {
                var declareFileName = this.emitSettings.mapOutputFileName(script.locationInfo.filename, TypeScriptCompiler.mapToDTSFileName);
                var declareFile = this.createFile(declareFileName, this.useUTF8ForFile(script));
                declarationEmitter = new DeclarationEmitter(this.typeChecker, this.emitSettings, this.errorReporter);
                declarationEmitter.setDeclarationFile(declareFile);
            }

            declarationEmitter.emitDeclarations(script);

            if (!reuseEmitter) {
                declarationEmitter.Close();
                return null;
            } else {
                return declarationEmitter;
            }
        }

        public emitDeclarations() {
            if (!this.canEmitDeclarations()) {
                return;
            }

            if (this.errorReporter.hasErrors) {
                // There were errors reported, do not generate declaration file
                return;
            }

            if (this.scripts.members.length == 0) {
                return;
            }

            var declarationEmitter: DeclarationEmitter = null;
            for (var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = <Script>this.scripts.members[i];
                if (this.emitSettings.outputMany || declarationEmitter == null) {
                    // Create or reuse file
                    declarationEmitter = this.emitDeclarationsUnit(script, !this.emitSettings.outputMany);
                } else {
                    // Emit in existing emitter
                    this.emitDeclarationsUnit(script, true, declarationEmitter);
                }
            }

            if (declarationEmitter) {
                declarationEmitter.Close();
            }
        }

        static mapToFileNameExtension(extension: string, fileName: string, wholeFileNameReplaced: bool) {
            if (wholeFileNameReplaced) {
                // The complete output is redirected in this file so do not change extension
                return fileName;
            } else {
                // Change the extension of the file
                var splitFname = fileName.split(".");
                splitFname.pop();
                return splitFname.join(".") + extension;
            }
        }

        static mapToJSFileName(fileName: string, wholeFileNameReplaced: bool) {
            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);
        }

        public emitUnit(script: Script, reuseEmitter?: bool, emitter?: Emitter) {
            if (!script.emitRequired(this.emitSettings)) {
                return null;
            }

            var fname = script.locationInfo.filename;
            if (!emitter) {
                var outFname = this.emitSettings.mapOutputFileName(fname, TypeScriptCompiler.mapToJSFileName);
                var outFile = this.createFile(outFname, this.useUTF8ForFile(script));
                emitter = new Emitter(this.typeChecker, outFname, outFile, this.emitSettings, this.errorReporter);
                if (this.settings.mapSourceFiles) {
                    emitter.setSourceMappings(new TypeScript.SourceMapper(fname, outFname, outFile, this.createFile(outFname + SourceMapper.MapFileExtension, false), this.errorReporter, this.settings.emitFullSourceMapPath));
                }
            } else if (this.settings.mapSourceFiles) {
                emitter.setSourceMappings(new TypeScript.SourceMapper(fname, emitter.emittingFileName, emitter.outfile, emitter.sourceMapper.sourceMapOut, this.errorReporter, this.settings.emitFullSourceMapPath));
            }

            this.typeChecker.locationInfo = script.locationInfo;
            emitter.emitJavascript(script, TokenID.Comma, false);
            if (!reuseEmitter) {
                emitter.Close();
                return null;
            } else {
                return emitter;
            }
        }

        public emit(ioHost: EmitterIOHost) {
            this.parseEmitOption(ioHost);

            var emitter: Emitter = null;
            for (var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = <Script>this.scripts.members[i];
                if (this.emitSettings.outputMany || emitter == null) {
                    emitter = this.emitUnit(script, !this.emitSettings.outputMany);
                } else {
                    this.emitUnit(script, true, emitter);
                }
            }

            if (emitter) {
                emitter.Close();
            }
        }

        public emitToOutfile(outputFile: ITextWriter) {
            if (this.settings.mapSourceFiles) {
                throw Error("Cannot generate source map");
            }

            if (this.settings.generateDeclarationFiles) {
                throw Error("Cannot generate declaration files");
            }

            if (this.settings.outputOption != "") {
                throw Error("Cannot parse output option");
            }

            var emitter: Emitter = emitter = new Emitter(this.typeChecker, "stdout", outputFile, this.emitSettings, this.errorReporter);;
            for (var i = 0, len = this.scripts.members.length; i < len; i++) {
                var script = <Script>this.scripts.members[i];
                this.typeChecker.locationInfo = script.locationInfo;
                emitter.emitJavascript(script, TokenID.Comma, false);
            }
        }

        private outputScriptToUTF8(script: Script): bool {
            return script.containsUnicodeChar || (this.emitSettings.emitComments && script.containsUnicodeCharInComment);
        }

        private outputScriptsToUTF8(scripts: Script[]): bool {
            for (var i = 0, len = scripts.length; i < len; i++) {
                var script = scripts[i];
                if (this.outputScriptToUTF8(script)) {
                    return true;
                }
            }
            return false;
        }

        private createFile(fileName: string, useUTF8: bool): ITextWriter {
            try {
                // Creating files can cause exceptions, report them.   
                return this.emitSettings.ioHost.createFile(fileName, useUTF8);
            } catch (ex) {
                this.errorReporter.emitterError(null, ex.message);
            }
        }

        //
        // Pull typecheck infrastructure
        //

        public pullResolveFile(filename: string): bool {
            if (!this.pullTypeChecker) {
                return false;
            }

            var unit = this.semanticInfoChain.getUnit(filename);

            if (!unit) {
                return false;
            }

            this.pullTypeChecker.setUnit(filename);
            this.pullTypeChecker.resolver.resolveBoundDecls(unit.getTopLevelDecls()[0], new PullTypeResolutionContext());

            return true;
        }

        public pullGetErrorsForFile(filename: string): SemanticError[]{

            var errors: PullError[] = [];

            var unit = this.semanticInfoChain.getUnit(filename);

            if (unit) {
                unit.getErrors(errors);
            }

            return errors;
        }

        public pullTypeCheck(refresh = false) {
            return this.timeFunction("pullTypeCheck()", () => {

                if (!this.pullTypeChecker || refresh) {
                    this.semanticInfoChain = new SemanticInfoChain();
                    this.pullTypeChecker = new PullTypeChecker(this.semanticInfoChain);
                }

                this.pullErrorReporter.setUnits(this.units);

                var declCollectionContext: DeclCollectionContext = null;
                var semanticInfo: SemanticInfo = null;
                var i = 0;

                var createDeclsStartTime = new Date().getTime();

                for (; i < this.scripts.members.length; i++) {

                    semanticInfo = new SemanticInfo(this.units[i].filename, this.units[i]);

                    declCollectionContext = new DeclCollectionContext(semanticInfo);

                    declCollectionContext.scriptName = this.units[i].filename;

                    // create decls
                    getAstWalkerFactory().walk(this.scripts.members[i], preCollectDecls, postCollectDecls, null, declCollectionContext);

                    semanticInfo.addTopLevelDecl(declCollectionContext.getParent());

                    this.semanticInfoChain.addUnit(semanticInfo);
                }

                var createDeclsEndTime = new Date().getTime();

                // bind declaration symbols
                var bindStartTime = new Date().getTime();

                var binder = new PullSymbolBinder(this.semanticInfoChain);

                // start at '1', so as to skip binding for global primitives such as 'any'
                for (i = 1; i < this.semanticInfoChain.units.length; i++) {
                    binder.bindDeclsForUnit(this.semanticInfoChain.units[i].getPath());
                }

                var bindEndTime = new Date().getTime();
                var typeCheckStartTime = new Date().getTime();

                // resolve symbols
                for (i = 0; i < this.scripts.members.length; i++) {
                    this.pullResolveFile(this.units[i].filename);
                }

                var typeCheckEndTime = new Date().getTime();

                this.logger.log("Decl creation: " + (createDeclsEndTime - createDeclsStartTime));
                this.logger.log("Binding: " + (bindEndTime - bindStartTime));
                this.logger.log("    Time in findSymbol: " + time_in_findSymbol);
                this.logger.log("Type resolution: " + (typeCheckEndTime - typeCheckStartTime));
                this.logger.log("Total: " + (typeCheckEndTime - createDeclsStartTime));

                this.pullErrorReporter.reportErrors(this.semanticInfoChain.postErrors());
            });
        }
        
        // returns 'true' if diffs were detected
        public pullUpdateScript(oldScript: Script, newScript: Script): bool {
            return this.timeFunction("pullUpdateScript: ", () => {
                
                var declDiffer = new PullDeclDiffer();

                // want to name the new script semantic info the same as the old one
                var newScriptSemanticInfo = new SemanticInfo(oldScript.locationInfo.filename, newScript.locationInfo);
                var oldScriptSemanticInfo = this.semanticInfoChain.getUnit(oldScript.locationInfo.filename);

                lastBoundPullDeclId = pullDeclID;
                lastBoundPullSymbolID = pullSymbolID;

                var declCollectionContext = new DeclCollectionContext(newScriptSemanticInfo);

                declCollectionContext.scriptName = oldScript.locationInfo.filename;

                // create decls
                getAstWalkerFactory().walk(newScript, preCollectDecls, postCollectDecls, null, declCollectionContext);

                var oldTopLevelDecl = oldScriptSemanticInfo.getTopLevelDecls()[0];
                var newTopLevelDecl = declCollectionContext.getParent();

                newScriptSemanticInfo.addTopLevelDecl(newTopLevelDecl);

                var diffResults: PullDeclDiff[] = [];

                var diffStartTime = new Date().getTime();
                declDiffer.diffDecls(oldTopLevelDecl, newTopLevelDecl, diffResults);

                var diffEndTime = new Date().getTime();
                this.logger.log("Update Script - Diff time: " + (diffEndTime - diffStartTime));

                // replace the old semantic info
                this.semanticInfoChain.updateUnit(oldScriptSemanticInfo, newScriptSemanticInfo);

                // re-bind
                var innerBindStartTime = new Date().getTime();

                var topLevelDecls = newScriptSemanticInfo.getTopLevelDecls();

                this.semanticInfoChain.update(newScript.locationInfo.filename);

                var binder = new PullSymbolBinder(this.semanticInfoChain);
                binder.setUnit(newScript.locationInfo.filename);

                for (var i = 0; i < topLevelDecls.length; i++) {
                    binder.bindDeclToPullSymbol(topLevelDecls[i], true);
                }

                var innerBindEndTime = new Date().getTime();

                this.logger.log("Update Script - Inner bind time: " + (innerBindEndTime - innerBindStartTime));
                if (diffResults.length) {

                    // propagate changes
                    var graphUpdater = new PullSymbolGraphUpdater(this.semanticInfoChain);
                    var diff: PullDeclDiff;

                    var traceStartTime = new Date().getTime();
                    for (var i = 0; i < diffResults.length; i++) {
                        diff = diffResults[i];

                        if (diff.kind == PullDeclEdit.DeclRemoved) {
                            graphUpdater.removeDecl(diff.oldDecl);
                        }
                        else if (diff.kind == PullDeclEdit.DeclAdded) {
                            graphUpdater.invalidateType(diff.oldDecl.getSymbol());
                            this.resolvePosition(diff.newDecl.getSpan().minChar, newScript);
                        }
                        else {
                            // PULLTODO: Other kinds of edits
                        }
                    }

                    var traceEndTime = new Date().getTime();

                    this.logger.log("Update Script - Trace time: " + (traceEndTime - traceStartTime));
                    this.logger.log("Update Script - Number of diffs: " + diffResults.length);

                    this.pullErrorReporter.setUnits(this.units);

                    this.pullErrorReporter.reportErrors(this.semanticInfoChain.postErrors())

                    return true;
                }

                this.pullErrorReporter.setUnits(this.units);

                this.pullErrorReporter.reportErrors(this.semanticInfoChain.postErrors())
                return false;
            });
        }

        public resolvePosition(pos: number, script: Script, scriptName?: string): { symbol: PullSymbol; ast: AST; } {

            // find the enclosing decl
            var declStack: PullDecl[] = [];
            var resultASTs: AST[] = [];
            if (!scriptName) {
                scriptName = script.locationInfo.filename;
            }
            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var lastDeclAST: AST = null;
            var foundAST: AST = null;
            var symbol: PullSymbol = null;

            // these are used to track intermediate nodes so that we can properly apply contextual types
            var lambdaAST: FuncDecl = null;
            var declarationInitASTs: VarDecl[] = [];
            var objectLitAST: UnaryExpression = null;
            var asgAST: BinaryExpression = null;
            var typeAssertionASTs: UnaryExpression[] = [];
            var resolutionContext = new PullTypeResolutionContext();
            var inTypeReference = false;

            var pre = (cur: AST, parent: AST): AST => {
                if (isValidAstNode(cur)) {
                    if (pos >= cur.minChar && pos <= cur.limChar) {

                        var previous = resultASTs[resultASTs.length - 1];

                        if (previous == undefined || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {

                            var decl = semanticInfo.getDeclForAST(cur);

                            if (decl) {
                                declStack[declStack.length] = decl;
                                lastDeclAST = cur;
                            }

                            if (cur.nodeType == NodeType.FuncDecl && hasFlag((<FuncDecl>cur).fncFlags, FncFlags.IsFunctionExpression)) {
                                lambdaAST = <FuncDecl>cur;
                            }
                            else if (cur.nodeType == NodeType.VarDecl) {
                                declarationInitASTs[declarationInitASTs.length] = <VarDecl>cur;
                            }
                            else if (cur.nodeType == NodeType.ObjectLit) {
                                objectLitAST = <UnaryExpression>cur;
                            }
                            else if (cur.nodeType == NodeType.TypeAssertion) {
                                typeAssertionASTs[typeAssertionASTs.length] = <UnaryExpression>cur;
                            }
                            else if (cur.nodeType == NodeType.Asg) {
                                asgAST = <BinaryExpression>cur;
                            }
                            else if (cur.nodeType == NodeType.TypeRef) {
                                inTypeReference = true;
                            }

                            resultASTs[resultASTs.length] = cur;
                        }
                    }
                }
                return cur;
            }

            getAstWalkerFactory().walk(script, pre);

            if (resultASTs.length) {

                this.pullTypeChecker.setUnit(script.locationInfo.filename);

                foundAST = resultASTs[resultASTs.length - 1];

                // are we within a decl?  if so, just grab its symbol
                if (lastDeclAST == foundAST) {
                    symbol = declStack[declStack.length - 1].getSymbol();
                    this.pullTypeChecker.resolver.resolveDeclaredSymbol(symbol, resolutionContext);
                }
                else {
                    // otherwise, it's an expression that needs to be resolved, so we must pull...

                    // first, find the enclosing decl
                    var enclosingDecl: PullDecl = null;

                    for (var i = declStack.length - 1; i >= 0; i--) {
                        if (!(declStack[i].getKind() & (PullElementKind.Variable | PullElementKind.Parameter))) {
                            enclosingDecl = declStack[i];
                            break;
                        }
                    }

                    // next, obtain the assigning AST, if applicable
                    // (this would be the ast for the last decl on the decl stack)

                    // if the found AST is a named, we want to check for previous dotted expressions,
                    // since those will give us the right typing
                    if (foundAST.nodeType == NodeType.Name && resultASTs.length > 1) {
                        for (var i = resultASTs.length - 2; i >= 0; i--) {
                            if ((resultASTs[i].nodeType === NodeType.VarDecl && (<VarDecl>resultASTs[i]).id === resultASTs[i + 1]) ||
                                //((resultASTs[i].nodeType === NodeType.Call || resultASTs[i].nodeType == NodeType.New) && (<CallExpression>resultASTs[i]).target === resultASTs[i + 1]) ||
                                (resultASTs[i].nodeType === NodeType.Dot && (<BinaryExpression>resultASTs[i]).operand2 === resultASTs[i + 1])) {
                                foundAST = resultASTs[i];   
                            }
                            else {
                                break;
                            }
                        }
                    }

                    // if it's a list, we may not have an exact AST, so find the next nearest one
                    if (foundAST.nodeType == NodeType.List) {
                        for (var i = 0; i < (<ASTList>foundAST).members.length; i++) {
                            if ((<ASTList>foundAST).members[i].minChar > pos) {
                                foundAST = (<ASTList>foundAST).members[i];
                                break;
                            }
                        }
                    }

                    resolutionContext.resolveAggressively = true;
                    resolutionContext.searchTypeSpace = inTypeReference;

                    var isTypedAssignment = false;

                    if (declarationInitASTs.length) {
                        var assigningAST: VarDecl;
                        var varSymbol: PullSymbol;

                        for (var i = 0; i < declarationInitASTs.length; i++) {

                            assigningAST = declarationInitASTs[i];
                            isTypedAssignment = (assigningAST != null) && (assigningAST.typeExpr != null);

                            this.pullTypeChecker.resolver.resolveDeclaration(assigningAST, resolutionContext);
                            varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST, scriptName);

                            if (varSymbol && isTypedAssignment) {
                                var contextualType = varSymbol.getType();
                                resolutionContext.pushContextualType(contextualType, false, null);
                            }

                            if (assigningAST.init) {
                                this.pullTypeChecker.resolver.resolveAST(assigningAST.init, isTypedAssignment, enclosingDecl, resolutionContext);
                            }
                        }
                    }

                    if (typeAssertionASTs.length) {
                        for (var i = 0; i < typeAssertionASTs.length; i++) {
                            this.pullTypeChecker.resolver.resolveAST(typeAssertionASTs[i], isTypedAssignment, enclosingDecl, resolutionContext);
                        }
                    }

                    if (asgAST) {
                        this.pullTypeChecker.resolver.resolveAST(asgAST, isTypedAssignment, enclosingDecl, resolutionContext);
                    }

                    if (objectLitAST) {
                        this.pullTypeChecker.resolver.resolveAST(objectLitAST, isTypedAssignment, enclosingDecl, resolutionContext);
                    }

                    if (lambdaAST) {
                        this.pullTypeChecker.resolver.resolveAST(lambdaAST, true, enclosingDecl, resolutionContext);
                        enclosingDecl = semanticInfo.getDeclForAST(lambdaAST);
                    }

                    symbol = this.pullTypeChecker.resolver.resolveAST(foundAST, isTypedAssignment, enclosingDecl, resolutionContext);
                }
            }

            return { symbol : symbol, ast : foundAST};
        }

        public pullGetTypeInfoAtPosition(pos: number, script: Script, scriptName?: string): { ast: AST; typeName: string; typeInfo: string; typeSymbol: PullTypeSymbol; } {
            return this.timeFunction("pullGetTypeInfoAtPosition for pos " + pos + ":", () => {
                
                var info = this.resolvePosition(pos, script, scriptName);

                if (info.symbol) {
                    var type = info.symbol.getType();
                    if (type) {
                        return { ast: info.ast, typeName: type.getName(), typeInfo: type.toString(), typeSymbol: type };
                    }
                }

                return { ast: info.ast, typeName: "couldn't find the type...", typeInfo: "couldn't find members...", typeSymbol: null };
            });
        }

        public pullUpdateUnit(sourceText: ISourceText, filename: string, setRecovery: bool): bool {
            return this.timeFunction("pullUpdateUnit(" + filename + ")", () => {
                for (var i = 0, len = this.units.length; i < len; i++) {
                    if (this.units[i].filename == filename) {

                        if (setRecovery) {
                            this.parser.setErrorRecovery(null);
                        }

                        var updateResult: UpdateUnitResult;

                        // Capture parsing errors for now
                        var parseErrors: ErrorEntry[] = [];
                        var errorCapture = (minChar: number, charLen: number, message: string, unitIndex: number): void => {
                            parseErrors.push(new ErrorEntry(unitIndex, minChar, minChar + charLen, message));
                        };
                        var svErrorCallback = this.parser.errorCallback;
                        if (svErrorCallback)
                            this.parser.errorCallback = errorCapture;

                        var oldScript = <Script>this.scripts.members[i];

                        var text = new TypeScript.SourceSimpleText(sourceText);

                        var syntaxTree = Parser1.parse(text, LanguageVersion.EcmaScript5, this.stringTable);
                        var newScript: Script = null;
                        try {
                            newScript = SyntaxTreeToAstVisitor.visit(syntaxTree.sourceUnit(), filename, i);

                            // TypeScriptCompiler.compareObjects(script, script2);
                        } catch (e1) {
                            IO.stdout.WriteLine("Error converting: " + filename);
                            IO.stdout.WriteLine("\t" + e1.message);
                        }

                        this.syntaxTrees[i] = syntaxTree;

                        //var newScript = this.parser.parse(sourceText, filename, i);

                        if (svErrorCallback)
                            this.parser.errorCallback = svErrorCallback;

                        this.scripts.members[i] = newScript;
                        this.units[i] = newScript.locationInfo;

                        return this.pullUpdateScript(oldScript, newScript);
                    }
                }
                throw new Error("Unknown file \"" + filename + "\"");
            });
        }
    }

    export class ScopeEntry {
        constructor (
            public name: string,
            public type: string,
            public sym: Symbol) {
        }
    }

    export class ScopeTraversal {
        constructor (private compiler: TypeScriptCompiler) {
        }

        public getScope(enclosingScopeContext: EnclosingScopeContext): SymbolScope {
            if (enclosingScopeContext.enclosingObjectLit && enclosingScopeContext.isMemberCompletion) {
                return enclosingScopeContext.getObjectLiteralScope();
            }
            else if (enclosingScopeContext.isMemberCompletion) {
                if (enclosingScopeContext.useFullAst) {
                    return this.compiler.typeFlow.findMemberScopeAtFullAst(enclosingScopeContext)
                }
                else {
                    return this.compiler.typeFlow.findMemberScopeAt(enclosingScopeContext)
                }
            }
            else {
                return enclosingScopeContext.getScope();
            }
        }

        public getScopeEntries(enclosingScopeContext: EnclosingScopeContext, getPrettyTypeName?: bool): ScopeEntry[] {
            var scope = this.getScope(enclosingScopeContext);
            if (scope == null) {
                return [];
            }

            var inScopeNames: IHashTable = new StringHashTable();
            var allSymbolNames: string[] = scope.getAllSymbolNames(enclosingScopeContext.isMemberCompletion);

            // there may be duplicates between the type and value tables, so batch the symbols
            // getTypeNamesForNames will prefer the entry in the value table
            for (var i = 0; i < allSymbolNames.length; i++) {
                var name = allSymbolNames[i];

                // Skip global/internal symbols that won't compile in user code
                if (name == globalId || name == "_Core" || name == "_element") {
                    continue;
                }

                inScopeNames.add(name, "");
            }

            var svModuleDecl = this.compiler.typeChecker.currentModDecl;
            this.compiler.typeChecker.currentModDecl = enclosingScopeContext.deepestModuleDecl;

            var result = this.getTypeNamesForNames(enclosingScopeContext, inScopeNames.getAllKeys(), scope, getPrettyTypeName);

            this.compiler.typeChecker.currentModDecl = svModuleDecl;
            return result;
        }

        private getTypeNamesForNames(enclosingScopeContext: EnclosingScopeContext, allNames: string[], scope: SymbolScope, getPrettyTypeName? : bool): ScopeEntry[] {
            var result: ScopeEntry[] = [];

            var enclosingScope = enclosingScopeContext.getScope();
            for (var i = 0; i < allNames.length; i++) {
                var name = allNames[i];
                // Search for the id in the value space first
                // if we don't find it, search in the type space.
                // We don't want to search twice, because the first
                // search may insert the name in the symbol value table
                // if the scope is aggregate
                var publicsOnly = enclosingScopeContext.publicsOnly && enclosingScopeContext.isMemberCompletion;
                var symbol = scope.find(name, publicsOnly, false/*typespace*/);  // REVIEW: Should search public members only?
                if (symbol == null) {
                    symbol = scope.find(name, publicsOnly, true/*typespace*/);
                }

                var displayThisMember = symbol && symbol.flags & SymbolFlags.Private ? symbol.container == scope.container : true;

                if (symbol) {
                    // Do not add dynamic module names to the list, since they're not legal as identifiers
                    if (displayThisMember && !isQuoted(symbol.name) && !isRelative(symbol.name)) {
                        var getPrettyOverload = getPrettyTypeName && symbol.declAST && symbol.declAST.nodeType == NodeType.FuncDecl;
                        var typeName = symbol.getType().getScopedTypeName(enclosingScope, getPrettyOverload);
                        result.push(new ScopeEntry(name, typeName, symbol));
                    }
                }
                else {
                    // Special case for "true" and "false"
                    // REVIEW: This may no longer be necessary?
                    if (name == "true" || name == "false") {
                        result.push(new ScopeEntry(name, "bool", this.compiler.typeChecker.booleanType.symbol));
                    }
                }
            }

            return result;
        }
    }
}
declare class Enumerator {
    public atEnd(): bool;
    public moveNext();
    public item(): any;
    constructor (o: any);
}
declare module process {
    export var argv: string[];
    export var platform: string;
    export function on(event: string, handler: (any) => void ): void;
    export module stdout {
        export function write(str: string);
    }
    export module stderr {
        export function write(str: string);
    }
    export module mainModule {
        export var filename: string;
    }
    export function exit(exitCode?: number);
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export enum DiagnosticCategory {
        Warning,
        Error,
    }

    export interface Diagnostic {
        category: DiagnosticCategory;
        message: string;
        code: number;
    }

    export enum DiagnosticMessages {
        error_2,
        warning_2,

        duplicateIdentifier_1,
        unresolvedSymbol_1,
        symbolDoesNotReferToAValue_1,
        invalidSuperReference,
        valueCannotBeModified,
        usedCallInsteadOfNew_1,
        valueIsNotCallable_1,
        valueIsNotNewable_1,
        invalidIndexLHS_2,
        incompatibleTypesForOperator_3,
        incompatibleTypesForOperatorWithReason_4,
        incompatibleTypes_2,
        incompatibleTypesWithReason_3,
        expectedClassOrInterface,
        unaryOperatorTypeError_2,

    }

    export interface TypeScriptDiagnosticMessages {
        error_2: Diagnostic;
        warning_2: Diagnostic;

        duplicateIdentifier_1: Diagnostic;
        unresolvedSymbol_1: Diagnostic;
        symbolDoesNotReferToAValue_1: Diagnostic;
        invalidSuperReference: Diagnostic;
        valueCannotBeModified: Diagnostic;
        usedCallInsteadOfNew_1: Diagnostic;
        valueIsNotCallable_1: Diagnostic;
        valueIsNotNewable_1: Diagnostic;
        invalidIndexLHS_2: Diagnostic;
        incompatibleTypesForOperator_3: Diagnostic;
        incompatibleTypesForOperatorWithReason_4: Diagnostic;
        incompatibleTypes_2: Diagnostic;
        incompatibleTypesWithReason_3: Diagnostic;
        expectedClassOrInterface: Diagnostic;
        unaryOperatorTypeError_2: Diagnostic;

    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export var typescriptDiagnosticMessages: TypeScriptDiagnosticMessages = {
        error_2: {
            category: DiagnosticCategory.Error,
            message: "error TS{0}: {1}",
            code: 0
        },

        warning_2: {
            category: DiagnosticCategory.Warning,
            message: "warning TS{0}: {1}",
            code: 1
        },

        duplicateIdentifier_1: {
            category: DiagnosticCategory.Error,
            message: "Duplicate identifier '{0}'",
            code: 100
        },

        unresolvedSymbol_1: {
            category: DiagnosticCategory.Error,
            message: "The name'{0}' does not exist in the current scope",
            code: 101
        },

        symbolDoesNotReferToAValue_1: {
            category: DiagnosticCategory.Error,
            message: "The name '{0}' does not refer to a value",
            code: 102
        },

        invalidSuperReference: {
            category: DiagnosticCategory.Error,
            message: "Keyword 'super' can only be used inside a class instance method",
            code: 103
        },

        valueCannotBeModified: {
            category: DiagnosticCategory.Error,
            message: "The left-hand side of an assignment expression must be a variable, property or indexer",
            code: 104
        },

        usedCallInsteadOfNew_1: {
            category: DiagnosticCategory.Error,
            message: "Value of type '{0}' is not callable.  Did you mean to include 'new'?",
            code: 105
        },

        valueIsNotCallable_1: {
            category: DiagnosticCategory.Error,
            message: "Value of type '{0}' is not callable",
            code: 106
        },

        valueIsNotNewable_1: {
            category: DiagnosticCategory.Error,
            message: "Value of type '{0}' is not newable",
            code: 107
        },

        invalidIndexLHS_2: {
            category: DiagnosticCategory.Error,
            message: "Value of type '{0}' is not indexable by type '{1}'",
            code: 108
        },

        incompatibleTypesForOperator_3: {
            category: DiagnosticCategory.Error,
            message: "Operator '{0}' cannot be applied to types '{1}' and '{2}'",
            code: 109
        },

        incompatibleTypesForOperatorWithReason_4: {
            category: DiagnosticCategory.Error,
            message: "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}",
            code: 110
        },

        incompatibleTypes_2: {
            category: DiagnosticCategory.Error,
            message: "Cannot convert '{0}' to '{1}'",
            code: 111
        },

        incompatibleTypesWithReason_3: {
            category: DiagnosticCategory.Error,
            message: "Cannot convert '{0}' to '{1}': {2}",
            code: 112
        },

        expectedClassOrInterface: {
            category: DiagnosticCategory.Error,
            message: "Expected var, class, interface, or module",
            code: 113
        },

        unaryOperatorTypeError_2: {
            category: DiagnosticCategory.Error,
            message: "Operator '{0}' cannot be applied to type '{1}'",
            code: 114
        },
    };
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='Enumerator.ts' />
///<reference path='process.ts' />

interface IResolvedFile {
    content: string;
    path: string;
}

interface IFileWatcher {
    close(): void;
}

interface IIO {
    readFile(path: string): string;
    writeFile(path: string, contents: string): void;
    createFile(path: string, useUTF8?: bool): ITextWriter;
    deleteFile(path: string): void;
    dir(path: string, re?: RegExp, options?: { recursive?: bool; }): string[];
    fileExists(path: string): bool;
    directoryExists(path: string): bool;
    createDirectory(path: string): void;
    resolvePath(path: string): string;
    dirName(path: string): string;
    findFile(rootPath: string, partialFilePath: string): IResolvedFile;
    print(str: string): void;
    printLine(str: string): void;
    arguments: string[];
    stderr: ITextWriter;
    stdout: ITextWriter;
    watchFile(filename: string, callback: (string) => void ): IFileWatcher;
    run(source: string, filename: string): void;
    getExecutingFilePath(): string;
    quit(exitCode?: number);
}

module IOUtils {
    // Creates the directory including its parent if not already present
    function createDirectoryStructure(ioHost: IIO, dirName: string) {
        if (ioHost.directoryExists(dirName)) {
            return;
        }

        var parentDirectory = ioHost.dirName(dirName);
        if (parentDirectory != "") {
            createDirectoryStructure(ioHost, parentDirectory);
        }
        ioHost.createDirectory(dirName);
    }

    // Creates a file including its directory structure if not already present
    export function createFileAndFolderStructure(ioHost: IIO, fileName: string, useUTF8?: bool) {
        var path = ioHost.resolvePath(fileName);
        var dirName = ioHost.dirName(path);
        createDirectoryStructure(ioHost, dirName);
        return ioHost.createFile(path, useUTF8);
    }

    export function throwIOError(message: string, error: Error) {
        var errorMessage = message;
        if (error && error.message) {
            errorMessage += (" " + error.message);
        }
        throw new Error(errorMessage);
    }

    export class BufferedTextWriter implements ITextWriter {
        public buffer = "";
        // Inner writer does not need a WriteLine method, since the BufferedTextWriter wraps it itself
        constructor(public writer: { Write: (str: string) => void; Close: () => void; }, public capacity = 1024) { }
        Write(str) {
            this.buffer += str;
            if (this.buffer.length >= this.capacity) {
                this.writer.Write(this.buffer);
                this.buffer = "";
            }
        }
        WriteLine(str) {
            this.Write(str + '\r\n');
        }
        Close() {
            this.writer.Write(this.buffer);
            this.writer.Close();
            this.buffer = null;
        }
    }
}

// Declare dependencies needed for all supported hosts
declare function setTimeout(callback: () =>void , ms?: number);
declare var require: any;

var IO = (function() {

    // Create an IO object for use inside WindowsScriptHost hosts
    // Depends on WSCript and FileSystemObject
    function getWindowsScriptHostIO(): IIO {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var streamObjectPool = [];

        function getStreamObject(): any { 
            if (streamObjectPool.length > 0) {
                return streamObjectPool.pop();
            }  else {
                return new ActiveXObject("ADODB.Stream");
            }
        }

        function releaseStreamObject(obj: any) { 
            streamObjectPool.push(obj);
        }

        var args = [];
        for (var i = 0; i < WScript.Arguments.length; i++) {
            args[i] = WScript.Arguments.Item(i);
        }

        return {
            readFile: function(path) {
                try {
                    var streamObj = getStreamObject();
                    streamObj.Open();
                    streamObj.Type = 2; // Text data
                    streamObj.Charset = 'x-ansi'; // Assume we are reading ansi text
                    streamObj.LoadFromFile(path);
                    var bomChar = streamObj.ReadText(2); // Read the BOM char
                    streamObj.Position = 0; // Position has to be at 0 before changing the encoding
                    if ((bomChar.charCodeAt(0) == 0xFE && bomChar.charCodeAt(1) == 0xFF)
                        || (bomChar.charCodeAt(0) == 0xFF && bomChar.charCodeAt(1) == 0xFE)) {
                        streamObj.Charset = 'unicode';
                    } else if (bomChar.charCodeAt(0) == 0xEF && bomChar.charCodeAt(1) == 0xBB) {
                        streamObj.Charset = 'utf-8'; 
                    }

                    // Read the whole file
                    var str = streamObj.ReadText(-1 /* read from the current position to EOS */);
                    streamObj.Close();
                    releaseStreamObject(streamObj);
                    return <string>str;
                }
                catch (err) {
                    IOUtils.throwIOError("Error reading file \"" + path + "\".", err);
                }
            },

            writeFile: function(path, contents) {
                var file = this.createFile(path);
                file.Write(contents);
                file.Close();
            },

            fileExists: function(path: string): bool {
                return fso.FileExists(path);
            },

            resolvePath: function(path: string): string {
                return fso.GetAbsolutePathName(path);
            },

            dirName: function(path: string): string {
                return fso.GetParentFolderName(path);
            },

            findFile: function(rootPath: string, partialFilePath: string): IResolvedFile {
                var path = fso.GetAbsolutePathName(rootPath) + "/" + partialFilePath;

                while (true) {
                    if (fso.FileExists(path)) {
                        try {
                            var content = this.readFile(path);
                            return { content: content, path: path };
                        }
                        catch (err) {
                            //Tools.CompilerDiagnostics.debugPrint("Could not find " + path + ", trying parent");
                        }
                    }
                    else {
                        rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));

                        if (rootPath == "") {
                            return null;
                        }
                        else {
                            path = fso.BuildPath(rootPath, partialFilePath);
                        }
                    }
                }
            },

            deleteFile: function(path: string): void {
                try {
                    if (fso.FileExists(path)) {
                        fso.DeleteFile(path, true); // true: delete read-only files
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't delete file '" + path + "'.", e);
                }
            },

            createFile: function (path, useUTF8?) {
                try {
                    var streamObj = getStreamObject();
                    streamObj.Charset = useUTF8 ? 'utf-8' : 'x-ansi';
                    streamObj.Open();
                    return {
                        Write: function (str) { streamObj.WriteText(str, 0); },
                        WriteLine: function (str) { streamObj.WriteText(str, 1); },
                        Close: function() {
                            try {
                                streamObj.SaveToFile(path, 2);
                            } catch (saveError) {
                                IOUtils.throwIOError("Couldn't write to file '" + path + "'.", saveError);
                            }
                            finally {
                                if (streamObj.State != 0 /*adStateClosed*/) {
                                    streamObj.Close();
                                }
                                releaseStreamObject(streamObj);
                            }
                        }
                    };
                } catch (creationError) {
                    IOUtils.throwIOError("Couldn't write to file '" + path + "'.", creationError);
                }
            },

            directoryExists: function(path) {
                return <bool>fso.FolderExists(path);
            },

            createDirectory: function(path) {
                try {
                    if (!this.directoryExists(path)) {
                        fso.CreateFolder(path);
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't create directory '" + path + "'.", e);
                }
            },

            dir: function(path, spec?, options?) {
                options = options || <{ recursive?: bool; }>{};
                function filesInFolder(folder, root): string[]{
                    var paths = [];
                    var fc: Enumerator;

                    if (options.recursive) {
                        fc = new Enumerator(folder.subfolders);

                        for (; !fc.atEnd() ; fc.moveNext()) {
                            paths = paths.concat(filesInFolder(fc.item(), root + "/" + fc.item().Name));
                        }
                    }

                    fc = new Enumerator(folder.files);

                    for (; !fc.atEnd() ; fc.moveNext()) {
                        if (!spec || fc.item().Name.match(spec)) {
                            paths.push(root + "/" + fc.item().Name);
                        }
                    }

                    return paths;
                }

                var folder = fso.GetFolder(path);
                var paths = [];

                return filesInFolder(folder, path);
            },

            print: function(str) {
                WScript.StdOut.Write(str);
            },

            printLine: function(str) {
                WScript.Echo(str);
            },

            arguments: <string[]>args,
            stderr: WScript.StdErr,
            stdout: WScript.StdOut,
            watchFile: null,
            run: function(source, filename) {
                try {
                    eval(source);
                } catch (e) {
                    IOUtils.throwIOError("Error while executing file '" + filename + "'.", e);
                }
            },
            getExecutingFilePath: function () {
                return WScript.ScriptFullName;
            },
            quit: function (exitCode? : number = 0) {
                try {
                    WScript.Quit(exitCode);
                } catch (e) {
                }
            }
        }

    };

    // Create an IO object for use inside Node.js hosts
    // Depends on 'fs' and 'path' modules
    function getNodeIO(): IIO {

        var _fs = require('fs');
        var _path = require('path');
        var _module = require('module');

        return {
            readFile: function(file) {
                try {
                    var buffer = _fs.readFileSync(file);
                    switch (buffer[0]) {
                        case 0xFE:
                            if (buffer[1] == 0xFF) {
                                // utf16-be. Reading the buffer as big endian is not supported, so convert it to 
                                // Little Endian first
                                var i = 0;
                                while ((i + 1) < buffer.length) {
                                    var temp = buffer[i]
                                    buffer[i] = buffer[i + 1];
                                    buffer[i + 1] = temp;
                                    i += 2;
                                }
                                return buffer.toString("ucs2", 2);
                            }
                            break;
                        case 0xFF:
                            if (buffer[1] == 0xFE) {
                                // utf16-le 
                                return buffer.toString("ucs2", 2);
                            }
                            break;
                        case 0xEF:
                            if (buffer[1] == 0xBB) {
                                // utf-8
                                return buffer.toString("utf8", 3);
                            }
                    }
                    // Default behaviour
                    return buffer.toString();
                } catch (e) {
                    IOUtils.throwIOError("Error reading file \"" + file + "\".", e);
                }
            },

            writeFile: <(path: string, contents: string) => void >_fs.writeFileSync,
            deleteFile: function(path) {
                try {
                    _fs.unlinkSync(path);
                } catch (e) {
                    IOUtils.throwIOError("Couldn't delete file '" + path + "'.", e);
                }
            },
            fileExists: function(path): bool {
                return _fs.existsSync(path);
            },
            createFile: function(path, useUTF8?) {
                function mkdirRecursiveSync(path) {
                    var stats = _fs.statSync(path);
                    if (stats.isFile()) {
                        IOUtils.throwIOError("\"" + path + "\" exists but isn't a directory.", null);
                    } else if (stats.isDirectory()) {
                        return;
                    } else {
                        mkdirRecursiveSync(_path.dirname(path));
                        _fs.mkdirSync(path, 0775);
                    }
                }

                mkdirRecursiveSync(_path.dirname(path));

                try {
                    var fd = _fs.openSync(path, 'w');
                } catch (e) {
                    IOUtils.throwIOError("Couldn't write to file '" + path + "'.", e);
                }
                // Writing to a buffer to improve performance
                return new IOUtils.BufferedTextWriter({
                    Write: function (str) { _fs.writeSync(fd, str); },
                    Close: function () { _fs.closeSync(fd); fd = null; }
                });
            },
            dir: function dir(path, spec?, options?) {
                options = options || <{ recursive?: bool; }>{};

                function filesInFolder(folder: string): string[]{
                    var paths = [];

                    var files = _fs.readdirSync(folder);
                    for (var i = 0; i < files.length; i++) {
                        var stat = _fs.statSync(folder + "/" + files[i]);
                        if (options.recursive && stat.isDirectory()) {
                            paths = paths.concat(filesInFolder(folder + "/" + files[i]));
                        } else if (stat.isFile() && (!spec || files[i].match(spec))) {
                            paths.push(folder + "/" + files[i]);
                        }
                    }

                    return paths;
                }

                return filesInFolder(path);
            },
            createDirectory: function(path: string): void {
                try {
                    if (!this.directoryExists(path)) {
                        _fs.mkdirSync(path);
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't create directory '" + path + "'.", e);
                }
            },

            directoryExists: function(path: string): bool {
                return _fs.existsSync(path) && _fs.lstatSync(path).isDirectory();
            },
            resolvePath: function(path: string): string {
                return _path.resolve(path);
            },
            dirName: function(path: string): string {
                return _path.dirname(path);
            },
            findFile: function(rootPath: string, partialFilePath): IResolvedFile {
                var path = rootPath + "/" + partialFilePath;

                while (true) {
                    if (_fs.existsSync(path)) {
                        try {
                            var content = this.readFile(path);
                            return { content: content, path: path };
                        } catch (err) {
                            //Tools.CompilerDiagnostics.debugPrint(("Could not find " + path) + ", trying parent");
                        }
                    }
                    else {
                        var parentPath = _path.resolve(rootPath, "..");

                        // Node will just continue to repeat the root path, rather than return null
                        if (rootPath === parentPath) {
                            return null;
                        }
                        else {
                            rootPath = parentPath;
                            path = _path.resolve(rootPath, partialFilePath);
                        }
                    }
                }
            },
            print: function(str) { process.stdout.write(str) },
            printLine: function(str) { process.stdout.write(str + '\n') },
            arguments: process.argv.slice(2),
            stderr: {
                Write: function(str) { process.stderr.write(str); },
                WriteLine: function(str) { process.stderr.write(str + '\n'); },
                Close: function() { }
            },
            stdout: {
                Write: function(str) { process.stdout.write(str); },
                WriteLine: function(str) { process.stdout.write(str + '\n'); },
                Close: function() { }
            },
            watchFile: function(filename: string, callback: (string) => void ): IFileWatcher {
                var firstRun = true;
                var processingChange = false;

                var fileChanged: any = function(curr, prev) {
                    if (!firstRun) {
                        if (curr.mtime < prev.mtime) {
                            return;
                        }

                        _fs.unwatchFile(filename, fileChanged);
                        if (!processingChange) {
                            processingChange = true;
                            callback(filename);
                            setTimeout(function() { processingChange = false; }, 100);
                        }
                    }
                    firstRun = false;
                    _fs.watchFile(filename, { persistent: true, interval: 500 }, fileChanged);
                };

                fileChanged();
                return {
                    filename: filename,
                    close: function() {
                        _fs.unwatchFile(filename, fileChanged);
                    }
                };
            },
            run: function(source, filename) {
                require.main.filename = filename;
                require.main.paths = _module._nodeModulePaths(_path.dirname(_fs.realpathSync(filename)));
                require.main._compile(source, filename);
            }, 
            getExecutingFilePath: function () {
                return process.mainModule.filename;
            },
            quit: process.exit
        }
    };

    if (typeof ActiveXObject === "function")
        return getWindowsScriptHostIO();
    else if (typeof require === "function")
        return getNodeIO();
    else
        return null; // Unsupported host
})();
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path="io.ts" />

interface IOptions {
    name?: string;
    flag?: bool;
    short?: string;
    usage?: string;
    set?: (s: string) => void;
    type?: string;
    experimental?: bool;
}

class OptionsParser {
    private DEFAULT_SHORT_FLAG = "-";
    private DEFAULT_LONG_FLAG = "--";

    // Find the option record for the given string. Returns null if not found.
    private findOption(arg: string) {

        for (var i = 0; i < this.options.length; i++) {

            if (arg === this.options[i].short || arg === this.options[i].name) {
                return this.options[i];
            }
        }

        return null;
    }

    public unnamed: string[] = [];

    public options: IOptions[] = [];

    constructor (public host: IIO) {
    }

    public printUsage() {
        this.host.printLine("Syntax:   tsc [options] [file ..]");
        this.host.printLine("");
        this.host.printLine("Examples: tsc hello.ts");
        this.host.printLine("          tsc --out foo.js foo.ts");
        this.host.printLine("          tsc @args.txt");
        this.host.printLine("");
        this.host.printLine("Options:");

        var output = [];
        var maxLength = 0;

        this.options = this.options.sort(function(a, b) {
            var aName = a.name.toLowerCase();
            var bName = b.name.toLowerCase();

            if (aName > bName) {
                return 1;
            } else if (aName < bName) {
                return -1;
            } else {
                return 0;
            }
        });

        // Build up output array
        for (var i = 0; i < this.options.length; i++) {
            var option = this.options[i];

            if (option.experimental) {
                continue;
            }

            if (!option.usage) {
                break;
            }

            var usageString = "  ";
            var type = option.type ? " " + option.type.toUpperCase() : "";

            if (option.short) {
                usageString += this.DEFAULT_SHORT_FLAG + option.short + type + ", ";
            }

            usageString += this.DEFAULT_LONG_FLAG + option.name + type;

            output.push([usageString, option.usage]);

            if (usageString.length > maxLength) {
                maxLength = usageString.length;
            }
        }

        output.push(["  @<file>", "Insert command line options and files from a file."]);

        // Print padded output
        for (var i = 0; i < output.length; i++) {
            this.host.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(" ") + output[i][1]);
        }
    }

    public option(name: string, config: IOptions, short?: string) {
        if (!config) {
            config = <any>short;
            short = null;
        }

        config.name = name;
        config.short = short;
        config.flag = false;

        this.options.push(config);
    }

    public flag(name: string, config: IOptions, short?: string) {
        if (!config) {
            config = <any>short;
            short = null;
        }

        config.name = name;
        config.short = short;
        config.flag = true

        this.options.push(config);
    }

    // Parse an arguments string
    public parseString(argString: string) {
        var position = 0;
        var tokens = argString.match(/\s+|"|[^\s"]+/g);

        function peek() {
            return tokens[position];
        }

        function consume() {
            return tokens[position++];
        }

        function consumeQuotedString() {
            var value = '';
            consume(); // skip opening quote.

            var token = peek();

            while (token && token !== '"') {
                consume();

                value += token;

                token = peek();
            }

            consume(); // skip ending quote;

            return value;
        }

        var args: string[] = [];
        var currentArg = '';

        while (position < tokens.length) {
            var token = peek();

            if (token === '"') {
                currentArg += consumeQuotedString();
            } else if (token.match(/\s/)) {
                if (currentArg.length > 0) {
                    args.push(currentArg);
                    currentArg = '';
                }

                consume();
            } else {
                consume();
                currentArg += token;
            }
        }

        if (currentArg.length > 0) {
            args.push(currentArg);
        }

        this.parse(args);
    }

    // Parse arguments as they come from the platform: split into arguments.
    public parse(args: string[]) {
        var position = 0;

        function consume() {
            return args[position++];
        }

        while (position < args.length) {
            var current = consume();
            var match = current.match(/^(--?|@)(.*)/);
            var value = null;

            if (match) {
                if (match[1] === '@') {
                    this.parseString(this.host.readFile(match[2]));
                } else {
                    var arg = match[2];
                    var option = this.findOption(arg);

                    if (option === null) {
                        this.host.printLine("Unknown option '" + arg +"'");
                        this.host.printLine("Use the '--help' flag to see options");
                    } else {
                        if (!option.flag)
                            value = consume();

                        option.set(value);
                    }
                }
            } else {
                this.unnamed.push(current);
            }
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts'/>
///<reference path='io.ts'/>
///<reference path='optionsParser.ts'/>

declare var localizedDiagnosticMessages: TypeScript.TypeScriptDiagnosticMessages;

class DiagnosticsLogger implements TypeScript.ILogger {
    constructor(public ioHost: IIO) {
    }
    public information(): bool { return false; }
    public debug(): bool { return false; }
    public warning(): bool { return false; }
    public error(): bool { return false; }
    public fatal(): bool { return false; }
    public log(s: string): void {
        this.ioHost.stdout.WriteLine(s);
    }
}

class ErrorReporter implements ITextWriter {
    public hasErrors: bool;

    constructor(public ioHost: IIO) {
        this.hasErrors = false;
    }

    public Write(s: string) {
        this.hasErrors = true;
        this.ioHost.stderr.Write(s);
    }

    public WriteLine(s: string) {
        this.hasErrors = true;
        this.ioHost.stderr.WriteLine(s);
    }

    public Close() {
    }

    public reset() {
        this.hasErrors = false;
    }
}

class CommandLineHost implements TypeScript.IResolverHost {

    public pathMap: any = {};
    public resolvedPaths: any = {};

    constructor(public compilationSettings: TypeScript.CompilationSettings, public errorReporter: (err:string)=>void) { 
    }

    public getPathIdentifier(path: string) {
        return this.compilationSettings.useCaseSensitiveFileResolution ? path : path.toLocaleUpperCase();
    }

    public isResolved(path: string) {
        return this.resolvedPaths[this.getPathIdentifier(this.pathMap[path])] != undefined;
    }

    public resolveCompilationEnvironment(preEnv: TypeScript.CompilationEnvironment,
                                         resolver: TypeScript.ICodeResolver,
                                         traceDependencies: bool): TypeScript.CompilationEnvironment {
        var resolvedEnv = new TypeScript.CompilationEnvironment(preEnv.compilationSettings, preEnv.ioHost);

        var nCode = preEnv.code.length;
        var path = "";

        var postResolutionError = 
            (errorFile: string, errorMessage: string) => {
                this.errorReporter(errorFile + (errorMessage == "" ? "" : ": " + errorMessage));
            }

        var resolutionDispatcher: TypeScript.IResolutionDispatcher = {
            postResolutionError: (errorFile, line, col, errorMessage) => {
                this.errorReporter(errorFile + "(" + line + "," + col + ") " + (errorMessage == "" ? "" : ": " + errorMessage));
            },
            postResolution: (path: string, code: TypeScript.ISourceText) => {
                var pathId = this.getPathIdentifier(path);
                if (!this.resolvedPaths[pathId]) {
                    resolvedEnv.code.push(<TypeScript.SourceUnit>code);
                    this.resolvedPaths[pathId] = true;
                }
            }
        };

        for (var i = 0; i < nCode; i++) {
            path = TypeScript.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.code[i].path));
            this.pathMap[preEnv.code[i].path] = path;
            resolver.resolveCode(path, "", false, resolutionDispatcher);
        }

        return resolvedEnv;
    }
}

class BatchCompiler {
    public compilationSettings: TypeScript.CompilationSettings;
    public compilationEnvironment: TypeScript.CompilationEnvironment;
    public resolvedEnvironment: TypeScript.CompilationEnvironment = null;
    public hasResolveErrors: bool = false;
    public compilerVersion = "0.9.0.0";
    public printedVersion = false;
    public errorReporter: ErrorReporter = null;

    constructor(public ioHost: IIO) {
        this.compilationSettings = new TypeScript.CompilationSettings();
        this.compilationEnvironment = new TypeScript.CompilationEnvironment(this.compilationSettings, this.ioHost);
        this.errorReporter = new ErrorReporter(this.ioHost);
    }

    public resolve() {
        var resolver = new TypeScript.CodeResolver(this.compilationEnvironment);
        var commandLineHost = new CommandLineHost(this.compilationSettings, (err) => this.errorReporter.WriteLine(err));
        var ret = commandLineHost.resolveCompilationEnvironment(this.compilationEnvironment, resolver, true);

        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {
            if (!commandLineHost.isResolved(this.compilationEnvironment.code[i].path)) {
                var path = this.compilationEnvironment.code[i].path;
                if (!TypeScript.isSTRFile(path) && !TypeScript.isDSTRFile(path) && !TypeScript.isTSFile(path) && !TypeScript.isDTSFile(path)) {
                    this.errorReporter.WriteLine("Unknown extension for file: \"" + path + "\". Only .ts and .d.ts extensions are allowed.");
                }
                else {
                    this.errorReporter.WriteLine("Error reading file \"" + path + "\": File not found");
                }
            }
        }

        return ret;
    }
    
    /// Do the actual compilation reading from input files and
    /// writing to output file(s).
    public compile(): bool {
        var compiler: TypeScript.TypeScriptCompiler;

        if (typeof localizedDiagnosticMessages == "undefined") {
            localizedDiagnosticMessages = null;
        }
        
        var logger = this.compilationSettings.gatherDiagnostics ? <TypeScript.ILogger>new DiagnosticsLogger(this.ioHost) : new TypeScript.NullLogger();
        compiler = new TypeScript.TypeScriptCompiler(
            this.errorReporter, logger, this.compilationSettings, localizedDiagnosticMessages);
        compiler.setErrorOutput(this.errorReporter);

        compiler.setErrorCallback(
            (minChar, charLen, message, unitIndex) => {
                compiler.errorReporter.hasErrors = true;
                var fname = this.resolvedEnvironment.code[unitIndex].path;
                var lineCol = { line: -1, col: -1 };
                compiler.parser.getSourceLineCol(lineCol, minChar);
                // line is 1-base, col, however, is 0-base. add 1 to the col before printing the message
                var msg = fname + " (" + lineCol.line + "," + (lineCol.col + 1) + "): " + message;
                if (this.compilationSettings.errorRecovery) {
                    this.errorReporter.WriteLine(msg);
                } else {
                    throw new SyntaxError(msg);
                }
            });

        if (this.compilationSettings.emitComments) {
            compiler.emitCommentsToOutput();
        }

        var consumeUnit = (code: TypeScript.SourceUnit, addAsResident: bool) => {
            try {
                // if file resolving is disabled, the file's content will not yet be loaded

                if (!this.compilationSettings.resolve) {
                    code.content = this.ioHost.readFile(code.path);
                    // If declaration files are going to be emitted, 
                    // preprocess the file contents and add in referenced files as well
                    if (this.compilationSettings.generateDeclarationFiles) {
                        TypeScript.CompilerDiagnostics.assert(code.referencedFiles == null, "With no resolve option, referenced files need to null");
                        code.referencedFiles = TypeScript.getReferencedFiles(code);
                    }
                }

                if (code.content != null) {
                    if (this.compilationSettings.errorRecovery) {
                        compiler.parser.setErrorRecovery(this.errorReporter);
                    }

                    compiler.addUnit(code.content, code.path, addAsResident, code.referencedFiles);
                }
            }
            catch (err) {
                compiler.errorReporter.hasErrors = true;
                // This includes syntax errors thrown from error callback if not in recovery mode
                this.errorReporter.WriteLine(err.message);
            }
        }

        for (var iCode = 0 ; iCode < this.resolvedEnvironment.code.length; iCode++) {
            consumeUnit(this.resolvedEnvironment.code[iCode], false);
        }

        var emitterIOHost = {
            createFile: (fileName: string, useUTF8?: bool) => IOUtils.createFileAndFolderStructure(this.ioHost, fileName, useUTF8),
            directoryExists: this.ioHost.directoryExists,
            fileExists: this.ioHost.fileExists,
            resolvePath: this.ioHost.resolvePath
        };

        try {
            if (this.compilationSettings.usePull) {
                compiler.pullTypeCheck();
            }
            else {
                compiler.typeCheck();
                compiler.emit(emitterIOHost);
                compiler.emitDeclarations();
            }
        } catch (err) {
            compiler.errorReporter.hasErrors = true;
            // Catch emitter exceptions
            if (err.message != "EmitError") {
                throw err;
            }
        }

        return compiler.errorReporter.hasErrors;
    }

    // Execute the provided inputs
    public run() {
        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {
            var unit = this.compilationEnvironment.code[i];
            
            var outputFileName: string = unit.path;
            if (TypeScript.isTSFile(outputFileName)) {
                outputFileName = outputFileName.replace(/\.ts$/, ".js");
            } else if (TypeScript.isSTRFile(outputFileName)) {
                outputFileName = outputFileName.replace(/\.str$/, ".js");
            }
            if (this.ioHost.fileExists(outputFileName)) {
                var unitRes = this.ioHost.readFile(outputFileName)
                this.ioHost.run(unitRes, outputFileName);
            }
        }
    }

    /// Begin batch compilation
    public batchCompile() {
        TypeScript.CompilerDiagnostics.diagnosticWriter = { Alert: (s: string) => { this.ioHost.printLine(s); } }

        var code: TypeScript.SourceUnit;

        var opts = new OptionsParser(this.ioHost);

        opts.option('out', {
            usage: 'Concatenate and emit output to single file | Redirect output structure to the directory',
            type: 'file|directory',
            set: (str) => {
                this.compilationSettings.outputOption = str;
            }
        });

        opts.option('style', {
            usage: 'Select style checking options (examples --style requireSemi:off or --style "eqeqeq;bitwise:off")',
            experimental: true,
            set: (str) => {
                this.compilationSettings.setStyleOptions(str);
            }
        });

        opts.flag('sourcemap', {
            usage: 'Generates corresponding .map file',
            set: () => {
                this.compilationSettings.mapSourceFiles = true;
            }
        });

        opts.flag('fullSourceMapPath', {
            usage: 'Writes the full path of map file in the generated js file',
            experimental: true,
            set: () => {
                this.compilationSettings.emitFullSourceMapPath = true;
            }
        });

        opts.flag('declaration', {
            usage: 'Generates corresponding .d.ts file',
            set: () => {
                this.compilationSettings.generateDeclarationFiles = true;
            }
        });

        if (this.ioHost.watchFile) {
            opts.flag('watch', {
                usage: 'Watch output files',
                set: () => {
                    this.compilationSettings.watch = true;
                }
            }, 'w');
        }

        opts.flag('exec', {
            usage: 'Execute the script after compilation',
            set: () => {
                this.compilationSettings.exec = true;
            }
        }, 'e');

        opts.flag('minw', {
            usage: 'Minimize whitespace',
            experimental: true,
            set: () => { this.compilationSettings.minWhitespace = true; }
        }, 'mw');

        opts.flag('const', {
            usage: 'Propagate constants to emitted code',
            experimental: true,
            set: () => { this.compilationSettings.propagateConstants = true; }
        });

        opts.flag('errorrecovery', {
            usage: 'Enable error recovery',
            experimental: true,
            set: () => {
                this.compilationSettings.errorRecovery = true;
            }
        }, 'er');

        opts.flag('comments', {
            usage: 'Emit comments to output',
            set: () => {
                this.compilationSettings.emitComments = true;
            }
        }, 'c');

        opts.flag('cflow', {
            usage: 'Control flow',
            experimental: true,
            set: () => {
                this.compilationSettings.controlFlow = true;
            }
        });

        opts.flag('cflowp', {
            usage: 'Print control flow',
            experimental: true,
            set: () => {
                this.compilationSettings.controlFlow = true;
                this.compilationSettings.printControlFlow = true;
            }
        });

        opts.flag('cflowu', {
            usage: 'Print Use Def control flow',
            experimental: true,
            set: () => {
                this.compilationSettings.controlFlow = true;
                this.compilationSettings.controlFlowUseDef = true;
            }
        });

        opts.flag('noerroronwith', {
            usage: 'Allow with statements',
            experimental: true,
            set: () => {
                this.compilationSettings.errorOnWith = false;
            }
        });

        opts.flag('noresolve', {
            usage: 'Skip resolution and preprocessing',
            experimental: true,
            set: () => {
                this.compilationSettings.resolve = false;
                this.compilationSettings.preprocess = false;
            }
        });

        opts.flag('debug', {
            usage: 'Print debug output',
            experimental: true,
            set: () => {
                TypeScript.CompilerDiagnostics.debug = true;
            }
        });

        opts.flag('canCallDefinitionSignature', {
            usage: 'Allows you to call the definition signature of an overload group',
            experimental: true,
            set: () => {
                this.compilationSettings.canCallDefinitionSignature = true;
            }
        });

        opts.flag('nooptimizemodules', {
            usage: 'Do not optimize module codegen',
            experimental: true,
            set: () => {
                TypeScript.optimizeModuleCodeGen = false;
            }
        });

        opts.flag('nolib', {
            usage: 'Do not include a default lib.d.ts with global declarations',
            set: () => {
                this.compilationSettings.useDefaultLib = false;
            }
        });


        opts.flag('inferProperties', {
            usage: 'Infer class properties from top-level assignments to \'this\'',
            experimental: true,
            set: () => {
                this.compilationSettings.inferPropertiesFromThisAssignment = true;
            }
        });

        opts.flag('diagnostics', {
            usage: 'gather diagnostic info about the compilation process',
            experimental: true,
            set: () => {
                this.compilationSettings.gatherDiagnostics = true;
            }
        });

        opts.flag('pull', {
            usage: 'use "pull model" for typecheck operations',
            experimental: true,
            set: () => {
                this.compilationSettings.usePull = true;
                this.compilationSettings.useFidelity = true;
            }
        });


        opts.option('target', {
            usage: 'Specify ECMAScript target version: "ES3" (default), or "ES5"',
            type: 'VER',
            set: (type) => {
                type = type.toLowerCase();

                if (type === 'es3') {
                    this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES3;
                } else if (type === 'es5') {
                    this.compilationSettings.codeGenTarget = TypeScript.CodeGenTarget.ES5;
                }
                else {
                    this.errorReporter.WriteLine("ECMAScript target version '" + type + "' not supported.  Using default 'ES3' code generation");
                }
            }
        });

        opts.option('module', {
            usage: 'Specify module code generation: "commonjs" (default) or "amd"',
            type: 'kind',
            set: (type) => {
                type = type.toLowerCase();

                if (type === 'commonjs' || type === 'node') {
                    TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;
                } else if (type === 'amd') {
                    TypeScript.moduleGenTarget = TypeScript.ModuleGenTarget.Asynchronous;
                } else {
                    this.errorReporter.WriteLine("Module code generation '" + type + "' not supported.  Using default 'commonjs' code generation");
                }
            }
        });

        var printedUsage = false;

        opts.flag('help', {
            usage: 'Print this message',
            set: () => {
                this.printVersion();
                opts.printUsage();
                printedUsage = true;
            }
        }, 'h');

        opts.flag('useCaseSensitiveFileResolution', {
            usage: 'Force file resolution to be case sensitive',
            experimental: true,
            set: () => {
                this.compilationSettings.useCaseSensitiveFileResolution = true;
            }
        });

        opts.flag('version', {
            usage: 'Print the compiler\'s version: ' + this.compilerVersion,
            set: () => {
                this.printVersion();
            }
        }, 'v');

        opts.flag('fidelity', {
            usage: 'Use the fidelity parser.',
            experimental: true,
            set: () => {
                this.compilationSettings.useFidelity = true;
            }
        });

        opts.parse(this.ioHost.arguments);
        
        if (this.compilationSettings.useDefaultLib) {
            var compilerFilePath = this.ioHost.getExecutingFilePath()
            var binDirPath = this.ioHost.dirName(compilerFilePath);
            var libStrPath = this.ioHost.resolvePath(binDirPath + "/lib.d.ts");
            code = new TypeScript.SourceUnit(libStrPath, null);
            this.compilationEnvironment.code.push(code);
        }

        for (var i = 0; i < opts.unnamed.length; i++) {
            code = new TypeScript.SourceUnit(opts.unnamed[i], null);
            this.compilationEnvironment.code.push(code);
        }

        // If no source files provided to compiler - print usage information
        if (this.compilationEnvironment.code.length == (this.compilationSettings.useDefaultLib ? 1 : 0)) {
            if (!printedUsage && !this.printedVersion) {
                this.printVersion();
                opts.printUsage();
                this.ioHost.quit(1);
            }
            return;
        }

        var sourceFiles: TypeScript.SourceUnit[] = [];
        if (this.compilationSettings.watch) {
            // Capture the state before calling resolve
            sourceFiles = this.compilationEnvironment.code.slice(0);
        }

        // Resolve file dependencies, if requested
        this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;

        this.compile();

        if (!this.errorReporter.hasErrors) {
            if (this.compilationSettings.exec) {
                this.run();
            }
        }

        if (this.compilationSettings.watch) {
            // Watch will cause the program to stick around as long as the files exist
            this.watchFiles(sourceFiles);
        }
        else {  
            // Exit with the appropriate error code
            this.ioHost.quit(this.errorReporter.hasErrors ? 1 : 0);
        }
    }

    public printVersion() {
        if (!this.printedVersion) {
            this.ioHost.printLine("Version " + this.compilerVersion);
            this.printedVersion = true;
        }
    }

    public watchFiles(soruceFiles: TypeScript.SourceUnit[]) {
        if (!this.ioHost.watchFile) {
            this.errorReporter.WriteLine("Error: Current host does not support -w[atch] option");
            return;
        }

        var resolvedFiles: string[] = []
        var watchers: { [x: string]: IFileWatcher; } = {};

        var addWatcher = (filename: string) => {
            if (!watchers[filename]) {
                var watcher = this.ioHost.watchFile(filename, onWatchedFileChange);
                watchers[filename] = watcher;
            }
            else {
                TypeScript.CompilerDiagnostics.debugPrint("Cannot watch file, it is already watched.");
            }
        };

        var removeWatcher = (filename: string) => {
            if (watchers[filename]) {
                watchers[filename].close();
                delete watchers[filename];
            }
            else {
                TypeScript.CompilerDiagnostics.debugPrint("Cannot stop watching file, it is not being watched.");
            }
        };

        var onWatchedFileChange = () => {
            // Reset the state
            this.compilationEnvironment.code = soruceFiles;

            // Clean errors for previous compilation
            this.errorReporter.reset();

            // Resolve file dependencies, if requested
            this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;

            // Check if any new files were added to the environment as a result of the file change
            var oldFiles = resolvedFiles;
            var newFiles: string[] = [];
            this.resolvedEnvironment.code.forEach((sf) => newFiles.push(sf.path));
            newFiles = newFiles.sort();

            var i = 0, j = 0;
            while (i < oldFiles.length && j < newFiles.length) {

                var compareResult = oldFiles[i].localeCompare(newFiles[j]);
                if (compareResult == 0) {
                    // No change here
                    i++;
                    j++;
                }
                else if (compareResult < 0) {
                    // Entry in old list does not exist in the new one, it was removed
                    removeWatcher(oldFiles[i]);
                    i++;
                }
                else {
                    // Entry in new list does exist in the new one, it was added
                    addWatcher(newFiles[j]);
                    j++;
                }
            }

            // All remaining unmatched items in the old list have been removed
            for (var k = i; k < oldFiles.length; k++) {
                removeWatcher(oldFiles[k]);
            }

            // All remaing unmatched items in the new list have been added
            for (var k = j; k < newFiles.length; k++) {
                addWatcher(newFiles[k]);
            }

            // Update the state
            resolvedFiles = newFiles;;

            // Print header
            this.ioHost.printLine("");
            this.ioHost.printLine("Recompiling (" + new Date() + "): ");
            resolvedFiles.forEach((f) => this.ioHost.printLine("    " + f));

            // Trigger a new compilation
            this.compile();

            if (!this.errorReporter.hasErrors) {
                if (this.compilationSettings.exec) {
                    this.run();
                }
            }
        };

        // Switch to using stdout for all error messages
        this.ioHost.stderr = this.ioHost.stdout;

        // Initialize the initial list of resolved files, and add watches to them
        this.resolvedEnvironment.code.forEach((sf) => {
            resolvedFiles.push(sf.path);
            addWatcher(sf.path);
        });
        resolvedFiles.sort();
    }
}

// Start the batch compilation using the current hosts IO
var batch = new BatchCompiler(IO);
batch.batchCompile();
