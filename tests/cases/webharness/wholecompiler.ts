//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export module CompilerDiagnostics {
        export var debug = false;
        export interface IDiagnosticWriter {
            Alert(output: string): void;
        }

        export var diagnosticWriter: IDiagnosticWriter = null;

        export var analysisPass: number = 0;

        export function Alert(output: string) {
            if (diagnosticWriter) {
                diagnosticWriter.Alert(output);
            }
        }

        export function debugPrint(s: string) {
            if (debug) {
                Alert(s);
            }
        }

        export function assert(condition: bool, s: string) {
            if (debug) {
                if (!condition) {
                    Alert(s);
                }
            }
        }

    }

    export interface ILogger {
        information(): bool;
        debug(): bool;
        warning(): bool;
        error(): bool;
        fatal(): bool;
        log(s: string): void;
    }

    export class NullLogger implements ILogger {
        public information(): bool { return false; }
        public debug(): bool { return false; }
        public warning(): bool { return false; }
        public error(): bool { return false; }
        public fatal(): bool { return false; }
        public log(s: string): void {
        }
    }

    export class LoggerAdapter implements ILogger {
        private _information: bool;
        private _debug: bool;
        private _warning: bool;
        private _error: bool;
        private _fatal: bool;

        constructor (public logger: ILogger) { 
            this._information = this.logger.information();
            this._debug = this.logger.debug();
            this._warning = this.logger.warning();
            this._error = this.logger.error();
            this._fatal = this.logger.fatal();
        }


        public information(): bool { return this._information; }
        public debug(): bool { return this._debug; }
        public warning(): bool { return this._warning; }
        public error(): bool { return this._error; }
        public fatal(): bool { return this._fatal; }
        public log(s: string): void {
            this.logger.log(s);
        }
    }

    export class BufferedLogger implements ILogger {
        public logContents = [];

        public information(): bool { return false; }
        public debug(): bool { return false; }
        public warning(): bool { return false; }
        public error(): bool { return false; }
        public fatal(): bool { return false; }
        public log(s: string): void {
            this.logContents.push(s);
        }
    }

    export function timeFunction(logger: ILogger, funcDescription: string, func: () =>any): any {
        var start = +new Date();
        var result = func();
        var end = +new Date();
        logger.log(funcDescription + " completed in " + (end - start) + " msec");
        return result;
    }

    export function stringToLiteral(value: string, length: number): string {
        var result = "";

        var addChar = (index: number) => {
            var ch = value.charCodeAt(index);
            switch (ch) {
                case 0x09: // tab
                    result += "\\t";
                    break;
                case 0x0a: // line feed
                    result += "\\n";
                    break;
                case 0x0b: // vertical tab
                    result += "\\v";
                    break;
                case 0x0c: // form feed
                    result += "\\f";
                    break;
                case 0x0d: // carriage return
                    result += "\\r";
                    break;
                case 0x22:  // double quote
                    result += "\\\"";
                    break;
                case 0x27: // single quote
                    result += "\\\'";
                    break;
                case 0x5c: // Backslash
                    result += "\\";
                    break;
                default:
                    result += value.charAt(index);
            }
        }

        var tooLong = (value.length > length);
        var i = 0;
        if (tooLong) {
            var mid = length >> 1;
            for (i = 0; i < mid; i++) addChar(i);
            result += "(...)";
            for (i = value.length - mid; i < value.length; i++) addChar(i);
        }
        else {
            length = value.length;
            for (i = 0; i < length; i++) addChar(i);
        }
        return result;
    }

    export function getDiagnosticMessage(diagnosticType: PullDiagnosticMessages, args: any[]): string {
        var diagnosticName: string = (<any>PullDiagnosticMessages)._map[diagnosticType];

        var diagnostic = <DiagnosticInfo> typescriptDiagnosticMessages[diagnosticName];

        if (!diagnostic) {
            throw new Error("Invalid diagnostic");
        }
        else {
            var components = diagnosticName.split("_");

            if (components.length) {
                var argCount = parseInt(components[1]);

                if (argCount != args.length) {
                    throw new Error("Expected " + argCount + " arguments to diagnostic, got " + args.length + " instead");
                }
            }
        }

        var diagnosticMessage = diagnostic.message.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined'
                ? args[num]
                : match;
        });

        var message: string;

        if (diagnosticType != PullDiagnosticMessages.error_2 && diagnosticType != PullDiagnosticMessages.warning_2) {
            var errorOrWarning = diagnostic.category == DiagnosticCategory.Error ?
                                    PullDiagnosticMessages.error_2 :
                                    PullDiagnosticMessages.warning_2;

            message = getDiagnosticMessage(errorOrWarning, [diagnostic.code, diagnosticMessage]);
        }
        else {
            message = diagnosticMessage;
        }

        return message;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export function hasFlag(val: number, flag: number) {
        return (val & flag) != 0;
    }

    export enum ASTFlags {
        None = 0,
        ExplicitSemicolon = 1, // statment terminated by an explicit semicolon
        AutomaticSemicolon = 1 << 1, // statment terminated by an automatic semicolon
        Writeable = 1 << 2,  // node is lhs that can be modified
        Error = 1 << 3, // node has an error
        DotLHSPartial = 1 << 4, // node is the lhs of an incomplete dot expr at cursor
        DotLHS = 1 << 5, // node is the lhs of a dot expr
        IsStatement = 1 << 6, // node is a statement
        StrictMode = 1 << 7, // node is in the strict mode environment
        PossibleOptionalParameter = 1 << 8,
        ClassBaseConstructorCall = 1 << 9,
        OptionalName = 1 << 10,
        // REVIEW: This flag is to mark lambda nodes to note that the LParen of an expression has already been matched in the lambda header.
        //         The flag is used to communicate this piece of information to the calling parseTerm, which intern will remove it.
        //         Once we have a better way to associate information with nodes, this flag should not be used.
        SkipNextRParen = 1 << 11,
        TypeReference = 1 << 12,
    }

    export enum DeclFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
    }

    export enum ModuleFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
        IsEnum = 1 << 8,
        ShouldEmitModuleDecl = 1 << 9,
        IsWholeFile = 1 << 10,
        IsDynamic = 1 << 11,
        MustCaptureThis = 1 << 12,
    }

    export enum SymbolFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
        Property = 1 << 8,
        Readonly = 1 << 9,
        ModuleMember = 1 << 10,
        InterfaceMember = 1 << 11,
        ClassMember = 1 << 12,
        BuiltIn = 1 << 13,
        TypeSetDuringScopeAssignment = 1 << 14,
        Constant = 1 << 15,
        Optional = 1 << 16,
        RecursivelyReferenced = 1 << 17,
        Bound = 1 << 18,
        CompilerGenerated = 1 << 19,
    }

    export enum VarFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
        AutoInit = 1 << 8,
        Property = 1 << 9,
        Readonly = 1 << 10,
        Class = 1 << 11,
        ClassProperty = 1 << 12,
        ClassBodyProperty = 1 << 13,
        ClassConstructorProperty = 1 << 14,
        ClassSuperMustBeFirstCallInConstructor = 1 << 15,
        Constant = 1 << 16,
        MustCaptureThis = 1 << 17,
    }

    export enum FncFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
        Signature = 1 << 9,
        Method = 1 << 10,
        HasReturnExpression = 1 << 11,
        CallMember = 1 << 12,
        ConstructMember = 1 << 13,
        HasSelfReference = 1 << 14,
        IsFatArrowFunction = 1 << 15,
        IndexerMember = 1 << 16,
        IsFunctionExpression = 1 << 17,
        ClassMethod = 1 << 18,
        ClassPropertyMethodExported = 1 << 19,
        HasSuperReferenceInFatArrowFunction = 1 << 20,
        IsPropertyBound = 1 << 21,
    }

    export enum SignatureFlags {
        None = 0,
        IsIndexer = 1,
        IsStringIndexer = 1 << 1,
        IsNumberIndexer = 1 << 2,
    }

    export function ToDeclFlags(fncFlags: FncFlags) : DeclFlags;
    export function ToDeclFlags(varFlags: VarFlags) : DeclFlags;
    export function ToDeclFlags(symFlags: SymbolFlags): DeclFlags;
    export function ToDeclFlags(moduleFlags: ModuleFlags): DeclFlags;
    export function ToDeclFlags(fncOrVarOrSymbolOrModuleFlags: any) {
        return <DeclFlags>fncOrVarOrSymbolOrModuleFlags;
    }

    export enum TypeFlags {
        None = 0,
        HasImplementation = 1,
        HasSelfReference = 1 << 1,
        MergeResult = 1 << 2,
        IsEnum = 1 << 3,
        BuildingName = 1 << 4,
        HasBaseType = 1 << 5,
        HasBaseTypeOfObject = 1 << 6,
        IsClass = 1 << 7,
    }

    export enum TypeRelationshipFlags {
        SuccessfulComparison = 0,
        SourceIsNullTargetIsVoidOrUndefined = 1,
        RequiredPropertyIsMissing = 1 << 1,
        IncompatibleSignatures = 1 << 2,
        SourceSignatureHasTooManyParameters = 3,
        IncompatibleReturnTypes = 1 << 4,
        IncompatiblePropertyTypes = 1 << 5,
        IncompatibleParameterTypes = 1 << 6,
    }

    export enum ModuleGenTarget {
        Synchronous = 0,
        Asynchronous = 1,
        Local = 1 << 1,
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    // Note: Any addition to the NodeType should also be supported with addition to AstWalkerDetailCallback
    export enum NodeType {
        None,
        Empty,
        EmptyExpr,
        True,
        False,
        This,
        Super,
        QString,
        Regex,
        Null,
        ArrayLit,
        ObjectLit,
        Void,
        Comma,
        Pos,
        Neg,
        Delete,
        Await,
        In,
        Dot,
        From,
        Is,
        InstOf,
        Typeof,
        NumberLit,
        Name,
        TypeParameter,
        GenericType,
        TypeRef,
        Index,
        Call,
        New,
        Asg,
        AsgAdd,
        AsgSub,
        AsgDiv,
        AsgMul,
        AsgMod,
        AsgAnd,
        AsgXor,
        AsgOr,
        AsgLsh,
        AsgRsh,
        AsgRs2,
        ConditionalExpression,
        LogOr,
        LogAnd,
        Or,
        Xor,
        And,
        Eq,
        Ne,
        Eqv,
        NEqv,
        Lt,
        Le,
        Gt,
        Ge,
        Add,
        Sub,
        Mul,
        Div,
        Mod,
        Lsh,
        Rsh,
        Rs2,
        Not,
        LogNot,
        IncPre,
        DecPre,
        IncPost,
        DecPost,
        TypeAssertion,
        FuncDecl,
        Member,
        VarDecl,
        ArgDecl,
        Return,
        Break,
        Continue,
        Throw,
        For,
        ForIn,
        If,
        While,
        DoWhile,
        Block,
        Case,
        Switch,
        Try,
        TryCatch,
        TryFinally,
        Finally,
        Catch,
        List,
        Script,
        ClassDeclaration,
        InterfaceDeclaration,
        ModuleDeclaration,
        ImportDeclaration,
        ExportAssignment,
        With,
        Label,
        LabeledStatement,
        EBStart,
        GotoEB,
        EndCode,
        Error,
        Comment,
        Debugger,
        GeneralNode = FuncDecl,
        LastAsg = AsgRs2,
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export class BlockIntrinsics {
        public prototype = undefined;
        public toString = undefined;
        public toLocaleString = undefined;
        public valueOf = undefined;
        public hasOwnProperty = undefined;
        public propertyIsEnumerable = undefined;
        public isPrototypeOf = undefined;

        constructor () {
            // initialize the 'constructor' field
            this["constructor"] = undefined;
        }
    }

    export interface IHashTable {
        getAllKeys(): string[];
        add(key: string, data): bool;
        addOrUpdate(key: string, data): bool;
        map(fn: (k: string, value: any, context: any) => void , context: any): void;
        every(fn: (k: string, value: any, context: any) => void , context: any): bool;
        some(fn: (k: string, value: any, context: any) => void , context: any): bool;
        count(): number;
        lookup(key: string): any;
    }

    export class StringHashTable implements IHashTable {
        public itemCount = 0;
        public table: any = new BlockIntrinsics();

        public getAllKeys(): string[] {
            var result: string[] = [];

            for (var k in this.table) {
                if (this.table[k] !== undefined) {
                    result.push(k);
                }
            }

            return result;
        }

        public add(key: string, data): bool {
            if (this.table[key] !== undefined) {
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        }

        public addOrUpdate(key: string, data): bool {
            if (this.table[key] !== undefined) {
                this.table[key] = data;
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        }

        public map(fn: (k: string, value: any, context: any) => void , context: any) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    fn(k, this.table[k], context);
                }
            }
        }

        public every(fn: (k: string, value: any, context: any) => void , context: any) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (!fn(k, this.table[k], context)) {
                        return false;
                    }
                }
            }

            return true;
        }

        public some(fn: (k: string, value: any, context: any) => void , context: any) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (fn(k, this.table[k], context)) {
                        return true;
                    }
                }
            }

            return false;
        }

        public count(): number {
            return this.itemCount;
        }

        public lookup(key: string) {
            var data = this.table[key];
            return data === undefined ? null : data;
        }
    }

    // The resident table is expected to reference the same table object, whereas the 
    // transientTable may reference different objects over time
    // REVIEW:  WARNING:  For performance reasons, neither the primary nor secondary table may be null
    export class DualStringHashTable implements IHashTable {

        public insertPrimary = true;

        constructor (public primaryTable: IHashTable,
                                        public secondaryTable: IHashTable) { }

        public getAllKeys(): string[]{
            return this.primaryTable.getAllKeys().concat(this.secondaryTable.getAllKeys());
        }

        public add(key: string, data): bool {
            if (this.insertPrimary) {
                return this.primaryTable.add(key, data);
            }
            else {
                return this.secondaryTable.add(key, data);
            }
        }

        public addOrUpdate(key: string, data): bool {
            if (this.insertPrimary) {
                return this.primaryTable.addOrUpdate(key, data);
            }
            else {
                return this.secondaryTable.addOrUpdate(key, data);
            }
        }

        public map(fn: (k: string, v, c) => void , context) {
            this.primaryTable.map(fn, context);
            this.secondaryTable.map(fn, context);
        }

        public every(fn: (k: string, v, c) => bool, context) {
            return this.primaryTable.every(fn, context) && this.secondaryTable.every(fn, context);
        }

        public some(fn: (k: string, v, c) => bool, context) {
            return this.primaryTable.some(fn, context) || this.secondaryTable.some(fn, context);
        }

        public count() {
            return this.primaryTable.count() + this.secondaryTable.count();
        }

        public lookup(key: string) {
            var data = this.primaryTable.lookup(key);
            if (data != undefined) {
                return data;
            }
            else {
                return this.secondaryTable.lookup(key);
            }
        }
    }

    export function numberHashFn(key: number): number {
        var c2 = 0x27d4eb2d; // a prime or an odd constant
        key = (key ^ 61) ^ (key >>> 16);
        key = key + (key << 3);
        key = key ^ (key >>> 4);
        key = key * c2;
        key = key ^ (key >>> 15);
        return key;
    }

    export function combineHashes(key1: number, key2: number) {
        return key2 ^ ((key1 >> 5) + key1);
    }

    export class HashEntry {
        public next: HashEntry;

        constructor (public key, public data) { }
    }

    export class HashTable {
        public itemCount: number = 0;
        public table: HashEntry[] = [];

        constructor (public size: number, public hashFn: (key) =>number,
                    public equalsFn: (key1, key2) =>bool) {
            for (var i: number = 0; i < this.size; i++) {
                this.table[i] = null;
            }
        }

        public add(key, data): bool {
            var current: HashEntry;
            var entry: HashEntry = new HashEntry(key, data);
            var val: number = this.hashFn(key);
            val = val % this.size;

            for (current = this.table[val]; current != null ; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    return false;
                }
            }
            entry.next = this.table[val];
            this.table[val] = entry;
            this.itemCount++;
            return true;
        }

        public remove(key) {
            var current: HashEntry;
            var val: number = this.hashFn(key);
            val = val % this.size;
            var result = null;
            var prevEntry: HashEntry = null;

            for (current = this.table[val]; current != null ; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    result = current.data;
                    this.itemCount--;
                    if (prevEntry) {
                        prevEntry.next = current.next;
                    }
                    else {
                        this.table[val] = current.next;
                    }
                    break;
                }
                prevEntry = current;
            }
            return result;
        }

        public count(): number { return this.itemCount; }

        public lookup(key) {
            var current: HashEntry;
            var val: number = this.hashFn(key);
            val = val % this.size;
            for (current = this.table[val]; current != null ; current = current.next) {
                if (this.equalsFn(key, current.key)) {
                    return (current.data);
                }
            }
            return (null);
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export interface IASTSpan {
        minChar: number;
        limChar: number;
    }

    export class ASTSpan implements IASTSpan {
        public minChar: number = -1;  // -1 = "undefined" or "compiler generated"
        public limChar: number = -1;  // -1 = "undefined" or "compiler generated"   
    }

    export var astID = 0;

    export class AST implements IASTSpan {
        public minChar: number = -1;  // -1 = "undefined" or "compiler generated"
        public limChar: number = -1;  // -1 = "undefined" or "compiler generated"   

        public type: Type = null;
        public flags = ASTFlags.Writeable;

        public typeCheckPhase = -1;

        private astID = astID++;

        // REVIEW: for diagnostic purposes
        public passCreated: number = CompilerDiagnostics.analysisPass;

        public preComments: Comment[] = null;
        public postComments: Comment[] = null;
        private docComments: Comment[] = null;

        public isParenthesized = false;

        constructor (public nodeType: NodeType) {
        }

        public getLength() { return this.limChar - this.minChar; }

        public getID() { return this.astID; }

        public isExpression() { return false; }

        public isStatementOrExpression() { return false; }

        public isCompoundStatement() { return false; }

        public isLeaf() { return this.isStatementOrExpression() && (!this.isCompoundStatement()); }
        
        public isDeclaration() { return false; }

        public typeCheck(typeFlow: TypeFlow) {
            switch (this.nodeType) {
                case NodeType.Error:
                case NodeType.EmptyExpr:
                    this.type = typeFlow.anyType;
                    break;
                case NodeType.This:
                    return typeFlow.typeCheckThis(this);
                case NodeType.Null:
                    this.type = typeFlow.nullType;
                    break;
                case NodeType.False:
                case NodeType.True:
                    this.type = typeFlow.booleanType;
                    break;
                case NodeType.Super:
                    return typeFlow.typeCheckSuper(this);
                case NodeType.EndCode:
                case NodeType.Empty:
                case NodeType.Void:
                    this.type = typeFlow.voidType;
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            switch (this.nodeType) {
                case NodeType.This:
                    emitter.recordSourceMappingStart(this);
                    if (emitter.thisFnc && (hasFlag(emitter.thisFnc.fncFlags, FncFlags.IsFatArrowFunction))) {
                        emitter.writeToOutput("_this");
                    }
                    else {
                        emitter.writeToOutput("this");
                    }
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.Null:
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("null");
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.False:
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("false");
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.True:
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("true");
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.Super:
                    emitter.recordSourceMappingStart(this);
                    emitter.emitSuperReference();
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.EndCode:
                case NodeType.Error:
                case NodeType.EmptyExpr:
                    break;
                case NodeType.Empty:
                    emitter.recordSourceMappingStart(this);
                    emitter.recordSourceMappingEnd(this);
                    break;
                case NodeType.Void:
                    emitter.recordSourceMappingStart(this);
                    emitter.writeToOutput("void ");
                    emitter.recordSourceMappingEnd(this);
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public print(context: PrintContext) {
            context.startLine();
            var lineCol = { line: -1, character: -1 };
            var limLineCol = { line: -1, character: -1 };

            var lab = this.printLabel();
            if (hasFlag(this.flags, ASTFlags.Error)) {
                lab += " (Error)";
            }
            context.writeLine(lab);
        }

        public printLabel() {
            if (nodeTypeTable[this.nodeType] !== undefined) {
                return nodeTypeTable[this.nodeType];
            }
            else {
                return (<any>NodeType)._map[this.nodeType];
            }
        }

        public addToControlFlow(context: ControlFlowContext): void {
            // by default, AST adds itself to current basic block and does not check its children
            context.walker.options.goChildren = false;
            context.addContent(this);
        }

        public netFreeUses(container: Symbol, freeUses: StringHashTable) {
        }

        public treeViewLabel() {
            return (<any>NodeType)._map[this.nodeType];
        }

        public static getResolvedIdentifierName(name: string): string {
            if (!name) return "";

            var resolved = "";
            var start = 0;
            var i = 0;
            while(i <= name.length - 6) {
                // Look for escape sequence \uxxxx
                if (name.charAt(i) === '\\' && name.charAt(i+1) === 'u') {
                    var charCode = parseInt(name.substr(i + 2, 4), 16);
                    resolved += name.substr(start, i - start);
                    resolved += String.fromCharCode(charCode);
                    i += 6;
                    start = i;
                    continue;
                } 
                i++;
            }
            // Append remaining string
            resolved += name.substring(start);
            return resolved;
        }

        public getDocComments() : Comment[] {
            if (!this.isDeclaration() || !this.preComments || this.preComments.length === 0) {
                return [];
            }

            if (!this.docComments) {
                var preCommentsLength = this.preComments.length;
                var docComments: Comment[] = [];
                for (var i = preCommentsLength - 1; i >= 0; i--) {
                    if (this.preComments[i].isDocComment()) {
                        var prevDocComment = docComments.length > 0 ? docComments[docComments.length - 1] : null;
                        if (prevDocComment === null || // If the help comments were not yet set then this is the comment
                             (this.preComments[i].limLine === prevDocComment.minLine ||
                              this.preComments[i].limLine + 1 === prevDocComment.minLine)) { // On same line or next line
                            docComments.push(this.preComments[i]);
                            continue;
                        }
                    }
                    break;
                }

                this.docComments = docComments.reverse();
            }

            return this.docComments;
        }
    }

    export class IncompleteAST extends AST {
        constructor (min: number, lim: number) {
            super(NodeType.Error);

            this.minChar = min;
            this.limChar = lim;
        }
    }

    export class ASTList extends AST {
        public enclosingScope: SymbolScope = null;
        public members: AST[] = [];

        constructor () {
            super(NodeType.List);
        }

        public addToControlFlow(context: ControlFlowContext) {
            var len = this.members.length;
            for (var i = 0; i < len; i++) {
                if (context.noContinuation) {
                    context.addUnreachable(this.members[i]);
                    break;
                }
                else {
                    this.members[i] = context.walk(this.members[i], this);
                }
            }
            context.walker.options.goChildren = false;
        }

        public append(ast: AST) {
            this.members[this.members.length] = ast;
            return this;
        }

        public appendAll(ast: AST) {
            if (ast.nodeType === NodeType.List) {
                var list = <ASTList>ast;
                for (var i = 0, len = list.members.length; i < len; i++) {
                    this.append(list.members[i]);
                }
            }
            else {
                this.append(ast);
            }
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascriptList(this, null, TokenID.Semicolon, startLine, false, false);
            emitter.recordSourceMappingEnd(this);
        }

        public typeCheck(typeFlow: TypeFlow) {
            var len = this.members.length;
            typeFlow.nestingLevel++;
            for (var i = 0; i < len; i++) {
                if (this.members[i]) {
                    this.members[i] = this.members[i].typeCheck(typeFlow);
                }
            }
            typeFlow.nestingLevel--;
            return this;
        }
    }

    export class Identifier extends AST {
        public sym: Symbol = null;
        public cloId = -1;
        public text: string;

        // 'actualText' is the text that the user has entered for the identifier. the text might 
        // include any Unicode escape sequences (e.g.: \u0041 for 'A'). 'text', however, contains 
        // the resolved value of any escape sequences in the actual text; so in the previous 
        // example, actualText = '\u0041', text = 'A'.
        //
        // For purposes of finding a symbol, use text, as this will allow you to match all 
        // variations of the variable text. For full-fidelity translation of the user input, such
        // as emitting, use the actualText field.
        // 
        // Note: 
        //    To change text, and to avoid running into a situation where 'actualText' does not 
        //    match 'text', always use setText.
        constructor (public actualText: string, public hasEscapeSequence?: bool) {
            super(NodeType.Name);
            this.setText(actualText, hasEscapeSequence);
        }

        public setText(actualText: string, hasEscapeSequence?: bool) {
            this.actualText = actualText;
            if (hasEscapeSequence) {
                this.text = AST.getResolvedIdentifierName(actualText);
            }
            else {
                this.text = actualText;
            }
        }

        public isMissing() { return false; }
        public isLeaf() { return true; }

        public treeViewLabel() {
            return "id: " + this.actualText;
        }

        public printLabel() {
            if (this.actualText) {
                return "id: " + this.actualText;
            }
            else {
                return "name node";
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckName(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitJavascriptName(this, true);
        }

        public static fromToken(token: Token): Identifier {
            return new Identifier(token.getText(), (<IdentifierToken>token).hasEscapeSequence);
        }
    }

    export class MissingIdentifier extends Identifier {
        constructor () {
            super("__missing");
        }

        public isMissing() {
            return true;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            // Emit nothing for a missing ID
        }
    }

    export class Label extends AST {
        constructor (public id: Identifier) {
            super(NodeType.Label);
        }

        public printLabel() { return this.id.actualText + ":"; }

        public typeCheck(typeFlow: TypeFlow) {
            this.type = typeFlow.voidType;
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.recordSourceMappingStart(this.id);
            emitter.writeToOutput(this.id.actualText);
            emitter.recordSourceMappingEnd(this.id);
            emitter.writeLineToOutput(":");
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class Expression extends AST {
        constructor (nodeType: NodeType) {
            super(nodeType);
        }

        public isExpression() { return true; }

        public isStatementOrExpression() { return true; }
    }

    export class UnaryExpression extends Expression {
        public targetType: Type = null; // Target type for an object literal (null if no target type)
        public castTerm: AST = null;

        constructor (nodeType: NodeType, public operand: AST) {
            super(nodeType);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            super.addToControlFlow(context);
            // TODO: add successor as catch block/finally block if present
            if (this.nodeType === NodeType.Throw) {
                context.returnStmt();
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
            switch (this.nodeType) {
                case NodeType.Not:
                    return typeFlow.typeCheckBitNot(this);

                case NodeType.LogNot:
                    return typeFlow.typeCheckLogNot(this);

                case NodeType.Pos:
                case NodeType.Neg:
                    return typeFlow.typeCheckUnaryNumberOperator(this);

                case NodeType.IncPost:
                case NodeType.IncPre:
                case NodeType.DecPost:
                case NodeType.DecPre:
                    return typeFlow.typeCheckIncOrDec(this);

                case NodeType.ArrayLit:
                    typeFlow.typeCheckArrayLit(this);
                    return this;

                case NodeType.ObjectLit:
                    typeFlow.typeCheckObjectLit(this);
                    return this;

                case NodeType.Throw:
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.voidType;
                    return this;

                case NodeType.Typeof:
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.stringType;
                    return this;

                case NodeType.Delete:
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.booleanType;
                    break;

                case NodeType.TypeAssertion:
                    this.castTerm = typeFlow.typeCheck(this.castTerm);
                    var applyTargetType = !this.operand.isParenthesized;

                    var targetType = applyTargetType ? this.castTerm.type : null;

                    typeFlow.checker.typeCheckWithContextualType(targetType, typeFlow.checker.inProvisionalTypecheckMode(), true, this.operand);
                    typeFlow.castWithCoercion(this.operand, this.castTerm.type, false, true);
                    this.type = this.castTerm.type;
                    return this;

                case NodeType.Void:
                    // REVIEW - Although this is good to do for completeness's sake,
                    // this shouldn't be strictly necessary from the void operator's
                    // point of view
                    this.operand = typeFlow.typeCheck(this.operand);
                    this.type = typeFlow.checker.undefinedType;
                    break;

                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            switch (this.nodeType) {
                case NodeType.IncPost:
                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);
                    emitter.writeToOutput("++");
                    break;
                case NodeType.LogNot:
                    emitter.writeToOutput("!");
                    emitter.emitJavascript(this.operand, TokenID.Exclamation, false);
                    break;
                case NodeType.DecPost:
                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);
                    emitter.writeToOutput("--");
                    break;
                case NodeType.ObjectLit:
                    emitter.emitObjectLiteral(<ASTList>this.operand);
                    break;
                case NodeType.ArrayLit:
                    emitter.emitArrayLiteral(<ASTList>this.operand);
                    break;
                case NodeType.Not:
                    emitter.writeToOutput("~");
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    break;
                case NodeType.Neg:
                    emitter.writeToOutput("-");
                    if (this.operand.nodeType === NodeType.Neg) {
                        this.operand.isParenthesized = true;
                    }
                    emitter.emitJavascript(this.operand, TokenID.Minus, false);
                    break;
                case NodeType.Pos:
                    emitter.writeToOutput("+");
                    if (this.operand.nodeType === NodeType.Pos) {
                        this.operand.isParenthesized = true;
                    }
                    emitter.emitJavascript(this.operand, TokenID.Plus, false);
                    break;
                case NodeType.IncPre:
                    emitter.writeToOutput("++");
                    emitter.emitJavascript(this.operand, TokenID.PlusPlus, false);
                    break;
                case NodeType.DecPre:
                    emitter.writeToOutput("--");
                    emitter.emitJavascript(this.operand, TokenID.MinusMinus, false);
                    break;
                case NodeType.Throw:
                    emitter.writeToOutput("throw ");
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    emitter.writeToOutput(";");
                    break;
                case NodeType.Typeof:
                    emitter.writeToOutput("typeof ");
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    break;
                case NodeType.Delete:
                    emitter.writeToOutput("delete ");
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    break;
                case NodeType.Void:
                    emitter.writeToOutput("void ");
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    break;
                case NodeType.TypeAssertion:
                    emitter.emitJavascript(this.operand, TokenID.Tilde, false);
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class CallExpression extends Expression {
        constructor (nodeType: NodeType,
                     public target: AST,
                     public typeArguments: ASTList,
                     public arguments: ASTList) {
            super(nodeType);
            this.minChar = this.target.minChar;
        }

        public signature: Signature = null;

        public typeCheck(typeFlow: TypeFlow) {
            if (this.nodeType === NodeType.New) {
                return typeFlow.typeCheckNew(this);
            }
            else {
                return typeFlow.typeCheckCall(this);
            }
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);

            if (this.nodeType === NodeType.New) {
                emitter.emitNew(this.target, this.arguments);
            }
            else {
                emitter.emitCall(this, this.target, this.arguments);
            }

            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class BinaryExpression extends Expression {
        constructor (nodeType: NodeType, public operand1: AST, public operand2: AST) {
            super(nodeType);
        }

        public typeCheck(typeFlow: TypeFlow) {
            switch (this.nodeType) {
                case NodeType.Dot:
                    return typeFlow.typeCheckDotOperator(this);
                case NodeType.Asg:
                    return typeFlow.typeCheckAsgOperator(this);
                case NodeType.Add:
                case NodeType.Sub:
                case NodeType.Mul:
                case NodeType.Div:
                case NodeType.Mod:
                case NodeType.Or:
                case NodeType.And:
                    return typeFlow.typeCheckArithmeticOperator(this, false);
                case NodeType.Xor:
                    return typeFlow.typeCheckBitwiseOperator(this, false);
                case NodeType.Ne:
                case NodeType.Eq:
                    var text: string;
                    if (typeFlow.checker.styleSettings.eqeqeq) {
                        text = nodeTypeTable[this.nodeType];
                        typeFlow.checker.errorReporter.styleError(this, "use of " + text);
                    }
                    else if (typeFlow.checker.styleSettings.eqnull) {
                        text = nodeTypeTable[this.nodeType];
                        if ((this.operand2 !== null) && (this.operand2.nodeType === NodeType.Null)) {
                            typeFlow.checker.errorReporter.styleError(this, "use of " + text + " to compare with null");
                        }
                    }
                case NodeType.Eqv:
                case NodeType.NEqv:
                case NodeType.Lt:
                case NodeType.Le:
                case NodeType.Ge:
                case NodeType.Gt:
                    return typeFlow.typeCheckBooleanOperator(this);
                case NodeType.Index:
                    return typeFlow.typeCheckIndex(this);
                case NodeType.Member:
                    this.type = typeFlow.voidType;
                    return this;
                case NodeType.LogOr:
                    return typeFlow.typeCheckLogOr(this);
                case NodeType.LogAnd:
                    return typeFlow.typeCheckLogAnd(this);
                case NodeType.AsgAdd:
                case NodeType.AsgSub:
                case NodeType.AsgMul:
                case NodeType.AsgDiv:
                case NodeType.AsgMod:
                case NodeType.AsgOr:
                case NodeType.AsgAnd:
                    return typeFlow.typeCheckArithmeticOperator(this, true);
                case NodeType.AsgXor:
                    return typeFlow.typeCheckBitwiseOperator(this, true);
                case NodeType.Lsh:
                case NodeType.Rsh:
                case NodeType.Rs2:
                    return typeFlow.typeCheckShift(this, false);
                case NodeType.AsgLsh:
                case NodeType.AsgRsh:
                case NodeType.AsgRs2:
                    return typeFlow.typeCheckShift(this, true);
                case NodeType.Comma:
                    return typeFlow.typeCheckCommaOperator(this);
                case NodeType.InstOf:
                    return typeFlow.typeCheckInstOf(this);
                case NodeType.In:
                    return typeFlow.typeCheckInOperator(this);
                case NodeType.From:
                    typeFlow.checker.errorReporter.simpleError(this, "Illegal use of 'from' keyword in binary expression");
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            var binTokenId = nodeTypeToTokTable[this.nodeType];

            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.nodeType != NodeType.Comma && binTokenId != undefined) {
                emitter.emitJavascript(this.operand1, binTokenId, false);

                if (tokenTable[binTokenId].text === "instanceof") {
                    emitter.writeToOutput(" instanceof ");
                }
                else if (tokenTable[binTokenId].text === "in") {
                    emitter.writeToOutput(" in ");
                }
                else {
                    emitter.writeToOutputTrimmable(" " + tokenTable[binTokenId].text + " ");
                }

                emitter.emitJavascript(this.operand2, binTokenId, false);
            }
            else {
                switch (this.nodeType) {
                    case NodeType.Dot:
                        if (!emitter.tryEmitConstant(this)) {
                            emitter.emitJavascript(this.operand1, TokenID.Dot, false);
                            emitter.writeToOutput(".");
                            emitter.emitJavascriptName(<Identifier>this.operand2, false);
                        }
                        break;
                    case NodeType.Index:
                        emitter.emitIndex(this.operand1, this.operand2);
                        break;

                    case NodeType.Member:
                        if (this.operand2.nodeType === NodeType.FuncDecl && (<FuncDecl>this.operand2).isAccessor()) {
                            var funcDecl = <FuncDecl>this.operand2;
                            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                                emitter.writeToOutput("get ");
                            }
                            else {
                                emitter.writeToOutput("set ");
                            }
                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);
                        }
                        else {
                            emitter.emitJavascript(this.operand1, TokenID.Colon, false);
                            emitter.writeToOutputTrimmable(": ");
                        }
                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);
                        break;
                    case NodeType.Comma:
                        emitter.emitJavascript(this.operand1, TokenID.Comma, false);
                        if (emitter.emitState.inObjectLiteral) {
                            emitter.writeLineToOutput(", ");
                        }
                        else {
                            emitter.writeToOutput(", ");
                        }
                        emitter.emitJavascript(this.operand2, TokenID.Comma, false);
                        break;
                    case NodeType.Is:
                        throw new Error("should be de-sugared during type check");
                    default:
                        throw new Error("please implement in derived class");
                }
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class ConditionalExpression extends Expression {
        constructor (public operand1: AST,
                     public operand2: AST,
                     public operand3: AST) {
            super(NodeType.ConditionalExpression);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckQMark(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascript(this.operand1, TokenID.Question, false);
            emitter.writeToOutput(" ? ");
            emitter.emitJavascript(this.operand2, TokenID.Question, false);
            emitter.writeToOutput(" : ");
            emitter.emitJavascript(this.operand3, TokenID.Question, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class NumberLiteral extends Expression {
        constructor (public value: number, public text: string) {
            super(NodeType.NumberLit);
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.type = typeFlow.doubleType;
            return this;
        }

        public treeViewLabel() {
            return "num: " + this.printLabel();
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public printLabel(): string {
            return this.text;
        }
    }

    export class RegexLiteral extends Expression {
        constructor (public text: string) {
            super(NodeType.Regex);
        }
        
        public typeCheck(typeFlow: TypeFlow) {
            this.type = typeFlow.regexType;
            return this;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class StringLiteral extends Expression {
        constructor (public text: string) {
            super(NodeType.QString);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitStringLiteral(this.text);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.type = typeFlow.stringType;
            return this;
        }

        public treeViewLabel() {
            return "st: " + this.text;
        }

        public printLabel() {
            return this.text;
        }
    }

    export class ModuleElement extends AST {
        constructor (nodeType: NodeType) {
            super(nodeType);
        }
    }

    export class ImportDeclaration extends ModuleElement {
        public isStatementOrExpression() { return true; }
        public varFlags = VarFlags.None;
        public isDynamicImport = false;
        public isDeclaration() { return true; }

        constructor (public id: Identifier, public alias: AST) {
            super(NodeType.ImportDeclaration);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            var mod = <ModuleType>this.alias.type;
            // REVIEW: Only modules may be aliased for now, though there's no real
            // restriction on what the type symbol may be
            if (emitter.importStatementShouldBeEmitted(this)) {
                var prevModAliasId = emitter.modAliasId;
                var prevFirstModAlias = emitter.firstModAlias;

                emitter.recordSourceMappingStart(this);
                emitter.emitParensAndCommentsInPlace(this, true);
                emitter.writeToOutput("var " + this.id.actualText + " = ");
                emitter.modAliasId = this.id.actualText;
                emitter.firstModAlias = this.firstAliasedModToString();
                var aliasAST = this.alias.nodeType == NodeType.TypeRef ? (<TypeReference>this.alias).term : this.alias;

                emitter.emitJavascript(aliasAST, TokenID.Tilde, false);
                // the dynamic import case will insert the semi-colon automatically
                if (!this.isDynamicImport) {
                    emitter.writeToOutput(";");
                }
                emitter.emitParensAndCommentsInPlace(this, false);
                emitter.recordSourceMappingEnd(this);

                emitter.modAliasId = prevModAliasId;
                emitter.firstModAlias = prevFirstModAlias;
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckImportDecl(this);
        }

        public getAliasName(aliasAST?: AST = this.alias) : string {
            if (aliasAST.nodeType === NodeType.Name) {
                return (<Identifier>aliasAST).actualText;
            } else {
                var dotExpr = <BinaryExpression>aliasAST;
                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);
            }
        }

        public firstAliasedModToString() {
            if (this.alias.nodeType === NodeType.Name) {
                return (<Identifier>this.alias).actualText;
            }
            else {
                var dotExpr = <TypeReference>this.alias;
                var firstMod = <Identifier>(<BinaryExpression>dotExpr.term).operand1;
                return firstMod.actualText;
            }
        }
    }

    export class ExportAssignment extends ModuleElement {
        constructor(public id: Identifier) {
            super(NodeType.ExportAssignment);
        }
    }

    export class BoundDecl extends AST {
        public init: AST = null;
        public typeExpr: AST = null;
        public varFlags = VarFlags.None;
        public sym: Symbol = null;
        public isDeclaration() { return true; }

        constructor (public id: Identifier, nodeType: NodeType, public nestingLevel: number) {
            super(nodeType);
        }

        public isStatementOrExpression() { return true; }

        public isPrivate() { return hasFlag(this.varFlags, VarFlags.Private); }
        public isPublic() { return hasFlag(this.varFlags, VarFlags.Public); }
        public isProperty() { return hasFlag(this.varFlags, VarFlags.Property); }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckBoundDecl(this);
        }

        public printLabel() {
            return this.treeViewLabel();
        }
    }

    export class VarDecl extends BoundDecl {
        constructor (id: Identifier, nest: number) {
            super(id, NodeType.VarDecl, nest);
        }

        public isAmbient() { return hasFlag(this.varFlags, VarFlags.Ambient); }
        public isExported() { return hasFlag(this.varFlags, VarFlags.Exported); }
        public isStatic() { return hasFlag(this.varFlags, VarFlags.Static); }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitJavascriptVarDecl(this, tokenId);
        }

        public treeViewLabel() {
            return "var " + this.id.actualText;
        }
    }

    export class ArgDecl extends BoundDecl {
        constructor (id: Identifier) {
            super(id, NodeType.ArgDecl, 0);
        }

        public isOptional = false;

        public isOptionalArg() { return this.isOptional || this.init; }

        public treeViewLabel() {
            return "arg: " + this.id.actualText;
        }

        public parameterPropertySym: FieldSymbol = null;

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(this.id.actualText);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    var internalId = 0;

    export class FuncDecl extends AST {
        public hint: string = null;
        public fncFlags = FncFlags.None;
        public returnTypeAnnotation: AST = null;
        public symbols: IHashTable;
        public variableArgList = false;
        public signature: Signature;
        public envids: Identifier[];
        public jumpRefs: Identifier[] = null;
        public internalNameCache: string = null;
        public tmp1Declared = false;
        public enclosingFnc: FuncDecl = null;
        public freeVariables: Symbol[] = [];
        public fileName = unknownLocationInfo.fileName;
        public classDecl: NamedDeclaration = null;
        public boundToProperty: VarDecl = null;
        public isOverload = false;
        public innerStaticFuncs: FuncDecl[] = [];
        public isInlineCallLiteral = false;
        public accessorSymbol: Symbol = null;
        public leftCurlyCount = 0;
        public rightCurlyCount = 0;
        public returnStatementsWithExpressions: ReturnStatement[] = [];
        public scopeType: Type = null; // Type of the FuncDecl, before target typing
        public endingToken: ASTSpan = null;
        public isDeclaration() { return true; }
        public constructorSpan: ASTSpan = null;

        constructor(public name: Identifier,
                    public bod: ASTList,
                    public isConstructor: bool,
                    public typeArguments: ASTList,
                    public arguments: ASTList,
                    public vars: ASTList,
                    public scopes: ASTList,
                    public statics: ASTList,
                    nodeType: number) {

            super(nodeType);
        }

        public internalName(): string {
            if (this.internalNameCache === null) {
                var extName = this.getNameText();
                if (extName) {
                    this.internalNameCache = "_internal_" + extName;
                }
                else {
                    this.internalNameCache = "_internal_" + internalId++;
                }
            }
            return this.internalNameCache;
        }

        public hasSelfReference() { return hasFlag(this.fncFlags, FncFlags.HasSelfReference); }
        public setHasSelfReference() { this.fncFlags |= FncFlags.HasSelfReference; }

        public hasSuperReferenceInFatArrowFunction() { return hasFlag(this.fncFlags, FncFlags.HasSuperReferenceInFatArrowFunction); }
        public setHasSuperReferenceInFatArrowFunction() { this.fncFlags |= FncFlags.HasSuperReferenceInFatArrowFunction; }

        public addCloRef(id: Identifier, sym: Symbol): number {
            if (this.envids === null) {
                this.envids = [];
            }
            this.envids[this.envids.length] = id;
            var outerFnc = this.enclosingFnc;
            if (sym) {
                while (outerFnc && (outerFnc.type.symbol != sym.container)) {
                    outerFnc.addJumpRef(sym);
                    outerFnc = outerFnc.enclosingFnc;
                }
            }
            return this.envids.length - 1;
        }

        public addJumpRef(sym: Symbol): void {
            if (this.jumpRefs === null) {
                this.jumpRefs = [];
            }
            var id = new Identifier(sym.name);
            this.jumpRefs[this.jumpRefs.length] = id;
            id.sym = sym;
            id.cloId = this.addCloRef(id, null);
        }

        public buildControlFlow(): ControlFlowContext {
            var entry = new BasicBlock();
            var exit = new BasicBlock();

            var context = new ControlFlowContext(entry, exit);

            var controlFlowPrefix = (ast: AST, parent: AST, walker: IAstWalker) => {
                ast.addToControlFlow(walker.state);
                return ast;
            }

            var walker = getAstWalkerFactory().getWalker(controlFlowPrefix, null, null, context);
            context.walker = walker;
            walker.walk(this.bod, this);

            return context;
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckFunction(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitJavascriptFunction(this);
        }

        public getNameText() {
            if (this.name) {
                return this.name.actualText;
            }
            else {
                return this.hint;
            }
        }

        public isMethod() {
            return (this.fncFlags & FncFlags.Method) != FncFlags.None;
        }

        public isCallMember() { return hasFlag(this.fncFlags, FncFlags.CallMember); }
        public isConstructMember() { return hasFlag(this.fncFlags, FncFlags.ConstructMember); }
        public isIndexerMember() { return hasFlag(this.fncFlags, FncFlags.IndexerMember); }
        public isSpecialFn() { return this.isCallMember() || this.isIndexerMember() || this.isConstructMember(); }
        public isAnonymousFn() { return this.name === null; }
        public isAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor) || hasFlag(this.fncFlags, FncFlags.SetAccessor); }
        public isGetAccessor() { return hasFlag(this.fncFlags, FncFlags.GetAccessor); }
        public isSetAccessor() { return hasFlag(this.fncFlags, FncFlags.SetAccessor); }
        public isAmbient() { return hasFlag(this.fncFlags, FncFlags.Ambient); }
        public isExported() { return hasFlag(this.fncFlags, FncFlags.Exported); }
        public isPrivate() { return hasFlag(this.fncFlags, FncFlags.Private); }
        public isPublic() { return hasFlag(this.fncFlags, FncFlags.Public); }
        public isStatic() { return hasFlag(this.fncFlags, FncFlags.Static); }

        public treeViewLabel() {
            if (this.name === null) {
                return "funcExpr";
            }
            else {
                return "func: " + this.name.actualText
            }
        }

        public ClearFlags(): void {
            this.fncFlags = FncFlags.None;
        }

        public isSignature() { return (this.fncFlags & FncFlags.Signature) != FncFlags.None; }
    }

    export class LocationInfo {
        public fileName: string;

        constructor(fileName: string,
                    public lineMap: LineMap) {
            this.fileName = fileName;
        }
    }

    export var unknownLocationInfo = new LocationInfo("unknown", null);

    export class Script extends FuncDecl {
        public locationInfo: LocationInfo = null;
        public referencedFiles: IFileReference[] = [];
        public requiresGlobal = false;
        public requiresExtendsBlock = false;
        public isDeclareFile = false;
        public hasBeenTypeChecked = false;
        public topLevelMod: ModuleDeclaration = null;
        public leftCurlyCount = 0;
        public rightCurlyCount = 0;
        public vars: ASTList;
        // Remember if the script contains Unicode chars, that is needed when generating code for this script object to decide the output file correct encoding.
        public containsUnicodeChar = false;
        public containsUnicodeCharInComment = false;
        public cachedEmitRequired: bool;

        private setCachedEmitRequired(value: bool) {
            this.cachedEmitRequired = value;
            return this.cachedEmitRequired;
        }

        constructor (vars: ASTList, scopes: ASTList) {
            super(new Identifier("script"), null, false, null, null, vars, scopes, null, NodeType.Script);
            this.vars = vars;
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckScript(this);
        }

        public treeViewLabel() {
            return "Script";
        }

        public emitRequired(emitOptions: EmitOptions) {
            if (this.cachedEmitRequired != undefined) {
                return this.cachedEmitRequired;
            }

            if (!this.isDeclareFile && this.bod) {
                if (this.bod.members.length === 0) {
                    // allow empty files that are not declare files 
                    return this.setCachedEmitRequired(true);
                }

                for (var i = 0, len = this.bod.members.length; i < len; i++) {
                    var stmt = this.bod.members[i];
                    if (stmt.nodeType === NodeType.ModuleDeclaration) {
                        if (!hasFlag((<ModuleDeclaration>stmt).modFlags, ModuleFlags.ShouldEmitModuleDecl | ModuleFlags.Ambient)) {
                            return this.setCachedEmitRequired(true);
                        }
                    }
                    else if (stmt.nodeType === NodeType.ClassDeclaration) {
                        if (!hasFlag((<ClassDeclaration>stmt).varFlags, VarFlags.Ambient)) {
                            return this.setCachedEmitRequired(true);
                        }
                    }
                    else if (stmt.nodeType === NodeType.VarDecl) {
                        if (!hasFlag((<VarDecl>stmt).varFlags, VarFlags.Ambient)) {
                            return this.setCachedEmitRequired(true);
                        }
                    }
                    else if (stmt.nodeType === NodeType.FuncDecl) {
                        if (!(<FuncDecl>stmt).isSignature()) {
                            return this.setCachedEmitRequired(true);
                        }
                    }
                    else if (stmt.nodeType != NodeType.InterfaceDeclaration && stmt.nodeType != NodeType.Empty) {
                        return this.setCachedEmitRequired(true);
                    }
                }

                if (emitOptions.compilationSettings.emitComments &&
                    ((this.bod.preComments && this.bod.preComments.length > 0) || (this.bod.postComments && this.bod.postComments.length > 0))) {
                    return this.setCachedEmitRequired(true);
                }
            }
            return this.setCachedEmitRequired(false);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            if (this.emitRequired(emitter.emitOptions)) {
                emitter.emitJavascriptList(this.bod, null, TokenID.Semicolon, true, false, false, true, this.requiresExtendsBlock);
            }
        }

        public externallyVisibleImportedSymbols: Symbol[] = [];

        public AddExternallyVisibleImportedSymbol(symbol: Symbol, checker: TypeChecker) {
            if (this.isExternallyVisibleSymbol(symbol)) {
                return;
            }

            // Before adding check if the external symbol is also marked for visibility
            if (!symbol.getType().symbol.isExternallyVisible(checker)) {
                // Report error
                var quotes = "";
                var moduleName = symbol.getType().symbol.prettyName;
                if (!isQuoted(moduleName)) {
                    quotes = "'";
                }
                checker.errorReporter.simpleError(symbol.declAST, "Externally visible import statement uses non exported module " + quotes + moduleName + quotes);
            }
            this.externallyVisibleImportedSymbols.push(symbol);
        }

        public isExternallyVisibleSymbol(symbol: Symbol) {
            for (var i = 0 ; i < this.externallyVisibleImportedSymbols.length; i++) {
                if (this.externallyVisibleImportedSymbols[i] === symbol) {
                    return true;
                }
            }
            return false;
        }
    }

    export class NamedDeclaration extends ModuleElement {
        public leftCurlyCount = 0;
        public rightCurlyCount = 0;
        public isDeclaration() { return true; }

        constructor (nodeType: NodeType,
                     public name: Identifier,
                     public members: ASTList) {
            super(nodeType);
        }
    }

    export class ModuleDeclaration extends NamedDeclaration {
        public modFlags = ModuleFlags.ShouldEmitModuleDecl;
        public mod: ModuleType = null;
        public prettyName: string;
        public amdDependencies: string[] = [];
        public vars: ASTList;
        // Remember if the module contains Unicode chars, that is needed for dynamic module as we will generate a file for each.
        public containsUnicodeChar = false;
        public containsUnicodeCharInComment = false;

        constructor (name: Identifier, members: ASTList, vars: ASTList, public endingToken: ASTSpan) {
            super(NodeType.ModuleDeclaration, name, members);

            this.vars = vars;
            this.prettyName = this.name.actualText;
        }

        public isExported() { return hasFlag(this.modFlags, ModuleFlags.Exported); }
        public isAmbient() { return hasFlag(this.modFlags, ModuleFlags.Ambient); }
        public isEnum() { return hasFlag(this.modFlags, ModuleFlags.IsEnum); }
        public isWholeFile() { return hasFlag(this.modFlags, ModuleFlags.IsWholeFile); }

        public recordNonInterface() {
            this.modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckModule(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            if (!hasFlag(this.modFlags, ModuleFlags.ShouldEmitModuleDecl)) {
                emitter.emitParensAndCommentsInPlace(this, true);
                emitter.emitJavascriptModule(this);
                emitter.emitParensAndCommentsInPlace(this, false);
            }
        }
    }

    export class TypeDeclaration extends NamedDeclaration {
        public varFlags = VarFlags.None;

        constructor(nodeType: NodeType,
                    name: Identifier,
                    public typeParameters: ASTList,
                    public extendsList: ASTList,
                    public implementsList: ASTList,
                    members: ASTList) {
            super(nodeType, name, members);
        }

        public isExported() { 
            return hasFlag(this.varFlags, VarFlags.Exported);
        }

        public isAmbient() {
            return hasFlag(this.varFlags, VarFlags.Ambient);
        }
    }

    export class ClassDeclaration extends TypeDeclaration {
        public knownMemberNames: any = {};
        public constructorDecl: FuncDecl = null;
        public constructorNestingLevel = 0;
        public endingToken: ASTSpan = null;

        constructor(name: Identifier,
                    typeParameters: ASTList,
                    members: ASTList,
                    extendsList: ASTList,
                    implementsList: ASTList) {
            super(NodeType.ClassDeclaration, name, typeParameters, extendsList, implementsList, members);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckClass(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitJavascriptClass(this);
        }
    }

    export class InterfaceDeclaration extends TypeDeclaration {
        constructor(name: Identifier,
                    typeParameters: ASTList,
                    members: ASTList,
                    extendsList: ASTList,
                    implementsList: ASTList) {
            super(NodeType.InterfaceDeclaration, name, typeParameters, extendsList, implementsList, members);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckInterface(this);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
        }
    }

    export class Statement extends ModuleElement {
        constructor (nodeType: NodeType) {
            super(nodeType);
            this.flags |= ASTFlags.IsStatement;
        }

        public isLoop() { return false; }

        public isStatementOrExpression() { return true; }

        public isCompoundStatement() { return this.isLoop(); }

        public typeCheck(typeFlow: TypeFlow) {
            this.type = typeFlow.voidType;
            return this;
        }
    }

    export class LabeledStatement extends Statement {
        constructor (public labels: ASTList, public stmt: AST) {
            super(NodeType.LabeledStatement);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.labels) {
                var labelsLen = this.labels.members.length;
                for (var i = 0; i < labelsLen; i++) {
                    this.labels.members[i].emit(emitter, tokenId, startLine);
                }
            }
            this.stmt.emit(emitter, tokenId, true);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            typeFlow.typeCheck(this.labels);
            this.stmt = this.stmt.typeCheck(typeFlow);
            return this;
        }

        public addToControlFlow(context: ControlFlowContext): void {
            var beforeBB = context.current;
            var bb = new BasicBlock();
            context.current = bb;
            beforeBB.addSuccessor(bb);
        }
    }

    export class Block extends Statement {
        constructor (public statements: ASTList,
                     public isStatementBlock: bool) {
            super(NodeType.Block);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.isStatementBlock) {
                emitter.writeLineToOutput(" {");
                emitter.indenter.increaseIndent();
            } else {
                emitter.setInVarBlock(this.statements.members.length);
            }
            var temp = emitter.setInObjectLiteral(false);
            if (this.statements) {
                emitter.emitJavascriptList(this.statements, null, TokenID.Semicolon, true, false, false);
            }
            if (this.isStatementBlock) {
                emitter.indenter.decreaseIndent();
                emitter.emitIndent();
                emitter.writeToOutput("}");
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public addToControlFlow(context: ControlFlowContext) {
            var afterIfNeeded = new BasicBlock();
            context.pushStatement(this, context.current, afterIfNeeded);
            if (this.statements) {
                context.walk(this.statements, this);
            }
            context.walker.options.goChildren = false;
            context.popStatement();
            if (afterIfNeeded.predecessors.length > 0) {
                context.current.addSuccessor(afterIfNeeded);
                context.current = afterIfNeeded;
            }
        }

        public typeCheck(typeFlow: TypeFlow) {
            if (!typeFlow.checker.styleSettings.emptyBlocks) {
                if ((this.statements === null) || (this.statements.members.length === 0)) {
                    typeFlow.checker.errorReporter.styleError(this, "empty block");
                }
            }

            typeFlow.typeCheck(this.statements);
            return this;
        }
    }

    export class Jump extends Statement {
        public target: string = null;
        public hasExplicitTarget() { return (this.target); }
        public resolvedTarget: Statement = null;

        constructor (nodeType: NodeType) {
            super(nodeType);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            super.addToControlFlow(context);
            context.unconditionalBranch(this.resolvedTarget, (this.nodeType === NodeType.Continue));
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.nodeType === NodeType.Break) {
                emitter.writeToOutput("break");
            }
            else {
                emitter.writeToOutput("continue");
            }
            if (this.hasExplicitTarget()) {
                emitter.writeToOutput(" " + this.target);
            }
            emitter.recordSourceMappingEnd(this);
            emitter.writeToOutput(";");
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }

    export class WhileStatement extends Statement {
        public body: AST = null;

        constructor (public cond: AST) {
            super(NodeType.While);
        }

        public isLoop() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("while(");
            emitter.emitJavascript(this.cond, TokenID.While, false);
            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, false);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckWhile(this);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            var loopHeader = context.current;
            var loopStart = new BasicBlock();
            var afterLoop = new BasicBlock();

            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            context.addContent(this.cond);
            var condBlock = context.current;
            var targetInfo: ITargetInfo = null;
            if (this.body) {
                context.current = new BasicBlock();
                condBlock.addSuccessor(context.current);
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
            }
            context.current = afterLoop;
            condBlock.addSuccessor(afterLoop);
            // TODO: check for while (true) and then only continue if afterLoop has predecessors
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        }
    }

    export class DoWhileStatement extends Statement {
        public body: AST = null;
        public whileAST: AST = null;
        public cond: AST = null;
        public isLoop() { return true; }

        constructor () {
            super(NodeType.DoWhile);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("do");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.recordSourceMappingStart(this.whileAST);
            emitter.writeToOutput(" while");
            emitter.recordSourceMappingEnd(this.whileAST);
            emitter.writeToOutput('(');
            emitter.emitJavascript(this.cond, TokenID.CloseParen, false);
            emitter.writeToOutput(")");
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.writeToOutput(";");
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckDoWhile(this);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            var loopHeader = context.current;
            var loopStart = new BasicBlock();
            var afterLoop = new BasicBlock();
            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            var targetInfo: ITargetInfo = null;
            if (this.body) {
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
                context.addContent(this.cond);
                // TODO: check for while (true) 
                context.current = afterLoop;
                loopEnd.addSuccessor(afterLoop);
            }
            else {
                context.addUnreachable(this.cond);
            }
            context.walker.options.goChildren = false;
        }
    }

    export class IfStatement extends Statement {
        public thenBod: AST;
        public elseBod: AST = null;
        public statement: ASTSpan = new ASTSpan();

        constructor (public cond: AST) {
            super(NodeType.If);
        }

        public isCompoundStatement() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("if (");
            emitter.emitJavascript(this.cond, TokenID.If, false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascriptStatements(this.thenBod, true);
            if (this.elseBod) {
                if (this.elseBod.nodeType === NodeType.If) {
                    emitter.writeToOutput(" else ");
                    this.elseBod.emit(emitter, tokenId, /*startLine:*/ false);
                }
                else {
                    emitter.writeToOutput(" else");
                    emitter.emitJavascriptStatements(this.elseBod, true);
                }
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckIf(this);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            this.cond.addToControlFlow(context);
            var afterIf = new BasicBlock();
            var beforeIf = context.current;
            context.pushStatement(this, beforeIf, afterIf);
            var hasContinuation = false;
            context.current = new BasicBlock();
            beforeIf.addSuccessor(context.current);
            context.walk(this.thenBod, this);
            if (!context.noContinuation) {
                hasContinuation = true;
                context.current.addSuccessor(afterIf);
            }
            if (this.elseBod) {
                // current block will be thenBod
                context.current = new BasicBlock();
                context.noContinuation = false;
                beforeIf.addSuccessor(context.current);
                context.walk(this.elseBod, this);
                if (!context.noContinuation) {
                    hasContinuation = true;
                    context.current.addSuccessor(afterIf);
                }
                else {
                    // thenBod created continuation for if statement
                    if (hasContinuation) {
                        context.noContinuation = false;
                    }
                }
            }
            else {
                beforeIf.addSuccessor(afterIf);
                context.noContinuation = false;
                hasContinuation = true;
            }
            var targetInfo = context.popStatement();
            if (afterIf.predecessors.length > 0) {
                context.noContinuation = false;
                hasContinuation = true;
            }
            if (hasContinuation) {
                context.current = afterIf;
            }
            context.walker.options.goChildren = false;
        }
    }

    export class ReturnStatement extends Statement {
        public returnExpression: AST = null;

        constructor () {
            super(NodeType.Return);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            if (this.returnExpression) {
                emitter.writeToOutput("return ");
                emitter.emitJavascript(this.returnExpression, TokenID.Semicolon, false);

                if (this.returnExpression.nodeType === NodeType.FuncDecl) {
                    emitter.writeToOutput(";");
                }
            }
            else {
                emitter.writeToOutput("return;");
            }
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            super.addToControlFlow(context);
            context.returnStmt();
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckReturn(this);
        }
    }

    export class EndCode extends AST {
        constructor () {
            super(NodeType.EndCode);
        }
    }

    export class ForInStatement extends Statement {
        constructor (public lval: AST, public obj: AST) {
            super(NodeType.ForIn);
            if (this.lval && (this.lval.nodeType === NodeType.VarDecl)) {
                (<BoundDecl>this.lval).varFlags |= VarFlags.AutoInit;
            }
        }
        public statement: ASTSpan = new ASTSpan();
        public body: AST;

        public isLoop() { return true; }

        public isFiltered() {
            if (this.body) {
                var singleItem: AST = null;
                if (this.body.nodeType === NodeType.List) {
                    var stmts = <ASTList>this.body;
                    if (stmts.members.length === 1) {
                        singleItem = stmts.members[0];
                    }
                }
                else {
                    singleItem = this.body;
                }
                // match template for filtering 'own' properties from obj
                if (singleItem !== null) {
                    if (singleItem.nodeType === NodeType.Block) {
                        var block = <Block>singleItem;
                        if ((block.statements !== null) && (block.statements.members.length === 1)) {
                            singleItem = block.statements.members[0];
                        }
                    }
                    if (singleItem.nodeType === NodeType.If) {
                        var cond = (<IfStatement>singleItem).cond;
                        if (cond.nodeType === NodeType.Call) {
                            var target = (<CallExpression>cond).target;
                            if (target.nodeType === NodeType.Dot) {
                                var binex = <BinaryExpression>target;
                                if ((binex.operand1.nodeType === NodeType.Name) &&
                                    (this.obj.nodeType === NodeType.Name) &&
                                    ((<Identifier>binex.operand1).actualText === (<Identifier>this.obj).actualText)) {
                                    var prop = <Identifier>binex.operand2;
                                    if (prop.actualText === "hasOwnProperty") {
                                        var args = (<CallExpression>cond).arguments;
                                        if ((args !== null) && (args.members.length === 1)) {
                                            var arg = args.members[0];
                                            if ((arg.nodeType === NodeType.Name) &&
                                                 (this.lval.nodeType === NodeType.Name)) {
                                                if (((<Identifier>this.lval).actualText) === (<Identifier>arg).actualText) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("for(");
            emitter.emitJavascript(this.lval, TokenID.For, false);
            emitter.writeToOutput(" in ");
            emitter.emitJavascript(this.obj, TokenID.For, false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascriptStatements(this.body, true);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            if (typeFlow.checker.styleSettings.forin) {
                if (!this.isFiltered()) {
                    typeFlow.checker.errorReporter.styleError(this, "no hasOwnProperty filter");
                }
            }
            return typeFlow.typeCheckForIn(this);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            if (this.lval) {
                context.addContent(this.lval);
            }
            if (this.obj) {
                context.addContent(this.obj);
            }

            var loopHeader = context.current;
            var loopStart = new BasicBlock();
            var afterLoop = new BasicBlock();

            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            if (this.body) {
                context.pushStatement(this, loopStart, afterLoop);
                context.walk(this.body, this);
                context.popStatement();
            }
            if (!(context.noContinuation)) {
                var loopEnd = context.current;
                loopEnd.addSuccessor(loopStart);
            }
            context.current = afterLoop;
            context.noContinuation = false;
            loopHeader.addSuccessor(afterLoop);
            context.walker.options.goChildren = false;
        }
    }

    export class ForStatement extends Statement {
        public cond: AST;
        public body: AST;
        public incr: AST;

        constructor (public init: AST) {
            super(NodeType.For);
        }

        public isLoop() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.writeToOutput("for(");
            if (this.init) {
                if (this.init.nodeType != NodeType.List) {
                    emitter.emitJavascript(this.init, TokenID.For, false);
                }
                else {
                    emitter.setInVarBlock((<ASTList>this.init).members.length); 
                    emitter.emitJavascriptList(this.init, null, TokenID.For, false, false, false);
                }
            }
            emitter.writeToOutput("; ");
            emitter.emitJavascript(this.cond, TokenID.For, false);
            emitter.writeToOutput("; ");
            emitter.emitJavascript(this.incr, TokenID.For, false);
            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckFor(this);
        }

        public addToControlFlow(context: ControlFlowContext): void {
            if (this.init) {
                context.addContent(this.init);
            }
            var loopHeader = context.current;
            var loopStart = new BasicBlock();
            var afterLoop = new BasicBlock();

            loopHeader.addSuccessor(loopStart);
            context.current = loopStart;
            var condBlock: BasicBlock = null;
            var continueTarget = loopStart;
            var incrBB: BasicBlock = null;
            if (this.incr) {
                incrBB = new BasicBlock();
                continueTarget = incrBB;
            }
            if (this.cond) {
                condBlock = context.current;
                context.addContent(this.cond);
                context.current = new BasicBlock();
                condBlock.addSuccessor(context.current);
            }
            var targetInfo: ITargetInfo = null;
            if (this.body) {
                context.pushStatement(this, continueTarget, afterLoop);
                context.walk(this.body, this);
                targetInfo = context.popStatement();
            }
            if (this.incr) {
                if (context.noContinuation) {
                    if (incrBB.predecessors.length === 0) {
                        context.addUnreachable(this.incr);
                    }
                }
                else {
                    context.current.addSuccessor(incrBB);
                    context.current = incrBB;
                    context.addContent(this.incr);
                }
            }
            var loopEnd = context.current;
            if (!(context.noContinuation)) {
                loopEnd.addSuccessor(loopStart);

            }
            if (condBlock) {
                condBlock.addSuccessor(afterLoop);
                context.noContinuation = false;
            }
            if (afterLoop.predecessors.length > 0) {
                context.noContinuation = false;
                context.current = afterLoop;
            }
            context.walker.options.goChildren = false;
        }
    }

    export class WithStatement extends Statement {
        public body: AST;

        public isCompoundStatement() { return true; }

        public withSym: WithSymbol = null;

        constructor (public expr: AST) {
            super(NodeType.With);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("with (");
            if (this.expr) {
                emitter.emitJavascript(this.expr, TokenID.With, false);
            }

            emitter.writeToOutput(")");
            emitter.emitJavascriptStatements(this.body, true);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            return typeFlow.typeCheckWith(this);
        }
    }

    export class SwitchStatement extends Statement {
        public caseList: ASTList;
        public defaultCase: CaseStatement = null;
        public statement: ASTSpan = new ASTSpan();

        constructor (public val: AST) {
            super(NodeType.Switch);
        }

        public isCompoundStatement() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            var temp = emitter.setInObjectLiteral(false);
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("switch(");
            emitter.emitJavascript(this.val, TokenID.Identifier, false);
            emitter.writeToOutput(")"); 
            emitter.recordSourceMappingEnd(this.statement);
            emitter.writeLineToOutput(" {");
            emitter.indenter.increaseIndent();
            var casesLen = this.caseList.members.length;
            for (var i = 0; i < casesLen; i++) {
                var caseExpr = this.caseList.members[i];
                emitter.emitJavascript(caseExpr, TokenID.Case, true);
            }
            emitter.indenter.decreaseIndent();
            emitter.emitIndent();
            emitter.writeToOutput("}");
            emitter.setInObjectLiteral(temp);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            var len = this.caseList.members.length;
            this.val = typeFlow.typeCheck(this.val);
            for (var i = 0; i < len; i++) {
                this.caseList.members[i] = typeFlow.typeCheck(this.caseList.members[i]);
            }
            this.defaultCase = <CaseStatement>typeFlow.typeCheck(this.defaultCase);
            this.type = typeFlow.voidType;
            return this;
        }

        // if there are break statements that match this switch, then just link cond block with block after switch
        public addToControlFlow(context: ControlFlowContext) {
            var condBlock = context.current;
            context.addContent(this.val);
            var execBlock = new BasicBlock();
            var afterSwitch = new BasicBlock();

            condBlock.addSuccessor(execBlock);
            context.pushSwitch(execBlock);
            context.current = execBlock;
            context.pushStatement(this, execBlock, afterSwitch);
            context.walk(this.caseList, this);
            context.popSwitch();
            var targetInfo = context.popStatement();
            var hasCondContinuation = (this.defaultCase === null);
            if (this.defaultCase === null) {
                condBlock.addSuccessor(afterSwitch);
            }
            if (afterSwitch.predecessors.length > 0) {
                context.noContinuation = false;
                context.current = afterSwitch;
            }
            else {
                context.noContinuation = true;
            }
            context.walker.options.goChildren = false;
        }
    }

    export class CaseStatement extends Statement {
        public expr: AST = null;
        public body: ASTList;
        public colonSpan: ASTSpan = new ASTSpan();

        constructor () {
            super(NodeType.Case);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            if (this.expr) {
                emitter.writeToOutput("case ");
                emitter.emitJavascript(this.expr, TokenID.Identifier, false);
            }
            else {
                emitter.writeToOutput("default");
            }
            emitter.recordSourceMappingStart(this.colonSpan);
            emitter.writeToOutput(":");
            emitter.recordSourceMappingEnd(this.colonSpan);
            if (this.body.members.length === 1 && this.body.members[0].nodeType === NodeType.Block) {
                // The case statement was written with curly braces, so emit it with the appropriate formatting
                emitter.emitJavascriptStatements(this.body, false);
            }
            else {
                // No curly braces. Format in the expected way
                emitter.writeLineToOutput("");
                emitter.indenter.increaseIndent();
                emitter.emitBareJavascriptStatements(this.body);
                emitter.indenter.decreaseIndent();
            }
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.expr = typeFlow.typeCheck(this.expr);
            typeFlow.typeCheck(this.body);
            this.type = typeFlow.voidType;
            return this;
        }

        // TODO: more reasoning about unreachable cases (such as duplicate literals as case expressions)
        // for now, assume all cases are reachable, regardless of whether some cases fall through
        public addToControlFlow(context: ControlFlowContext) {
            var execBlock = new BasicBlock();
            var sw = context.currentSwitch[context.currentSwitch.length - 1];
            // TODO: fall-through from previous (+ to end of switch)
            if (this.expr) {
                var exprBlock = new BasicBlock();
                context.current = exprBlock;
                sw.addSuccessor(exprBlock);
                context.addContent(this.expr);
                exprBlock.addSuccessor(execBlock);
            }
            else {
                sw.addSuccessor(execBlock);
            }
            context.current = execBlock;
            if (this.body) {
                context.walk(this.body, this);
            }
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        }
    }

    export class TypeParameter extends AST {
        constructor(public name: Identifier, public constraint: AST) {
            super(NodeType.TypeParameter);
        }
    }

    export class GenericType extends AST {
        constructor(public name: AST, public typeArguments: ASTList) {
            super(NodeType.GenericType);
        }
    }

    export class TypeReference extends AST {
        constructor (public term: AST, public arrayCount: number) {
            super(NodeType.TypeRef);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            throw new Error("should not emit a type ref");
        }

        public typeCheck(typeFlow: TypeFlow) {
            var prevInTCTR = typeFlow.inTypeRefTypeCheck;
            typeFlow.inTypeRefTypeCheck = true;
            var typeLink = getTypeLink(this, typeFlow.checker, true);
            typeFlow.checker.resolveTypeLink(typeFlow.scope, typeLink, false);

            if (this.term) {
                typeFlow.typeCheck(this.term);
            }

            typeFlow.checkForVoidConstructor(typeLink.type, this);

            this.type = typeLink.type;

            // in error recovery cases, there may not be a term
            if (this.term) {
                this.term.type = this.type;
            }

            typeFlow.inTypeRefTypeCheck = prevInTCTR;
            return this;
        }
    }

    export class TryFinally extends Statement {
        constructor (public tryNode: AST, public finallyNode: Finally) {
            super(NodeType.TryFinally);
        }

        public isCompoundStatement() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascript(this.tryNode, TokenID.Try, false);
            emitter.emitJavascript(this.finallyNode, TokenID.Finally, false);
            emitter.recordSourceMappingEnd(this);
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.tryNode = typeFlow.typeCheck(this.tryNode);
            this.finallyNode = <Finally>typeFlow.typeCheck(this.finallyNode);
            this.type = typeFlow.voidType;
            return this;
        }

        public addToControlFlow(context: ControlFlowContext) {
            var afterFinally = new BasicBlock();
            context.walk(this.tryNode, this);
            var finBlock = new BasicBlock();
            if (context.current) {
                context.current.addSuccessor(finBlock);
            }
            context.current = finBlock;
            context.pushStatement(this, null, afterFinally);
            context.walk(this.finallyNode, this);
            if (!context.noContinuation && context.current) {
                context.current.addSuccessor(afterFinally);
            }
            if (afterFinally.predecessors.length > 0) {
                context.current = afterFinally;
            }
            else {
                context.noContinuation = true;
            }
            context.popStatement();
            context.walker.options.goChildren = false;
        }
    }

    export class TryCatch extends Statement {
        constructor (public tryNode: Try, public catchNode: Catch) {
            super(NodeType.TryCatch);
        }

        public isCompoundStatement() { return true; }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.emitJavascript(this.tryNode, TokenID.Try, false);
            emitter.emitJavascript(this.catchNode, TokenID.Catch, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public addToControlFlow(context: ControlFlowContext) {
            var beforeTry = context.current;
            var tryBlock = new BasicBlock();
            beforeTry.addSuccessor(tryBlock);
            context.current = tryBlock;
            var afterTryCatch = new BasicBlock();
            context.pushStatement(this, null, afterTryCatch);
            context.walk(this.tryNode, this);
            if (!context.noContinuation) {
                if (context.current) {
                    context.current.addSuccessor(afterTryCatch);
                }
            }
            context.current = new BasicBlock();
            beforeTry.addSuccessor(context.current);
            context.walk(this.catchNode, this);
            context.popStatement();
            if (!context.noContinuation) {
                if (context.current) {
                    context.current.addSuccessor(afterTryCatch);
                }
            }
            context.current = afterTryCatch;
            context.walker.options.goChildren = false;
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.tryNode = <Try>typeFlow.typeCheck(this.tryNode);
            this.catchNode = <Catch>typeFlow.typeCheck(this.catchNode);
            this.type = typeFlow.voidType;
            return this;
        }
    }

    export class Try extends Statement {
        constructor (public body: AST) {
            super(NodeType.Try);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("try ");
            emitter.emitJavascript(this.body, TokenID.Try, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.body = typeFlow.typeCheck(this.body);
            return this;
        }

        public addToControlFlow(context: ControlFlowContext) {
            if (this.body) {
                context.walk(this.body, this);
            }
            context.walker.options.goChildren = false;
            context.noContinuation = false;
        }
    }

    export class Catch extends Statement {
        constructor (public param: VarDecl, public body: AST) {
            super(NodeType.Catch);
            if (this.param) {
                this.param.varFlags |= VarFlags.AutoInit;
            }
        }
        public statement: ASTSpan = new ASTSpan();
        public containedScope: SymbolScope = null;

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(" ");
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("catch (");
            emitter.emitJavascript(this.param, TokenID.OpenParen, false);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitJavascript(this.body, TokenID.Catch, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public addToControlFlow(context: ControlFlowContext) {
            if (this.param) {
                context.addContent(this.param);
                var bodBlock = new BasicBlock();
                context.current.addSuccessor(bodBlock);
                context.current = bodBlock;
            }
            if (this.body) {
                context.walk(this.body, this);
            }
            context.noContinuation = false;
            context.walker.options.goChildren = false;
        }

        public typeCheck(typeFlow: TypeFlow) {
            var prevScope = typeFlow.scope;
            typeFlow.scope = this.containedScope;
            this.param = <VarDecl>typeFlow.typeCheck(this.param);
            var exceptVar = new ValueLocation();
            var varSym = new VariableSymbol((<VarDecl>this.param).id.text,
                                          this.param.minChar,
                                          typeFlow.checker.locationInfo.fileName,
                                          exceptVar);
            exceptVar.symbol = varSym;
            exceptVar.typeLink = new TypeLink();
            // var type for now (add syntax for type annotation)
            exceptVar.typeLink.type = typeFlow.anyType;
            var thisFnc = typeFlow.thisFnc;
            if (thisFnc && thisFnc.type) {
                exceptVar.symbol.container = thisFnc.type.symbol;
            }
            else {
                exceptVar.symbol.container = null;
            }
            this.param.sym = exceptVar.symbol;
            typeFlow.scope.enter(exceptVar.symbol.container, this.param, exceptVar.symbol,
                                 typeFlow.checker.errorReporter, false, false, false);
            this.body = typeFlow.typeCheck(this.body);

            // if we're in provisional typecheck mode, clean up the symbol entry
            // REVIEW: This is obviously bad form, since we're counting on the internal
            // layout of the symbol table, but this is also the only place where we insert
            // symbols during typecheck
            if (typeFlow.checker.inProvisionalTypecheckMode()) {
                var table = typeFlow.scope.getTable();
                (<any>table).secondaryTable.table[exceptVar.symbol.name] = undefined;
            }
            this.type = typeFlow.voidType;
            typeFlow.scope = prevScope;
            return this;
        }
    }

    export class Finally extends Statement {
        constructor (public body: AST) {
            super(NodeType.Finally);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput(" finally");
            emitter.emitJavascript(this.body, TokenID.Finally, false);
            emitter.recordSourceMappingEnd(this);
            emitter.emitParensAndCommentsInPlace(this, false);
        }

        public addToControlFlow(context: ControlFlowContext) {
            if (this.body) {
                context.walk(this.body, this);
            }
            context.walker.options.goChildren = false;
            context.noContinuation = false;
        }

        public typeCheck(typeFlow: TypeFlow) {
            this.body = typeFlow.typeCheck(this.body);
            return this;
        }
    }

    export class Comment extends AST {
        public text: string[] = null;
        public minLine: number;
        public limLine: number;
        private docCommentText: string = null;

        constructor(public content: string,
                    public isBlockComment: bool,
                    public endsLine) {
            super(NodeType.Comment);
        }

        public getText(): string[] {
            if (this.text === null) {
                if (this.isBlockComment) {
                    this.text = this.content.split("\n");
                    for (var i = 0; i < this.text.length; i++) {
                        this.text[i] = this.text[i].replace(/^\s+|\s+$/g, '');
                    }
                }
                else {
                    this.text = [(this.content.replace(/^\s+|\s+$/g, ''))];
                }
            }

            return this.text;
        }

        public isDocComment() {
            if (this.isBlockComment) {
                return this.content.charAt(2) === "*" && this.content.charAt(3) != "/";
            }

            return false;
        }

        public getDocCommentText() {
            if (this.docCommentText === null) {
                this.docCommentText = Comment.cleanJSDocComment(this.content);
            }

            return this.docCommentText;
        }

        static consumeLeadingSpace(line: string, startIndex: number, maxSpacesToRemove?: number) {
            var endIndex = line.length;
            if (maxSpacesToRemove != undefined) {
                endIndex = min(startIndex + maxSpacesToRemove, endIndex);
            }

            for (; startIndex < endIndex; startIndex++) {
                var charCode = line.charCodeAt(startIndex);
                if (charCode != LexCodeSpace && charCode != LexCodeTAB) {
                    return startIndex;
                }
            }
            
            if (endIndex != line.length) {
                return endIndex;
            }

            return -1;
        }

        static isSpaceChar(line: string, index: number) {
            var length = line.length;
            if (index < length) {
                var charCode = line.charCodeAt(index);
                // If the character is space
                return charCode === LexCodeSpace || charCode === LexCodeTAB;
            }

            // If the index is end of the line it is space
            return index === length;
        }

        static cleanDocCommentLine(line: string, jsDocStyleComment: bool, jsDocLineSpaceToRemove?: number) {
            var nonSpaceIndex = Comment.consumeLeadingSpace(line, 0);
            if (nonSpaceIndex != -1) {
                var jsDocSpacesRemoved = nonSpaceIndex;
                if (jsDocStyleComment && line.charAt(nonSpaceIndex) === '*') { // remove leading * in case of jsDocComment
                    var startIndex = nonSpaceIndex + 1;
                    nonSpaceIndex = Comment.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);

                    if (nonSpaceIndex != -1) {
                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;
                    } else {
                        return null;
                    }
                }

                return {
                    minChar: nonSpaceIndex,
                    limChar: line.charAt(line.length - 1) === "\r" ? line.length - 1 : line.length,
                    jsDocSpacesRemoved: jsDocSpacesRemoved
                };
            }

            return null;
        }

        static cleanJSDocComment(content: string, spacesToRemove?: number) {

            var docCommentLines: string[] = [];
            content = content.replace("/**", ""); // remove /**
            if (content.length >= 2 && content.charAt(content.length - 1) === "/" && content.charAt(content.length - 2) === "*") {
                content = content.substring(0, content.length - 2); // remove last */
            }
            var lines = content.split("\n");
            var inParamTag = false;
            for (var l = 0; l < lines.length; l++) {
                var line = lines[l];
                var cleanLinePos = Comment.cleanDocCommentLine(line, true, spacesToRemove);
                if (!cleanLinePos) {
                    // Whole line empty, read next line
                    continue;
                }

                var docCommentText = "";
                var prevPos = cleanLinePos.minChar;
                for (var i = line.indexOf("@", cleanLinePos.minChar); 0 <= i && i < cleanLinePos.limChar; i = line.indexOf("@", i + 1)) {
                    // We have encoutered @. 
                    // If we were omitting param comment, we dont have to do anything
                    // other wise the content of the text till @ tag goes as doc comment
                    var wasInParamtag = inParamTag;

                    // Parse contents next to @
                    if (line.indexOf("param", i + 1) === i + 1 && Comment.isSpaceChar(line, i + 6)) {
                        // It is param tag. 

                        // If we were not in param tag earlier, push the contents from prev pos of the tag this tag start as docComment
                        if (!wasInParamtag) {
                            docCommentText += line.substring(prevPos, i);
                        }

                        // New start of contents 
                        prevPos = i;
                        inParamTag = true;
                    } else if (wasInParamtag) {
                        // Non param tag start
                        prevPos = i;
                        inParamTag = false;
                    }
                }

                if (!inParamTag) {
                    docCommentText += line.substring(prevPos, cleanLinePos.limChar);
                }

                // Add line to comment text if it is not only white space line
                var newCleanPos = Comment.cleanDocCommentLine(docCommentText, false);
                if (newCleanPos) {
                    if (spacesToRemove === undefined) {
                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;
                    }
                    docCommentLines.push(docCommentText);
                }
            }
            
            return docCommentLines.join("\n");
        }

        static getDocCommentText(comments: Comment[]) {
            var docCommentText: string[] = [];
            for (var c = 0 ; c < comments.length; c++) {
                var commentText = comments[c].getDocCommentText();
                if (commentText != "") {
                    docCommentText.push(commentText);
                }
            }
            return docCommentText.join("\n");
        }

        static getParameterDocCommentText(param: string, fncDocComments: Comment[]) {
            if (fncDocComments.length === 0 || !fncDocComments[0].isBlockComment) {
                // there were no fnc doc comments and the comment is not block comment then it cannot have 
                // @param comment that can be parsed
                return "";
            }
            
            for (var i = 0; i < fncDocComments.length; i++) {
                var commentContents = fncDocComments[i].content;
                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {
                    j += 6;
                    if (!Comment.isSpaceChar(commentContents, j)) {
                        // This is not param tag but a tag line @paramxxxxx
                        continue;
                    }

                    // This is param tag. Check if it is what we are looking for
                    j = Comment.consumeLeadingSpace(commentContents, j);
                    if (j === -1) {
                        break;
                    }
                    
                    // Ignore the type expression
                    if (commentContents.charCodeAt(j) === LexCodeLC) {
                        j++;
                        // Consume the type
                        var charCode = 0;
                        for (var curlies = 1; j < commentContents.length; j++) {
                            charCode = commentContents.charCodeAt(j);
                            // { character means we need to find another } to match the found one
                            if (charCode === LexCodeLC) {
                                curlies++;
                                continue;
                            }

                            // } char
                            if (charCode === LexCodeRC) {
                                curlies--;
                                if (curlies === 0) {
                                    // We do not have any more } to match the type expression is ignored completely
                                    break;
                                } else {
                                    // there are more { to be matched with }
                                    continue;
                                }
                            }

                            // Found start of another tag
                            if (charCode === LexCodeAtSign) {
                                break;
                            }
                        }

                        // End of the comment
                        if (j === commentContents.length) {
                            break;
                        }

                        // End of the tag, go onto looking for next tag
                        if (charCode === LexCodeAtSign) {
                            continue;
                        }

                        j = Comment.consumeLeadingSpace(commentContents, j + 1);
                        if (j === -1) {
                            break;
                        }
                    }

                    // Parameter name
                    if (param != commentContents.substr(j, param.length) || !Comment.isSpaceChar(commentContents, j + param.length)) {
                        // this is not the parameter we are looking for
                        continue;
                    }

                    // Found the parameter we were looking for
                    j = Comment.consumeLeadingSpace(commentContents, j + param.length);
                    if (j === -1) {
                        return "";
                    }
                    
                    var endOfParam = commentContents.indexOf("@", j);
                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);

                    // Find alignement spaces to remove
                    var paramSpacesToRemove: number = undefined;
                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\n") + 1;
                    if (paramLineIndex != 0) {
                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) === "\r") {
                            paramLineIndex++;
                        }
                    }
                    var startSpaceRemovalIndex = Comment.consumeLeadingSpace(commentContents, paramLineIndex);
                    if (startSpaceRemovalIndex != j && commentContents.charAt(startSpaceRemovalIndex) === "*") {
                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;
                    }

                    // Clean jsDocComment and return
                    return Comment.cleanJSDocComment(paramHelpString, paramSpacesToRemove);
                }
            }

            return "";
        }

        static getDocCommentFirstOverloadSignature(signatureGroup: SignatureGroup) {
            for (var i = 0; i < signatureGroup.signatures.length; i++) {
                var signature = signatureGroup.signatures[i];
                if (signature === signatureGroup.definitionSignature) {
                    continue;
                }

                return TypeScript.Comment.getDocCommentText(signature.declAST.getDocComments());
            }

            return "";
        }
    }

    export class DebuggerStatement extends Statement {
        constructor () {
            super(NodeType.Debugger);
        }

        public emit(emitter: Emitter, tokenId: TokenID, startLine: bool) {
            emitter.emitParensAndCommentsInPlace(this, true);
            emitter.recordSourceMappingStart(this);
            emitter.writeToOutput("debugger");
            emitter.recordSourceMappingEnd(this);
            emitter.writeLineToOutput(";");
            emitter.emitParensAndCommentsInPlace(this, false);
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export interface IAstWalker {
        walk(ast: AST, parent: AST): AST;
        options: AstWalkOptions;
        state: any; // user state object
    }

    export class AstWalkOptions {
        public goChildren = true;
        public goNextSibling = true;
        public reverseSiblings = false; // visit siblings in reverse execution order

        public stopWalk(stop:bool = true) {
            this.goChildren = !stop;
            this.goNextSibling = !stop;
        }
    }

    export interface IAstWalkCallback {
        (ast: AST, parent: AST, walker: IAstWalker): AST;
    }

    export interface IAstWalkChildren {
        (preAst: AST, parent: AST, walker: IAstWalker): void;
    }

    class AstWalker implements IAstWalker {
        constructor (
            private childrenWalkers: IAstWalkChildren[],
            private pre: IAstWalkCallback,
            private post: IAstWalkCallback,
            public options: AstWalkOptions,
            public state: any) {
        }

        public walk(ast: AST, parent: AST): AST {
            var preAst = this.pre(ast, parent, this);
            if (preAst === undefined) {
                preAst = ast;
            }
            if (this.options.goChildren) {
                var svGoSib = this.options.goNextSibling;
                this.options.goNextSibling = true;
                // Call the "walkChildren" function corresponding to "nodeType".
                this.childrenWalkers[ast.nodeType](ast, parent, this);
                this.options.goNextSibling = svGoSib;
            }
            else {
                // no go only applies to children of node issuing it
                this.options.goChildren = true;
            }
            if (this.post) {
                var postAst = this.post(preAst, parent, this);
                if (postAst === undefined) {
                    postAst = preAst;
                }
                return postAst;
            }
            else {
                return preAst;
            }
        }
    }

    export class AstWalkerFactory {
        private childrenWalkers: IAstWalkChildren[] = [];

        constructor () {
            this.initChildrenWalkers();
        }

        public walk(ast: AST, pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): AST {
            return this.getWalker(pre, post, options, state).walk(ast, null)
        }

        public getWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {
            return this.getSlowWalker(pre, post, options, state);
        }

        private getSlowWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker {
            if (!options) {
                options = new AstWalkOptions();
            }

            return new AstWalker(this.childrenWalkers, pre, post, options, state);
        }

        private initChildrenWalkers(): void {
            this.childrenWalkers[NodeType.None] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Empty] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.EmptyExpr] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.True] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.False] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.This] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Super] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.QString] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Regex] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Null] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.ArrayLit] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.ObjectLit] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.Void] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.Comma] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Pos] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.Neg] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.Delete] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.Await] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.In] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Dot] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.From] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Is] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.InstOf] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Typeof] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.NumberLit] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Name] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.TypeParameter] = ChildrenWalkers.walkTypeParameterChildren;
            this.childrenWalkers[NodeType.GenericType] = ChildrenWalkers.walkGenericTypeChildren;
            this.childrenWalkers[NodeType.TypeRef] = ChildrenWalkers.walkTypeReferenceChildren;
            this.childrenWalkers[NodeType.Index] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Call] = ChildrenWalkers.walkCallExpressionChildren;
            this.childrenWalkers[NodeType.New] = ChildrenWalkers.walkCallExpressionChildren;
            this.childrenWalkers[NodeType.Asg] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgAdd] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgSub] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgDiv] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgMul] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgMod] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgAnd] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgXor] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgOr] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgLsh] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgRsh] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.AsgRs2] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.ConditionalExpression] = ChildrenWalkers.walkTrinaryExpressionChildren;
            this.childrenWalkers[NodeType.LogOr] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.LogAnd] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Or] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Xor] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.And] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Eq] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Ne] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Eqv] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.NEqv] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Lt] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Le] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Gt] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Ge] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Add] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Sub] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Mul] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Div] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Mod] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Lsh] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Rsh] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Rs2] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.Not] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.LogNot] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.IncPre] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.DecPre] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.IncPost] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.DecPost] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.TypeAssertion] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.FuncDecl] = ChildrenWalkers.walkFuncDeclChildren;
            this.childrenWalkers[NodeType.Member] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[NodeType.VarDecl] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[NodeType.ArgDecl] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[NodeType.Return] = ChildrenWalkers.walkReturnStatementChildren;
            this.childrenWalkers[NodeType.Break] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Continue] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Throw] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[NodeType.For] = ChildrenWalkers.walkForStatementChildren;
            this.childrenWalkers[NodeType.ForIn] = ChildrenWalkers.walkForInStatementChildren;
            this.childrenWalkers[NodeType.If] = ChildrenWalkers.walkIfStatementChildren;
            this.childrenWalkers[NodeType.While] = ChildrenWalkers.walkWhileStatementChildren;
            this.childrenWalkers[NodeType.DoWhile] = ChildrenWalkers.walkDoWhileStatementChildren;
            this.childrenWalkers[NodeType.Block] = ChildrenWalkers.walkBlockChildren;
            this.childrenWalkers[NodeType.Case] = ChildrenWalkers.walkCaseStatementChildren;
            this.childrenWalkers[NodeType.Switch] = ChildrenWalkers.walkSwitchStatementChildren;
            this.childrenWalkers[NodeType.Try] = ChildrenWalkers.walkTryChildren;
            this.childrenWalkers[NodeType.TryCatch] = ChildrenWalkers.walkTryCatchChildren;
            this.childrenWalkers[NodeType.TryFinally] = ChildrenWalkers.walkTryFinallyChildren;
            this.childrenWalkers[NodeType.Finally] = ChildrenWalkers.walkFinallyChildren;
            this.childrenWalkers[NodeType.Catch] = ChildrenWalkers.walkCatchChildren;
            this.childrenWalkers[NodeType.List] = ChildrenWalkers.walkListChildren;
            this.childrenWalkers[NodeType.Script] = ChildrenWalkers.walkScriptChildren;
            this.childrenWalkers[NodeType.ClassDeclaration] = ChildrenWalkers.walkClassDeclChildren;
            this.childrenWalkers[NodeType.InterfaceDeclaration] = ChildrenWalkers.walkTypeDeclChildren;
            this.childrenWalkers[NodeType.ModuleDeclaration] = ChildrenWalkers.walkModuleDeclChildren;
            this.childrenWalkers[NodeType.ImportDeclaration] = ChildrenWalkers.walkImportDeclChildren;
            this.childrenWalkers[NodeType.ExportAssignment] = ChildrenWalkers.walkExportAssignmentChildren;
            this.childrenWalkers[NodeType.With] = ChildrenWalkers.walkWithStatementChildren;
            this.childrenWalkers[NodeType.Label] = ChildrenWalkers.walkLabelChildren;
            this.childrenWalkers[NodeType.LabeledStatement] = ChildrenWalkers.walkLabeledStatementChildren;
            this.childrenWalkers[NodeType.EBStart] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.GotoEB] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.EndCode] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Error] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Comment] = ChildrenWalkers.walkNone;
            this.childrenWalkers[NodeType.Debugger] = ChildrenWalkers.walkNone;

            // Verify the code is up to date with the enum
            for (var e in (<any>NodeType)._map) {
                if ((<any>this.childrenWalkers)[e] === undefined) {
                    throw new Error("initWalkers function is not up to date with enum content!");
                }
            }
        }
    }

    var globalAstWalkerFactory: AstWalkerFactory;

    export function getAstWalkerFactory(): AstWalkerFactory {
        if (!globalAstWalkerFactory) {
            globalAstWalkerFactory = new AstWalkerFactory();
        }
        return globalAstWalkerFactory;
    }

    module ChildrenWalkers {
        export function walkNone(preAst: ASTList, parent: AST, walker: IAstWalker): void {
            // Nothing to do
        }

        export function walkListChildren(preAst: ASTList, parent: AST, walker: IAstWalker): void {
            var len = preAst.members.length;
            var i = 0;
            if (walker.options.reverseSiblings) {
                for (i = len - 1; i >= 0; i--) {
                    if (walker.options.goNextSibling) {
                        preAst.members[i] = walker.walk(preAst.members[i], preAst);
                    }
                }
            }
            else {
                for (i = 0; i < len; i++) {
                    if (walker.options.goNextSibling) {
                        preAst.members[i] = walker.walk(preAst.members[i], preAst);
                    }
                }
            }
        }

        export function walkUnaryExpressionChildren(preAst: UnaryExpression, parent: AST, walker: IAstWalker): void {
            if (preAst.castTerm) {
                preAst.castTerm = walker.walk(preAst.castTerm, preAst);
            }
            if (preAst.operand) {
                preAst.operand = walker.walk(preAst.operand, preAst);
            }
        }

        export function walkBinaryExpressionChildren(preAst: BinaryExpression, parent: AST, walker: IAstWalker): void {
            if (walker.options.reverseSiblings) {
                if (preAst.operand2) {
                    preAst.operand2 = walker.walk(preAst.operand2, preAst);
                }
                if ((preAst.operand1) && (walker.options.goNextSibling)) {
                    preAst.operand1 = walker.walk(preAst.operand1, preAst);
                }
            } else {
                if (preAst.operand1) {
                    preAst.operand1 = walker.walk(preAst.operand1, preAst);
                }
                if ((preAst.operand2) && (walker.options.goNextSibling)) {
                    preAst.operand2 = walker.walk(preAst.operand2, preAst);
                }
            }
        }

        export function walkTypeParameterChildren(preAst: TypeParameter, parent: AST, walker: IAstWalker): void {
            if (preAst.name) {
                preAst.name = <Identifier>walker.walk(preAst.name, preAst);
            }

            if (preAst.constraint && (walker.options.goNextSibling)) {
                preAst.constraint = <ASTList> walker.walk(preAst.constraint, preAst);
            }
        }

        export function walkGenericTypeChildren(preAst: GenericType, parent: AST, walker: IAstWalker): void {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }

            if (preAst.typeArguments && (walker.options.goNextSibling)) {
                preAst.typeArguments = <ASTList> walker.walk(preAst.typeArguments, preAst);
            }
        }

        export function walkTypeReferenceChildren(preAst: TypeReference, parent: AST, walker: IAstWalker): void {
            if (preAst.term) {
                preAst.term = walker.walk(preAst.term, preAst);
            }
        }

        export function walkCallExpressionChildren(preAst: CallExpression, parent: AST, walker: IAstWalker): void {
            if (!walker.options.reverseSiblings) {
                preAst.target = walker.walk(preAst.target, preAst);
            }
            if (preAst.arguments && (walker.options.goNextSibling)) {
                preAst.arguments = <ASTList> walker.walk(preAst.arguments, preAst);
            }
            if ((walker.options.reverseSiblings) && (walker.options.goNextSibling)) {
                preAst.target = walker.walk(preAst.target, preAst);
            }
        }

        export function walkTrinaryExpressionChildren(preAst: ConditionalExpression, parent: AST, walker: IAstWalker): void {
            if (preAst.operand1) {
                preAst.operand1 = walker.walk(preAst.operand1, preAst);
            }
            if (preAst.operand2 && (walker.options.goNextSibling)) {
                preAst.operand2 = walker.walk(preAst.operand2, preAst);
            }
            if (preAst.operand3 && (walker.options.goNextSibling)) {
                preAst.operand3 = walker.walk(preAst.operand3, preAst);
            }
        }

        export function walkFuncDeclChildren(preAst: FuncDecl, parent: AST, walker: IAstWalker): void {
            if (preAst.name) {
                preAst.name = <Identifier>walker.walk(preAst.name, preAst);
            }
            if (preAst.typeArguments) {
                preAst.typeArguments = <ASTList>walker.walk(preAst.typeArguments, preAst);
            }
            if (preAst.arguments && (walker.options.goNextSibling)) {
                preAst.arguments = <ASTList>walker.walk(preAst.arguments, preAst);
            }
            if (preAst.returnTypeAnnotation && (walker.options.goNextSibling)) {
                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);
            }
            if (preAst.bod && (walker.options.goNextSibling)) {
                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);
            }
        }

        export function walkBoundDeclChildren(preAst: BoundDecl, parent: AST, walker: IAstWalker): void {
            if (preAst.id) {
                preAst.id = <Identifier>walker.walk(preAst.id, preAst);
            }
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }
            if ((preAst.typeExpr) && (walker.options.goNextSibling)) {
                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);
            }
        }

        export function walkReturnStatementChildren(preAst: ReturnStatement, parent: AST, walker: IAstWalker): void {
            if (preAst.returnExpression) {
                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);
            }
        }

        export function walkForStatementChildren(preAst: ForStatement, parent: AST, walker: IAstWalker): void {
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }

            if (preAst.cond && walker.options.goNextSibling) {
                preAst.cond = walker.walk(preAst.cond, preAst);
            }

            if (preAst.incr && walker.options.goNextSibling) {
                preAst.incr = walker.walk(preAst.incr, preAst);
            }

            if (preAst.body && walker.options.goNextSibling) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkForInStatementChildren(preAst: ForInStatement, parent: AST, walker: IAstWalker): void {
            preAst.lval = walker.walk(preAst.lval, preAst);
            if (walker.options.goNextSibling) {
                preAst.obj = walker.walk(preAst.obj, preAst);
            }
            if (preAst.body && (walker.options.goNextSibling)) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkIfStatementChildren(preAst: IfStatement, parent: AST, walker: IAstWalker): void {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.thenBod && (walker.options.goNextSibling)) {
                preAst.thenBod = walker.walk(preAst.thenBod, preAst);
            }
            if (preAst.elseBod && (walker.options.goNextSibling)) {
                preAst.elseBod = walker.walk(preAst.elseBod, preAst);
            }
        }

        export function walkWhileStatementChildren(preAst: WhileStatement, parent: AST, walker: IAstWalker): void {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body && (walker.options.goNextSibling)) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkDoWhileStatementChildren(preAst: DoWhileStatement, parent: AST, walker: IAstWalker): void {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body && (walker.options.goNextSibling)) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkBlockChildren(preAst: Block, parent: AST, walker: IAstWalker): void {
            if (preAst.statements) {
                preAst.statements = <ASTList>walker.walk(preAst.statements, preAst);
            }
        }

        export function walkCaseStatementChildren(preAst: CaseStatement, parent: AST, walker: IAstWalker): void {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }

            if (preAst.body && walker.options.goNextSibling) {
                preAst.body = <ASTList>walker.walk(preAst.body, preAst);
            }
        }

        export function walkSwitchStatementChildren(preAst: SwitchStatement, parent: AST, walker: IAstWalker): void {
            if (preAst.val) {
                preAst.val = walker.walk(preAst.val, preAst);
            }

            if ((preAst.caseList) && walker.options.goNextSibling) {
                preAst.caseList = <ASTList>walker.walk(preAst.caseList, preAst);
            }
        }

        export function walkTryChildren(preAst: Try, parent: AST, walker: IAstWalker): void {
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkTryCatchChildren(preAst: TryCatch, parent: AST, walker: IAstWalker): void {
            if (preAst.tryNode) {
                preAst.tryNode = <Try>walker.walk(preAst.tryNode, preAst);
            }

            if ((preAst.catchNode) && walker.options.goNextSibling) {
                preAst.catchNode = <Catch>walker.walk(preAst.catchNode, preAst);
            }
        }

        export function walkTryFinallyChildren(preAst: TryFinally, parent: AST, walker: IAstWalker): void {
            if (preAst.tryNode) {
                preAst.tryNode = walker.walk(preAst.tryNode, preAst);
            }

            if (preAst.finallyNode && walker.options.goNextSibling) {
                preAst.finallyNode = <Finally>walker.walk(preAst.finallyNode, preAst);
            }
        }

        export function walkFinallyChildren(preAst: Finally, parent: AST, walker: IAstWalker): void {
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkCatchChildren(preAst: Catch, parent: AST, walker: IAstWalker): void {
            if (preAst.param) {
                preAst.param = <VarDecl>walker.walk(preAst.param, preAst);
            }

            if ((preAst.body) && walker.options.goNextSibling) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkRecordChildren(preAst: NamedDeclaration, parent: AST, walker: IAstWalker): void {
            preAst.name = <Identifier>walker.walk(preAst.name, preAst);
            if (walker.options.goNextSibling && preAst.members) {
                preAst.members = <ASTList>walker.walk(preAst.members, preAst);
            }

        }

        export function walkNamedTypeChildren(preAst: TypeDeclaration, parent: AST, walker: IAstWalker): void {
            walkRecordChildren(preAst, parent, walker);
        }

        export function walkClassDeclChildren(preAst: ClassDeclaration, parent: AST, walker: IAstWalker): void {
            walkNamedTypeChildren(preAst, parent, walker);

            if (walker.options.goNextSibling && preAst.typeParameters) {
                preAst.typeParameters = <ASTList>walker.walk(preAst.typeParameters, preAst);
            }

            if (walker.options.goNextSibling && preAst.extendsList) {
                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);
            }

            if (walker.options.goNextSibling && preAst.implementsList) {
                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);
            }
        }

        export function walkScriptChildren(preAst: Script, parent: AST, walker: IAstWalker): void {
            if (preAst.bod) {
                preAst.bod = <ASTList>walker.walk(preAst.bod, preAst);
            }
        }

        export function walkTypeDeclChildren(preAst: InterfaceDeclaration, parent: AST, walker: IAstWalker): void {
            walkNamedTypeChildren(preAst, parent, walker);

            if (walker.options.goNextSibling && preAst.typeParameters) {
                preAst.typeParameters = <ASTList>walker.walk(preAst.typeParameters, preAst);
            }

            // walked arguments as part of members
            if (walker.options.goNextSibling && preAst.extendsList) {
                preAst.extendsList = <ASTList>walker.walk(preAst.extendsList, preAst);
            }

            if (walker.options.goNextSibling && preAst.implementsList) {
                preAst.implementsList = <ASTList>walker.walk(preAst.implementsList, preAst);
            }
        }

        export function walkModuleDeclChildren(preAst: ModuleDeclaration, parent: AST, walker: IAstWalker): void {
            walkRecordChildren(preAst, parent, walker);
        }

        export function walkImportDeclChildren(preAst: ImportDeclaration, parent: AST, walker: IAstWalker): void {
            if (preAst.id) {
                preAst.id = <Identifier>walker.walk(preAst.id, preAst);
            }
            if (preAst.alias) {
                preAst.alias = walker.walk(preAst.alias, preAst);
            }
        }

        export function walkExportAssignmentChildren(preAst: ExportAssignment, parent: AST, walker: IAstWalker): void {
            if (preAst.id) {
                preAst.id = <Identifier>walker.walk(preAst.id, preAst);
            }
        }

        export function walkWithStatementChildren(preAst: WithStatement, parent: AST, walker: IAstWalker): void {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }

            if (preAst.body && walker.options.goNextSibling) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }

        export function walkLabelChildren(preAst: Label, parent: AST, walker: IAstWalker): void {
            //TODO: Walk "id"?
        }

        export function walkLabeledStatementChildren(preAst: LabeledStatement, parent: AST, walker: IAstWalker): void {
            preAst.labels = <ASTList>walker.walk(preAst.labels, preAst);
            if (walker.options.goNextSibling) {
                preAst.stmt = walker.walk(preAst.stmt, preAst);
            }
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript.AstWalkerWithDetailCallback {
    export interface AstWalkerDetailCallback {
        EmptyCallback? (pre, ast: AST): bool;
        EmptyExprCallback? (pre, ast: AST): bool;
        TrueCallback? (pre, ast: AST): bool;
        FalseCallback? (pre, ast: AST): bool;
        ThisCallback? (pre, ast: AST): bool;
        SuperCallback? (pre, ast: AST): bool;
        QStringCallback? (pre, ast: AST): bool;
        RegexCallback? (pre, ast: AST): bool;
        NullCallback? (pre, ast: AST): bool;
        ArrayLitCallback? (pre, ast: AST): bool;
        ObjectLitCallback? (pre, ast: AST): bool;
        VoidCallback? (pre, ast: AST): bool;
        CommaCallback? (pre, ast: AST): bool;
        PosCallback? (pre, ast: AST): bool;
        NegCallback? (pre, ast: AST): bool;
        DeleteCallback? (pre, ast: AST): bool;
        AwaitCallback? (pre, ast: AST): bool;
        InCallback? (pre, ast: AST): bool;
        DotCallback? (pre, ast: AST): bool;
        FromCallback? (pre, ast: AST): bool;
        IsCallback? (pre, ast: AST): bool;
        InstOfCallback? (pre, ast: AST): bool;
        TypeofCallback? (pre, ast: AST): bool;
        NumberLitCallback? (pre, ast: AST): bool;
        NameCallback? (pre, identifierAst: Identifier): bool;
        TypeRefCallback? (pre, ast: AST): bool;
        IndexCallback? (pre, ast: AST): bool;
        CallCallback? (pre, ast: AST): bool;
        NewCallback? (pre, ast: AST): bool;
        AsgCallback? (pre, ast: AST): bool;
        AsgAddCallback? (pre, ast: AST): bool;
        AsgSubCallback? (pre, ast: AST): bool;
        AsgDivCallback? (pre, ast: AST): bool;
        AsgMulCallback? (pre, ast: AST): bool;
        AsgModCallback? (pre, ast: AST): bool;
        AsgAndCallback? (pre, ast: AST): bool;
        AsgXorCallback? (pre, ast: AST): bool;
        AsgOrCallback? (pre, ast: AST): bool;
        AsgLshCallback? (pre, ast: AST): bool;
        AsgRshCallback? (pre, ast: AST): bool;
        AsgRs2Callback? (pre, ast: AST): bool;
        QMarkCallback? (pre, ast: AST): bool;
        LogOrCallback? (pre, ast: AST): bool;
        LogAndCallback? (pre, ast: AST): bool;
        OrCallback? (pre, ast: AST): bool;
        XorCallback? (pre, ast: AST): bool;
        AndCallback? (pre, ast: AST): bool;
        EqCallback? (pre, ast: AST): bool;
        NeCallback? (pre, ast: AST): bool;
        EqvCallback? (pre, ast: AST): bool;
        NEqvCallback? (pre, ast: AST): bool;
        LtCallback? (pre, ast: AST): bool;
        LeCallback? (pre, ast: AST): bool;
        GtCallback? (pre, ast: AST): bool;
        GeCallback? (pre, ast: AST): bool;
        AddCallback? (pre, ast: AST): bool;
        SubCallback? (pre, ast: AST): bool;
        MulCallback? (pre, ast: AST): bool;
        DivCallback? (pre, ast: AST): bool;
        ModCallback? (pre, ast: AST): bool;
        LshCallback? (pre, ast: AST): bool;
        RshCallback? (pre, ast: AST): bool;
        Rs2Callback? (pre, ast: AST): bool;
        NotCallback? (pre, ast: AST): bool;
        LogNotCallback? (pre, ast: AST): bool;
        IncPreCallback? (pre, ast: AST): bool;
        DecPreCallback? (pre, ast: AST): bool;
        IncPostCallback? (pre, ast: AST): bool;
        DecPostCallback? (pre, ast: AST): bool;
        TypeAssertionCallback? (pre, ast: AST): bool;
        FuncDeclCallback? (pre, funcDecl: FuncDecl): bool;
        MemberCallback? (pre, ast: AST): bool;
        VarDeclCallback? (pre, varDecl: VarDecl): bool;
        ArgDeclCallback? (pre, ast: AST): bool;
        ReturnCallback? (pre, ast: AST): bool;
        BreakCallback? (pre, ast: AST): bool;
        ContinueCallback? (pre, ast: AST): bool;
        ThrowCallback? (pre, ast: AST): bool;
        ForCallback? (pre, ast: AST): bool;
        ForInCallback? (pre, ast: AST): bool;
        IfCallback? (pre, ast: AST): bool;
        WhileCallback? (pre, ast: AST): bool;
        DoWhileCallback? (pre, ast: AST): bool;
        BlockCallback? (pre, block: Block): bool;
        CaseCallback? (pre, ast: AST): bool;
        SwitchCallback? (pre, ast: AST): bool;
        TryCallback? (pre, ast: AST): bool;
        TryCatchCallback? (pre, ast: AST): bool;
        TryFinallyCallback? (pre, ast: AST): bool;
        FinallyCallback? (pre, ast: AST): bool;
        CatchCallback? (pre, ast: AST): bool;
        ListCallback? (pre, astList: ASTList): bool;
        ScriptCallback? (pre, script: Script): bool;
        ClassDeclarationCallback? (pre, ast: AST): bool;
        InterfaceDeclarationCallback? (pre, interfaceDecl: InterfaceDeclaration): bool;
        ModuleDeclarationCallback? (pre, moduleDecl: ModuleDeclaration): bool;
        ImportDeclarationCallback? (pre, ast: AST): bool;
        ExportAssignmentCallback? (pre, ast: AST): bool;
        WithCallback? (pre, ast: AST): bool;
        LabelCallback? (pre, labelAST: AST): bool;
        LabeledStatementCallback? (pre, ast: AST): bool;
        EBStartCallback? (pre, ast: AST): bool;
        GotoEBCallback? (pre, ast: AST): bool;
        EndCodeCallback? (pre, ast: AST): bool;
        ErrorCallback? (pre, ast: AST): bool;
        CommentCallback? (pre, ast: AST): bool;
        DebuggerCallback? (pre, ast: AST): bool;
        DefaultCallback? (pre, ast: AST): bool;
    }

    export function walk(script: Script, callback: AstWalkerDetailCallback): void {
        var pre = (cur: AST, parent: AST) => {
            walker.options.goChildren = AstWalkerCallback(true, cur, callback);
            return cur;
        }

        var post = (cur: AST, parent: AST) => {
            AstWalkerCallback(false, cur, callback);
            return cur;
        }

        var walker = TypeScript.getAstWalkerFactory().getWalker(pre, post);
        walker.walk(script, null);
    }

    function AstWalkerCallback(pre: bool, ast: AST, callback: AstWalkerDetailCallback): bool {
        // See if the Callback needs to be handled using specific one or default one
        var nodeType = ast.nodeType;
        var callbackString = (<any>NodeType)._map[nodeType] + "Callback";
        if (callback[callbackString]) {
            return callback[callbackString](pre, ast);
        }

        if (callback.DefaultCallback) {
            return callback.DefaultCallback(pre, ast);
        }

        return true;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export function lastOf(items: any[]): any {
        return (items === null || items.length === 0) ? null : items[items.length - 1];
    }

    export function max(a: number, b: number): number {
        return a >= b ? a : b;
    }

    export function min(a: number, b: number): number {
        return a <= b ? a : b;
    }

    //
    // Helper class representing a path from a root ast node to a (grand)child ast node.
    // This is helpful as our tree don't have parents.
    //
    export class AstPath {
        public asts: AST[] = [];
        public top: number = -1;

        static reverseIndexOf(items: any[], index: number): any {
            return (items === null || items.length <= index) ? null : items[items.length - index - 1];
        }

        public clone(): AstPath {
            var clone = new AstPath();
            clone.asts = this.asts.map((value) => { return value; });
            clone.top = this.top;
            return clone;
        }

        public pop(): TypeScript.AST {
            var head = this.ast();
            this.up();

            while (this.asts.length > this.count()) {
                this.asts.pop();
            }
            return head;
        }

        public push(ast: TypeScript.AST) {
            while (this.asts.length > this.count()) {
                this.asts.pop();
            }
            this.top = this.asts.length;
            this.asts.push(ast);
        }

        public up() {
            if (this.top <= -1)
                throw new Error("Invalid call to 'up'");
            this.top--;
        }

        public down() {
            if (this.top === this.ast.length - 1)
                throw new Error("Invalid call to 'down'");
            this.top++;
        }

        public nodeType(): TypeScript.NodeType {
            if (this.ast() === null)
                return TypeScript.NodeType.None;
            return this.ast().nodeType;
        }

        public ast() {
            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));
        }

        public parent() {
            return <TypeScript.AST>AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);
        }

        public count() {
            return this.top + 1;
        }

        public get(index: number): TypeScript.AST {
            return this.asts[index];
        }

        public isNameOfClass(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.ClassDeclaration) &&
                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());
        }

        public isNameOfInterface(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.InterfaceDeclaration) &&
                ((<TypeScript.InterfaceDeclaration>this.parent()).name === this.ast());
        }

        public isNameOfArgument(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.ArgDecl) &&
                ((<TypeScript.ArgDecl>this.parent()).id === this.ast());
        }

        public isNameOfVariable(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.VarDecl) &&
                ((<TypeScript.VarDecl>this.parent()).id === this.ast());
        }

        public isNameOfModule(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.ModuleDeclaration) &&
                ((<TypeScript.ModuleDeclaration>this.parent()).name === this.ast());
        }

        public isNameOfFunction(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === TypeScript.NodeType.Name) &&
                (this.parent().nodeType === TypeScript.NodeType.FuncDecl) &&
                ((<TypeScript.FuncDecl>this.parent()).name === this.ast());
        }

        public isChildOfScript(): bool {
            var ast = lastOf(this.asts);
            return this.count() >= 3 &&
                this.asts[this.top] === ast &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Script;
        }

        public isChildOfModule(): bool {
            var ast = lastOf(this.asts);
            return this.count() >= 3 &&
                this.asts[this.top] === ast &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ModuleDeclaration;
        }

        public isChildOfClass(): bool {
            var ast = lastOf(this.asts);
            return this.count() >= 3 &&
                this.asts[this.top] === ast &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ClassDeclaration;
        }

        public isArgumentOfClassConstructor(): bool {
            var ast = lastOf(this.asts);
            return this.count() >= 5 &&
                this.asts[this.top] === ast &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&
                this.asts[this.top - 3].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 4].nodeType === TypeScript.NodeType.ClassDeclaration &&
                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).isConstructor) &&
                ((<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1]) &&
                ((<TypeScript.ClassDeclaration>this.asts[this.top - 4]).constructorDecl === this.asts[this.top - 2]);
        }

        public isChildOfInterface(): bool {
            var ast = lastOf(this.asts);
            return this.count() >= 3 &&
                this.asts[this.top] === ast &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.InterfaceDeclaration;
        }

        public isTopLevelImplicitModule() {
            return this.count() >= 1 &&
                this.asts[this.top].nodeType === TypeScript.NodeType.ModuleDeclaration &&
                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top]).modFlags, TypeScript.ModuleFlags.IsWholeFile);
        }

        public isBodyOfTopLevelImplicitModule() {
            return this.count() >= 2 &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&
                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members === this.asts[this.top - 0] &&
                TypeScript.hasFlag((<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).modFlags, TypeScript.ModuleFlags.IsWholeFile);
        }

        public isBodyOfScript(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Script &&
                 (<TypeScript.Script>this.asts[this.top - 1]).bod === this.asts[this.top - 0];
        }

        public isBodyOfSwitch(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Switch &&
                 (<TypeScript.SwitchStatement>this.asts[this.top - 1]).caseList === this.asts[this.top - 0];
        }

        public isBodyOfModule(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ModuleDeclaration &&
                 (<TypeScript.ModuleDeclaration>this.asts[this.top - 1]).members === this.asts[this.top - 0];
        }

        public isBodyOfClass(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ClassDeclaration &&
                 (<TypeScript.ClassDeclaration>this.asts[this.top - 1]).members === this.asts[this.top - 0];
        }

        public isBodyOfFunction(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&
                 (<TypeScript.FuncDecl>this.asts[this.top - 1]).bod === this.asts[this.top - 0];
        }

        public isBodyOfInterface(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.InterfaceDeclaration &&
                 (<TypeScript.InterfaceDeclaration>this.asts[this.top - 1]).members === this.asts[this.top - 0];
        }

        public isBodyOfBlock(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Block &&
                (<TypeScript.Block>this.asts[this.top - 1]).statements === this.asts[this.top - 0];
        }

        public isBodyOfFor(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.For &&
                (<TypeScript.ForStatement>this.asts[this.top - 1]).body === this.asts[this.top - 0];
        }

        public isBodyOfCase(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Case &&
                (<TypeScript.CaseStatement>this.asts[this.top - 1]).body === this.asts[this.top - 0];
        }

        public isBodyOfTry(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Try &&
                (<TypeScript.Try>this.asts[this.top - 1]).body === this.asts[this.top - 0];
        }

        public isBodyOfCatch(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Catch &&
                (<TypeScript.Catch>this.asts[this.top - 1]).body === this.asts[this.top - 0];
        }

        public isBodyOfDoWhile(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.DoWhile &&
                (<TypeScript.DoWhileStatement>this.asts[this.top - 1]).body === this.asts[this.top - 0];
        }

        public isBodyOfWhile(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.While &&
                (<TypeScript.WhileStatement>this.asts[this.top - 1]).body === this.asts[this.top - 0];
        }

        public isBodyOfForIn(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ForIn &&
                (<TypeScript.ForInStatement>this.asts[this.top - 1]).body === this.asts[this.top - 0];
        }

        public isBodyOfWith(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.With &&
                (<TypeScript.WithStatement>this.asts[this.top - 1]).body === this.asts[this.top - 0];
        }

        public isBodyOfFinally(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Finally &&
                (<TypeScript.Finally>this.asts[this.top - 1]).body === this.asts[this.top - 0];
        }

        public isCaseOfSwitch(): bool {
            return this.count() >= 3 &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList === this.asts[this.top - 1];
        }

        public isDefaultCaseOfSwitch(): bool {
            return this.count() >= 3 &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.Switch &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).caseList === this.asts[this.top - 1] &&
                (<TypeScript.SwitchStatement>this.asts[this.top - 2]).defaultCase === this.asts[this.top - 0];
        }

        public isListOfObjectLit(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand === this.asts[this.top - 0];
        }

        public isBodyOfObjectLit(): bool {
            return this.isListOfObjectLit();
        }

        public isEmptyListOfObjectLit(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ObjectLit &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand === this.asts[this.top - 0] &&
                (<TypeScript.ASTList>this.asts[this.top - 0]).members.length === 0;
        }

        public isMemberOfObjectLit(): bool {
            return this.count() >= 3 &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.ObjectLit &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Member &&
                (<TypeScript.UnaryExpression>this.asts[this.top - 2]).operand === this.asts[this.top - 1];
        }

        public isNameOfMemberOfObjectLit(): bool {
            return this.count() >= 4 &&
                this.asts[this.top - 3].nodeType === TypeScript.NodeType.ObjectLit &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Name &&
                (<TypeScript.UnaryExpression>this.asts[this.top - 3]).operand === this.asts[this.top - 2];
        }

        public isListOfArrayLit(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.ArrayLit &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.UnaryExpression>this.asts[this.top - 1]).operand === this.asts[this.top - 0];
        }

        public isTargetOfMember(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&
                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand1 === this.asts[this.top - 0];
        }

        public isMemberOfMember(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Member &&
                (<TypeScript.BinaryExpression>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];
        }

        public isItemOfList(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List;
            //(<Tools.ASTList>this.asts[this.top - 1]).operand2 === this.asts[this.top - 0];
        }

        public isThenOfIf(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&
                (<TypeScript.IfStatement>this.asts[this.top - 1]).thenBod === this.asts[this.top - 0];
        }

        public isElseOfIf(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.If &&
                (<TypeScript.IfStatement>this.asts[this.top - 1]).elseBod === this.asts[this.top - 0];
        }

        public isBodyOfDefaultCase(): bool {
            return this.isBodyOfCase();
        }

        public isSingleStatementList(): bool {
            return this.count() >= 1 &&
                this.asts[this.top].nodeType === TypeScript.NodeType.List &&
                (<TypeScript.ASTList>this.asts[this.top]).members.length === 1;
        }

        public isArgumentListOfFunction(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.FuncDecl &&
                (<TypeScript.FuncDecl>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        }

        public isArgumentOfFunction(): bool {
            return this.count() >= 3 &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 2].nodeType === TypeScript.NodeType.FuncDecl &&
                (<TypeScript.FuncDecl>this.asts[this.top - 2]).arguments === this.asts[this.top - 1];
        }

        public isArgumentListOfCall(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.Call &&
                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        }

        public isArgumentListOfNew(): bool {
            return this.count() >= 2 &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.List &&
                this.asts[this.top - 1].nodeType === TypeScript.NodeType.New &&
                (<TypeScript.CallExpression>this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        }

        public isSynthesizedBlock(): bool {
            return this.count() >= 1 &&
                this.asts[this.top - 0].nodeType === TypeScript.NodeType.Block &&
                (<TypeScript.Block>this.asts[this.top - 0]).isStatementBlock === false;
        }

        public isInClassImplementsList(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.parent().nodeType === TypeScript.NodeType.ClassDeclaration) &&
                (this.isMemberOfList((<TypeScript.ClassDeclaration>this.parent()).implementsList, this.ast()));
        }

        public isInInterfaceExtendsList(): bool {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.parent().nodeType === TypeScript.NodeType.InterfaceDeclaration) &&
                (this.isMemberOfList((<TypeScript.InterfaceDeclaration>this.parent()).extendsList, this.ast()));
        }

        private isMemberOfList(list: ASTList, item: AST): bool {
            if (list && list.members) {
                for (var i = 0, n = list.members.length; i < n; i++) {
                    if (list.members[i] === item) {
                        return true;
                    }
                }
            }

            return false;
        }
    }

    export function isValidAstNode(ast: TypeScript.IASTSpan): bool {
        if (ast === null)
            return false;

        if (ast.minChar === -1 || ast.limChar === -1)
            return false;

        return true;
    }

    export class AstPathContext {
        public path = new TypeScript.AstPath();
    }

    export enum GetAstPathOptions {
        Default = 0,
        EdgeInclusive = 1,
        //We need this options dealing with an AST coming from an incomplete AST. For example:
        //     class foo { // r
        // If we ask for the AST at the position after the "r" character, we won't see we are 
        // inside a comment, because the "class" AST node has a limChar corresponding to the position of 
        // the "{" character, meaning we don't traverse the tree down to the stmt list of the class, meaning
        // we don't find the "precomment" attached to the errorneous empty stmt.
        //TODO: It would be nice to be able to get rid of this.
        DontPruneSearchBasedOnPosition = 1 << 1,
    }

    ///
    /// Return the stack of AST nodes containing "position"
    ///
    export function getAstPathToPosition(script: TypeScript.AST, pos: number, options = GetAstPathOptions.Default): TypeScript.AstPath {
        var lookInComments = (comments: TypeScript.Comment[]) => {
            if (comments && comments.length > 0) {
                for (var i = 0; i < comments.length; i++) {
                    var minChar = comments[i].minChar;
                    var limChar = comments[i].limChar;
                    if (!comments[i].isBlockComment) {
                        limChar++; // For single line comments, include 1 more character (for the newline)
                    }
                    if (pos >= minChar && pos < limChar) {
                        ctx.path.push(comments[i]);
                    }
                }
            }
        }

        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: IAstWalker) {
            if (isValidAstNode(cur)) {

                // Add "cur" to the stack if it contains our position
                // For "identifier" nodes, we need a special case: A position equal to "limChar" is
                // valid, since the position corresponds to a caret position (in between characters)
                // For example:
                //  bar
                //  0123
                // If "position === 3", the caret is at the "right" of the "r" character, which should be considered valid
                var inclusive =
                    hasFlag(options, GetAstPathOptions.EdgeInclusive) ||
                    cur.nodeType === TypeScript.NodeType.Name ||
                    cur.nodeType === TypeScript.NodeType.TypeRef ||
                    pos === script.limChar; // Special "EOF" case

                var minChar = cur.minChar;
                var limChar = cur.limChar + (inclusive ? 1 : 0)
                if (pos >= minChar && pos < limChar) {

                    // TODO: Since AST is sometimes not correct wrt to position, only add "cur" if it's better
                    //       than top of the stack.
                    var previous = ctx.path.ast();
                    if (previous === null || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {
                        ctx.path.push(cur);
                    }
                    else {
                        //logger.log("TODO: Ignoring node because minChar, limChar not better than previous node in stack");
                    }
                }

                // The AST walker skips comments, but we might be in one, so check the pre/post comments for this node manually
                if (pos < limChar) {
                    lookInComments(cur.preComments);
                }
                if (pos >= minChar) {
                    lookInComments(cur.postComments);
                }

                if (!hasFlag(options, GetAstPathOptions.DontPruneSearchBasedOnPosition)) {
                    // Don't go further down the tree if pos is outside of [minChar, limChar]
                    walker.options.goChildren = (minChar <= pos && pos <= limChar);
                }
            }
            return cur;
        }

        var ctx = new AstPathContext();
        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);
        return ctx.path;
    }

    ///
    /// Simple function to Walk an AST using a simple callback function.
    ///
    export function walkAST(ast: TypeScript.AST, callback: (path: AstPath, walker: TypeScript.IAstWalker) => void ): void {
        var pre = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {
            var path: TypeScript.AstPath = walker.state;
            path.push(cur);
            callback(path, walker);
            return cur;
        }
        var post = function (cur: TypeScript.AST, parent: TypeScript.AST, walker: TypeScript.IAstWalker) {
            var path: TypeScript.AstPath = walker.state;
            path.pop();
            return cur;
        }

        var path = new AstPath();
        TypeScript.getAstWalkerFactory().walk(ast, pre, post, null, path);
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class Binder {
        constructor(public checker: TypeChecker) { }
        
        public resolveBaseTypeLinks(typeLinks: TypeLink[], scope: SymbolScope) {
            var extendsList: Type[] = null;
            if (typeLinks) {
                extendsList = [];
                for (var i = 0, len = typeLinks.length; i < len; i++) {
                    extendsList[i] = this.checker.resolveBaseTypeLink(typeLinks[i], scope);
                }
            }
            return extendsList;
        }

        public resolveBases(scope: SymbolScope, type: Type) {
            type.extendsList = this.resolveBaseTypeLinks(type.extendsTypeLinks, scope);

            var i = 0, len = type.extendsList.length;
            var derivedIsClass = type.isClassInstance();
            var baseRef: AST = null;
            for (; i < len; i++) {
                var baseIsClass = type.extendsList[i].isClassInstance();
                if (type.extendsList[i] != this.checker.anyType) {
                    baseRef = type.extendsTypeLinks[i].ast;
                    if (derivedIsClass) {
                        if (!baseIsClass) {
                            this.checker.errorReporter.simpleError(baseRef,
                                                                     "A class may only extend other classes, " + type.extendsList[i].symbol.fullName() + " is not a class.");
                        }
                    }
                    else {
                        if (baseIsClass) {
                            this.checker.errorReporter.simpleError(baseRef,
                                                                     "An interface may only extend other interfaces, " + type.extendsList[i].symbol.fullName() + " is a class.");
                        }
                    }
                }
            }

            type.implementsList = this.resolveBaseTypeLinks(type.implementsTypeLinks, scope);

            if (type.implementsList) {
                for (i = 0, len = type.implementsList.length; i < len; i++) {
                    var iface = type.implementsList[i];
                    baseRef = type.implementsTypeLinks[i].ast;
                    if (iface.isClassInstance()) {
                        if (derivedIsClass) {
                            this.checker.errorReporter.simpleError(baseRef,
                                                                     "A class may only implement an interface; " + iface.symbol.fullName() + " is a class.");
                        }
                    }
                }
            }
        }

        public resolveSignatureGroup(signatureGroup: SignatureGroup, scope: SymbolScope, instanceType: Type) {
            var supplyVar = !(signatureGroup.hasImplementation);
            for (var i = 0, len = signatureGroup.signatures.length; i < len; i++) {
                var signature = signatureGroup.signatures[i];
                if (instanceType) {
                    signature.returnType.type = instanceType;
                }
                else {
                    this.checker.resolveTypeLink(scope, signature.returnType, supplyVar);
                }
                var paramLen = signature.parameters.length;
                for (var j = 0; j < paramLen; j++) {
                    this.bindSymbol(scope, signature.parameters[j]);
                }
                if (signature.hasVariableArgList) {
                    // check that last parameter has an array type
                    var lastParam = <ParameterSymbol>signature.parameters[paramLen - 1];
                    lastParam.argsOffset = paramLen - 1;
                    if (!lastParam.getType().isArray()) {
                        this.checker.errorReporter.simpleErrorFromSym(lastParam,
                                                                 "... parameter must have array type");
                        lastParam.parameter.typeLink.type = this.checker.makeArrayType(lastParam.parameter.typeLink.type);
                    }
                }
            }
        }

        public bindType(scope: SymbolScope, type: Type, instanceType: Type): void {
            if (instanceType) {
                this.bindType(scope, instanceType, null);
            }
            var callAndConstructScope = scope;
            if (type.hasMembers()) {
                var members = type.members;
                var ambientMembers = type.ambientMembers;
                var typeMembers = type.getAllEnclosedTypes(); // REVIEW: Should only be getting exported types?
                var ambientTypeMembers = type.getAllAmbientEnclosedTypes(); // REVIEW: Should only be getting exported types?
                var memberScope = new SymbolTableScope(members, ambientMembers, typeMembers, ambientTypeMembers, type.symbol);
                var agg = new SymbolAggregateScope(type.symbol);
                var prevCurrentModDecl = this.checker.currentModDecl;
                var prevBindStatus = this.checker.inBind;
                agg.addParentScope(memberScope);
                agg.addParentScope(scope);
                if (type.isModuleType()) {
                    this.checker.currentModDecl = <ModuleDeclaration>type.symbol.declAST;
                    this.checker.inBind = true;
                }
                if (members) {
                    this.bind(agg, type.members.allMembers); // REVIEW: Should only be getting exported types?
                }
                if (typeMembers) {
                    this.bind(agg, typeMembers.allMembers);
                }
                if (ambientMembers) {
                    this.bind(agg, ambientMembers.allMembers);
                }
                if (ambientTypeMembers) {
                    this.bind(agg, ambientTypeMembers.allMembers);
                }
                if (type.isModuleType()) {
                    callAndConstructScope = agg;
                }
                this.checker.currentModDecl = prevCurrentModDecl;
                this.checker.inBind = prevBindStatus;
            }
            if (type.extendsTypeLinks) {
                this.resolveBases(scope, type);
            }
            if (type.construct) {
                this.resolveSignatureGroup(type.construct, callAndConstructScope, instanceType);
            }
            if (type.call) {
                this.resolveSignatureGroup(type.call, callAndConstructScope, null);
            }
            if (type.index) {
                this.resolveSignatureGroup(type.index, scope, null);
            }
            if (type.elementType) {
                this.bindType(scope, type.elementType, null);
            }
        }

        public bindSymbol(scope: SymbolScope, symbol: Symbol) {
            if (!symbol.bound) {
                var prevLocationInfo = this.checker.locationInfo;
                if (this.checker.fileNameToLocationInfo && (symbol.fileName != unknownLocationInfo.fileName) && this.checker.fileNameToLocationInfo.lookup(symbol.fileName)) {
                    this.checker.locationInfo = this.checker.fileNameToLocationInfo.lookup(symbol.fileName);
                }
                switch (symbol.kind()) {
                    case SymbolKind.Type:

                        if (symbol.flags & SymbolFlags.Bound) {
                            break;
                        }

                        var typeSymbol = <TypeSymbol>symbol;
                        typeSymbol.flags |= SymbolFlags.Bound;

                        // Since type collection happens out of order, a dynamic module referenced by an import statement
                        // may not yet be in scope when the import symbol is created.  In that case, we need to search
                        // out the module symbol now
                        // Note that we'll also want to do this in resolveTypeMembers, in case the symbol is set outside the
                        // context of a given module  (E.g., an outer import statement)
                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType == NodeType.Name) {
                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;
                            var modSym = this.checker.findSymbolForDynamicModule(modPath, this.checker.locationInfo.fileName, (id) => scope.find(id, false, true));
                            if (modSym) {
                                typeSymbol.type = modSym.getType();
                            }
                        }

                        if (typeSymbol.type && typeSymbol.type != this.checker.gloModType) {
                            this.bindType(scope, typeSymbol.type, typeSymbol.instanceType);

                            // bind expansions on the parent type symbol
                            if (typeSymbol.type.isModuleType()) {
                                for (var i = 0; i < typeSymbol.expansions.length; i++) {
                                    this.bindType(scope, typeSymbol.expansions[i], typeSymbol.instanceType);
                                }
                            }
                        }
                        break;
                    case SymbolKind.Field:
                        this.checker.resolveTypeLink(scope, (<FieldSymbol>symbol).field.typeLink,
                                                false);
                        break;
                    case SymbolKind.Parameter:
                        this.checker.resolveTypeLink(scope,
                                                (<ParameterSymbol>symbol).parameter.typeLink,
                                                true);
                        break;
                }
                this.checker.locationInfo = prevLocationInfo;
            }
            symbol.bound = true;
        }

        public bind(scope: SymbolScope, table: IHashTable) {
            table.map(
                (key, sym, binder) => {
                    return binder.bindSymbol(scope, sym);
                },
                this);
        }
    }

}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

module TypeScript {
    class Base64Format {
        static encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        static encode(inValue: number) {
            if (inValue < 64) {
                return Base64Format.encodedValues.charAt(inValue);
            }
            throw TypeError(inValue + ": not a 64 based value");
        }

        static decodeChar(inChar: string) {
            if (inChar.length === 1) {
                return Base64Format.encodedValues.indexOf(inChar);
            } else {
                throw TypeError('"' + inChar + '" must have length 1');
            }
        }
    }

    export class Base64VLQFormat {
        static encode(inValue: number) {
            // Add a new least significant bit that has the sign of the value.
            // if negative number the least significant bit that gets added to the number has value 1
            // else least significant bit value that gets added is 0
            // eg. -1 changes to binary : 01 [1] => 3
            //     +1 changes to binary : 01 [0] => 2
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            }
            else {
                inValue = inValue << 1;
            }

            // Encode 5 bits at a time starting from least significant bits
            var encodedStr = "";
            do {
                var currentDigit = inValue & 31; // 11111
                inValue = inValue >> 5;
                if (inValue > 0) {
                    // There are still more digits to decode, set the msb (6th bit)
                    currentDigit = currentDigit | 32; 
                }
                encodedStr = encodedStr + Base64Format.encode(currentDigit);
            } while (inValue > 0);

            return encodedStr;
        }

        static decode(inString: string) {
            var result = 0;
            var negative = false;

            var shift = 0;
            for (var i = 0; i < inString.length; i++) {
                var byte = Base64Format.decodeChar(inString[i]);
                if (i === 0) {
                    // Sign bit appears in the LSBit of the first value
                    if ((byte & 1) === 1) {
                        negative = true;
                    }
                    result = (byte >> 1) & 15; // 1111x
                } else {
                    result = result | ((byte & 31) << shift); // 11111
                }

                shift += (i == 0) ? 4 : 5;

                if ((byte & 32) === 32) {
                    // Continue
                } else {
                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };
                }
            }

            throw new Error('Base64 value "' + inString + '" finished with a continuation bit');
        }
    }
}
﻿/* -----------------------------------------------------------------------------
This file is based on or incorporates material from the projects listed below 
(collectively, "Third Party Code"). Microsoft is not the original author of the 
Third Party Code. The original copyright notice and the license, under which 
Microsoft received such Third Party Code, are set forth below. Such licenses 
and notices are provided for informational purposes only. Microsoft, not the 
third party, licenses the Third Party Code to you under the terms of the 
Apache License, Version 2.0. See License.txt in the project root for complete 
license information. Microsoft reserves all rights not expressly granted under 
the Apache 2.0 License, whether by implication, estoppel or otherwise. 
----------------------------------------------------------------------------- */

/*
    json2.js
    2011-10-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON2: any = {};

(function() {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = <any>function (key) {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear() + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate()) + 'T' +
                    f(this.getUTCHours()) + ':' +
                    f(this.getUTCMinutes()) + ':' +
                    f(this.getUTCSeconds()) + 'Z'
                : null;
        };

        var strProto: any = String.prototype;
        var numProto: any = Number.prototype;
        numProto.JSON = strProto.JSON =
            (<any>Boolean).prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"': '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

        // If the string contains no control characters, no quote characters, and no
        // backslash characters, then we can safely slap some quotes around it.
        // Otherwise we must also replace the offending characters with safe escape
        // sequences.

        escapable.lastIndex = <any>0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a: string) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder): string {

        // Produce a string from holder[key].

        var i,          // The loop counter.
            k = null,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

        // If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

        // If we were called with a replacer function, then call the replacer to
        // obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

        // What happens next depends on the value's type.

        switch (typeof value) {
            case 'string':
                return quote(value);

            case 'number':

                // JSON numbers must be finite. Encode non-finite numbers as null.

                return isFinite(value) ? String(value) : 'null';

            case 'boolean':
            case 'null':

                // If the value is a boolean or null, convert it to a string. Note:
                // typeof null does not produce 'null'. The case is included here in
                // the remote chance that this gets fixed someday.

                return String(value);

            // If the type is 'object', we might be dealing with an object or an array or
            // null.

            case 'object':

                // Due to a specification blunder in ECMAScript, typeof null is 'object',
                // so watch out for that case.

                if (!value) {
                    return 'null';
                }

                // Make an array to hold the partial results of stringifying this object value.

                gap += indent;
                partial = [];

                // Is the value an array?

                if (Object.prototype.toString.apply(value, []) === '[object Array]') {

                    // The value is an array. Stringify every element. Use null as a placeholder
                    // for non-JSON values.

                    length = value.length;
                    for (i = 0; i < length; i += 1) {
                        partial[i] = str(i, value) || 'null';
                    }

                    // Join all of the elements together, separated with commas, and wrap them in
                    // brackets.

                    v = partial.length === 0
                        ? '[]'
                        : gap
                        ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                        : '[' + partial.join(',') + ']';
                    gap = mind;
                    return v;
                }

                // If the replacer is an array, use it to select the members to be stringified.

                if (rep && typeof rep === 'object') {
                    length = rep.length;
                    for (i = 0; i < length; i += 1) {
                        if (typeof rep[i] === 'string') {
                            k = rep[i];
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                } else {

                    // Otherwise, iterate through all of the keys in the object.

                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? ': ' : ':') + v);
                            }
                        }
                    }
                }

                // Join all of the member texts together, separated with commas,
                // and wrap them in braces.

                v = partial.length === 0
                    ? '{}'
                    : gap
                    ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                    : '{' + partial.join(',') + '}';
                gap = mind;
                return v;
        }
    }

    // If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON2.stringify !== 'function') {
        JSON2.stringify = function (value, replacer, space) {

            // The stringify method takes a value and an optional replacer, and an optional
            // space parameter, and returns a JSON text. The replacer can be a function
            // that can replace values, or an array of strings that will select the keys.
            // A default replacer method can be provided. Use of the space parameter can
            // produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

            // If the space parameter is a number, make an indent string containing that
            // many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

                // If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

            // If there is a replacer, it must be a function or an array.
            // Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

            // Make a fake root object containing our value under the key of ''.
            // Return the result of stringifying the value.

            return str('', { '': value });
        };
    }
} ());
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />
///<reference path='..\harness\external\json2Stringify.ts' />

module TypeScript {
    export class SourceMapPosition {
        public sourceLine: number;
        public sourceColumn: number;
        public emittedLine: number;
        public emittedColumn: number;
    }

    export class SourceMapping {
        public start = new SourceMapPosition();
        public end = new SourceMapPosition();
        public nameIndex: number = -1;
        public childMappings: SourceMapping[] = [];
    }

    export class SourceMapper {
        static MapFileExtension = ".map";
        
        public sourceMappings: SourceMapping[] = [];
        public currentMappings: SourceMapping[][] = [];

        public names: string[] = [];
        public currentNameIndex: number[] = [];

        public jsFileName: string;
        public tsFileName: string;

        constructor(tsFileName: string,
                    jsFileName: string,
                    public sourceMapFileName: string,
                    public jsFile: ITextWriter,
                    public sourceMapOut: ITextWriter,
                    emitFullPathOfSourceMap: bool) {
            this.currentMappings.push(this.sourceMappings);

            jsFileName = switchToForwardSlashes(jsFileName);
            this.jsFileName = TypeScript.getPrettyName(jsFileName, false, true);
            
            var removalIndex = jsFileName.lastIndexOf(this.jsFileName);
            var fixedPath = jsFileName.substring(0, removalIndex);

            if (emitFullPathOfSourceMap) {
                if (jsFileName.indexOf("://") == -1) {
                    jsFileName = "file:///" + jsFileName;
                }
                this.jsFileName = jsFileName;
            }

            this.tsFileName = TypeScript.getRelativePathToFixedPath(fixedPath, tsFileName);
        }
        
        // Generate source mapping.
        // Creating files can cause exceptions, they will be caught higher up in TypeScriptCompiler.emit
        static emitSourceMapping(allSourceMappers: SourceMapper[]): void {
            // At this point we know that there is at least one source mapper present.
            // If there are multiple source mappers, all will correspond to same map file but different sources

            // Output map file name into the js file
            var sourceMapper = allSourceMappers[0];
            sourceMapper.jsFile.WriteLine("//@ sourceMappingURL=" + sourceMapper.jsFileName + SourceMapper.MapFileExtension);

            // Now output map file
            var sourceMapOut = sourceMapper.sourceMapOut;
            var mappingsString = "";
            var tsFiles: string[] = [];

            var prevEmittedColumn = 0;
            var prevEmittedLine = 0;
            var prevSourceColumn = 0;
            var prevSourceLine = 0;
            var prevSourceIndex = 0;
            var prevNameIndex = 0;
            var namesList: string[] = [];
            var namesCount = 0;
            var emitComma = false;

            var recordedPosition: SourceMapPosition = null;
            for (var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {
                sourceMapper = allSourceMappers[sourceMapperIndex];

                // If there are any mappings generated
                var currentSourceIndex = tsFiles.length;
                tsFiles.push(sourceMapper.tsFileName);

                // Join namelist
                if (sourceMapper.names.length > 0) {
                    namesList.push.apply(namesList, sourceMapper.names);
                }

                var recordSourceMapping = (mappedPosition: SourceMapPosition, nameIndex: number) => {
                    if (recordedPosition != null &&
                        recordedPosition.emittedColumn == mappedPosition.emittedColumn &&
                        recordedPosition.emittedLine == mappedPosition.emittedLine) {
                        // This position is already recorded
                        return;
                    }

                    // Record this position
                    if (prevEmittedLine !== mappedPosition.emittedLine) {
                        while (prevEmittedLine < mappedPosition.emittedLine) {
                            prevEmittedColumn = 0;
                            mappingsString = mappingsString + ";";
                            prevEmittedLine++;
                        }
                        emitComma = false;
                    }
                    else if (emitComma) {
                        mappingsString = mappingsString + ",";
                    }

                    // 1. Relative Column
                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);
                    prevEmittedColumn = mappedPosition.emittedColumn;

                    // 2. Relative sourceIndex 
                    mappingsString = mappingsString + Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);
                    prevSourceIndex = currentSourceIndex;

                    // 3. Relative sourceLine 0 based
                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);
                    prevSourceLine = mappedPosition.sourceLine - 1;

                    // 4. Relative sourceColumn 0 based 
                    mappingsString = mappingsString + Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);
                    prevSourceColumn = mappedPosition.sourceColumn;

                    // 5. Relative namePosition 0 based
                    if (nameIndex >= 0) {
                        mappingsString = mappingsString + Base64VLQFormat.encode(namesCount + nameIndex - prevNameIndex);
                        prevNameIndex = namesCount + nameIndex;
                    }

                    emitComma = true;
                    recordedPosition = mappedPosition;
                }

                // Record starting spans
                var recordSourceMappingSiblings = (sourceMappings: SourceMapping[]) => {
                    for (var i = 0; i < sourceMappings.length; i++) {
                        var sourceMapping = sourceMappings[i];
                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);
                        recordSourceMappingSiblings(sourceMapping.childMappings);
                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);
                    }
                }

                recordSourceMappingSiblings(sourceMapper.sourceMappings);
                namesCount = namesCount + sourceMapper.names.length;
            }

            // Write the actual map file
            sourceMapOut.Write(JSON2.stringify({
                version: 3,
                file: sourceMapper.jsFileName,
                sources: tsFiles,
                names: namesList,
                mappings: mappingsString
            }));

            // Closing files could result in exceptions, report them if they occur
            sourceMapOut.Close();
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export enum EmitContainer {
        Prog,
        Module,
        DynamicModule,
        Class,
        Constructor,
        Function,
        Args,
        Interface,
    }

    export class EmitState {
        public column: number;
        public line: number;
        public pretty: bool;
        public inObjectLiteral: bool;
        public container: EmitContainer;

        constructor () {
            this.column = 0;
            this.line = 0;
            this.pretty = false;
            this.inObjectLiteral = false;
            this.container = EmitContainer.Prog;
        }
    }

    export class EmitOptions {
        public ioHost: EmitterIOHost = null;
        public outputMany: bool = true;
        public commonDirectoryPath = "";

        constructor(public compilationSettings: CompilationSettings) {
        }

        public mapOutputFileName(fileName: string, extensionChanger: (fname: string, wholeFileNameReplaced: bool) => string) {
            if (this.outputMany) {
                var updatedFileName = fileName;
                if (this.compilationSettings.outputOption != "") {
                    // Replace the common directory path with the option specified
                    updatedFileName = fileName.replace(this.commonDirectoryPath, "");
                    updatedFileName = this.compilationSettings.outputOption + updatedFileName;
                }
                return extensionChanger(updatedFileName, false);
            } else {
                return extensionChanger(this.compilationSettings.outputOption, true);
            }
        }
    }

    export class Indenter {
        static indentStep : number = 4;
        static indentStepString : string = "    ";
        static indentStrings: string[] = [];
        public indentAmt: number = 0;

        public increaseIndent() {
            this.indentAmt += Indenter.indentStep;
        }

        public decreaseIndent() {
            this.indentAmt -= Indenter.indentStep;
        }

        public getIndent() {
            var indentString = Indenter.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {
                    indentString += Indenter.indentStepString;
                }
                Indenter.indentStrings[this.indentAmt] = indentString;
            }
            return indentString;
        }
    }

    export interface BoundDeclInfo {
        boundDecl: BoundDecl;
        pullDecl: PullDecl;
    }

    export class Emitter {
        public globalThisCapturePrologueEmitted = false;
        public extendsPrologueEmitted = false;
        public thisClassNode: TypeDeclaration = null;
        public thisFnc: FuncDecl = null;
        public moduleDeclList: ModuleDeclaration[] = [];
        public moduleName = "";
        public emitState = new EmitState();
        public indenter = new Indenter();
        public ambientModule = false;
        public modAliasId: string = null;
        public firstModAlias: string = null;
        public allSourceMappers: SourceMapper[] = [];
        public sourceMapper: SourceMapper = null;
        public captureThisStmtString = "var _this = this;";
        public varListCountStack: number[] = [0];

        constructor(public checker: TypeChecker,
                    public emittingFileName: string,
                    public outfile: ITextWriter,
                    public emitOptions: EmitOptions) {
        }

        public isPull() { return false; }

        public importStatementShouldBeEmitted(importDeclAST: ImportDeclaration): bool {
            return !importDeclAST.isDynamicImport || (importDeclAST.id.sym && !(<TypeSymbol>importDeclAST.id.sym).onlyReferencedAsTypeRef);
        }

        public setSourceMappings(mapper: SourceMapper) {
            this.allSourceMappers.push(mapper);
            this.sourceMapper = mapper;
        }

        public writeToOutput(s: string) {
            this.outfile.Write(s);
            // TODO: check s for newline
            this.emitState.column += s.length;
        }

        public writeToOutputTrimmable(s: string) {
            if (this.emitOptions.compilationSettings.minWhitespace) {
                s = s.replace(/[\s]*/g, '');
            }
            this.writeToOutput(s);
        }

        public writeLineToOutput(s: string) {
            if (this.emitOptions.compilationSettings.minWhitespace) {
                this.writeToOutput(s);
                var c = s.charCodeAt(s.length - 1);
                if (!((c === LexCodeSpace) || (c === LexCodeSMC) || (c === LexCodeLBR))) {
                    this.writeToOutput(' ');
                }
            }
            else {
                this.outfile.WriteLine(s);
                this.emitState.column = 0
                this.emitState.line++;
            }
        }

        public writeCaptureThisStatement(ast: AST) {
            this.emitIndent();
            this.recordSourceMappingStart(ast);
            this.writeToOutput(this.captureThisStmtString);
            this.recordSourceMappingEnd(ast);
            this.writeLineToOutput("");
        }

        public setInVarBlock(count: number) {
            this.varListCountStack[this.varListCountStack.length - 1] = count;
        }

        public setInObjectLiteral(val: bool): bool {
            var temp = this.emitState.inObjectLiteral;
            this.emitState.inObjectLiteral = val;
            return temp;
        }

        public setContainer(c: number): number {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        }

        private getIndentString() {
            if (this.emitOptions.compilationSettings.minWhitespace) {
                return "";
            }
            else {
                return this.indenter.getIndent();
            }
        }

        public emitIndent() {
            this.writeToOutput(this.getIndentString());
        }

        public emitCommentInPlace(comment: Comment) {
            var text = comment.getText();
            var hadNewLine = false;

            if (comment.isBlockComment) {
                if (this.emitState.column === 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);

                if (text.length > 1 || comment.endsLine) {
                    for (var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingEnd(comment);
                    this.writeLineToOutput("");
                    hadNewLine = true;
                } else {
                    this.recordSourceMappingEnd(comment);
                }
            }
            else {
                if (this.emitState.column === 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingEnd(comment);
                this.writeLineToOutput("");
                hadNewLine = true;
            }

            if (hadNewLine) {
                this.emitIndent();
            }
            else {
                this.writeToOutput(" ");
            }
        }

        public emitParensAndCommentsInPlace(ast: AST, pre: bool) {
            var comments = pre ? ast.preComments : ast.postComments;

            // comments should be printed before the LParen, but after the RParen
            if (ast.isParenthesized && !pre) {
                this.writeToOutput(")");
            }
            if (this.emitOptions.compilationSettings.emitComments && comments && comments.length != 0) {
                for (var i = 0; i < comments.length; i++) {
                    this.emitCommentInPlace(comments[i]);
                }
            }
            if (ast.isParenthesized && pre) {
                this.writeToOutput("(");
            }
        }

        // TODO: emit accessor pattern
        public emitObjectLiteral(content: ASTList) {
            if (content.members.length === 0) {
                this.writeToOutput("{}");
                return;
            }

            this.writeLineToOutput("{");
            this.indenter.increaseIndent();
            var inObjectLiteral = this.setInObjectLiteral(true);
            this.emitJavascriptList(content, ",", TokenID.Comma, true, false, false);
            this.setInObjectLiteral(inObjectLiteral);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeToOutput("}");
        }

        public emitArrayLiteral(content: ASTList) {
            this.writeToOutput("[");
            if (content && content.members.length > 0) {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascriptList(content, ", ", TokenID.Comma, true, false, false);
                this.indenter.decreaseIndent();
                this.emitIndent();
            }
            this.writeToOutput("]");
        }

        public emitNew(target: AST, args: ASTList) {
            this.writeToOutput("new ");
            if (target.nodeType === NodeType.TypeRef) {
                var typeRef = <TypeReference>target;
                if (typeRef.arrayCount) {
                    this.writeToOutput("Array()");
                }
                else {
                    this.emitJavascript(typeRef.term, TokenID.Tilde, false);
                    this.writeToOutput("()");
                }
            }
            else {
                this.emitJavascript(target, TokenID.Tilde, false);
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(args);
            }
        }

        public getVarDeclFromIdentifier(boundDeclInfo: BoundDeclInfo): BoundDeclInfo {
            CompilerDiagnostics.assert(boundDeclInfo.boundDecl && boundDeclInfo.boundDecl.init &&
                boundDeclInfo.boundDecl.init.nodeType == NodeType.Name,
                "The init expression of bound declaration when emitting as constant has to be indentifier");

            var init = boundDeclInfo.boundDecl.init;
            var ident = <Identifier>init;
            if (ident.sym !== null && ident.sym.declAST.nodeType === NodeType.VarDecl) {
                return { boundDecl: <VarDecl>ident.sym.declAST, pullDecl: null };
            }

            return null;
        }

        private getConstantValue(boundDeclInfo: BoundDeclInfo): number {
            var init = boundDeclInfo.boundDecl.init;
            if (init) {
                if (init.nodeType === NodeType.NumberLit) {
                    var numLit = <NumberLiteral>init;
                    return numLit.value;
                }
                else if (init.nodeType === NodeType.Lsh) {
                    var binop = <BinaryExpression>init;
                    if (binop.operand1.nodeType === NodeType.NumberLit &&
                        binop.operand2.nodeType === NodeType.NumberLit) {
                        return (<NumberLiteral>binop.operand1).value << (<NumberLiteral>binop.operand2).value;
                    }
                }
                else if (init.nodeType === NodeType.Name) {
                    var varDeclInfo = this.getVarDeclFromIdentifier(boundDeclInfo);
                    if (varDeclInfo) {
                        return this.getConstantValue(varDeclInfo);
                    }
                }
            }

            return null;
        }

        public getConstantDecl(dotExpr: BinaryExpression): BoundDeclInfo {
            var propertyName = <Identifier>dotExpr.operand2;
            if (propertyName && propertyName.sym && propertyName.sym.isVariable()) {
                if (hasFlag(propertyName.sym.flags, SymbolFlags.Constant)) {
                    if (propertyName.sym.declAST) {
                        var boundDecl = <BoundDecl>propertyName.sym.declAST;
                        return { boundDecl: boundDecl, pullDecl: null };
                    }
                }
            }

            return null;
        }

        public tryEmitConstant(dotExpr: BinaryExpression) {
            if (!this.emitOptions.compilationSettings.propagateConstants) {
                return false;
            }
            var propertyName = <Identifier>dotExpr.operand2;
            var boundDeclInfo = this.getConstantDecl(dotExpr);
            if (boundDeclInfo) {
                var value = this.getConstantValue(boundDeclInfo);
                if (value !== null) {
                    this.writeToOutput(value.toString());
                    var comment = " /* ";
                    comment += propertyName.actualText;
                    comment += " */ ";
                    this.writeToOutput(comment);
                    return true;
                }
            }

            return false;
        }

        public emitCall(callNode: CallExpression, target: AST, args: ASTList) {
            if (!this.emitSuperCall(callNode)) {
                if (!hasFlag(callNode.flags, ASTFlags.ClassBaseConstructorCall)) {
                    if (target.nodeType === NodeType.FuncDecl && !target.isParenthesized) {
                        this.writeToOutput("(");
                    }
                    if (callNode.target.nodeType === NodeType.Super && this.emitState.container === EmitContainer.Constructor) {
                        this.writeToOutput("_super.call");
                    }
                    else {
                        this.emitJavascript(target, TokenID.OpenParen, false);
                    }
                    if (target.nodeType === NodeType.FuncDecl && !target.isParenthesized) {
                        this.writeToOutput(")");
                    }
                    this.recordSourceMappingStart(args);
                    this.writeToOutput("(");
                    if (callNode.target.nodeType === NodeType.Super && this.emitState.container === EmitContainer.Constructor) {
                        this.writeToOutput("this");
                        if (args && args.members.length) {
                            this.writeToOutput(", ");
                        }
                    }
                    this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);
                    this.writeToOutput(")");
                    this.recordSourceMappingEnd(args);
                }
                else {
                    this.indenter.decreaseIndent();
                    this.indenter.decreaseIndent();
                    var constructorCall = new ASTList();
                    constructorCall.members[0] = callNode;
                    this.emitConstructorCalls(constructorCall, this.thisClassNode);
                    this.indenter.increaseIndent();
                    this.indenter.increaseIndent();
                }
            }
        }

        public emitConstructorCalls(bases: ASTList, classDecl: TypeDeclaration) {
            if (bases === null) {
                return;
            }
            var basesLen = bases.members.length;
            this.recordSourceMappingStart(classDecl);
            for (var i = 0; i < basesLen; i++) {
                var baseExpr = bases.members[i];
                var baseSymbol: Symbol = null;
                if (baseExpr.nodeType === NodeType.Call) {
                    baseSymbol = (<CallExpression>baseExpr).target.type.symbol;
                }
                else {
                    baseSymbol = baseExpr.type.symbol;
                }
                var baseName = baseSymbol.name;
                if (baseSymbol.declModule != classDecl.type.symbol.declModule) {
                    baseName = baseSymbol.fullName();
                }
                if (baseExpr.nodeType === NodeType.Call) {
                    this.emitIndent();
                    this.writeToOutput("_super.call(this");
                    var args = (<CallExpression>baseExpr).arguments;
                    if (args && (args.members.length > 0)) {
                        this.writeToOutput(", ");
                        this.emitJavascriptList(args, ", ", TokenID.Comma, false, false, false);
                    }
                    this.writeToOutput(")");
                }
                else {
                    if (baseExpr.type && (baseExpr.type.isClassInstance())) {
                        // parameterless constructor call;
                        this.emitIndent();
                        this.writeToOutput(classDecl.name.actualText + "._super.constructor");
                        //emitJavascript(baseExpr,TokenID.LParen,false);
                        this.writeToOutput(".call(this)");
                    }
                }
            }
            this.recordSourceMappingEnd(classDecl);
        }

        public getClassPropertiesMustComeAfterSuperCall(funcDecl: FuncDecl, classDecl: TypeDeclaration) {
            var isClassConstructor = funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod);
            var hasNonObjectBaseType = isClassConstructor && hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseType) && !hasFlag(this.thisClassNode.type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);
            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);
            return classPropertiesMustComeAfterSuperCall;
        }

        public isAccessorInObjectLiteral(funcDecl: FuncDecl) {
            return (<FieldSymbol>funcDecl.accessorSymbol).isObjectLitField;
        }

        public emitInnerFunction(funcDecl: FuncDecl, printName: bool, isMember: bool,
            hasSelfRef: bool, classDecl: TypeDeclaration) {
            /// REVIEW: The code below causes functions to get pushed to a newline in cases where they shouldn't
            /// such as: 
            ///     Foo.prototype.bar = 
            ///         function() {
            ///         };
            /// Once we start emitting comments, we should pull this code out to place on the outer context where the function
            /// is used.
            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {
            //    this.writeLineToOutput("");
            //    this.increaseIndent();
            //    emitIndent();
            //}

            var classPropertiesMustComeAfterSuperCall = this.getClassPropertiesMustComeAfterSuperCall(funcDecl, classDecl);

            // We have no way of knowing if the current function is used as an expression or a statement, so as to enusre that the emitted
            // JavaScript is always valid, add an extra parentheses for unparenthesized function expressions
            var shouldParenthesize = hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) && !funcDecl.isParenthesized && !funcDecl.isAccessor() && (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon));

            this.emitParensAndCommentsInPlace(funcDecl, true);
            if (shouldParenthesize) {
                this.writeToOutput("(");
            }
            this.recordSourceMappingStart(funcDecl);
            if (!(funcDecl.isAccessor() && this.isAccessorInObjectLiteral(funcDecl))) {
                this.writeToOutput("function ");
            }
            if (printName) {
                var id = funcDecl.getNameText();
                if (id && !funcDecl.isAccessor()) {
                    if (funcDecl.name) {
                        this.recordSourceMappingStart(funcDecl.name);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.name) {
                        this.recordSourceMappingEnd(funcDecl.name);
                    }
                }
            }

            this.writeToOutput("(");
            var argsLen = 0;
            var i = 0;
            var arg: ArgDecl;
            var defaultArgs: ArgDecl[] = [];
            if (funcDecl.arguments) {
                var tempContainer = this.setContainer(EmitContainer.Args);
                argsLen = funcDecl.arguments.members.length;
                var printLen = argsLen;
                if (funcDecl.variableArgList) {
                    printLen--;
                }
                for (i = 0; i < printLen; i++) {
                    arg = <ArgDecl>funcDecl.arguments.members[i];
                    if (arg.init) {
                        defaultArgs.push(arg);
                    }
                    this.emitJavascript(arg, TokenID.OpenParen, false);
                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                    }
                }
                this.setContainer(tempContainer);
            }
            this.writeLineToOutput(") {");

            if (funcDecl.isConstructor) {
                this.recordSourceMappingNameStart("constructor");
            } else if (funcDecl.isGetAccessor()) {
                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());
            } else if (funcDecl.isSetAccessor()) {
                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());
            } else {
                this.recordSourceMappingNameStart(funcDecl.getNameText());
            }
            this.indenter.increaseIndent();

            // set default args first
            for (i = 0; i < defaultArgs.length; i++) {
                arg = defaultArgs[i];
                this.emitIndent();
                this.recordSourceMappingStart(arg);
                this.writeToOutput("if (typeof " + arg.id.actualText + " === \"undefined\") { ");//
                this.recordSourceMappingStart(arg.id);
                this.writeToOutput(arg.id.actualText);
                this.recordSourceMappingEnd(arg.id);
                this.writeToOutput(" = ");
                this.emitJavascript(arg.init, TokenID.OpenParen, false);
                this.writeLineToOutput("; }")
                this.recordSourceMappingEnd(arg);
            }

            if (funcDecl.isConstructor && this.shouldCaptureThis(funcDecl.classDecl)) {
                this.writeCaptureThisStatement(funcDecl);
            }

            if (funcDecl.isConstructor && !classPropertiesMustComeAfterSuperCall) {
                if (funcDecl.arguments) {
                    argsLen = funcDecl.arguments.members.length;
                    for (i = 0; i < argsLen; i++) {
                        arg = <ArgDecl>funcDecl.arguments.members[i];
                        if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {
                            this.emitIndent();
                            this.recordSourceMappingStart(arg);
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput("this." + arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeToOutput(" = ");
                            this.recordSourceMappingStart(arg.id);
                            this.writeToOutput(arg.id.actualText);
                            this.recordSourceMappingEnd(arg.id);
                            this.writeLineToOutput(";");
                            this.recordSourceMappingEnd(arg);
                        }
                    }
                }
            }
            if (hasSelfRef) {
                this.writeCaptureThisStatement(funcDecl);
            }
            if (funcDecl.variableArgList) {
                argsLen = funcDecl.arguments.members.length;
                var lastArg = <ArgDecl>funcDecl.arguments.members[argsLen - 1];
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.recordSourceMappingStart(lastArg.id);
                this.writeToOutput(lastArg.id.actualText);
                this.recordSourceMappingEnd(lastArg.id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (")
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var _i = 0;");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput(" ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i < (arguments.length - " + (argsLen - 1) + ")");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput("; ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i++");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();

                this.recordSourceMappingStart(lastArg);
                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (argsLen - 1) + "];");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }

            // if it's a class, emit the uninitializedMembers, first emit the non-proto class body members
            if (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod) && !classPropertiesMustComeAfterSuperCall) {

                var nProps = (<ASTList>this.thisClassNode.members).members.length;

                for (i = 0; i < nProps; i++) {
                    if ((<ASTList>this.thisClassNode.members).members[i].nodeType === NodeType.VarDecl) {
                        var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[i];
                        if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {
                            this.emitIndent();
                            this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);
                            this.writeLineToOutput("");
                        }
                    }
                }
                //this.writeLineToOutput("");
            }

            this.emitBareJavascriptStatements(funcDecl.bod, classPropertiesMustComeAfterSuperCall);

            this.indenter.decreaseIndent();
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl.endingToken);
            this.writeToOutput("}");

            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl.endingToken);
            this.recordSourceMappingEnd(funcDecl);

            if (shouldParenthesize) {
                this.writeToOutput(")");
            }

            // The extra call is to make sure the caller's funcDecl end is recorded, since caller wont be able to record it
            this.recordSourceMappingEnd(funcDecl);

            this.emitParensAndCommentsInPlace(funcDecl, false);

            if (!isMember &&
                //funcDecl.name != null &&
                !hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) &&
                (!hasFlag(funcDecl.fncFlags, FncFlags.Signature) || funcDecl.isConstructor)) {
                this.writeLineToOutput("");
            } else if (hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression)) {
                if (hasFlag(funcDecl.flags, ASTFlags.ExplicitSemicolon) || hasFlag(funcDecl.flags, ASTFlags.AutomaticSemicolon)) {
                    // If either of these two flags are set, then the function expression is a statement. Terminate it.
                    this.writeLineToOutput(";");
                }
            }
            /// TODO: See the other part of this at the beginning of function
            //if (funcDecl.preComments!=null && funcDecl.preComments.length>0) {
            //    this.decreaseIndent();
            //}           
        }

        public getModuleImportAndDepencyList(moduleDecl: ModuleDeclaration) {
            var importList = "";
            var dependencyList = "";
            var i = 0;
            // all dependencies are quoted
            for (i = 0; i < (<ModuleType>moduleDecl.mod).importedModules.length; i++) {
                var importStatement = (<ModuleType>moduleDecl.mod).importedModules[i]

                // if the imported module is only used in a type position, do not add it as a requirement
                if (importStatement.id.sym &&
                    !(<TypeSymbol>importStatement.id.sym).onlyReferencedAsTypeRef) {
                    if (i <= (<ModuleType>moduleDecl.mod).importedModules.length - 1) {
                        dependencyList += ", ";
                        importList += ", ";
                    }

                    importList += "__" + importStatement.id.actualText + "__";
                    dependencyList += importStatement.firstAliasedModToString();
                }
            }

            // emit any potential amd dependencies
            for (i = 0; i < moduleDecl.amdDependencies.length; i++) {
                dependencyList += ", \"" + moduleDecl.amdDependencies[i] + "\"";
            }

            return {
                importList: importList,
                dependencyList: dependencyList
            };
        }

        public isParentDynamicModule(moduleDecl: ModuleDeclaration) {
            var containingMod: ModuleDeclaration = null;
            if (moduleDecl.type && moduleDecl.type.symbol.container && moduleDecl.type.symbol.container.declAST) {
                containingMod = <ModuleDeclaration>moduleDecl.type.symbol.container.declAST;
            }
            var parentIsDynamic = containingMod && hasFlag(containingMod.modFlags, ModuleFlags.IsDynamic);
            return parentIsDynamic;
        }

        public shouldCaptureThis(ast: AST) {
            if (ast === null) {
                return this.checker.mustCaptureGlobalThis;
            }

            if (ast.nodeType === NodeType.ModuleDeclaration) {
                return hasFlag((<ModuleDeclaration>ast).modFlags,  ModuleFlags.MustCaptureThis);
            } else if (ast.nodeType === NodeType.ClassDeclaration) {
                return hasFlag((<ClassDeclaration>ast).varFlags, VarFlags.MustCaptureThis);
            } else if (ast.nodeType === NodeType.FuncDecl) {
                var func = <FuncDecl>ast;
                // Super calls use 'this' reference. If super call is in a lambda, 'this' value needs to be captured in the parent.
                return func.hasSelfReference() || func.hasSuperReferenceInFatArrowFunction();
            }

            return false;
        }

        public emitJavascriptModule(moduleDecl: ModuleDeclaration) {
            var modName = moduleDecl.name.actualText;
            if (isTSFile(modName)) {
                moduleDecl.name.setText(modName.substring(0, modName.length - 3));
            }

            if (!hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient)) {
                var isDynamicMod = hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic);
                var prevOutFile = this.outfile;
                var prevOutFileName = this.emittingFileName;
                var prevAllSourceMappers = this.allSourceMappers;
                var prevSourceMapper = this.sourceMapper;
                var prevColumn = this.emitState.column;
                var prevLine = this.emitState.line;
                var temp = this.setContainer(EmitContainer.Module);
                var svModuleName = this.moduleName;
                var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);
                this.moduleDeclList[this.moduleDeclList.length] = moduleDecl;
                var isWholeFile = hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile);
                this.moduleName = moduleDecl.name.actualText;

                // prologue
                if (isDynamicMod) {
                    // create the new outfile for this module
                    var tsModFileName = stripQuotes(moduleDecl.name.actualText);
                    var modFilePath = trimModName(tsModFileName) + ".js";
                    modFilePath = this.emitOptions.mapOutputFileName(modFilePath, TypeScriptCompiler.mapToJSFileName);

                    if (this.emitOptions.ioHost) {
                        // Ensure that the slashes are normalized so that the comparison is fair
                        // REVIEW: Note that modFilePath is normalized to forward slashes in Parser.parse, so the 
                        // first call to switchToForwardSlashes is technically a no-op, but it will prevent us from
                        // regressing if the parser changes
                        if (switchToForwardSlashes(modFilePath) != switchToForwardSlashes(this.emittingFileName)) {
                            this.emittingFileName = modFilePath;
                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.compilationSettings.emitComments && moduleDecl.containsUnicodeCharInComment);
                            this.outfile = this.createFile(this.emittingFileName, useUTF8InOutputfile);
                            if (prevSourceMapper != null) {
                                this.allSourceMappers = [];
                                var sourceMapFile = this.emittingFileName + SourceMapper.MapFileExtension;
                                var sourceMappingFile = this.createFile(sourceMapFile, false);
                                this.setSourceMappings(new SourceMapper(tsModFileName, this.emittingFileName, sourceMapFile, this.outfile, sourceMappingFile, this.emitOptions.compilationSettings.emitFullSourceMapPath));
                                this.emitState.column = 0;
                                this.emitState.line = 0;
                            }
                        } else {
                            CompilerDiagnostics.assert(this.emitOptions.outputMany, "Cannot have dynamic modules compiling into single file");
                        }
                    }

                    this.setContainer(EmitContainer.DynamicModule); // discard the previous 'Module' container

                    this.recordSourceMappingStart(moduleDecl);
                    if (this.emitOptions.compilationSettings.moduleGenTarget === ModuleGenTarget.Asynchronous) { // AMD
                        var dependencyList = "[\"require\", \"exports\"";
                        var importList = "require, exports";

                        var importAndDependencyList = this.getModuleImportAndDepencyList(moduleDecl);
                        importList += importAndDependencyList.importList;
                        dependencyList += importAndDependencyList.dependencyList + "]";

                        this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                    }
                    else { // Node

                    }
                }
                else {

                    if (!isExported) {
                        this.recordSourceMappingStart(moduleDecl);
                        this.writeToOutput("var ");
                        this.recordSourceMappingStart(moduleDecl.name);
                        this.writeToOutput(this.moduleName);
                        this.recordSourceMappingEnd(moduleDecl.name);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(moduleDecl);
                        this.emitIndent();
                    }

                    this.writeToOutput("(");
                    this.recordSourceMappingStart(moduleDecl);
                    this.writeToOutput("function (");
                    this.recordSourceMappingStart(moduleDecl.name);
                    this.writeToOutput(this.moduleName);
                    this.recordSourceMappingEnd(moduleDecl.name);
                    this.writeLineToOutput(") {");
                }

                if (!isWholeFile) {
                    this.recordSourceMappingNameStart(this.moduleName);
                }

                // body - don't indent for Node
                if (!isDynamicMod || this.emitOptions.compilationSettings.moduleGenTarget === ModuleGenTarget.Asynchronous) {
                    this.indenter.increaseIndent();
                }

                if (this.shouldCaptureThis(moduleDecl)) {
                    this.writeCaptureThisStatement(moduleDecl);
                }

                this.emitJavascriptList(moduleDecl.members, null, TokenID.Semicolon, true, false, false);
                if (!isDynamicMod || this.emitOptions.compilationSettings.moduleGenTarget === ModuleGenTarget.Asynchronous) {
                    this.indenter.decreaseIndent();
                }
                this.emitIndent();

                // epilogue
                if (isDynamicMod) {
                    if (this.emitOptions.compilationSettings.moduleGenTarget === ModuleGenTarget.Asynchronous) { // AMD
                        this.writeLineToOutput("})");
                    }
                    else { // Node
                    }
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl);

                    // close the module outfile, and restore the old one
                    if (this.outfile != prevOutFile) {
                        this.emitSourceMapsAndClose();
                        if (prevSourceMapper != null) {
                            this.allSourceMappers = prevAllSourceMappers;
                            this.sourceMapper = prevSourceMapper;
                            this.emitState.column = prevColumn;
                            this.emitState.line = prevLine;
                        }
                        this.outfile = prevOutFile;
                        this.emittingFileName = prevOutFileName;
                    }
                }
                else {
                    var parentIsDynamic = this.isParentDynamicModule(moduleDecl);
                    this.recordSourceMappingStart(moduleDecl.endingToken);
                    if (temp === EmitContainer.Prog && isExported) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
                    }
                    else if (isExported || temp === EmitContainer.Prog) {
                        var dotMod = svModuleName != "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
                    }
                    else if (!isExported && temp != EmitContainer.Prog) {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
                    }
                    else {
                        this.writeToOutput("}");
                        if (!isWholeFile) {
                            this.recordSourceMappingNameEnd();
                        }
                        this.recordSourceMappingEnd(moduleDecl.endingToken);
                        this.writeToOutput(")();");
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                    this.writeLineToOutput("");
                    if (temp != EmitContainer.Prog && isExported) {
                        this.emitIndent();
                        this.recordSourceMappingStart(moduleDecl);
                        if (parentIsDynamic) {
                            this.writeLineToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                        } else {
                            this.writeLineToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                        }
                        this.recordSourceMappingEnd(moduleDecl);
                    }
                }

                this.setContainer(temp);
                this.moduleName = svModuleName;
                this.moduleDeclList.length--;
            }
        }

        public emitIndex(operand1: AST, operand2: AST) {
            var temp = this.setInObjectLiteral(false);
            this.emitJavascript(operand1, TokenID.Tilde, false);
            this.writeToOutput("[");
            this.emitJavascriptList(operand2, ", ", TokenID.Comma, false, false, false);
            this.writeToOutput("]");
            this.setInObjectLiteral(temp);
        }

        public emitStringLiteral(text: string) {
            // should preserve escape etc.
            // TODO: simplify object literal simple name
            this.writeToOutput(text);
        }

        public emitJavascriptFunction(funcDecl: FuncDecl) {
            if (hasFlag(funcDecl.fncFlags, FncFlags.Signature) || funcDecl.isOverload) {
                return;
            }
            var temp: number;
            var tempFnc = this.thisFnc;
            this.thisFnc = funcDecl;

            if (funcDecl.isConstructor) {
                temp = this.setContainer(EmitContainer.Constructor);
            }
            else {
                temp = this.setContainer(EmitContainer.Function);
            }

            var hasSelfRef = false;
            var funcName = funcDecl.getNameText();

            if ((this.emitState.inObjectLiteral || !funcDecl.isAccessor()) &&
                ((temp != EmitContainer.Constructor) ||
                ((funcDecl.fncFlags & FncFlags.Method) === FncFlags.None))) {
                var tempLit = this.setInObjectLiteral(false);
                hasSelfRef = this.shouldCaptureThis(funcDecl);
                this.recordSourceMappingStart(funcDecl);
                this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()), false, hasSelfRef, this.thisClassNode);
                this.setInObjectLiteral(tempLit);
            }
            this.setContainer(temp);
            this.thisFnc = tempFnc;

            if (!hasFlag(funcDecl.fncFlags, FncFlags.Signature)) {
                if (hasFlag(funcDecl.fncFlags, FncFlags.Static)) {
                    if (this.thisClassNode) {
                        if (funcDecl.isAccessor()) {
                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);
                        }
                        else {
                            this.emitIndent();
                            this.recordSourceMappingStart(funcDecl);
                            this.writeLineToOutput(this.thisClassNode.name.actualText + "." + funcName +
                                          " = " + funcName + ";");
                            this.recordSourceMappingEnd(funcDecl);
                        }
                    }
                }
                else if ((this.emitState.container === EmitContainer.Module || this.emitState.container === EmitContainer.DynamicModule) && hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported)) {
                    this.emitIndent();
                    var modName = this.emitState.container === EmitContainer.Module ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeLineToOutput(modName + "." + funcName +
                                      " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        }

        public emitAmbientVarDecl(varDecl: VarDecl) {
            if (varDecl.init) {
                this.emitParensAndCommentsInPlace(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                this.writeToOutput(" = ");
                this.emitJavascript(varDecl.init, TokenID.Comma, false);
                this.recordSourceMappingEnd(varDecl);
                this.writeToOutput(";");
                this.emitParensAndCommentsInPlace(varDecl, false);
            }
        }

        public varListCount(): number {
            return this.varListCountStack[this.varListCountStack.length - 1];
        }

        // Emits "var " if it is allowed
        public emitVarDeclVar() {
            // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var
            // If it is var list of form  var a = varList count will be 0
            if (this.varListCount() >= 0) {
                this.writeToOutput("var ");
                this.setInVarBlock(-this.varListCount());
            }
            return true;
        }

        public onEmitVar() {
            if (this.varListCount() > 0) {
                this.setInVarBlock(this.varListCount() - 1);
            }
            else if (this.varListCount() < 0) {
                this.setInVarBlock(this.varListCount() + 1);
            }
        }

        public isContainedInClassDeclaration(varDecl: VarDecl) {
            var sym = varDecl.sym;
            if (sym && sym.isMember() && sym.container &&
                    (sym.container.kind() === SymbolKind.Type)) {
                var type = (<TypeSymbol>sym.container).type;
                if (type.isClass() && (!hasFlag(sym.flags, SymbolFlags.ModuleMember))) {
                    return true;
                }
            }

            return false;
        }

        public isContainedInModuleOrEnumDeclaration(varDecl: VarDecl) {
            var sym = varDecl.sym;
            if (sym && sym.isMember() && sym.container &&
                    (sym.container.kind() === SymbolKind.Type)) {
                var type = (<TypeSymbol>sym.container).type;
                if (type.hasImplementation()) {
                    return true;
                }
            }

            return false;
        }

        public getContainedSymbolName(varDecl: VarDecl) {
            return varDecl.sym.container.name;
        }

        public emitJavascriptVarDecl(varDecl: VarDecl, tokenId: TokenID) {
            if ((varDecl.varFlags & VarFlags.Ambient) === VarFlags.Ambient) {
                this.emitAmbientVarDecl(varDecl);
                this.onEmitVar();
            }
            else {
                this.emitParensAndCommentsInPlace(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                if (this.isContainedInClassDeclaration(varDecl)) {
                    // class
                    if (this.emitState.container != EmitContainer.Args) {
                        if (varDecl.isStatic()) {
                            this.writeToOutput(this.getContainedSymbolName(varDecl) + ".");
                        }
                        else {
                            this.writeToOutput("this.");
                        }
                    }
                }
                else if (this.isContainedInModuleOrEnumDeclaration(varDecl)) {
                    // module
                    if (!varDecl.isExported() && !varDecl.isProperty()) {
                        this.emitVarDeclVar();
                    }
                    else {
                        if (this.emitState.container === EmitContainer.DynamicModule) {
                            this.writeToOutput("exports.");
                        }
                        else {
                            this.writeToOutput(this.moduleName + ".");
                        }
                    }
                }
                else {
                    // function, constructor, method etc.
                    if (tokenId != TokenID.OpenParen) {
                        this.emitVarDeclVar();
                    }
                }
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                var hasInitializer = (varDecl.init != null);
                if (hasInitializer) {
                    this.writeToOutputTrimmable(" = ");

                    // Ensure we have a fresh var list count when recursing into the variable 
                    // initializer.  We don't want our current list of variables to affect how we
                    // emit nested variable lists.
                    this.varListCountStack.push(0);
                    this.emitJavascript(varDecl.init, TokenID.Comma, false);
                    this.varListCountStack.pop();
                }
                this.onEmitVar();
                if ((tokenId != TokenID.OpenParen)) {
                    if (this.varListCount() < 0) {
                        this.writeToOutput(", ");
                    } else if (tokenId != TokenID.For) {
                        this.writeToOutputTrimmable(";");
                    }
                }
                this.recordSourceMappingEnd(varDecl);
                this.emitParensAndCommentsInPlace(varDecl, false);
            }
        }

        public declEnclosed(moduleDecl: ModuleDeclaration): bool {
            if (moduleDecl === null) {
                return true;
            }
            for (var i = 0, len = this.moduleDeclList.length; i < len; i++) {
                if (this.moduleDeclList[i] === moduleDecl) {
                    return true;
                }
            }
            return false;
        }

        public emitJavascriptName(name: Identifier, addThis: bool) {
            var sym = name.sym;
            this.emitParensAndCommentsInPlace(name, true);
            this.recordSourceMappingStart(name);
            if (!name.isMissing()) {
                if (addThis && (this.emitState.container != EmitContainer.Args) && sym) {
                    // TODO: flag global module with marker other than string name
                    if (sym.container && (sym.container.name != globalId)) {
                        if (hasFlag(sym.flags, SymbolFlags.Static) && (hasFlag(sym.flags, SymbolFlags.Property))) {
                            if (sym.declModule && hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {
                                this.writeToOutput("exports.");
                            }
                            else {
                                this.writeToOutput(sym.container.name + ".");
                            }
                        }
                        else if (sym.kind() === SymbolKind.Field) {
                            var fieldSym = <FieldSymbol>sym;
                            if (hasFlag(fieldSym.flags, SymbolFlags.ModuleMember)) {
                                if ((sym.container != this.checker.gloMod) && ((hasFlag(sym.flags, SymbolFlags.Property)) || hasFlag(sym.flags, SymbolFlags.Exported))) {
                                    if (hasFlag(sym.declModule.modFlags, ModuleFlags.IsDynamic)) {
                                        this.writeToOutput("exports.");
                                    }
                                    else {
                                        this.writeToOutput(sym.container.name + ".");
                                    }
                                }
                            }
                            else {
                                if (sym.isInstanceProperty()) {
                                    this.emitThis();
                                    this.writeToOutput(".");
                                }
                            }
                        }
                        else if (sym.kind() === SymbolKind.Type) {
                            if (sym.isInstanceProperty()) {
                                var typeSym = <TypeSymbol>sym;
                                var type = typeSym.type;
                                if (type.call && !hasFlag(sym.flags, SymbolFlags.ModuleMember)) {
                                    this.emitThis();
                                    this.writeToOutput(".");
                                }
                            }
                            else if ((sym.fileName != this.checker.locationInfo.fileName) || (!this.declEnclosed(sym.declModule))) {
                                this.writeToOutput(sym.container.name + ".")
                            }
                        }
                    }
                    else if (sym.container === this.checker.gloMod &&
                                hasFlag(sym.flags, SymbolFlags.Exported) &&
                                !hasFlag(sym.flags, SymbolFlags.Ambient) &&
                                // check that it's a not a member of an ambient module...
                                !((sym.isType() || sym.isMember()) &&
                                    sym.declModule &&
                                    hasFlag(sym.declModule.modFlags, ModuleFlags.Ambient)) &&
                                this.emitState.container === EmitContainer.Prog &&
                                sym.declAST.nodeType != NodeType.FuncDecl) {
                        this.writeToOutput("this.");
                    }
                }

                // If it's a dynamic module, we need to print the "require" invocation
                if (sym &&
                    sym.declAST &&
                    sym.declAST.nodeType === NodeType.ModuleDeclaration &&
                    (hasFlag((<ModuleDeclaration>sym.declAST).modFlags, ModuleFlags.IsDynamic))) {
                    var moduleDecl: ModuleDeclaration = <ModuleDeclaration>sym.declAST;

                    if (this.emitOptions.compilationSettings.moduleGenTarget === ModuleGenTarget.Asynchronous) {
                        this.writeLineToOutput("__" + this.modAliasId + "__;");
                    }
                    else {
                        var modPath = name.actualText;//(<ModuleDecl>moduleDecl.mod.symbol.declAST).name.actualText;
                        var isSingleQuotedMod = isSingleQuoted(modPath);
                        var isAmbient = moduleDecl.mod.symbol.declAST && hasFlag((<ModuleDeclaration>moduleDecl.mod.symbol.declAST).modFlags, ModuleFlags.Ambient);
                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : quoteBaseName(modPath);
                        modPath = isAmbient ? modPath : (!isRelative(stripQuotes(modPath)) ? quoteStr("./" + stripQuotes(modPath)) : modPath);
                        if (isSingleQuotedMod) {
                            modPath = changeToSingleQuote(modPath);
                        }
                        this.writeToOutput("require(" + modPath + ")");
                    }
                }
                else {
                    this.writeToOutput(name.actualText);
                }
            }
            this.recordSourceMappingEnd(name);
            this.emitParensAndCommentsInPlace(name, false);
        }

        public emitJavascriptStatements(stmts: AST, emitEmptyBod: bool) {
            if (stmts) {
                if (stmts.nodeType != NodeType.Block) {
                    var hasContents = (stmts && (stmts.nodeType != NodeType.List || ((<ASTList>stmts).members.length > 0)));
                    if (emitEmptyBod || hasContents) {
                        var hasOnlyBlockStatement = ((stmts.nodeType === NodeType.Block) ||
                            ((stmts.nodeType === NodeType.List) && ((<ASTList>stmts).members.length === 1) && ((<ASTList>stmts).members[0].nodeType === NodeType.Block)));

                        this.recordSourceMappingStart(stmts);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput(" {");
                            this.indenter.increaseIndent();
                        }
                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, false);
                        if (!hasOnlyBlockStatement) {
                            this.writeLineToOutput("");
                            this.indenter.decreaseIndent();
                            this.emitIndent();
                            this.writeToOutput("}");
                        }
                        this.recordSourceMappingEnd(stmts);
                    }
                }
                else {
                    this.emitJavascript(stmts, TokenID.Semicolon, true);
                }
            }
            else if (emitEmptyBod) {
                this.writeToOutput("{ }");
            }
        }

        public emitBareJavascriptStatements(stmts: AST, emitClassPropertiesAfterSuperCall: bool = false) {
            // just the statements without enclosing curly braces
            if (stmts.nodeType != NodeType.Block) {
                if (stmts.nodeType === NodeType.List) {
                    var stmtList = <ASTList>stmts;
                    if ((stmtList.members.length === 2) &&
                        (stmtList.members[0].nodeType === NodeType.Block) &&
                        (stmtList.members[1].nodeType === NodeType.EndCode)) {
                        this.emitJavascript(stmtList.members[0], TokenID.Semicolon, true);
                        this.writeLineToOutput("");
                    }
                    else {
                        this.emitJavascriptList(stmts, null, TokenID.Semicolon, true, false, emitClassPropertiesAfterSuperCall);
                    }
                }
                else {
                    this.emitJavascript(stmts, TokenID.Semicolon, true);
                }
            }
            else {
                this.emitJavascript(stmts, TokenID.Semicolon, true);
            }
        }

        public recordSourceMappingNameStart(name: string) {
            if (this.sourceMapper) {
                var finalName = name;
                if (!name) {
                    finalName = "";
                } else if (this.sourceMapper.currentNameIndex.length > 0) {
                    finalName = this.sourceMapper.names[this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1]] + "." + name;
                }

                // We are currently not looking for duplicate but that is possible.
                this.sourceMapper.names.push(finalName);
                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);
            }
        }

        public recordSourceMappingNameEnd() {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        }

        public getLineMap(): LineMap {
            return this.checker.locationInfo.lineMap;
        }

        public recordSourceMappingStart(ast: IASTSpan) {
            if (this.sourceMapper && isValidAstNode(ast)) {
                var lineCol = { line: -1, character: -1 };
                var sourceMapping = new SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;
                // REVIEW: check time consumed by this binary search (about two per leaf statement)
                var lineMap = this.getLineMap();
                lineMap.fillLineAndCharacterFromPosition(ast.minChar, lineCol);
                sourceMapping.start.sourceColumn = lineCol.character;
                sourceMapping.start.sourceLine = lineCol.line + 1;
                lineMap.fillLineAndCharacterFromPosition(ast.limChar, lineCol);
                sourceMapping.end.sourceColumn = lineCol.character;
                sourceMapping.end.sourceLine = lineCol.line + 1;
                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }
                // Set parent and child relationship
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
            }
        }

        public recordSourceMappingEnd(ast: IASTSpan) {
            if (this.sourceMapper && isValidAstNode(ast)) {
                // Pop source mapping childs
                this.sourceMapper.currentMappings.pop();

                // Get the last source mapping from sibling list = which is the one we are recording end for
                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];

                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;
            }
        }

        // Note: may throw exception.
        public emitSourceMapsAndClose(): void {
            // Output a source mapping.  As long as we haven't gotten any errors yet.
            if (this.sourceMapper !== null) {
                SourceMapper.emitSourceMapping(this.allSourceMappers);
            }

            try {
                this.outfile.Close();
            }
            catch (e) {
                Emitter.throwEmitterError(e);
            }
        }

        public emitJavascriptList(ast: AST, delimiter: string, tokenId: TokenID, startLine: bool, onlyStatics: bool, emitClassPropertiesAfterSuperCall: bool = false, emitPrologue? = false, requiresExtendsBlock?: bool) {
            if (ast === null) {
                return;
            }
            else if (ast.nodeType != NodeType.List) {
                this.emitPrologue(emitPrologue);
                this.emitJavascript(ast, tokenId, startLine);
            }
            else {
                var list = <ASTList>ast;
                this.emitParensAndCommentsInPlace(ast, true);
                if (list.members.length === 0) {
                    this.emitParensAndCommentsInPlace(ast, false);
                    return;
                }

                var len = list.members.length;
                for (var i = 0; i < len; i++) {
                    if (emitPrologue) {
                        // If the list has Strict mode flags, emit prologue after first statement
                        // otherwise emit before first statement
                        if (i === 1 || !hasFlag(list.flags, ASTFlags.StrictMode)) {
                            this.emitPrologue(requiresExtendsBlock);
                            emitPrologue = false;
                        }
                    }

                    // In some circumstances, class property initializers must be emitted immediately after the 'super' constructor
                    // call which, in these cases, must be the first statement in the constructor body
                    if (i === 1 && emitClassPropertiesAfterSuperCall) {

                        // emit any parameter properties first
                        var constructorDecl = (<ClassDeclaration>this.thisClassNode).constructorDecl;

                        if (constructorDecl && constructorDecl.arguments) {
                            var argsLen = constructorDecl.arguments.members.length;
                            for (var iArg = 0; iArg < argsLen; iArg++) {
                                var arg = <BoundDecl>constructorDecl.arguments.members[iArg];
                                if ((arg.varFlags & VarFlags.Property) != VarFlags.None) {
                                    this.emitIndent();
                                    this.recordSourceMappingStart(arg);
                                    this.recordSourceMappingStart(arg.id);
                                    this.writeToOutput("this." + arg.id.actualText);
                                    this.recordSourceMappingEnd(arg.id);
                                    this.writeToOutput(" = ");
                                    this.recordSourceMappingStart(arg.id);
                                    this.writeToOutput(arg.id.actualText);
                                    this.recordSourceMappingEnd(arg.id);
                                    this.writeLineToOutput(";");
                                    this.recordSourceMappingEnd(arg);
                                }
                            }
                        }

                        var nProps = (<ASTList>this.thisClassNode.members).members.length;

                        for (var iMember = 0; iMember < nProps; iMember++) {
                            if ((<ASTList>this.thisClassNode.members).members[iMember].nodeType === NodeType.VarDecl) {
                                var varDecl = <VarDecl>(<ASTList>this.thisClassNode.members).members[iMember];
                                if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {
                                    this.emitIndent();
                                    this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);
                                    this.writeLineToOutput("");
                                }
                            }
                        }
                    }

                    var emitNode = list.members[i];

                    var isStaticDecl =
                                (emitNode.nodeType === NodeType.FuncDecl && hasFlag((<FuncDecl>emitNode).fncFlags, FncFlags.Static)) ||
                                (emitNode.nodeType === NodeType.VarDecl && hasFlag((<VarDecl>emitNode).varFlags, VarFlags.Static))

                    if (onlyStatics ? !isStaticDecl : isStaticDecl) {
                        continue;
                    }
                    this.emitJavascript(emitNode, tokenId, startLine);

                    if (delimiter && (i < (len - 1))) {
                        if (startLine) {
                            this.writeLineToOutput(delimiter);
                        }
                        else {
                            this.writeToOutput(delimiter);
                        }
                    }
                    else if (startLine &&
                             (emitNode.nodeType != NodeType.ModuleDeclaration) &&
                             (emitNode.nodeType != NodeType.InterfaceDeclaration) &&
                             (!((emitNode.nodeType === NodeType.VarDecl) &&
                                ((((<VarDecl>emitNode).varFlags) & VarFlags.Ambient) === VarFlags.Ambient) &&
                                (((<VarDecl>emitNode).init) === null)) && this.varListCount() >= 0) &&
                             (emitNode.nodeType != NodeType.Block || (<Block>emitNode).isStatementBlock) &&
                             (emitNode.nodeType != NodeType.EndCode) &&
                             (emitNode.nodeType != NodeType.FuncDecl)) {
                        this.writeLineToOutput("");
                    }
                }
                this.emitParensAndCommentsInPlace(ast, false);
            }
        }

        // tokenId is the id the preceding token
        public emitJavascript(ast: AST, tokenId: TokenID, startLine: bool) {
            if (ast === null) {
                return;
            }

            // REVIEW: simplify rules for indenting
            if (startLine && (this.indenter.indentAmt > 0) && (ast.nodeType != NodeType.List) &&
                (ast.nodeType != NodeType.Block)) {
                if ((ast.nodeType != NodeType.InterfaceDeclaration) &&
                    (!((ast.nodeType === NodeType.VarDecl) &&
                       ((((<VarDecl>ast).varFlags) & VarFlags.Ambient) === VarFlags.Ambient) &&
                       (((<VarDecl>ast).init) === null)) && this.varListCount() >= 0) &&
                    (ast.nodeType != NodeType.EndCode) &&
                    ((ast.nodeType != NodeType.FuncDecl) ||
                     (this.emitState.container != EmitContainer.Constructor))) {
                    this.emitIndent();
                }
            }

            ast.emit(this, tokenId, startLine);

            if ((tokenId === TokenID.Semicolon) && (ast.nodeType < NodeType.GeneralNode)) {
                this.writeToOutput(";");
            }
        }

        public isAccessorEmitted(funcDecl: FuncDecl) {
            var returnVal = !(<FieldSymbol>funcDecl.accessorSymbol).hasBeenEmitted;
            (<FieldSymbol>funcDecl.accessorSymbol).hasBeenEmitted = true;
            return returnVal;
        }

        public getGetterAndSetterFunction(funcDecl: FuncDecl): { getter: FuncDecl; setter: FuncDecl; } {
            var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;
            var result: { getter: FuncDecl; setter: FuncDecl; } = {
                getter: null,
                setter: null
            };

            if (accessorSymbol.getter) {
                result.getter = <FuncDecl>accessorSymbol.getter.declAST;
            }

            if (accessorSymbol.setter) {
                result.getter = <FuncDecl>accessorSymbol.setter.declAST;
            }

            return result;
        }

        public emitPropertyAccessor(funcDecl: FuncDecl, className: string, isProto: bool) {
            if (!this.isAccessorEmitted(funcDecl)) {
                var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;
                this.emitIndent();
                this.recordSourceMappingStart(funcDecl);
                this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \"" : ", \"") + funcDecl.name.actualText + "\"" + ", {");
                this.indenter.increaseIndent();

                var accessors = this.getGetterAndSetterFunction(funcDecl);
                if (accessors.getter) {
                    this.emitIndent();
                    this.recordSourceMappingStart(accessors.getter);
                    this.writeToOutput("get: ");
                    this.emitInnerFunction(accessors.getter, false, isProto, this.shouldCaptureThis(accessors.getter), null);
                    this.writeLineToOutput(",");
                }

                if (accessors.setter) {
                    this.emitIndent();
                    this.recordSourceMappingStart(accessors.setter);
                    this.writeToOutput("set: ");
                    this.emitInnerFunction(accessors.setter, false, isProto, this.shouldCaptureThis(accessors.setter), null);
                    this.writeLineToOutput(",");
                }

                this.emitIndent();
                this.writeLineToOutput("enumerable: true,");
                this.emitIndent();
                this.writeLineToOutput("configurable: true");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("});");
                this.recordSourceMappingEnd(funcDecl);
            }
        }

        public emitPrototypeMember(member: AST, className: string) {
            if (member.nodeType === NodeType.FuncDecl) {
                var funcDecl = <FuncDecl>member;
                if (funcDecl.isAccessor()) {
                    this.emitPropertyAccessor(funcDecl, className, true);
                }
                else {
                    this.emitIndent();
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");
                    this.emitInnerFunction(funcDecl, false, true, this.shouldCaptureThis(funcDecl), null);
                    this.writeLineToOutput(";");
                }
            }
            else if (member.nodeType === NodeType.VarDecl) {
                var varDecl = <VarDecl>member;

                if (varDecl.init) {
                    this.emitIndent();
                    this.recordSourceMappingStart(varDecl);
                    this.recordSourceMappingStart(varDecl.id);
                    this.writeToOutput(className + ".prototype." + varDecl.id.actualText);
                    this.recordSourceMappingEnd(varDecl.id);
                    this.writeToOutput(" = ");
                    this.emitJavascript(varDecl.init, TokenID.Equals, false);
                    this.recordSourceMappingEnd(varDecl);
                    this.writeLineToOutput(";");
                }
            }
        }

        public emitJavascriptClass(classDecl: ClassDeclaration) {
            if (!hasFlag(classDecl.varFlags, VarFlags.Ambient)) {
                var svClassNode = this.thisClassNode;
                var i = 0;
                this.thisClassNode = classDecl;
                var className = classDecl.name.actualText;
                this.emitParensAndCommentsInPlace(classDecl, true);
                var temp = this.setContainer(EmitContainer.Class);

                this.recordSourceMappingStart(classDecl);
                this.writeToOutput("var " + className);

                //if (hasFlag(classDecl.varFlags, VarFlags.Exported) && (temp === EmitContainer.Module || temp === EmitContainer.DynamicModule)) {
                //    var modName = temp === EmitContainer.Module ? this.moduleName : "exports";
                //    this.writeToOutput(" = " + modName + "." + className);
                //}

                var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;
                var baseNameDecl: AST = null;
                var baseName: AST = null;
                var varDecl: VarDecl = null;

                if (hasBaseClass) {
                    this.writeLineToOutput(" = (function (_super) {");
                } else {
                    this.writeLineToOutput(" = (function () {");
                }

                this.recordSourceMappingNameStart(className);
                this.indenter.increaseIndent();

                if (hasBaseClass) {
                    baseNameDecl = classDecl.extendsList.members[0];
                    baseName = baseNameDecl.nodeType === NodeType.Call ? (<CallExpression>baseNameDecl).target : baseNameDecl;
                    this.emitIndent();
                    this.writeLineToOutput("__extends(" + className + ", _super);");
                }

                this.emitIndent();

                var constrDecl = classDecl.constructorDecl;

                // output constructor
                if (constrDecl) {
                    // declared constructor
                    this.emitJavascript(classDecl.constructorDecl, TokenID.OpenParen, false);

                }
                else {
                    var wroteProps = 0;

                    this.recordSourceMappingStart(classDecl);
                    // default constructor
                    this.indenter.increaseIndent();
                    this.writeToOutput("function " + classDecl.name.actualText + "() {");
                    this.recordSourceMappingNameStart("constructor");
                    if (hasBaseClass) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeLineToOutput("_super.apply(this, arguments);");
                        wroteProps++;
                    }

                    if (classDecl.varFlags & VarFlags.MustCaptureThis) {
                        this.writeCaptureThisStatement(classDecl);
                    }

                    var members = (<ASTList>this.thisClassNode.members).members

                    // output initialized properties
                    for (i = 0; i < members.length; i++) {
                        if (members[i].nodeType === NodeType.VarDecl) {
                            varDecl = <VarDecl>members[i];
                            if (!hasFlag(varDecl.varFlags, VarFlags.Static) && varDecl.init) {
                                this.writeLineToOutput("");
                                this.emitIndent();
                                this.emitJavascriptVarDecl(varDecl, TokenID.Tilde);
                                wroteProps++;
                            }
                        }
                    }
                    if (wroteProps) {
                        this.writeLineToOutput("");
                        this.indenter.decreaseIndent();
                        this.emitIndent();
                        this.writeLineToOutput("}");
                    }
                    else {
                        this.writeLineToOutput(" }");
                        this.indenter.decreaseIndent();
                    }
                    this.recordSourceMappingNameEnd();
                    this.recordSourceMappingEnd(classDecl);
                }

                var membersLen = classDecl.members.members.length;
                for (var j = 0; j < membersLen; j++) {

                    var memberDecl: AST = classDecl.members.members[j];

                    if (memberDecl.nodeType === NodeType.FuncDecl) {
                        var fn = <FuncDecl>memberDecl;

                        if (hasFlag(fn.fncFlags, FncFlags.Method) && !fn.isSignature()) {
                            if (!hasFlag(fn.fncFlags, FncFlags.Static)) {
                                this.emitPrototypeMember(fn, className);
                            }
                            else { // static functions
                                if (fn.isAccessor()) {
                                    this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);
                                }
                                else {
                                    this.emitIndent();
                                    this.recordSourceMappingStart(fn)
                                    this.writeToOutput(classDecl.name.actualText + "." + fn.name.actualText + " = ");
                                    this.emitInnerFunction(fn, (fn.name && !fn.name.isMissing()), true,
                                            this.shouldCaptureThis(fn), null);
                                    this.writeLineToOutput(";");
                                }
                            }
                        }
                    }
                    else if (memberDecl.nodeType === NodeType.VarDecl) {
                        varDecl = <VarDecl>memberDecl;
                        if (hasFlag(varDecl.varFlags, VarFlags.Static)) {

                            if (varDecl.init) {
                                // EMITREVIEW
                                this.emitIndent();
                                this.recordSourceMappingStart(varDecl);
                                this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");
                                this.emitJavascript(varDecl.init, TokenID.Equals, false);
                                // EMITREVIEW

                                this.writeLineToOutput(";");
                                this.recordSourceMappingEnd(varDecl);
                            }
                        }
                    }
                    else {
                        throw Error("We want to catch this");
                    }
                }

                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeLineToOutput("return " + className + ";");
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.recordSourceMappingStart(classDecl.endingToken);
                this.writeToOutput("}");
                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl.endingToken);
                this.recordSourceMappingStart(classDecl);
                this.writeToOutput(")(");
                if (hasBaseClass)
                    this.emitJavascript(baseName, TokenID.Tilde, false);
                this.writeToOutput(");");
                this.recordSourceMappingEnd(classDecl);

                if ((temp === EmitContainer.Module || temp === EmitContainer.DynamicModule) && hasFlag(classDecl.varFlags, VarFlags.Exported)) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = temp === EmitContainer.Module ? this.moduleName : "exports";
                    this.recordSourceMappingStart(classDecl);
                    this.writeToOutput(modName + "." + className + " = " + className + ";");
                    this.recordSourceMappingEnd(classDecl);
                }

                this.emitIndent();
                this.recordSourceMappingEnd(classDecl);
                this.emitParensAndCommentsInPlace(classDecl, false);
                this.setContainer(temp);
                this.thisClassNode = svClassNode;
            }
        }

        public emitPrologue(reqInherits: bool) {
            if (!this.extendsPrologueEmitted) {
                if (reqInherits) {
                    this.extendsPrologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
            }

            if (!this.globalThisCapturePrologueEmitted) {
                if (this.shouldCaptureThis(null)) {
                    this.globalThisCapturePrologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        }

        public emitSuperReference() {
            this.writeToOutput("_super.prototype");
        }

        public emitSuperCall(callEx: CallExpression): bool {
            if (callEx.target.nodeType === NodeType.Dot) {
                var dotNode = <BinaryExpression>callEx.target;
                if (dotNode.operand1.nodeType === NodeType.Super) {
                    this.emitJavascript(dotNode, TokenID.OpenParen, false);
                    this.writeToOutput(".call(");
                    this.emitThis();
                    if (callEx.arguments && callEx.arguments.members.length > 0) {
                        this.writeToOutput(", ");
                        this.emitJavascriptList(callEx.arguments, ", ", TokenID.Comma, false, false, false);
                    }
                    this.writeToOutput(")");
                    return true;
                }
            }
            return false;
        }

        public emitThis() {
            if (this.thisFnc && !this.thisFnc.isMethod() && (!this.thisFnc.isConstructor)) {
                this.writeToOutput("_this");
            }
            else {
                this.writeToOutput("this");
            }
        }

        public static throwEmitterError(e: Error): void {
            var error: any = new Error(e.message);
            error.isEmitterError = true;
            throw error;
        }

        public static handleEmitterError(fileName: string, e: Error): IDiagnostic[] {
            if ((<any>e).isEmitterError === true) {
                return [new Diagnostic(0, 0, fileName, e.message)];
            }

            throw e;
        }

        // Note: throws exception.  
        private createFile(fileName: string, useUTF8: bool): ITextWriter {
            try {
                return this.emitOptions.ioHost.createFile(fileName, useUTF8);
            }
            catch (e) {
                Emitter.throwEmitterError(e);
            }
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class ErrorReporter {
        public errorCallback: (minChar: number, charLen: number, message: string, fileName: string, lineMap: LineMap) => void = null;
        public locationInfo: LocationInfo = unknownLocationInfo;
        public lineCol = { line: 0, character: 0 };
        public hasErrors = false;
        public pushToErrorSink = false;
        public errorSink: string[] = [];

        constructor (public outfile: ITextWriter) { }

        public getCapturedErrors() { return this.errorSink; }
        public freeCapturedErrors() { this.errorSink = []; }
        public captureError(emsg: string) { this.errorSink[this.errorSink.length] = emsg; }

        public emitPrefix() {
            this.outfile.Write(this.locationInfo.fileName + "(" + this.lineCol.line + "," + this.lineCol.character + "): ");
        }

        public writePrefix(ast: AST): void {
            if (ast) {
                this.setError(ast);
            }
            else {
                this.lineCol.line = 0;
                this.lineCol.character = 0;
            }
            this.emitPrefix();
        }

        public writePrefixFromSym(symbol: Symbol): void {
            if (symbol && this.locationInfo.lineMap) {
                this.locationInfo.lineMap.fillLineAndCharacterFromPosition(symbol.location, this.lineCol);
                if (this.lineCol.line >= 0) {
                    this.lineCol.line++;
                }
            }
            else {
                this.lineCol.line = -1;
                this.lineCol.character = -1;
            }
            this.emitPrefix();
        }

        public setError(ast: AST) {
            if (ast) {
                ast.flags |= ASTFlags.Error;
                if (this.locationInfo.lineMap) {
                    this.locationInfo.lineMap.fillLineAndCharacterFromPosition(ast.minChar, this.lineCol);
                    if (this.lineCol.line >= 0) {
                        this.lineCol.line++;
                    }
                }
            }
        }

        public reportError(ast: AST, message: string) {
            if (this.pushToErrorSink) {
                this.captureError(message);
                return;
            }

            this.hasErrors = true;
            if (ast && this.errorCallback) {
                var len = (ast.limChar - ast.minChar);
                this.errorCallback(ast.minChar, len, message, this.locationInfo.fileName, this.locationInfo.lineMap);
            }
            else {
                this.writePrefix(ast);
                this.outfile.WriteLine(message); // Right after the semi-colon
            }
        }

        public reportErrorFromSym(symbol: Symbol, message: string) {
            if (this.pushToErrorSink) {
                this.captureError(message);
                return;
            }

            this.hasErrors = true;
            if (this.errorCallback) {
                this.errorCallback(symbol.location, symbol.length, message, this.locationInfo.fileName, this.locationInfo.lineMap);
            }
            else {
                this.writePrefixFromSym(symbol);
                this.outfile.WriteLine(message);
            }
        }

        public duplicateIdentifier(ast: AST, name: string) {
            this.reportError(ast, "Duplicate identifier '" + name + "'");
        }

        public unresolvedSymbol(ast: AST, name: string) {
            this.reportError(ast, "The name '" + name + "' does not exist in the current scope");
        }

        public symbolDoesNotReferToAValue(ast: AST, name: string): void {
            this.reportError(ast, "The name '" + name + "' does not refer to a value");
        }

        public styleError(ast: AST, msg: string): void {
            var bkThrow = this.pushToErrorSink;
            this.pushToErrorSink = false;
            this.reportError(ast, "STYLE: " + msg);
            this.pushToErrorSink = bkThrow;
        }

        public simpleError(ast: AST, msg: string): void {
            this.reportError(ast, msg);
        }

        public simpleErrorFromSym(sym: Symbol, msg: string): void {
            this.reportErrorFromSym(sym, msg);
        }

        public invalidSuperReference(ast: AST) {
            this.simpleError(ast, "Keyword 'super' can only be used inside a class instance method");
        }

        public valueCannotBeModified(ast: AST) {
            this.simpleError(ast, "The left-hand side of an assignment expression must be a variable, property or indexer");
        }

        public invalidCall(ast: CallExpression, nodeType: number, scope: SymbolScope): void {
            var targetType = ast.target.type;
            var typeName = targetType.getScopedTypeName(scope);
            if (targetType.construct && (nodeType == NodeType.Call)) {
                this.reportError(ast, "Value of type '" + typeName + "' is not callable.  Did you mean to include 'new'?");
            } else {
                var catString = (nodeType == NodeType.Call) ? "callable" : "newable";

                this.reportError(ast, "Value of type '" + typeName + "' is not " + catString);
            }
        }

        public indexLHS(ast: BinaryExpression, scope: SymbolScope): void {
            var targetType = ast.operand1.type.getScopedTypeName(scope);
            var indexType = ast.operand2.type.getScopedTypeName(scope);
            this.simpleError(ast, "Value of type '" + targetType + "' is not indexable by type '" + indexType + "'");
        }

        public incompatibleTypes(ast: AST, t1: Type, t2: Type, op: string, scope: SymbolScope, comparisonInfo?:TypeComparisonInfo) {
            if (!t1) {
                // t1 = this.checker.anyType;
            }
            if (!t2) {
                // t2 = this.checker.anyType;
            }

            var reason = comparisonInfo ? comparisonInfo.message : "";
            if (op) {
                this.reportError(ast, "Operator '" + op + "' cannot be applied to types '" + t1.getScopedTypeName(scope) +
                                  "' and '" + t2.getScopedTypeName(scope) + "'" + (reason ? ": " + reason : ""));
            }
            else {
                this.reportError(ast, "Cannot convert '" + t1.getScopedTypeName(scope) +
                                  "' to '" + t2.getScopedTypeName(scope) + "'" + (reason ? ": " + reason : ""));
            }
        }

        public expectedClassOrInterface(ast: AST): void {
            this.simpleError(ast, "Expected var, class, interface, or module");
        }

        public unaryOperatorTypeError(ast: AST, op: string, type: Type) {
            this.reportError(ast, "Operator '" + op + "' cannot be applied to type '" + type.getTypeName() + "'");
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    // TODO: refactor indent logic for use in emit
    export class PrintContext {
        public builder = "";
        public indent1 = "  ";
        public indentStrings: string[] = [];
        public indentAmt = 0;

        constructor (public outfile: ITextWriter) {
        }

        public increaseIndent() {
            this.indentAmt++;
        }

        public decreaseIndent() {
            this.indentAmt--;
        }

        public startLine() {
            if (this.builder.length > 0) {
                CompilerDiagnostics.Alert(this.builder);
            }
            var indentString = this.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for (var i = 0; i < this.indentAmt; i++) {
                    indentString += this.indent1;
                }
                this.indentStrings[this.indentAmt] = indentString;
            }
            this.builder += indentString;
        }

        public write(s) {
            this.builder += s;
        }

        public writeLine(s) {
            this.builder += s;
            this.outfile.WriteLine(this.builder);
            this.builder = "";
        }

    }

    export function prePrintAST(ast: AST, parent: AST, walker: IAstWalker) {
        var pc: PrintContext = <PrintContext>walker.state;

        ast.print(pc);
        pc.increaseIndent();
        return ast;
    }


    export function postPrintAST(ast: AST, parent: AST, walker: IAstWalker) {
        var pc: PrintContext = <PrintContext>walker.state;
        pc.decreaseIndent();
        return ast;
    }
}
﻿/* -----------------------------------------------------------------------------
This file is based on or incorporates material from the projects listed below 
(collectively, "Third Party Code"). Microsoft is not the original author of the 
Third Party Code. The original copyright notice and the license, under which 
Microsoft received such Third Party Code, are set forth below. Such licenses 
and notices are provided for informational purposes only. Microsoft, not the 
third party, licenses the Third Party Code to you under the terms of the 
Apache License, Version 2.0. See License.txt in the project root for complete 
license information. Microsoft reserves all rights not expressly granted under 
the Apache 2.0 License, whether by implication, estoppel or otherwise. 
----------------------------------------------------------------------------- */

/*
    json2.js
    2011-10-19

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, regexp: true */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/

// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

///<reference path='json2Stringify.ts'/>
var JSON = (typeof JSON === "undefined") ? JSON2 : JSON;
(function() {
    'use strict';

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

    // If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON2.parse !== 'function') {
        JSON2.parse = function (text, reviver) {

            // The parse method takes a text and an optional reviver function, and returns
            // a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key): {} {

                // The walk method is used to recursively walk the resulting structure so
                // that modifications can be made.

                var k = null, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


            // Parsing happens in four stages. In the first stage, we replace certain
            // Unicode characters with escape sequences. JavaScript handles many characters
            // incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = <any>0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

            // In the second stage, we run the text against regular expressions that look
            // for non-JSON patterns. We are especially concerned with '()' and 'new'
            // because they can cause invocation, and '=' because it can cause mutation.
            // But just to be safe, we want to reject all unexpected forms.

            // We split the second stage into 4 regexp operations in order to work around
            // crippling inefficiencies in IE's and Safari's regexp engines. First we
            // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
            // replace all simple value tokens with ']' characters. Third, we delete all
            // open brackets that follow a colon or comma or that begin the text. Finally,
            // we look to see that the remaining characters are only whitespace or ']' or
            // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

                // In the third stage we use the eval function to compile the text into a
                // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
                // in JavaScript: it can begin a block or an object literal. We wrap the text
                // in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

                // In the optional fourth stage, we recursively walk the new structure, passing
                // each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({ '': j }, '')
                    : j;
            }

            // If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
} ());
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
///<reference path='typescript.ts' />
///<reference path='..\harness\external\json2.ts' />

module TypeScript {

    export var LexEOF = (-1);

    export var LexCodeNWL = 0x0A;
    export var LexCodeRET = 0x0D;
    export var LexCodeLS = 0x2028;
    export var LexCodePS = 0x2029;
    export var LexCodeTAB = 0x09;
    export var LexCodeVTAB = 0x0B;
    export var LexCode_e = 'e'.charCodeAt(0);
    export var LexCode_E = 'E'.charCodeAt(0);
    export var LexCode_x = 'x'.charCodeAt(0);
    export var LexCode_X = 'X'.charCodeAt(0);
    export var LexCode_a = 'a'.charCodeAt(0);
    export var LexCode_A = 'A'.charCodeAt(0);
    export var LexCode_f = 'f'.charCodeAt(0);
    export var LexCode_F = 'F'.charCodeAt(0);

    export var LexCode_g = 'g'.charCodeAt(0);
    export var LexCode_m = 'm'.charCodeAt(0);
    export var LexCode_i = 'i'.charCodeAt(0);

    export var LexCode_u = 'u'.charCodeAt(0);

    export var LexCode_0 = '0'.charCodeAt(0);
    export var LexCode_9 = '9'.charCodeAt(0);
    export var LexCode_8 = '8'.charCodeAt(0);
    export var LexCode_7 = '7'.charCodeAt(0);

    export var LexCodeBSL = '\\'.charCodeAt(0);
    export var LexCodeSHP = '#'.charCodeAt(0);
    export var LexCodeBNG = '!'.charCodeAt(0);
    export var LexCodeQUO = '"'.charCodeAt(0);
    export var LexCodeAPO = '\''.charCodeAt(0);
    export var LexCodePCT = '%'.charCodeAt(0);
    export var LexCodeAMP = '&'.charCodeAt(0);
    export var LexCodeLPR = '('.charCodeAt(0);
    export var LexCodeRPR = ')'.charCodeAt(0);
    export var LexCodePLS = '+'.charCodeAt(0);
    export var LexCodeMIN = '-'.charCodeAt(0);
    export var LexCodeMUL = '*'.charCodeAt(0);
    export var LexCodeSLH = '/'.charCodeAt(0);
    export var LexCodeXOR = '^'.charCodeAt(0);
    export var LexCodeCMA = ','.charCodeAt(0);
    export var LexCodeDOT = '.'.charCodeAt(0);
    export var LexCodeLT = '<'.charCodeAt(0);
    export var LexCodeEQ = '='.charCodeAt(0);
    export var LexCodeGT = '>'.charCodeAt(0);
    export var LexCodeQUE = '?'.charCodeAt(0);
    export var LexCodeLBR = '['.charCodeAt(0);
    export var LexCodeRBR = ']'.charCodeAt(0);
    export var LexCodeUSC = '_'.charCodeAt(0);
    export var LexCodeLC = '{'.charCodeAt(0);
    export var LexCodeRC = '}'.charCodeAt(0);
    export var LexCodeBAR = '|'.charCodeAt(0);
    export var LexCodeTIL = '~'.charCodeAt(0);
    export var LexCodeCOL = ':'.charCodeAt(0);
    export var LexCodeSMC = ';'.charCodeAt(0);
    export var LexCodeUnderscore = '_'.charCodeAt(0);
    export var LexCodeDollar = '$'.charCodeAt(0);
    export var LexCodeSpace = 32;
    export var LexCodeAtSign = '@'.charCodeAt(0);
    export var LexCodeASCIIChars = 128;

    export var LexKeywordTable = undefined;
    // PULLTODO: When generics are on by default, remove the assertion to 'any[]'
    var autoToken: Token[] = <any[]>(new Array(LexCodeASCIIChars));
    var lexIdStartTable: bool[] = <any[]>(new Array(LexCodeASCIIChars));

    // Unicode range maps
    // REVIEW: These range maps have been extracted from the Unicode specifications, they might be missing values, and/or include 
    //         incorrect ranges. but for the most they seem to be correct. A more accurate and thorough review is needed.

    /*
        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
        IdentifierStart :: Can contain Unicode 3.0.0  categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.
        IdentifierPart :: Can contain IdentifierStart + Unicode 3.0.0  categories “Non-spacing mark (Mn)”, “Combining spacing mark (Mc)”, “Decimal number (Nd)”, or “Connector punctuation (Pc)”.
                    
        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
    */
    var unicodeES3IdStart = [
        170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,
        1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611,
        2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970,
        2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517,
        3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138,
        4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885,
        4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147,
        8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588,
        12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140,
        65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,
    ];

    var unicodeES3IdCont = [
        768, 846, 864, 866, 1155, 1158, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1611, 1621, 1632, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 2305, 2307, 2364, 2364, 2366, 2381, 2385, 2388, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492,
        2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2562, 2562, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2662, 2673, 2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2790, 2799, 2817, 2819, 2876, 2876, 2878, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2918, 2927, 2946, 2947, 3006, 3010, 3014, 3016,
        3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3174, 3183, 3202, 3203, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3302, 3311, 3330, 3331, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3633, 3633,
        3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903, 3953, 3972, 3974, 3975, 3984, 3991, 3993, 4028, 4038, 4038, 4140, 4146, 4150, 4153, 4160, 4169, 4182, 4185, 4969, 4977, 6068, 6099, 6112, 6121, 6160, 6169, 6313, 6313,
        8255, 8256, 8400, 8412, 8417, 8417, 12330, 12335, 12441, 12442, 12539, 12539, 64286, 64286, 65056, 65059, 65075, 65076, 65101, 65103, 65296, 65305, 65343, 65343, 65381, 65381,
    ];


    /*
        As per ECMAScript Language Specification 5th Edition, Section 7.6: Identifier Names and Identifiers
        IdentifierStart :: Can contain Unicode 6.2  categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.
        IdentifierPart :: Can contain IdentifierStart + Unicode 6.2  categories “Non-spacing mark (Mn)”, “Combining spacing mark (Mc)”, “Decimal number (Nd)”, “Connector punctuation (Pc)”, <ZWNJ>, or <ZWJ>.
                    
        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
    */
    var unicodeES5IdStart = [
         170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775,
         1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489,
         2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864,
         2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,
         3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743,
         3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680,
         4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000,
         6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957,
         7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486,
         8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726,
         11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606,
         42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595,
         43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262,
         64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,
    ];

    var unicodeES5IdCont = [
        768, 879, 1155, 1159, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1552, 1562, 1611, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 1984, 1993, 2027, 2035, 2070, 2073, 2075, 2083, 2085, 2087, 2089, 2093, 2137, 2139, 2276, 2302, 2304, 2307, 2362, 2364,
        2366, 2383, 2385, 2391, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2561, 2563, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2662, 2673, 2677, 2677, 2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2786, 2787, 2790, 2799, 2817, 2819,
        2876, 2876, 2878, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2914, 2915, 2918, 2927, 2946, 2946, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3046, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3170, 3171, 3174, 3183, 3202, 3203, 3260, 3260, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3298, 3299, 3302, 3311,
        3330, 3331, 3390, 3396, 3398, 3400, 3402, 3405, 3415, 3415, 3426, 3427, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3633, 3633, 3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903,
        3953, 3972, 3974, 3975, 3981, 3991, 3993, 4028, 4038, 4038, 4139, 4158, 4160, 4169, 4182, 4185, 4190, 4192, 4194, 4196, 4199, 4205, 4209, 4212, 4226, 4237, 4239, 4253, 4957, 4959, 5906, 5908, 5938, 5940, 5970, 5971, 6002, 6003, 6068, 6099, 6109, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6313, 6313, 6432, 6443, 6448, 6459, 6470, 6479,
        6576, 6592, 6600, 6601, 6608, 6617, 6679, 6683, 6741, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6912, 6916, 6964, 6980, 6992, 7001, 7019, 7027, 7040, 7042, 7073, 7085, 7088, 7097, 7142, 7155, 7204, 7223, 7232, 7241, 7248, 7257, 7376, 7378, 7380, 7400, 7405, 7405, 7410, 7412, 7616, 7654, 7676, 7679, 8204, 8205, 8255, 8256, 8276, 8276,
        8400, 8412, 8417, 8417, 8421, 8432, 11503, 11505, 11647, 11647, 11744, 11775, 12330, 12335, 12441, 12442, 42528, 42537, 42607, 42607, 42612, 42621, 42655, 42655, 42736, 42737, 43010, 43010, 43014, 43014, 43019, 43019, 43043, 43047, 43136, 43137, 43188, 43204, 43216, 43225, 43232, 43249, 43264, 43273, 43302, 43309, 43335, 43347,
        43392, 43395, 43443, 43456, 43472, 43481, 43561, 43574, 43587, 43587, 43596, 43597, 43600, 43609, 43643, 43643, 43696, 43696, 43698, 43700, 43703, 43704, 43710, 43711, 43713, 43713, 43755, 43759, 43765, 43766, 44003, 44010, 44012, 44013, 44016, 44025, 64286, 64286, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103,
        65296, 65305, 65343, 65343,
    ];

    export function LexLookUpUnicodeMap(code: number, map: number[]): bool {
        // Perform binary search in one of the unicode range maps
        var lo: number = 0;
        var hi: number = map.length;
        var mid: number;

        while (lo + 1 < hi) {
            mid = lo + (hi - lo) / 2;
            // mid has to be even to catch a range's beginning
            mid -= mid % 2;
            if (map[mid] <= code && code <= map[mid + 1])
                return true;
            if (code < map[mid])
                hi = mid;
            else
                lo = mid + 2;
        }
        return false;
    }

    export function LexIsUnicodeDigit(code: number, codeGenTarget: LanguageVersion): bool {
        if (codeGenTarget === LanguageVersion.EcmaScript3) {
            return LexLookUpUnicodeMap(code, unicodeES3IdCont);
        } else {
            return LexLookUpUnicodeMap(code, unicodeES5IdCont);
        }
    }

    export function LexIsUnicodeIdStart(code: number, codeGenTarget: LanguageVersion): bool {
        if (codeGenTarget === LanguageVersion.EcmaScript3) {
            return LexLookUpUnicodeMap(code, unicodeES3IdStart);
        } else {
            return LexLookUpUnicodeMap(code, unicodeES5IdStart);
        }
    }

    export function LexInitialize() {
        initializeStaticTokens();
        autoToken[LexCodeLPR] = staticTokens[TokenID.OpenParen];
        autoToken[LexCodeRPR] = staticTokens[TokenID.CloseParen];
        autoToken[LexCodeCMA] = staticTokens[TokenID.Comma];
        autoToken[LexCodeSMC] = staticTokens[TokenID.Semicolon];
        autoToken[LexCodeLBR] = staticTokens[TokenID.OpenBracket];
        autoToken[LexCodeRBR] = staticTokens[TokenID.CloseBracket];
        autoToken[LexCodeTIL] = staticTokens[TokenID.Tilde];
        autoToken[LexCodeQUE] = staticTokens[TokenID.Question];
        autoToken[LexCodeLC] = staticTokens[TokenID.OpenBrace];
        autoToken[LexCodeRC] = staticTokens[TokenID.CloseBrace];
        autoToken[LexCodeCOL] = staticTokens[TokenID.Colon];
        LexKeywordTable = new StringHashTable();
        for (var i in (<any>TokenID)._map) {
            if ((<number><any>i) <= TokenID.LimKeyword) {
                LexKeywordTable.add((<any>TokenID)._map[i].toLowerCase(), i);
            }
        }
        for (var j = 0; j < LexCodeASCIIChars; j++) {
            if (LexIsIdentifierStartChar(j)) {
                lexIdStartTable[j] = true;
            }
            else {
                lexIdStartTable[j] = false;
            }
        }
    }

    export function LexAdjustIndent(code, indentAmt) {
        if ((code === LexCodeLBR) || (code === LexCodeLC) || (code === LexCodeLPR)) {
            return indentAmt + 1;
        }
        else if ((code === LexCodeRBR) || (code === LexCodeRC) || (code === LexCodeRPR)) {
            return indentAmt - 1;
        }
        else return indentAmt;
    }

    export function LexIsIdentifierStartChar(code): bool {
        return (((code >= 97) && (code <= 122)) ||
                ((code >= 65) && (code <= 90)) ||
                (code === LexCodeDollar) ||
                (code === LexCodeUnderscore));
    }

    export function LexIsDigit(code): bool {
        return ((code >= 48) && (code <= 57));
    }

    export function LexIsIdentifierChar(code: number) {
        return lexIdStartTable[code] || LexIsDigit(code);
    }

    export function LexMatchingOpen(code) {
        if (code === LexCodeRBR)
            return LexCodeLBR;
        else if (code === LexCodeRC)
            return LexCodeLC;
        else if (code === LexCodeRPR)
            return LexCodeLPR;
        else return 0;
    }

    export enum NumberScanState {
        Start,
        InFraction,
        InEmptyFraction,
        InExponent
    }

    export enum LexState {
        Start,
        InMultilineComment,
        InMultilineSingleQuoteString,
        InMultilineDoubleQuoteString,
    }

    export enum LexMode {
        Line,
        File,
    }

    export enum CommentStyle {
        Line,
        Block
    }
    
    export interface IScanner {
        startPos: number;
        pos: number;
        scan(): Token;
        previousToken(): Token;
        prevLine: number;
        line: number;
        col: number;
        leftCurlyCount: number;
        rightCurlyCount: number;
        lastTokenLimChar(): number;
        lastTokenHadNewline(): bool;
        lexState: number;
        getComments(): CommentToken[];
        getCommentsForLine(line: number): CommentToken[];
        resetComments(): void;
        lineMap: LineMap;
        setSourceText(newSrc: IScriptSnapshot, textMode: number): void;
        setErrorHandler(reportError: (message: string) => void ): void;
        seenUnicodeChar: bool;
        seenUnicodeCharInComment: bool;
        getLookAheadToken(): Token;
    }

    export class Scanner implements IScanner {
        // REVIEW: When adding new variables make sure to handle storing them in getLookAheadToken. 
        //         The method works by storing the state before scanning and restoring it later on,
        //         missing a member variable could result in an inconsistent state.
        public prevLine = 0;
        public line = 0;
        public col = 0;
        public pos = 0;
        public startPos = 0;
        public startCol: number;
        public startLine: number;
        public src: string;
        public len = 0;
        public lineMap: LineMap = null;

        public ch = LexEOF;
        public lexState = LexState.Start;
        public mode = LexMode.File;
        public scanComments: bool = true;
        public interveningWhitespace = false; // Was there a whitespace token between the last token and the current one?
        private interveningWhitespacePos = 0; //  If yes, this contains the start position of the whitespace
        public leftCurlyCount = 0;
        public rightCurlyCount = 0;
        public commentStack: CommentToken[] = [];
        public seenUnicodeChar: bool = false;
        seenUnicodeCharInComment: bool = false;

        private reportError: (message: string) => void;

        private prevTok = staticTokens[TokenID.EndOfFile];

        constructor(private codeGenTarget: LanguageVersion) {
            this.startCol = this.col;
            this.startLine = this.line;

            if (!LexKeywordTable) {
                LexInitialize();
            }
        }

        public previousToken() { return this.prevTok; }

        public setSourceText(newSrc: IScriptSnapshot, textMode: number) {
            this.mode = textMode;
            this.scanComments = (this.mode === LexMode.Line);
            this.pos = 0;
            this.interveningWhitespacePos = 0;
            this.startPos = 0;
            this.line = 0;
            this.col = 0;
            this.startCol = this.col;
            this.startLine = this.line;
            this.len = 0;
            this.src = newSrc.getText(0, newSrc.getLength());
            this.len = this.src.length;
            this.lineMap = LineMap.fromScriptSnapshot(newSrc);
            this.commentStack = [];
            this.leftCurlyCount = 0;
            this.rightCurlyCount = 0;
            this.seenUnicodeChar = false;
            this.seenUnicodeCharInComment = false;
        }

        public setErrorHandler(reportError: (message: string) => void ) {
            this.reportError = reportError;
        }

        public setText(newSrc: string, textMode: number) {
            this.setSourceText(ScriptSnapshot.fromString(newSrc), textMode);
        }

        public setScanComments(value: bool) {
            this.scanComments = value;
        }

        public tokenStart(): void {
            this.startPos = this.pos;
            this.startLine = this.line;
            this.startCol = this.col;
            this.interveningWhitespace = false;
        }

        public peekChar(): number {
            if (this.pos < this.len) {
                return this.src.charCodeAt(this.pos);
            }
            else {
                return LexEOF;
            }
        }

        public peekCharAt(index: number): number {
            if (index < this.len) {
                return this.src.charCodeAt(index);
            }
            else {
                return LexEOF;
            }
        }

        public IsHexDigit(c: number) {
            return ((c >= LexCode_0) && (c <= LexCode_9)) || ((c >= LexCode_A) && (c <= LexCode_F)) ||
                ((c >= LexCode_a) && (c <= LexCode_f));
        }

        public IsOctalDigit(c: number) {
            return ((c >= LexCode_0) && (c <= LexCode_7)) ||
                ((c >= LexCode_a) && (c <= LexCode_f));
        }

        public scanHexDigits(): Token {
            var atLeastOneDigit = false;
            for (; ;) {
                if (this.IsHexDigit(this.ch)) {
                    this.nextChar();
                    atLeastOneDigit = true;
                }
                else {
                    if (atLeastOneDigit) {
                        var text = this.src.substring(this.startPos, this.pos);
                        return new NumberLiteralToken(parseInt(text), text);
                    }
                    else {
                        return null;
                    }
                }
            }

        }

        public scanOctalDigits(): Token {
            var atLeastOneDigit = false;
            for (; ;) {
                if (this.IsOctalDigit(this.ch)) {
                    this.nextChar();
                    atLeastOneDigit = true;
                }
                else {
                    if (atLeastOneDigit) {
                        var text = this.src.substring(this.startPos, this.pos);
                        return new NumberLiteralToken(parseInt(text), text);
                    }
                    else {
                        return null;
                    }
                }
            }

        }

        public scanDecimalNumber(state: number): Token {
            var atLeastOneDigit = false;
            var svPos = this.pos;
            var svCol = this.col;
            var text: string;
            
            for (; ;) {
                if (LexIsDigit(this.ch)) {
                    atLeastOneDigit = true;
                    if (this.ch != LexCode_0 && state === NumberScanState.InEmptyFraction) {
                        state = NumberScanState.InFraction;
                    }
                    this.nextChar();
                }
                else if (this.ch === LexCodeDOT) {
                    if (state === NumberScanState.Start) {
                        // DecimalDigit* .
                        this.nextChar();
                        state = NumberScanState.InEmptyFraction;
                    }
                    else {
                        // dot not part of number
                        if (atLeastOneDigit) {
                            // DecimalDigit* . DecimalDigit+
                            text = this.src.substring(this.startPos, this.pos);
                            return new NumberLiteralToken(parseFloat(text), text);
                        }
                        else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    }
                } else if ((this.ch === LexCode_e) || (this.ch === LexCode_E)) {
                    if (state === NumberScanState.Start) {
                        if (atLeastOneDigit) {
                            // DecimalDigit+ (. DecimalDigit*) [eE] [+-]DecimalDigit+
                            atLeastOneDigit = false;
                            this.nextChar();
                            state = NumberScanState.InExponent;
                        }
                        else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    }
                    else if (state === NumberScanState.InFraction || state === NumberScanState.InEmptyFraction) {
                        // DecimalDigit+ . DecimalDigit* [eE]
                        this.nextChar();
                        state = NumberScanState.InExponent;
                        atLeastOneDigit = false;
                    }
                    else {
                        // DecimalDigit+ . DecimalDigit* [eE] DecimalDigit+
                        if (atLeastOneDigit) {
                            text = this.src.substring(this.startPos, this.pos);
                            return new NumberLiteralToken(parseFloat(text), text);
                        }
                        else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    }
                }
                else if ((this.ch === LexCodePLS) || (this.ch === LexCodeMIN)) {
                    if (state === NumberScanState.InExponent) {
                        if (!atLeastOneDigit) {
                            this.nextChar();
                        }
                        else {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                    }
                    else if (state === NumberScanState.InEmptyFraction || state === NumberScanState.InFraction) {
                        // This case will not generate bad javascript if we miss the fractional part, but we just want to be consistent with the dot case
                        text = this.src.substring(this.startPos, this.pos);
                        return new NumberLiteralToken(parseFloat(text), text);
                    }
                    else {
                        if (!atLeastOneDigit) {
                            this.pos = svPos;
                            this.col = svCol;
                            return null;
                        }
                        else {
                            text = this.src.substring(this.startPos, this.pos);
                            return new NumberLiteralToken(parseFloat(text), text);
                        }
                    }
                }
                else {
                    if (!atLeastOneDigit) {
                        this.pos = svPos;
                        this.col = svCol;
                        return null;
                    }
                    else {
                        text = this.src.substring(this.startPos, this.pos);
                        return new NumberLiteralToken(parseFloat(text), text);
                    }
                }
            }
        }

        // 0 [xX] hexDigits
        // 0 octalDigits
        // 0 [89] decimalDigits
        // decimalDigits? fraction? exponent?

        public scanNumber(): Token {
            if (this.peekChar() === LexCode_0) {
                switch (this.peekCharAt(this.pos + 1)) {
                    case LexCode_x:
                    case LexCode_X:
                        // Hex
                        this.advanceChar(2);
                        return this.scanHexDigits();
                    case LexCode_8:
                    case LexCode_9:
                    case LexCodeDOT:
                        return this.scanDecimalNumber(NumberScanState.Start);
                    default:
                        // Octal
                        return this.scanOctalDigits();
                }
            }
            else {
                return this.scanDecimalNumber(NumberScanState.Start);
            }
        }

        public scanFraction(): Token {
            return this.scanDecimalNumber(NumberScanState.InFraction);
        }

        public newLine(): void {
            this.col = 0;
            if (this.mode === LexMode.File) {
                this.line++;
            }
        }

        public finishMultilineComment(): bool {
            var ch2: number;
            this.lexState = LexState.InMultilineComment;
            while (this.pos < this.len) {
                if (this.ch === LexCodeMUL) {
                    ch2 = this.peekCharAt(this.pos + 1);
                    if (ch2 === LexCodeSLH) {
                        this.advanceChar(2);
                        if (this.mode === LexMode.File) {
                            this.tokenStart();
                        }
                        this.lexState = LexState.Start;
                        return true;
                    }
                }
                else if (this.ch === LexCodeNWL) {
                    this.newLine();
                    if (this.mode === LexMode.Line) {
                        this.nextChar();
                        return false;
                    }
                }
                else if (this.ch >= LexCodeASCIIChars) {
                    this.seenUnicodeCharInComment = true;
                }
                this.nextChar();
            }
            return false;
        }

        public pushComment(comment: CommentToken) {
            this.commentStack.push(comment);
        }

        public getComments() {
            var stack = this.commentStack;
            this.commentStack = [];
            return stack;
        }

        public getCommentsForLine(line: number) {
            var comments: CommentToken[] = null;
            while ((this.commentStack.length > 0) && (this.commentStack[0].line === line)) {
                if (comments === null) {
                    comments = [this.commentStack.shift()];
                }
                else {
                    comments = comments.concat([this.commentStack.shift()]);
                }

            }
            return comments;
        }

        public resetComments() {
            this.commentStack = [];
        }

        public endsLine(c: number) {
            return (c === LexCodeNWL) || (c === LexCodeRET) || (c === LexCodeLS) || (c === LexCodePS);
        }

        public finishSinglelineComment() {
            while (this.pos < this.len) {
                if (this.endsLine(this.ch))
                    break;
                if (this.ch >= LexCodeASCIIChars) {
                    this.seenUnicodeCharInComment = true;
                }
                this.nextChar();
            }

            if (this.mode === LexMode.File) {
                this.tokenStart();
            }
        }

        public findClosingSLH() {
            var index = this.pos;
            var ch2 = this.src.charCodeAt(index);
            var prevCh = 0;
            var liveEsc = false;
            while (!this.endsLine(ch2) && (index < this.len)) {
                if ((ch2 === LexCodeSLH) && (!liveEsc)) {
                    return index;
                }
                prevCh = ch2;
                index++;
                if (liveEsc) {
                    liveEsc = false;
                }
                else {
                    liveEsc = (prevCh === LexCodeBSL);
                }

                ch2 = this.src.charCodeAt(index);
            }
            return -1;
        }

        public speculateRegex(): Token {
            if (noRegexTable[this.prevTok.tokenId] != undefined) {
                return null;
            }
            var svPos = this.pos;
            var svCol = this.col;
            // first char is '/' and has been skipped
            var index = this.findClosingSLH();
            if (index > 0) {
                // found closing /
                var pattern = this.src.substring(svPos, index);
                var flags = "";
                this.pos = index + 1;
                this.ch = this.peekChar();
                var flagsStart = this.pos;
                // TODO: check for duplicate flags
                while ((this.ch === LexCode_i) || (this.ch === LexCode_g) || (this.ch === LexCode_m)) {
                    this.nextChar();
                }

                if ((this.pos - flagsStart) > 3) {
                    return null;
                }
                else {
                    flags = this.src.substring(flagsStart, this.pos);
                }

                var regex = undefined;
                try {
                    regex = new RegExp(pattern, flags);
                }
                catch (regexException) {
                }

                if (regex) {
                    // no line boundary in regex string
                    this.col = svCol + (this.pos - this.startPos);
                    return new RegularExpressionLiteralToken(this.src.substring(svPos - 1, this.pos));
                }
            }

            this.pos = svPos;
            this.col = svCol;

            return null;
        }

        public lastTokenHadNewline() {
            return this.prevLine != this.startLine;
        }

        public lastTokenLimChar() {
            return this.interveningWhitespace ? this.interveningWhitespacePos : this.startPos;
        }

        // use only when known not to skip line terminators
        public advanceChar(amt: number) {
            this.pos += amt;
            this.col += amt;
            this.ch = this.peekChar();
        }

        public nextChar() {
            this.pos++;
            this.col++;
            this.ch = this.peekChar();
        }

        public getLookAheadToken(): Token {
            // REVIEW: This method is only used for parsing varargs in lambda expressions. If this 
            //         functionality is needed for more common cases, it needs to be designed. 
            //         Look-ahead token needs to be integrated in the scanner design to allow for 
            //         an efficient lookup.

            // Store the scanner state
            var prevLine = this.prevLine;
            var line = this.line;
            var col = this.col;
            var pos = this.pos;
            var startPos = this.startPos;
            var startCol = this.startCol;
            var startLine = this.startLine;
            var ch = this.ch;
            var prevTok = this.prevTok;
            var lexState = this.lexState;
            var interveningWhitespace = this.interveningWhitespace;
            var interveningWhitespacePos = this.interveningWhitespacePos;
            var leftCurlyCount = this.leftCurlyCount;
            var rightCurlyCount = this.rightCurlyCount;
            var seenUnicodeChar = this.seenUnicodeChar;
            var seenUnicodeCharInComment = this.seenUnicodeCharInComment;
            var commentStackLength = this.commentStack.length;

            var lookAheadToken = this.scan();

            // Restore state
            this.prevLine = prevLine;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.startPos = startPos;
            this.startCol = startCol;
            this.startLine = startLine;
            this.ch = ch;
            this.prevTok = prevTok;
            this.lexState = lexState;
            this.interveningWhitespace = interveningWhitespace;
            this.interveningWhitespacePos = interveningWhitespacePos;
            this.leftCurlyCount = leftCurlyCount;
            this.rightCurlyCount = rightCurlyCount;
            this.seenUnicodeChar = seenUnicodeChar;
            this.seenUnicodeCharInComment = seenUnicodeCharInComment;
            this.commentStack.length = commentStackLength;

            return lookAheadToken;
        }

        public scanInLine(): Token {
            if ((this.lexState === LexState.InMultilineComment) && (this.scanComments)) {
                this.ch = this.peekChar();
                var commentLine = this.line;
                this.finishMultilineComment();
                if (this.startPos < this.pos) {
                    var commentText = this.src.substring(this.startPos, this.pos);
                    this.tokenStart();
                    return new CommentToken(commentText,/*isBlock*/true, this.startPos, commentLine,/*endsLine*/true);
                }
                else {
                    return staticTokens[TokenID.EndOfFile];
                }
            }
            else if (this.lexState === LexState.InMultilineSingleQuoteString && this.pos < this.len) {
                this.ch = this.peekChar();
                this.lexState = LexState.Start;
                return this.scanStringConstant(LexCodeAPO);
            }
            else if (this.lexState === LexState.InMultilineDoubleQuoteString && this.pos < this.len) {
                this.ch = this.peekChar();
                this.lexState = LexState.Start;
                return this.scanStringConstant(LexCodeQUO);
            }
            this.prevLine = this.line;
            var prevTok = this.innerScan();

            // Ingore white spaces
            if (prevTok.tokenId != TokenID.Whitespace) {
                this.prevTok = prevTok;
            }
            return prevTok;
        }

        public scan(): Token {
            this.prevLine = this.line;
            this.prevTok = this.innerScan();
            return this.prevTok;
        }

        private isValidUnicodeIdentifierChar(): bool {
            var valid = LexIsUnicodeIdStart(this.ch, this.codeGenTarget) || LexIsUnicodeDigit(this.ch, this.codeGenTarget);
            this.seenUnicodeChar = this.seenUnicodeChar || valid;
            return valid;
        }

        private scanStringConstant(endCode: number): Token {

            // Accumulate with escape characters
            scanStringConstantLoop:
            for (; ;) {
                switch (this.ch) {
                    case LexEOF:
                        // Unexpected end of file
                        this.reportScannerError("Unterminated string constant");
                        break scanStringConstantLoop;

                    case LexCodeLS:
                    case LexCodePS:
                        this.seenUnicodeChar = true;
                    // Intentional fall through
                    case LexCodeRET:
                    case LexCodeNWL:
                        this.reportScannerError("Unterminated string constant");
                        break scanStringConstantLoop;

                    case LexCodeAPO:
                    case LexCodeQUO:
                        if (this.ch === endCode) {
                            // Found string terminator. Skip past end code.
                            this.nextChar();
                            break scanStringConstantLoop;
                        }
                        break;

                    case LexCodeBSL:
                        // Consume the current slash
                        this.nextChar();

                        switch (this.ch) {
                            case LexCodeAPO:
                            case LexCodeQUO:
                            case LexCodeBSL:
                                // Valid escape sequences
                                this.nextChar();
                                continue scanStringConstantLoop;

                            case LexCodeLS:
                            case LexCodePS:
                                this.seenUnicodeChar = true;
                            // Intentional fall through
                            case LexCodeRET:
                            case LexCodeNWL:
                                // Skip /r in a /r/n sequence
                                if (this.ch === LexCodeRET && this.peekCharAt(this.pos + 1) === LexCodeNWL) {
                                    this.nextChar();
                                }

                                // Record new line
                                this.newLine();

                                if (this.mode === LexMode.Line) {
                                    // Consume the new line char
                                    this.nextChar();
                                    this.lexState = endCode === LexCodeAPO ? LexState.InMultilineSingleQuoteString : LexState.InMultilineDoubleQuoteString;
                                    break scanStringConstantLoop;
                                }
                                break;

                            case LexCode_x:
                            case LexCode_u:
                                var expectedHexDigits = this.ch === LexCode_x ? 2 : 4;
                                this.nextChar();
                                for (var i = 0; i < expectedHexDigits; i++) {
                                    if (this.IsHexDigit(this.ch)) {
                                        this.nextChar();
                                    }
                                    else {
                                        this.reportScannerError("Invalid Unicode escape sequence");
                                        break;
                                    }
                                }
                                continue scanStringConstantLoop;
                        }
                        break;
                }

                // Record seeing a Unicode char
                if (this.ch >= LexCodeASCIIChars) {
                    this.seenUnicodeChar = true;
                }

                this.nextChar();
            }

            return new StringLiteralToken(this.src.substring(this.startPos, this.pos));
        }

        private scanIdentifier(): Token {
            var hasEscape = false;
            var isFirstChar = (this.ch === LexCodeBSL);
            var hasUnicode: any = false;

            for (; ;) {
                while (lexIdStartTable[this.ch] || LexIsDigit(this.ch) ||
                      (this.ch >= LexCodeASCIIChars && this.isValidUnicodeIdentifierChar())) {
                    this.nextChar();
                }
                if (this.ch === LexCodeBSL) {
                    this.nextChar();
                    if (this.ch === LexCode_u) {
                        // 4 hex digits
                        this.nextChar();
                        for (var h = 0; h < 4 ; h++) {
                            if (this.IsHexDigit(this.ch)) {
                                this.nextChar();
                            }
                            else {
                                this.reportScannerError("Invalid Unicode escape sequence");
                                return staticTokens[TokenID.Error];
                            }
                        }
                        var hexChar = parseInt(this.src.substring(this.pos - 4, this.pos), 16);

                        // Verify is valid ID char 
                        if (lexIdStartTable[hexChar] || (!isFirstChar && LexIsDigit(hexChar)) ||
                            (hexChar >= LexCodeASCIIChars && (LexIsUnicodeIdStart(hexChar, this.codeGenTarget) || (!isFirstChar && LexIsUnicodeDigit(hexChar, this.codeGenTarget))))) {
                        }
                        else {
                            this.reportScannerError("Invalid identifier character");
                            return staticTokens[TokenID.Error];
                        }

                        hasEscape = true;
                        isFirstChar = false;
                        continue;
                    }

                    this.reportScannerError("Invalid Unicode escape sequence");
                    return staticTokens[TokenID.Error];
                }
                break;
            }

            var id: number;
            var text = this.src.substring(this.startPos, this.pos);
            if (!hasEscape && (id = LexKeywordTable.lookup(text)) != null) {
                return staticTokens[id];
            }
            else {
                return new IdentifierToken(text, hasEscape);
            }
        }

        public innerScan(): Token {
            var rtok;
            this.tokenStart();
            this.ch = this.peekChar();

            start: while (this.pos < this.len) {
                if (lexIdStartTable[this.ch] || this.ch === LexCodeBSL || (this.ch >= LexCodeASCIIChars && LexIsUnicodeIdStart(this.ch, this.codeGenTarget))) {
                    // identifier or keyword
                    return this.scanIdentifier();
                }
                else if (this.ch === LexCodeSpace) {
                    if (!this.interveningWhitespace) {
                        this.interveningWhitespacePos = this.pos;
                    }
                    do {
                        this.nextChar();
                    } while (this.ch === LexCodeSpace);
                    if (this.mode === LexMode.Line) {
                        var whitespaceText = this.src.substring(this.startPos, this.pos);
                        return new WhitespaceToken(TokenID.Whitespace, whitespaceText);
                    }
                    else {
                        this.tokenStart();
                        this.interveningWhitespace = true;
                    }
                }
                else if (this.ch === LexCodeSLH) {
                    this.nextChar();
                    var commentText;
                    if (this.ch === LexCodeSLH) {
                        if (!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos - 1;
                        }
                        var commentStartPos = this.pos - 1;
                        var commentStartLine = this.line;
                        this.finishSinglelineComment();
                        var commentText = this.src.substring(commentStartPos, this.pos);
                        var commentToken = new CommentToken(commentText,/*isBlock*/false, commentStartPos, commentStartLine,/*endsLine*/false);
                        if (this.scanComments) {
                            // respect scanner contract: when returning a token, startPos is the start position of the token
                            this.startPos = commentStartPos;
                            return commentToken;
                        }
                        else {
                            this.pushComment(commentToken);
                        }

                        this.interveningWhitespace = true;
                    }
                    else if (this.ch === LexCodeMUL) {
                        if (!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos - 1;
                        }
                        var commentStartPos = this.pos - 1;
                        var commentStartLine = this.line;
                        this.nextChar();  // Skip the "*"
                        this.finishMultilineComment();
                        var commentText = this.src.substring(commentStartPos, this.pos);
                        var endsLine = this.endsLine(this.peekChar());
                        var commentToken = new CommentToken(commentText,/*isBlock*/true, commentStartPos, commentStartLine, endsLine);
                        if (this.scanComments) {
                            // respect scanner contract: when returning a token, startPos is the start position of the token
                            this.startPos = commentStartPos;
                            return commentToken;
                        }
                        else {
                            this.pushComment(commentToken);
                        }
                        this.interveningWhitespace = true;
                    }
                    else {
                        var regexTok = this.speculateRegex();
                        if (regexTok) {
                            return regexTok;
                        }
                        else {
                            if (this.peekCharAt(this.pos) === LexCodeEQ) {
                                this.nextChar();
                                return staticTokens[TokenID.SlashEquals];
                            }
                            else {
                                return staticTokens[TokenID.Slash];
                            }
                        }
                    }
                }
                else if (this.ch === LexCodeSMC) {
                    this.nextChar();
                    return staticTokens[TokenID.Semicolon];
                }
                else if ((this.ch === LexCodeAPO) || (this.ch === LexCodeQUO)) {
                    // Skip the first quote
                    var endCode = this.ch;
                    this.nextChar();
                    return this.scanStringConstant(endCode);
                }
                else if (autoToken[this.ch]) {
                    var atok = autoToken[this.ch];
                    if (atok.tokenId === TokenID.OpenBrace) {
                        this.leftCurlyCount++;
                    }
                    else if (atok.tokenId === TokenID.CloseBrace) {
                        this.rightCurlyCount++;
                    }
                    this.nextChar();
                    return atok;
                }
                else if ((this.ch >= LexCode_0) && (this.ch <= LexCode_9)) {
                    rtok = this.scanNumber();
                    if (rtok) {
                        return rtok;
                    }
                    else {
                        this.nextChar();
                        return staticTokens[TokenID.Error];
                    }
                }
                else switch (this.ch) {
                    // TAB
                    case LexCodeTAB:
                    case LexCodeVTAB:
                        if (!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos;
                        }
                        if (this.mode === LexMode.Line) {
                            do {
                                this.nextChar();
                            } while ((this.ch === LexCodeSpace) || (this.ch === 9));
                            var wsText = this.src.substring(this.startPos, this.pos);
                            return new WhitespaceToken(TokenID.Whitespace, wsText);
                        }
                        else {
                            this.interveningWhitespace = true;
                        }
                    // Newlines and BOM
                    case 0xFF: // UTF16 SEQUENCE
                    case 0xFE:
                    case 0xEF:    // UTF8 SEQUENCE
                    case 0xBB:
                    case 0xBF:
                    case LexCodeLS:
                    case LexCodePS:
                    case LexCodeNWL:
                    case LexCodeRET:
                        if (this.ch === LexCodeNWL) {
                            this.newLine();
                            if (this.mode === LexMode.Line) {
                                return staticTokens[TokenID.EndOfFile];
                            }
                        }
                        if (!this.interveningWhitespace) {
                            this.interveningWhitespacePos = this.pos;
                        }
                        this.nextChar();
                        this.tokenStart();
                        this.interveningWhitespace = true;
                        break;
                    case LexCodeDOT: {
                        if (this.peekCharAt(this.pos + 1) === LexCodeDOT) {
                            if (this.peekCharAt(this.pos + 2) === LexCodeDOT) {
                                this.advanceChar(3);
                                return staticTokens[TokenID.DotDotDot];
                            }
                            else {
                                this.nextChar();
                                return staticTokens[TokenID.Dot];
                            }
                        }
                        else {
                            this.nextChar();
                            rtok = this.scanFraction();
                            if (rtok) {
                                return rtok;
                            }
                            else {
                                return staticTokens[TokenID.Dot];
                            }
                        }
                        // break;
                    }
                    case LexCodeEQ:
                        if (this.peekCharAt(this.pos + 1) === LexCodeEQ) {
                            if (this.peekCharAt(this.pos + 2) === LexCodeEQ) {
                                this.advanceChar(3);
                                return staticTokens[TokenID.EqualsEqualsEquals];
                            }
                            else {
                                this.advanceChar(2);
                                return staticTokens[TokenID.EqualsEquals];
                            }
                        }
                        else if (this.peekCharAt(this.pos + 1) === LexCodeGT) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.EqualsGreaterThan];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Equals];
                        }
                    // break;
                    case LexCodeBNG:
                        if (this.peekCharAt(this.pos + 1) === LexCodeEQ) {
                            if (this.peekCharAt(this.pos + 2) === LexCodeEQ) {
                                this.advanceChar(3);
                                return staticTokens[TokenID.ExclamationEqualsEquals];
                            }
                            else {
                                this.advanceChar(2);
                                return staticTokens[TokenID.ExclamationEquals];
                            }
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Exclamation];
                        }
                    // break;
                    case LexCodePLS:
                        if (this.peekCharAt(this.pos + 1) === LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.PlusEquals];
                        }
                        else if (this.peekCharAt(this.pos + 1) === LexCodePLS) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.PlusPlus];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Plus];
                        }
                    // break;
                    case LexCodeMIN:
                        if (this.peekCharAt(this.pos + 1) === LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.MinusEquals];
                        }
                        else if (this.peekCharAt(this.pos + 1) === LexCodeMIN) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.MinusMinus];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Minus];
                        }
                    // break;
                    case LexCodeMUL:
                        if (this.peekCharAt(this.pos + 1) === LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.AsteriskEquals];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Asterisk];
                        }
                    // break;
                    case LexCodePCT:
                        if (this.peekCharAt(this.pos + 1) === LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.PercentEquals];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Percent];
                        }
                    // break;
                    case LexCodeLT:
                        if (this.peekCharAt(this.pos + 1) === LexCodeLT) {
                            if (this.peekCharAt(this.pos + 2) === LexCodeEQ) {
                                this.advanceChar(3);
                                return staticTokens[TokenID.LessThanLessThanEquals];
                            }
                            else {
                                this.advanceChar(2);
                                return staticTokens[TokenID.LessThanLessThan];
                            }
                        }
                        else if (this.peekCharAt(this.pos + 1) === LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.LessThanEquals];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.LessThan];
                        }
                    //  break;
                    case LexCodeGT:
                        if (this.peekCharAt(this.pos + 1) === LexCodeGT) {
                            if (this.peekCharAt(this.pos + 2) === LexCodeEQ) {
                                this.advanceChar(3);
                                return staticTokens[TokenID.GreaterThanGreaterThanEquals];
                            }
                            else if (this.peekCharAt(this.pos + 2) === LexCodeGT) {
                                if (this.peekCharAt(this.pos + 3) === LexCodeEQ) {
                                    this.advanceChar(4);
                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThanEquals];
                                }
                                else {
                                    this.advanceChar(3);
                                    return staticTokens[TokenID.GreaterThanGreaterThanGreaterThan];
                                }
                            }
                            else {
                                this.advanceChar(2);
                                return staticTokens[TokenID.GreaterThanGreaterThan];
                            }
                        }
                        else if (this.peekCharAt(this.pos + 1) === LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.GreaterThanEquals];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.GreaterThan];
                        }
                    // break;
                    case LexCodeXOR:
                        if (this.peekCharAt(this.pos + 1) === LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.CaretEquals];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Caret];
                        }
                    //  break;
                    case LexCodeBAR:
                        if (this.peekCharAt(this.pos + 1) === LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.BarEquals];
                        }
                        else if (this.peekCharAt(this.pos + 1) === LexCodeBAR) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.BarBar];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.Bar];
                        }
                    //  break;
                    case LexCodeAMP:
                        if (this.peekCharAt(this.pos + 1) === LexCodeEQ) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.AmpersandEquals];
                        }
                        else if (this.peekCharAt(this.pos + 1) === LexCodeAMP) {
                            this.advanceChar(2);
                            return staticTokens[TokenID.AmpersandAmpersand];
                        }
                        else {
                            this.nextChar();
                            return staticTokens[TokenID.And];
                        }
                    //  break;
                    default:
                        // Report error
                        this.reportScannerError("Invalid character");
                        this.nextChar();

                        continue start;
                }
            }
            return staticTokens[TokenID.EndOfFile];
        }

        private reportScannerError(message: string) {
            if (this.reportError) {
                this.reportError(message);
            }
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export class AssignScopeContext {
        constructor (public scopeChain: ScopeChain,
                     public typeFlow: TypeFlow,
                     public modDeclChain: ModuleDeclaration[]) {
        }
    }

    export function pushAssignScope(scope: SymbolScope,
        context: AssignScopeContext,
        type: Type,
        classType: Type,
        fnc: FuncDecl) {

        var chain = new ScopeChain(null, context.scopeChain, scope);
        chain.thisType = type;
        chain.classType = classType;
        chain.fnc = fnc;
        context.scopeChain = chain;
    }

    export function popAssignScope(context: AssignScopeContext) {
        context.scopeChain = context.scopeChain.previous;
    }

    export function instanceCompare(a: Symbol, b: Symbol) {
        if (((a === null) || (!a.isInstanceProperty()))) {
            return b;
        }
        else {
            return a;
        }
    }

    export function instanceFilterStop(s: Symbol) {
        return s.isInstanceProperty();
    }

    export class ScopeSearchFilter {

        constructor (public select: (a: Symbol, b: Symbol) =>Symbol,
                            public stop: (s: Symbol) =>bool) { }

        public result: Symbol = null;

        public reset() {
            this.result = null;
        }

        public update(b: Symbol): bool {
            this.result = this.select(this.result, b);
            if (this.result) {
                return this.stop(this.result);
            }
            else {
                return false;
            }
        }
    }

    export var instanceFilter = new ScopeSearchFilter(instanceCompare, instanceFilterStop);

    export function preAssignModuleScopes(ast: AST, context: AssignScopeContext) {
        var moduleDecl = <ModuleDeclaration>ast;
        var memberScope: SymbolTableScope = null;
        var aggScope: SymbolAggregateScope = null;

        if (moduleDecl.name && moduleDecl.mod) {
            moduleDecl.name.sym = moduleDecl.mod.symbol;
        }

        var mod = moduleDecl.mod;

        // We're likely here because of error recovery
        if (!mod) {
            return;
        }

        memberScope = new SymbolTableScope(mod.members, mod.ambientMembers, mod.enclosedTypes, mod.ambientEnclosedTypes, mod.symbol);
        mod.memberScope = memberScope;
        context.modDeclChain.push(moduleDecl);
        context.typeFlow.checker.currentModDecl = moduleDecl;
        aggScope = new SymbolAggregateScope(mod.symbol);
        aggScope.addParentScope(memberScope);
        aggScope.addParentScope(context.scopeChain.scope);
        pushAssignScope(aggScope, context, null, null, null);
        mod.containedScope = aggScope;
        if (mod.symbol) {
            context.typeFlow.addLocalsFromScope(mod.containedScope, mod.symbol, moduleDecl.vars, mod.members.privateMembers, true);
        }
    }

    export function preAssignClassScopes(ast: AST, context: AssignScopeContext) {
        var classDecl = <InterfaceDeclaration>ast;
        var memberScope: SymbolTableScope = null;
        var aggScope: SymbolAggregateScope = null;

        if (classDecl.name && classDecl.type) {
            classDecl.name.sym = classDecl.type.symbol;
        }

        var classType = ast.type;

        if (classType) {
            var classSym = classType.symbol;
            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(classType);

            aggScope = new SymbolAggregateScope(classType.symbol);
            aggScope.addParentScope(memberScope);
            aggScope.addParentScope(context.scopeChain.scope);

            classType.containedScope = aggScope;
            classType.memberScope = memberScope;

            var instanceType = classType.instanceType;
            memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(instanceType);
            instanceType.memberScope = memberScope;

            aggScope = new SymbolAggregateScope(instanceType.symbol);
            aggScope.addParentScope(context.scopeChain.scope);

            pushAssignScope(aggScope, context, instanceType, classType, null);
            instanceType.containedScope = aggScope;
        }
        else {
            ast.type = context.typeFlow.anyType;
        }
    }

    export function preAssignInterfaceScopes(ast: AST, context: AssignScopeContext) {
        var interfaceDecl = <InterfaceDeclaration>ast;
        var memberScope: SymbolTableScope = null;
        var aggScope: SymbolAggregateScope = null;

        if (interfaceDecl.name && interfaceDecl.type) {
            interfaceDecl.name.sym = interfaceDecl.type.symbol;
        }

        var interfaceType = ast.type;
        memberScope = <SymbolTableScope>context.typeFlow.checker.scopeOf(interfaceType);
        interfaceType.memberScope = memberScope;
        aggScope = new SymbolAggregateScope(interfaceType.symbol);
        aggScope.addParentScope(memberScope);
        aggScope.addParentScope(context.scopeChain.scope);
        pushAssignScope(aggScope, context, null, null, null);
        interfaceType.containedScope = aggScope;
    }

    export function preAssignWithScopes(ast: AST, context: AssignScopeContext) {
        var withStmt = <WithStatement>ast;
        var withType = withStmt.type;

        var members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
        var ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));

        withType = new Type();
        var withSymbol = new WithSymbol(withStmt.minChar, context.typeFlow.checker.locationInfo.fileName, withType, context.typeFlow.compilationSettings.optimizeModuleCodeGen);
        withType.members = members;
        withType.ambientMembers = ambientMembers;
        withType.symbol = withSymbol;
        withType.setHasImplementation();
        withStmt.type = withType;

        var withScope = new TypeScript.SymbolScopeBuilder(withType.members, withType.ambientMembers, null, null, context.scopeChain.scope, withType.symbol);

        pushAssignScope(withScope, context, null, null, null);
        withType.containedScope = withScope;
    }

    export function preAssignFuncDeclScopes(ast: AST, context: AssignScopeContext) {
        var funcDecl = <FuncDecl>ast;

        var container: Symbol = null;
        var localContainer: Symbol = null;
        if (funcDecl.type) {
            localContainer = ast.type.symbol;
        }

        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);
        var isInnerStatic = isStatic && context.scopeChain.fnc != null;
        // for inner static functions, use the parent's member scope, so local vars cannot be captured
        var parentScope = isInnerStatic ? context.scopeChain.fnc.type.memberScope : context.scopeChain.scope;

        // if this is not a method, but enclosed by class, use constructor as
        // the enclosing scope
        // REVIEW: Some twisted logic here - this needs to be cleaned up once old classes are removed
        //  - if it's a new class, always use the contained scope, since we initialize the constructor scope below
        if (context.scopeChain.thisType &&
            (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod))) {
            var instType = context.scopeChain.thisType;

            if (!(instType.typeFlags & TypeFlags.IsClass) && !hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
                if (!funcDecl.isMethod() || isStatic) {
                    parentScope = instType.constructorScope;
                }
                else {
                    // use constructor scope if a method as well
                    parentScope = instType.containedScope;
                }
            }
            else {
                if (context.scopeChain.previous.scope.container &&
                    context.scopeChain.previous.scope.container.declAST &&
                    context.scopeChain.previous.scope.container.declAST.nodeType === NodeType.FuncDecl &&
                    (<FuncDecl>context.scopeChain.previous.scope.container.declAST).isConstructor) {

                        // if the parent is the class constructor, use the constructor scope
                    parentScope = instType.constructorScope;
                }
                else if (isStatic && context.scopeChain.classType) {
                    parentScope = context.scopeChain.classType.containedScope;
                }
                else {
                    // else, use the contained scope
                    parentScope = instType.containedScope;
                }
            }
            container = instType.symbol;
        }
        else if (funcDecl.isConstructor && context.scopeChain.thisType) {
            // sets the container to the class type's symbol (which is shared by the instance type)
            container = context.scopeChain.thisType.symbol;
        }

        var fgSym: TypeSymbol = null;

        if (funcDecl.type === null || hasFlag(funcDecl.type.symbol.flags, SymbolFlags.TypeSetDuringScopeAssignment)) {
            if (context.scopeChain.fnc && context.scopeChain.fnc.type) {
                container = context.scopeChain.fnc.type.symbol;
            }

            var funcScope = null;
            var outerFnc: FuncDecl = context.scopeChain.fnc;
            var nameText = funcDecl.name ? funcDecl.name.actualText : null;

            if (isStatic) {
                // In the case of function-nested statics, no member list will have bee initialized for the function, so we need
                // to copy it over.  We don't set this by default because having a non-null member list will throw off assignment
                // compatibility tests
                if (outerFnc.type.members === null && container.getType().memberScope) {
                    outerFnc.type.members = (<SymbolScopeBuilder>(<TypeSymbol>container).type.memberScope).valueMembers;
                }
                funcScope = context.scopeChain.fnc.type.memberScope;
                outerFnc.innerStaticFuncs[outerFnc.innerStaticFuncs.length] = funcDecl;
            }
            else {
                funcScope = context.scopeChain.scope;
            }

            // REVIEW: We don't search for another sym for accessors to prevent us from
            // accidentally coalescing function signatures with the same name (E.g., a function
            // 'f' the outer scope and a setter 'f' in an object literal within that scope)
            if (nameText && nameText != "__missing" && !funcDecl.isAccessor()) {
                if (isStatic) {
                    fgSym = funcScope.findLocal(nameText, false, false);
                }
                else {
                    // REVIEW: This logic should be symmetric with preCollectClassTypes
                    fgSym = funcScope.findLocal(nameText, false, false);
                }
            }

            context.typeFlow.checker.createFunctionSignature(funcDecl, container,
                                                            funcScope, fgSym, fgSym === null);

            // it's a getter or setter for a class property                     
            if (!funcDecl.accessorSymbol && 
                (funcDecl.fncFlags & FncFlags.ClassMethod) &&
                container && 
                ((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || 
                    (fgSym && fgSym.isAccessor())) 
            {
                funcDecl.accessorSymbol = context.typeFlow.checker.createAccessorSymbol(funcDecl, fgSym, container.getType(), (funcDecl.isMethod() && isStatic), true, funcScope, container);
            }

            funcDecl.type.symbol.flags |= SymbolFlags.TypeSetDuringScopeAssignment;
        }

        // Set the symbol for functions and their overloads
        if (funcDecl.name && funcDecl.type) {
            funcDecl.name.sym = funcDecl.type.symbol;
        }

        // Keep track of the original scope type, because target typing might override
        // the "type" member. We need the original "Scope type" for completion list, etc.
        funcDecl.scopeType = funcDecl.type;

        // Overloads have no scope, so bail here
        if (funcDecl.isOverload) {
            return;
        }

        var funcTable = new StringHashTable();
        var funcMembers = new ScopedMembers(new DualStringHashTable(funcTable, new StringHashTable()));
        var ambientFuncTable = new StringHashTable();
        var ambientFuncMembers = new ScopedMembers(new DualStringHashTable(ambientFuncTable, new StringHashTable()));
        var funcStaticTable = new StringHashTable();
        var funcStaticMembers = new ScopedMembers(new DualStringHashTable(funcStaticTable, new StringHashTable()));
        var ambientFuncStaticTable = new StringHashTable();
        var ambientFuncStaticMembers = new ScopedMembers(new DualStringHashTable(ambientFuncStaticTable, new StringHashTable()));

        // REVIEW: Is it a problem that this is being set twice for properties and constructors?
        funcDecl.fileName = context.typeFlow.checker.locationInfo.fileName;

        var locals = new SymbolScopeBuilder(funcMembers, ambientFuncMembers, null, null, parentScope, localContainer);
        var statics = new SymbolScopeBuilder(funcStaticMembers, ambientFuncStaticMembers, null, null, parentScope, null);

        if (funcDecl.isConstructor && context.scopeChain.thisType) {
            context.scopeChain.thisType.constructorScope = locals;
        }

        // basically, there are two problems
        // - Above, for new classes, we were overwriting the constructor scope with the containing scope.  This caused constructor params to be
        // in scope everywhere
        // - Below, we're setting the contained scope table to the same table we were overwriting the constructor scope with, which we need to
        // fish lambda params, etc, out (see funcTable below)
        //
        // A good first approach to solving this would be to change addLocalsFromScope to take a scope instead of a table, and add to the
        // constructor scope as appropriate

        funcDecl.symbols = funcTable;

        if (!funcDecl.isSpecialFn()) {
            var group = funcDecl.type;
            var signature = funcDecl.signature;

            if (!funcDecl.isConstructor) {
                group.containedScope = locals;
                locals.container = group.symbol;

                group.memberScope = statics;
                statics.container = group.symbol;
            }
            funcDecl.enclosingFnc = context.scopeChain.fnc;
            group.enclosingType = isStatic ? context.scopeChain.classType : context.scopeChain.thisType;
            // for mapping when type checking
            fgSym = <TypeSymbol>ast.type.symbol;
            if (((funcDecl.fncFlags & FncFlags.Signature) === FncFlags.None) && funcDecl.vars) {
                context.typeFlow.addLocalsFromScope(locals, fgSym, funcDecl.vars,
                                                    funcTable, false);
                context.typeFlow.addLocalsFromScope(statics, fgSym, funcDecl.statics,
                                                    funcStaticTable, false);
            }
            if (signature.parameters) {
                var len = signature.parameters.length;
                for (var i = 0; i < len; i++) {
                    var paramSym: ParameterSymbol = signature.parameters[i];
                    context.typeFlow.checker.resolveTypeLink(locals,
                                                                paramSym.parameter.typeLink, true);
                }
            }
            context.typeFlow.checker.resolveTypeLink(locals, signature.returnType,
                                                        funcDecl.isSignature());
        }

        if (!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
            var thisType = (funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) ? context.scopeChain.thisType : null;
            pushAssignScope(locals, context, thisType, null, funcDecl);
        }

        if (funcDecl.name && hasFlag(funcDecl.fncFlags, FncFlags.IsFunctionExpression) && !funcDecl.isAccessor()) {
            // If the function is an expression, the name will not be visible in the enclosing scope.
            // Add the function symbol under its name to the local scope to allow for recursive calls.
            if (funcDecl.name.sym) {
                funcTable.add(funcDecl.name.actualText, funcDecl.name.sym);
            }
        }
    }

    export function preAssignCatchScopes(ast: AST, context: AssignScopeContext) {
        var catchBlock = <Catch>ast;
        if (catchBlock.param) {
            var catchTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable())); // REVIEW: Should we be allocating a public table instead of a private one?
            var catchLocals = new SymbolScopeBuilder(catchTable, null, null, null, context.scopeChain.scope,
                                                   context.scopeChain.scope.container);
            catchBlock.containedScope = catchLocals;
            pushAssignScope(catchLocals, context, context.scopeChain.thisType, context.scopeChain.classType, context.scopeChain.fnc);
        }
    }

    export function preAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {
        var context:AssignScopeContext = walker.state;
        var go = true;

        if (ast) {
            if (ast.nodeType === NodeType.List) {
                var list = <ASTList>ast;
                list.enclosingScope = context.scopeChain.scope;
            }
            else if (ast.nodeType === NodeType.ModuleDeclaration) {
                preAssignModuleScopes(ast, context);
            }
            else if (ast.nodeType === NodeType.ClassDeclaration) {
                preAssignClassScopes(ast, context);
            }
            else if (ast.nodeType === NodeType.InterfaceDeclaration) {
                preAssignInterfaceScopes(ast, context);
            }
            else if (ast.nodeType === NodeType.With) {
                preAssignWithScopes(ast, context);
            }
            else if (ast.nodeType === NodeType.FuncDecl) {
                preAssignFuncDeclScopes(ast, context);
            }
            else if (ast.nodeType === NodeType.Catch) {
                preAssignCatchScopes(ast, context);
            }
            else if (ast.nodeType === NodeType.TypeRef) {
                go = false;
            }
        }
        walker.options.goChildren = go;
        return ast;
    }

    export function postAssignScopes(ast: AST, parent: AST, walker: IAstWalker) {
        var context:AssignScopeContext = walker.state;
        var go = true;
        if (ast) {
            if (ast.nodeType === NodeType.ModuleDeclaration) {
                var prevModDecl = <ModuleDeclaration>ast;

                popAssignScope(context);

                context.modDeclChain.pop();
                if (context.modDeclChain.length >= 1) {
                    context.typeFlow.checker.currentModDecl = context.modDeclChain[context.modDeclChain.length - 1];
                }
            }
            else if (ast.nodeType === NodeType.ClassDeclaration) {
                popAssignScope(context);
            }
            else if (ast.nodeType === NodeType.InterfaceDeclaration) {
                popAssignScope(context);
            }
            else if (ast.nodeType === NodeType.With) {
                popAssignScope(context);
            }
            else if (ast.nodeType === NodeType.FuncDecl) {
                var funcDecl = <FuncDecl>ast;
                if ((!funcDecl.isConstructor || hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) && !funcDecl.isOverload) {
                    popAssignScope(context);
                }
            }
            else if (ast.nodeType === NodeType.Catch) {
                var catchBlock = <Catch>ast;
                if (catchBlock.param) {
                    popAssignScope(context);
                }
            }
            else {
                go = false;
            }
        }
        walker.options.goChildren = go;
        return ast;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class TypeCollectionContext {
        public script: Script = null;

        constructor (public scopeChain: ScopeChain, public checker: TypeChecker) {
        }
    }

    export function pushTypeCollectionScope(container: Symbol,
        valueMembers: ScopedMembers,
        ambientValueMembers: ScopedMembers,
        enclosedTypes: ScopedMembers,
        ambientEnclosedTypes: ScopedMembers,
        context: TypeCollectionContext,
        thisType: Type,
        classType: Type,
        moduleDecl: ModuleDeclaration) {
        var builder = new SymbolScopeBuilder(valueMembers, ambientValueMembers, enclosedTypes, ambientEnclosedTypes, null, container);
        var chain: ScopeChain = new ScopeChain(container, context.scopeChain, builder);
        chain.thisType = thisType;
        chain.classType = classType;
        chain.moduleDecl = moduleDecl;
        context.scopeChain = chain;
    }

    export function popTypeCollectionScope(context: TypeCollectionContext) {
        context.scopeChain = context.scopeChain.previous;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class Signature {
        public hasVariableArgList = false;
        public returnType: TypeLink;
        public parameters: ParameterSymbol[] = null;
        public declAST: FuncDecl = null;
        public typeCheckStatus = TypeCheckStatus.NotStarted;
        public nonOptionalParameterCount = 0;

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Signature {
            var result = new Signature();
            if (this.hasVariableArgList) {
                result.hasVariableArgList = true;
            }
            result.returnType = new TypeLink();
            if (this.returnType.type) {
                result.returnType.type =
                    this.returnType.type.specializeType(pattern, replacement, checker, false);
            }
            else {
                result.returnType.type = checker.anyType;
            }

            if (this.parameters) {
                result.parameters = [];
                for (var i = 0, len = this.parameters.length; i < len; i++) {
                    var oldSym:ParameterSymbol = this.parameters[i];
                    var paramDef = new ValueLocation();
                    var paramSym = new ParameterSymbol(oldSym.name, oldSym.location,
                                                     checker.locationInfo.fileName,
                                                     paramDef);

                    paramSym.declAST = this.declAST;
                    paramDef.symbol = paramSym;
                    paramDef.typeLink = new TypeLink();
                    result.parameters[i] = paramSym;
                    var oldType = oldSym.getType();
                    if (oldType) {
                        paramDef.typeLink.type = oldType.specializeType(pattern, replacement, checker, false);
                    }
                    else {
                        paramDef.typeLink.type = checker.anyType;
                    }
                }
            }
            result.nonOptionalParameterCount = this.nonOptionalParameterCount;
            result.declAST = this.declAST;

            return result;
        }

        public toString() {
            return this.toStringHelper(false, false, null);
        }

        public toStringHelper(shortform: bool, brackets: bool, scope: SymbolScope) {
            return this.toStringHelperEx(shortform, brackets, scope).toString();
        }

        public toStringHelperEx(shortform: bool, brackets: bool, scope: SymbolScope, prefix?: string = ""): MemberNameArray {
            var builder = new MemberNameArray();
            if (brackets) {
                builder.prefix =  prefix + "[";
            }
            else {
                builder.prefix = prefix + "(";
            }

            var paramLen = this.parameters.length;
            var len = this.hasVariableArgList ? paramLen - 1 : paramLen;
            for (var i = 0; i < len; i++) {
                builder.add(MemberName.create(this.parameters[i].name + (this.parameters[i].isOptional() ? "?" : "") + ": "));
                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));
                if (i < paramLen - 1) {
                    builder.add(MemberName.create(", "));
                }
            }

            if (this.hasVariableArgList) {
                builder.add(MemberName.create("..." + this.parameters[i].name + ": "));
                builder.add(this.parameters[i].getType().getScopedTypeNameEx(scope));
            }

            if (shortform) {
                if (brackets) {
                    builder.add(MemberName.create("] => "));
                }
                else {
                    builder.add(MemberName.create(") => "));
                }
            }
            else {
                if (brackets) {
                    builder.add(MemberName.create("]: "));
                }
                else {
                    builder.add(MemberName.create("): "));
                }
            }

            if (this.returnType.type) {
                 builder.add(this.returnType.type.getScopedTypeNameEx(scope));
            }
            else {
                builder.add(MemberName.create("any"));
            }
            return builder;
        }
    }

    export class SignatureGroup {
        public signatures: Signature[] = [];
        public hasImplementation = true;
        public definitionSignature: Signature = null;
        public hasBeenTypechecked = false;
        public flags: SignatureFlags = SignatureFlags.None;
        public addSignature(signature: Signature) {
            if (this.signatures == null) {
                this.signatures = [];
            }
            this.signatures[this.signatures.length] = signature;
            
            // REVIEW: duplicates should be found within createFunctionSignature,
            // so we won't check for them here
            if (signature.declAST &&
                !signature.declAST.isOverload &&
                !signature.declAST.isSignature() && 
                !hasFlag(signature.declAST.fncFlags, FncFlags.Ambient) &&
                !hasFlag(signature.declAST.fncFlags, FncFlags.Signature)) {
                this.definitionSignature = signature;
            }
        }

        public toString() { return this.signatures.toString(); }
        public toStrings(prefix: string, shortform: bool, scope: SymbolScope, getPrettyTypeName? : bool, useSignature? : Signature) {
            var result : MemberName[] = [];  
            var len = this.signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }

            var getMemberNameOfSignature = (signature: Signature) => {
                if (this.flags & SignatureFlags.IsIndexer) {
                    return signature.toStringHelperEx(shortform, true, scope);
                }
                else {
                    return signature.toStringHelperEx(shortform, false, scope, prefix);
                }
            }

            if (useSignature) {
                result.push(getMemberNameOfSignature(useSignature));
            } else {
                for (var i = 0; i < len; i++) {
                    // the definition signature shouldn't be printed if there are overloads
                    if (len > 1 && this.signatures[i] == this.definitionSignature) {
                        continue;
                    }

                    result.push(getMemberNameOfSignature(this.signatures[i]));
                    if (getPrettyTypeName) {
                        break;
                    }
                }
            }

            if (getPrettyTypeName && len > 1) {
                var lastMemberName = <MemberNameArray>result[result.length - 1];
                var overloadString = " (+ " + ((this.definitionSignature != null) ? len - 2 : len - 1) + " overload(s))";
                lastMemberName.add(MemberName.create(overloadString));
            }

            return result;
        }

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): SignatureGroup {
            var result = new SignatureGroup();
            if (this.signatures) {
                for (var i = 0, len = this.signatures.length; i < len; i++) {
                    result.addSignature(this.signatures[i].specializeType(pattern, replacement, checker));
                }
            }
            return result;
        }

        // verifies that signatures are
        //  - unique within a given group
        //  - compatible with the declaration signature
        public verifySignatures(checker: TypeChecker) {

            var len = 0;
            
            // TODO: verify no signature pair with identical parameters
            if (this.signatures && ((len = this.signatures.length) > 0)) {
                
                for (var i = 0; i < len; i++) {
                    
                    for (var j = i + 1; j < len; j++) {
                        // next check for equivalence between overloads - no two can be exactly the same                     
                        if (this.signatures[i].declAST && this.signatures[j].declAST &&
                            (hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Signature) && hasFlag(this.signatures[j].declAST.fncFlags, FncFlags.Signature)) &&
                            checker.signaturesAreIdentical(this.signatures[i], this.signatures[j])) {
                            checker.errorReporter.simpleError(this.signatures[i].declAST, (this.signatures[i].declAST && this.signatures[i].declAST.name) ? "Signature for '" + this.signatures[i].declAST.name.actualText + "' is duplicated" :"Signature is duplicated");
                        }
                    }
                    
                    // finally, ensure that the definition is assignable to each signature
                    if (this.definitionSignature) {
                        if (!checker.signatureIsAssignableToTarget(this.definitionSignature, this.signatures[i])) {
                            checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload signature is not compatible with function definition");
                        }
                    }
                }
            }
        }

        public typeCheck(checker: TypeChecker, ast: AST, hasConstruct:bool) {
            
            if (this.hasBeenTypechecked) {
                return;
            }
            
            // set here to prevent us from recursively invoking typeCheck again
            this.hasBeenTypechecked = true;
            
            var len = 0;
            
            if (this.signatures && ((len = this.signatures.length) > 0)) {
                
                // first, typecheck each signature
                for (var i = 0; i < len; i++) {

                    if (!hasConstruct && !this.definitionSignature && this.signatures[i].declAST && this.signatures[i].declAST.isOverload && !hasFlag(this.signatures[i].declAST.fncFlags, FncFlags.Ambient)) {
                        checker.errorReporter.simpleError(this.signatures[i].declAST, "Overload declaration lacks definition");
                    }

                    // If we're typechecking a constructor via one of its overloads, ensure that the outer class is typechecked, since we need to validate its inheritance properties
                    // to properly check that 'super' is being used correctly
                    if (this.signatures[i].declAST && this.signatures[i].declAST.isConstructor && this.signatures[i].declAST.classDecl && this.signatures[i].declAST.classDecl.type.symbol.typeCheckStatus == TypeCheckStatus.NotStarted) {
                        checker.typeFlow.typeCheck(this.signatures[i].declAST.classDecl);
                    }

                    checker.typeFlow.typeCheck(this.signatures[i].declAST);
                }

                this.verifySignatures(checker);
            }
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export enum TypeCheckStatus {
        NotStarted,
        Started,
        Finished,
    }

    // For lexically-scoped constructs
    export function aLexicallyEnclosesB(a: Symbol, b: Symbol) {
        if (a.declAST && b && b.declAST && a.declAST.nodeType === NodeType.FuncDecl) {
            return a.declAST.minChar <= b.declAST.minChar && a.declAST.limChar >= b.declAST.limChar;
        }
        else {
            return false;
        }
    }

    export function aEnclosesB(a: Symbol, b: Symbol) {
        while (a.container) {
            if (a === b || aLexicallyEnclosesB(a.container, b)) {
                return true;
            }
            a = a.container;
        }
        return false;
    }

    export interface PhasedTypecheckObject {
        typeCheckStatus: TypeCheckStatus;
    }

    export class Symbol {
        public bound = false;
        public container: Symbol;
        public instanceScope(): SymbolScope { return null; }
        public isVariable() { return false; }
        public isMember() { return false; }
        public isInferenceSymbol() { return false; }
        public isWith() { return false; }
        public writeable() { return false; }
        public isType(): bool { return false; }
        public getType(): Type { return null; }
        public flags: SymbolFlags = SymbolFlags.None;
        public refs: Identifier[];
        public isAccessor() { return false; }
        public isObjectLitField = false;

        public declAST: AST = null;
        public declModule: ModuleDeclaration = null;  // if child of module, this is the module that declared it

        public passSymbolCreated: number = CompilerDiagnostics.analysisPass;

        constructor(public name: string,
                    public location: number,
                    public length: number,
                    public fileName: string) {
        }

        public isInstanceProperty() {
            return hasFlag(this.flags, SymbolFlags.Property) && (!hasFlag(this.flags, SymbolFlags.ModuleMember));
        }

        public getTypeName(scope: SymbolScope): string {
            return this.getTypeNameEx(scope).toString();
        }
        
        public getTypeNameEx(scope: SymbolScope): MemberName {
            return MemberName.create(this.toString());
        }

        public getOptionalNameString() {
            return hasFlag(this.flags, SymbolFlags.Optional) ? "?" : "";
        }

        public pathToRoot() {
            var path: Symbol[] = [];
            var node = this;
            while (node && (node.name != globalId)) {
                path[path.length] = node;
                node = node.container;
            }
            return path;
        }

        public findCommonAncestorPath(b: Symbol): Symbol[] {
            if (this.container === null) {
                return [];
            }
            var aPath = this.container.pathToRoot();
            var bPath: Symbol[];
            if (b) {
                bPath = b.pathToRoot();
            }
            else {
                bPath = [];
            }
            var commonNodeIndex = -1;
            for (var i = 0, aLen = aPath.length; i < aLen; i++) {
                var aNode = aPath[i];
                for (var j = 0, bLen = bPath.length; j < bLen; j++) {
                    var bNode = bPath[j];
                    if (aNode === bNode) {
                        commonNodeIndex = i;
                        break;
                    }
                }
                if (commonNodeIndex >= 0) {
                    break;
                }
            }
            if (commonNodeIndex >= 0) {
                return aPath.slice(0, commonNodeIndex);
            }
            else {
                return aPath;
            }
        }

        // Gets the pretty Name for the symbol withing the scope
        public getPrettyName(scopeSymbol: Symbol) {
            return this.name;
        }

        public scopeRelativeName(scope: SymbolScope): string {
            if (scope === null) {
                return this.getPrettyName(null) + this.getOptionalNameString();
            }
            var lca = this.findCommonAncestorPath(scope.container);
            var builder = "";
            for (var i = 0, len = lca.length; i < len; i++) {
                var prettyName = lca[i].getPrettyName(i === len - 1 ? scope.container : lca[i + 1]);
                builder = prettyName + "." + builder;
            }
            builder += this.getPrettyName(len === 0 ? scope.container : lca[0]) + this.getOptionalNameString();
            return builder;
        }

        public fullName(scope?: SymbolScope): string {
            var scopeSymbol = !scope ? null : scope.container;
            var scopeRootPath: Symbol[] = !scopeSymbol ? [] : scopeSymbol.pathToRoot();
            var dynamicModuleRoot: Symbol = null;
            if (scopeRootPath.length > 0 && scopeRootPath[scopeRootPath.length - 1].declAST &&
                scopeRootPath[scopeRootPath.length - 1].declAST.nodeType === NodeType.ModuleDeclaration &&
                (<ModuleDeclaration>scopeRootPath[scopeRootPath.length - 1].declAST).isWholeFile()) {
                dynamicModuleRoot = scopeRootPath[scopeRootPath.length - 1];
            }
            var builder = this.getPrettyName(scopeSymbol);
            var ancestor = this.container;
            while (ancestor && (ancestor.name != globalId) && ancestor != dynamicModuleRoot) {
                builder = ancestor.getPrettyName(scopeSymbol) + "." + builder;
                ancestor = ancestor.container;
            }
            return builder;
        }

        public isExternallyVisible(checker: TypeChecker) {
            // Global module is not hidden
            if (this === checker.gloMod) {
                return true;
            }

            // private symbol
            if (hasFlag(this.flags, SymbolFlags.Private)) {
                return false;
            }

            // If the current container is not exported
            // If its in global - it is visible, otherwise it isn't
            if (!hasFlag(this.flags, SymbolFlags.Exported)) {
                return this.container === checker.gloMod;
            }

            // It is visible if its container is visible too
            return this.container.isExternallyVisible(checker);
        }

        public visible(scope: SymbolScope, checker: TypeChecker) {
            if (checker === null || this.container === checker.gloMod) {
                return true;
            }

            if (hasFlag(this.flags, SymbolFlags.ModuleMember)) {

                if (hasFlag(this.flags, SymbolFlags.Exported)) {
                    if (!hasFlag(this.flags, SymbolFlags.Private)) {
                        return true;
                    }
                    else {
                        return aEnclosesB(this, scope.container);
                    }
                }
                else {
                    // REVIEW:
                    // Note that in the scope-assignment and binding phases,
                    // currentModDecl will point to the "master" module decl,
                    // and not necessarily the one that the symbol in question
                    // was declared in.
                    // That's ok - there's no harm done in attributing the symbol
                    // to the master mod decl in either of those phases, so long
                    // as we reference the actual module fragment of declaration
                    // during typecheck.  Doing this also prevents us from printing
                    // multiple error messages if the symbol is not visible.
                    return checker && (checker.currentModDecl === this.declModule) ||
                                                (checker.currentModDecl &&
                                                    checker.currentModDecl.mod &&
                                                    checker.currentModDecl.mod.symbol &&
                                                    this.declModule &&
                                                    this.declModule.mod &&
                                                    this.declModule.mod.symbol &&
                                                    aEnclosesB(checker.currentModDecl.mod.symbol, this.declModule.mod.symbol));
                }
            }
            else {
                // field or method
                var isFunction = this.declAST && this.declAST.nodeType === NodeType.FuncDecl;
                var isMethod = isFunction && (<FuncDecl>this.declAST).isMethod();
                var isStaticFunction = isFunction && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Static)
                var isPrivateMethod = isMethod && hasFlag((<FuncDecl>this.declAST).fncFlags, FncFlags.Private);
                var isAlias = this.isType() && (<TypeSymbol>this).aliasLink;

                if (this.isMember() || isMethod || isStaticFunction || isAlias) {
                    if (hasFlag(this.flags, SymbolFlags.Private) || isPrivateMethod) {
                        if (scope.container === null && this.container != scope.container) {
                            return false; // it's an inner member being accessed by the global scope
                        }
                        else {
                            return this.container === null ? true : aEnclosesB(scope.container, this.container);
                        }
                    }
                    else {
                        return true;
                    }
                }
                else if (this.container) {
                    return aEnclosesB(this, scope.container);
                }
                else {
                    return true;
                }
            }
        }

        public addRef(identifier: Identifier) {
            if (!this.refs) {
                this.refs = [];
            }
            this.refs[this.refs.length] = identifier;
        }

        public toString() {
            if (this.name) {
                return this.name;
            }
            else {
                return "_anonymous";
            }
        }

        public print(outfile) {
            outfile.Write(this.toString());
        }

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {
            throw new Error("please implement in derived class");
        }

        public setType(type: Type) {
            throw new Error("please implement in derived class");
        }

        public kind(): SymbolKind {
            throw new Error("please implement in derived class");
        }

        public getInterfaceDeclFromSymbol(checker: TypeChecker) {
            if (this.declAST != null) {
                if (this.declAST.nodeType === NodeType.InterfaceDeclaration) {
                    return <InterfaceDeclaration>this.declAST;
                } else if (this.container != null && this.container != checker.gloMod && this.container.declAST.nodeType === NodeType.InterfaceDeclaration) {
                    return <InterfaceDeclaration>this.container.declAST;
                }
            }

            return null;
        }

        public getVarDeclFromSymbol() {
            if (this.declAST != null && this.declAST.nodeType === NodeType.VarDecl) {
                return <VarDecl>this.declAST;
            }

            return null;
        }

        public getDocComments() : Comment[] {
            if (this.declAST != null) {
                return this.declAST.getDocComments();
            }

            return [];
        }

        public isStatic() {
            return hasFlag(this.flags, SymbolFlags.Static);
        }
    }

    export class ValueLocation {
        public symbol: Symbol;
        public typeLink: TypeLink;
    }

    export class InferenceSymbol extends Symbol {
        constructor (name: string, location: number, length: number, fileName: string) {
            super(name, location, length, fileName);
        }

        public typeCheckStatus = TypeCheckStatus.NotStarted;
        public isInferenceSymbol() { return true; }
        public transferVarFlags(varFlags: VarFlags) {
            if (hasFlag(varFlags, VarFlags.Ambient)) {
                this.flags |= SymbolFlags.Ambient;
            }
            if (hasFlag(varFlags, VarFlags.Constant)) {
                this.flags |= SymbolFlags.Constant;
            }
            if (hasFlag(varFlags, VarFlags.Static)) {
                this.flags |= SymbolFlags.Static;
            }
            if (hasFlag(varFlags, VarFlags.Property)) {
                this.flags |= SymbolFlags.Property;
            }
            if (hasFlag(varFlags, VarFlags.Private)) {
                this.flags |= SymbolFlags.Private;
            }
            if (hasFlag(varFlags, VarFlags.Public)) {
                this.flags |= SymbolFlags.Public;
            }
            if (hasFlag(varFlags, VarFlags.Readonly)) {
                this.flags |= SymbolFlags.Readonly;
            }
            if (hasFlag(varFlags, VarFlags.Exported)) {
                this.flags |= SymbolFlags.Exported;
            }
        }
    }

    export class TypeSymbol extends InferenceSymbol {
        public additionalLocations: number[];
        public expansions: Type[] = []; // For types that may be "split", keep track of the subsequent definitions
        public expansionsDeclAST: AST[] = [];
        public isDynamic = false;
        public onlyReferencedAsTypeRef: bool;

        constructor(locName: string, location: number, length: number, fileName: string, public type: Type, optimizeModuleCodeGen: bool) {
            super(locName, location, length, fileName);
            this.prettyName = this.name;
            this.onlyReferencedAsTypeRef = optimizeModuleCodeGen;
        }

        public addLocation(loc: number) {
            if (!this.additionalLocations) {
                this.additionalLocations = [];
            }
            this.additionalLocations[this.additionalLocations.length] = loc;
        }
        public isMethod = false;
        public aliasLink:ImportDeclaration = null;
        public kind() { return SymbolKind.Type; }
        public isType(): bool { return true; }
        public getType() { return this.type; }
        public prettyName: string;

        public getTypeNameEx(scope: SymbolScope) {
            return this.type.getMemberTypeNameEx(this.name ? this.name + this.getOptionalNameString() : "", false, false, scope);
        }

        public instanceScope(): SymbolScope {
            // Don't use the constructor scope for a class body or methods - use the contained scope
            if (!(this.type.typeFlags & TypeFlags.IsClass) && this.type.isClass()) {
                return this.type.instanceType.constructorScope;
            }
            else {
                return this.type.containedScope;
            }
        }
        // corresponding instance type if this is a class
        public instanceType: Type;

        public toString() {
            var result = this.type.getTypeName();
            if (this.name) {
                result = this.name + ":" + result;
            }
            return result;
        }

        public isClass() { return this.instanceType != null; }
        public isFunction() { return this.declAST != null && this.declAST.nodeType === NodeType.FuncDecl; }

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {
            if (this.type === pattern) {
                return replacement.symbol;
            }
            else {
                var replType = this.type.specializeType(pattern, replacement, checker, false);
                if (replType != this.type) {
                    var result = new TypeSymbol(this.name, -1, 0, unknownLocationInfo.fileName, replType, checker.compilationSettings.optimizeModuleCodeGen);
                    return result;
                }
                else {
                    return this;
                }
            }
        }

        // Gets the pretty name of the symbol with respect to symbol of the scope (scopeSymbol)
        // searchTillRoot specifies if the name need to searched in the root path of the scope
        public getPrettyName(scopeSymbol: Symbol) {
            if (!!scopeSymbol && isQuoted(this.prettyName) && this.type.isModuleType()) {
                // Its a dynamic module - and need to be specialized with the scope
                // Check in exported module members in each scope
                var symbolPath = scopeSymbol.pathToRoot();
                var prettyName = this.getPrettyNameOfDynamicModule(symbolPath);
                if (prettyName != null) {
                    return prettyName.name;
                }
            }

            return this.prettyName;
        }

        public getPrettyNameOfDynamicModule(scopeSymbolPath: Symbol[]) {
            var scopeSymbolPathLength = scopeSymbolPath.length;
            var externalSymbol: { name: string; symbol: Symbol; } = null;
            var moduleType: ModuleType;

            if (scopeSymbolPath.length > 0 &&
                scopeSymbolPath[scopeSymbolPathLength - 1].getType().isModuleType() &&
                (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 1]).isDynamic) {

                // Check if submodule is dynamic
                if (scopeSymbolPathLength > 1 &&
                    scopeSymbolPath[scopeSymbolPathLength - 2].getType().isModuleType() &&
                    (<TypeSymbol>scopeSymbolPath[scopeSymbolPathLength - 2]).isDynamic) {
                    moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 2].getType();
                    externalSymbol = moduleType.findDynamicModuleName(this.type);

                }

                if (externalSymbol === null) {
                    // Check in this module
                    moduleType = <ModuleType>scopeSymbolPath[scopeSymbolPathLength - 1].getType();
                    externalSymbol = moduleType.findDynamicModuleName(this.type);
                }
            }

            return externalSymbol;
        }

        public getDocComments(): Comment[]{
            var comments : Comment[] = [];
            if (this.declAST != null) {
                comments = comments.concat(this.declAST.getDocComments());
            }

            for (var i = 0; i < this.expansionsDeclAST.length; i++) {
                comments = comments.concat(this.expansionsDeclAST[i].getDocComments());
            }

            return comments;
        }
    }

    export class WithSymbol extends TypeSymbol {
        constructor(location: number, fileName: string, withType: Type, optimizeModuleCodeGen: bool) {
            super("with", location, 4, fileName, withType, optimizeModuleCodeGen);
        }
        public isWith() { return true; }
    }

    export class FieldSymbol extends InferenceSymbol {
        public name: string;
        public location: number;

        constructor (name: string, location: number, fileName: string, public canWrite: bool,
                      public field: ValueLocation) {

            super(name, location, name.length, fileName);
            this.name = name;
            this.location = location;
        }
        public kind() { return SymbolKind.Field; }
        public writeable() { return this.isAccessor() ? this.setter != null : this.canWrite; }
        public getType() { return this.field.typeLink.type; }
        public getTypeNameEx(scope: SymbolScope) {
            return MemberName.create(this.field.typeLink.type ? this.field.typeLink.type.getScopedTypeNameEx(scope) : MemberName.create("any"), this.name + this.getOptionalNameString() + ": ", "");
        }

        public isMember() { return true; }
        public setType(type: Type) {
            this.field.typeLink.type = type;
        }

        public getter: TypeSymbol = null;
        public setter: TypeSymbol = null;
        public hasBeenEmitted = false; // since getters and setters are emitted together, need to track if one has been emitted

        public isAccessor() { return this.getter != null || this.setter != null; }

        public isVariable() { return true; }
        public toString() { return this.getTypeNameEx(null).toString(); }
        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {
            var rType = this.field.typeLink.type.specializeType(pattern, replacement, checker, false);
            if (rType != this.field.typeLink.type) {
                var fieldDef = new ValueLocation();
                var result = new FieldSymbol(this.name, 0, checker.locationInfo.fileName,
                                           this.canWrite, fieldDef);
                result.flags = this.flags;
                fieldDef.symbol = result;
                fieldDef.typeLink = new TypeLink();
                result.setType(rType);
                result.typeCheckStatus = TypeCheckStatus.Finished;
                return result;
            }
            else {
                return this;
            }
        }

        public getDocComments(): Comment[] {
            if (this.getter != null || this.setter != null) {
                var comments : Comment[] = [];
                if (this.getter != null) {
                    comments = comments.concat(this.getter.getDocComments());
                }
                if (this.setter != null) {
                    comments = comments.concat(this.setter.getDocComments());
                }
                return comments;
            }
            else if (this.declAST != null) {
                return this.declAST.getDocComments();
            }

            return [];
        }

    }

    export class ParameterSymbol extends InferenceSymbol {
        public name: string;
        public location: number;
        private paramDocComment: string = null;
        public funcDecl: AST = null;
        
        constructor (name: string, location: number, fileName: string,
                          public parameter: ValueLocation) {
            super(name, location, name.length, fileName);

            this.name = name;
            this.location = location;
        }
        public kind() { return SymbolKind.Parameter; }
        public writeable() { return true; }
        public getType() { return this.parameter.typeLink.type; }
        public setType(type: Type) {
            this.parameter.typeLink.type = type;
        }
        public isVariable() { return true; }
        public argsOffset = (-1);
        public isOptional() {
            if (this.parameter && this.parameter.symbol && this.parameter.symbol.declAST) {
                return (<ArgDecl>this.parameter.symbol.declAST).isOptional;
            }
            else {
                return false;
            }
        }

        public getTypeNameEx(scope: SymbolScope) {
            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + (this.isOptional() ? "?" : "") + ": ", "");
        }

        public toString() { return this.getTypeNameEx(null).toString(); }

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker): Symbol {
            var rType = this.parameter.typeLink.type.specializeType(pattern, replacement, checker, false);
            if (this.parameter.typeLink.type != rType) {
                var paramDef = new ValueLocation();
                var result = new ParameterSymbol(this.name, 0, checker.locationInfo.fileName,
                                               paramDef);
                paramDef.symbol = result;
                result.setType(rType);
                return result;
            }
            else {
                return this;
            }
        }

        public getParameterDocComments() {
            if (!this.paramDocComment) {
                var parameterComments: string[] = [];
                if (this.funcDecl) {
                    var fncDocComments = this.funcDecl.getDocComments();
                    var paramComment = Comment.getParameterDocCommentText(this.name, fncDocComments);
                    if (paramComment != "") {
                        parameterComments.push(paramComment);
                    }
                }
                var docComments = TypeScript.Comment.getDocCommentText(this.getDocComments());
                if (docComments != "") {
                    parameterComments.push(docComments);
                }
                
                this.paramDocComment = parameterComments.join("\n");
            }

            return this.paramDocComment;
        }

        public fullName(): string {
            return this.name;
        }
    }

    export class VariableSymbol extends InferenceSymbol {
        constructor (name: string, location: number, fileName: string, public variable: ValueLocation) {
            super(name, location, name.length, fileName);
        }

        public kind() { return SymbolKind.Variable; }
        public writeable() { return true; }
        public getType() { return this.variable.typeLink.type; }
        public getTypeNameEx(scope: SymbolScope) {
            return MemberName.create(this.getType().getScopedTypeNameEx(scope), this.name + ": ", "");
        }

        public setType(type: Type) {
            this.variable.typeLink.type = type;
        }
        public isVariable() { return true; }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    // private members are private to the scope
    // public members are public to the scope
    export class ScopedMembers {

        public allMembers: IHashTable;
        public publicMembers: IHashTable;
        public privateMembers: IHashTable;

        constructor (public dualMembers: DualStringHashTable) { 
            this.allMembers = this.dualMembers;
            this.publicMembers = this.dualMembers.primaryTable;
            this.privateMembers = this.dualMembers.secondaryTable;
        }

        // add a public member
        public addPublicMember(key: string, data) { return this.dualMembers.primaryTable.add(key, data); }

        // add a private member 
        public addPrivateMember(key: string, data) { return this.dualMembers.secondaryTable.add(key, data); }
    }

    export enum SymbolKind {
        None,
        Type,
        Field,
        Parameter,
        Variable,
    }

    export class SymbolScope {
        constructor (public container: Symbol) { }
        public printLabel() { return "base"; }
        public getAllSymbolNames(members: bool): string[]{
            return ["please", "implement", "in", "derived", "classes"];
        }
        public getAllTypeSymbolNames(members: bool): string[]{
            return ["please", "implement", "in", "derived", "classes"];
        }
        public getAllValueSymbolNames(members: bool): string[]{
            return ["please", "implement", "in", "derived", "classes"];
        }
        // advanced search using a filter
        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool): Symbol { return null; }
        // find in this immediate scope
        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }
        // find in value namespace 
        public find(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }
        // find symbol that supplies an implementation
        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }
        // restrict the search to ambient values
        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol { return null; }
        public print(outfile: ITextWriter) {
            if (this.container) {
                outfile.WriteLine(this.printLabel() + " scope with container: " + this.container.name + "...");
            }
            else {
                outfile.WriteLine(this.printLabel() + " scope...");
            }
        }

        public enter(container: Symbol, ast: AST, symbol: Symbol, errorReporter: ErrorReporter, publicOnly: bool,
            typespace: bool, ambient: bool): void {
            throw new Error("please implement in derived class");
        }

        public getTable(): IHashTable {
            throw new Error("please implement in derived class");
        }
    }

    function symbolCanBeUsed(sym: Symbol, publicOnly) {
        return publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||
                            (sym.declAST && sym.declAST.nodeType === NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))
                          : true;
    }

    export class SymbolAggregateScope extends SymbolScope {
        public printLabel() { return "agg"; }
        public valueCache: IHashTable = null;
        public valueImplCache: IHashTable = null;
        public valueAmbientCache: IHashTable = null;
        public typeCache: IHashTable = null;
        public typeImplCache: IHashTable = null;
        public typeAmbientCache: IHashTable = null;
        public parents: SymbolScope[] = null;
        public container: Symbol;

        constructor (container: Symbol) {
            super(container);
            this.container = container;
        }

        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {
            if (this.parents) {
                for (var i = 0; i < this.parents.length; i++) {
                    var sym = this.parents[i].search(filter, name, publicOnly, typespace);
                    if (sym) {
                        if (filter.update(sym)) {
                            return sym;
                        }
                    }
                }
            }
            return filter.result;
        }

        public getAllSymbolNames(members: bool): string[]{
            var result: string[] = [];
            if (this.parents) {
                for (var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        }

        public getAllTypeSymbolNames(members: bool): string[]{
            var result: string[] = [];
            if (this.parents) {
                for (var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllTypeSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        }

        public getAllValueSymbolNames(members: bool): string[]{
            var result: string[] = [];
            if (this.parents) {
                for (var i = 0; i < this.parents.length; i++) {
                    var parentResult = this.parents[i].getAllValueSymbolNames(members);
                    if (parentResult) {
                        result = result.concat(parentResult);
                    }
                }
            }
            return result;
        }

        public print(outfile: ITextWriter) {
            super.print(outfile);
            if (this.parents) {
                for (var i = 0; i < this.parents.length; i++) {
                    this.parents[i].print(outfile);
                }
            }
        }

        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var i = 0;
            var implCache = this.valueImplCache;

            if (typespace) {
                implCache = this.typeImplCache;
            }
            if (implCache &&
                ((sym = implCache.lookup(name)) != null) &&
                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||
                                        (sym.declAST && sym.declAST.nodeType === NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))
                                        : true)) {
                return sym;
            }
            if (this.parents) {
                for (i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].findImplementation(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (implCache) {
                if (typespace) {
                    this.typeImplCache = new StringHashTable();
                    implCache = this.typeImplCache;
                }
                else {
                    this.valueImplCache = new StringHashTable();
                    implCache = this.valueImplCache;
                }
            }
            implCache.add(name, sym);
            return sym;
        }

        public find(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var i = 0;
            var cache = this.valueCache;

            if (typespace) {
                cache = this.typeCache;
            }
            if (cache &&
                ((sym = cache.lookup(name)) != null) &&
                (publicOnly ? !(hasFlag(sym.flags, SymbolFlags.Private) ||
                                        (sym.declAST && sym.declAST.nodeType === NodeType.FuncDecl && hasFlag((<FuncDecl>sym.declAST).fncFlags, FncFlags.Private)))
                                        : true)) {
                return sym;
            }
            if (this.parents) {
                for (i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].find(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (cache === null) {
                if (typespace) {
                    this.typeCache = new StringHashTable();
                    cache = this.typeCache;
                }
                else {
                    this.valueCache = new StringHashTable();
                    cache = this.valueCache;
                }
            }
            cache.add(name, sym);
            return sym;
        }

        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var i = 0;
            var cache = this.valueAmbientCache;
            if (typespace) {
                cache = this.typeAmbientCache;
            }
            if (cache && ((sym = cache.lookup(name)) != null)) {
                return sym;
            }
            if (this.parents) {
                for (i = 0; i < this.parents.length; i++) {
                    sym = this.parents[i].findAmbient(name, publicOnly, typespace);
                    if (sym) {
                        break;
                    }
                }
            }
            if (cache === null) {
                if (typespace) {
                    this.typeAmbientCache = new StringHashTable();
                    cache = this.typeAmbientCache;
                }
                else {
                    this.valueAmbientCache = new StringHashTable();
                    cache = this.valueAmbientCache;
                }
            }
            cache.add(name, sym);
            return sym;
        }

        public addParentScope(parent: SymbolScope): void {
            if (this.parents === null) {
                this.parents = [];
            }
            this.parents[this.parents.length] = parent;
        }
    }

    export class SymbolTableScope extends SymbolScope {
        public container: Symbol;

        constructor(public valueMembers: ScopedMembers,
                            public ambientValueMembers: ScopedMembers,
                            public enclosedTypes: ScopedMembers,
                            public ambientEnclosedTypes: ScopedMembers,
                            container: Symbol)
        {
            super(container);
            this.container = container;
        }

        public printLabel() { return "table"; }

        public getAllSymbolNames(members: bool): string[]{
            var result = this.getAllTypeSymbolNames(members);

            return result.concat(this.getAllValueSymbolNames(members));
        }

        public getAllTypeSymbolNames(members: bool): string[]{
            var result = [];
            if (this.ambientEnclosedTypes) {
                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());
            }
            if (this.enclosedTypes) {
                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());
            }
            return result;
        }

        public getAllValueSymbolNames(members: bool): string[]{
            var result = [];
            if (this.ambientValueMembers) {
                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());
            }
            if (this.valueMembers) {
                result = result.concat(this.valueMembers.allMembers.getAllKeys());
            }
            return result;
        }

        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {
            var sym = this.find(name, publicOnly, typespace);
            filter.update(sym);
            return filter.result;
        }

        public find(name: string, publicOnly: bool, typespace: bool): Symbol {
            var table: IHashTable = null;
            var ambientTable: IHashTable = null;

            if (typespace) {
                table = (this.enclosedTypes === null) ? null :
                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes === null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            else {
                table = (this.valueMembers === null) ? null :
                                publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
                ambientTable = (this.ambientValueMembers === null) ? null :
                                    publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            }
            var s: Symbol;
            
            if (ambientTable) {
                s = ambientTable.lookup(name);
                if (s) { return s; }
            }
            if (table) {
                s = table.lookup(name);
                if (s) { return s; }
            }

            return null;
        }

        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {
            var ambientTable = (this.ambientValueMembers === null) ? null :
                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                ambientTable = (this.ambientEnclosedTypes === null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable) {
                var s = ambientTable.lookup(name);
                if (s) { return s; }
            }

            return null;
        }

        public print(outfile: ITextWriter) {
            super.print(outfile);
            if (this.ambientValueMembers) {
                this.ambientValueMembers.allMembers.map((key, sym, context) =>
                    outfile.WriteLine("  " + key), null);
            }
            if (this.valueMembers) {
                this.valueMembers.allMembers.map((key, sym, context) =>
                    outfile.WriteLine("  " + key), null);
            }
            if (this.ambientEnclosedTypes) {
                this.ambientEnclosedTypes.allMembers.map((key, sym, context) =>
                    outfile.WriteLine("  " + key), null);
            }
            if (this.enclosedTypes) {
                this.enclosedTypes.allMembers.map((key, sym, context) =>
                    outfile.WriteLine("  " + key), null);
            }
        }

        public findImplementation(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym = this.find(name, publicOnly, typespace);
            if (sym) {
                if (sym.kind() === SymbolKind.Type) {
                    var typeSym = <TypeSymbol>sym;
                    if (!typeSym.type.hasImplementation()) {
                        sym = null;
                    }
                }
                else if (sym.container) {
                    if (sym.container.kind() === SymbolKind.Type) {
                        var ctypeSym = <TypeSymbol>sym.container;
                        if (!ctypeSym.type.hasImplementation()) {
                            sym = null;
                        }
                    }
                }
            }
            return sym;
        }

        public getTable() {
            return this.valueMembers.publicMembers;
        }
    }

    export class SymbolScopeBuilder extends SymbolScope {
        public container: Symbol;
        
        constructor (public valueMembers: ScopedMembers,
                    public ambientValueMembers: ScopedMembers,
                    public enclosedTypes: ScopedMembers,
                    public ambientEnclosedTypes: ScopedMembers,
                    public parent: SymbolScope,
                    container: Symbol)
        {
            super(container);
            this.container = container;
        }

        public printLabel() { return "builder"; }
        public getAllSymbolNames(members: bool): string[]{
            var result: string[] = this.getAllTypeSymbolNames(members);
            return result.concat(this.getAllValueSymbolNames(members));
        }

        public getAllTypeSymbolNames(members: bool): string[]{
            var result: string[] = [];
            if (this.ambientEnclosedTypes) {
                result = result.concat(this.ambientEnclosedTypes.allMembers.getAllKeys());
            }
            if (this.enclosedTypes) {
                result = result.concat(this.enclosedTypes.allMembers.getAllKeys());
            }
            if (!members && this.parent) {
                var parentResult = this.parent.getAllTypeSymbolNames(members);
                if (parentResult) {
                    result = result.concat(parentResult);
                }
            }
            return result;
        }

        public getAllValueSymbolNames(members: bool): string[]{
            var result: string[] = [];
            if (this.ambientValueMembers) {
                result = result.concat(this.ambientValueMembers.allMembers.getAllKeys());
            }
            if (this.valueMembers) {
                result = result.concat(this.valueMembers.allMembers.getAllKeys());
            }
            if (!members && this.parent) {
                var parentResult = this.parent.getAllValueSymbolNames(members);
                if (parentResult) {
                    result = result.concat(parentResult);
                }
            }
            return result;
        }

        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool) {
            var sym: Symbol = null;
            var table = (this.valueMembers === null) ? null :
                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers === null) ? null :
                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes === null) ? null :
                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes === null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable) {
                if ((sym = ambientTable.lookup(name)) != null) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            if (table) {
                if ((sym = table.lookup(name)) != null) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            if (this.parent) {
                sym = this.parent.search(filter, name, publicOnly, typespace);
                if (sym) {
                    if (filter.update(sym)) {
                        return sym;
                    }
                }
            }
            return filter.result;
        }

        public print(outfile: ITextWriter) {
            super.print(outfile);
            if (this.ambientValueMembers) {
                this.ambientValueMembers.allMembers.map(function (key, s, context) {
                    var sym = <Symbol>s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.valueMembers) {
                this.valueMembers.allMembers.map(function (key, s, context) {
                    var sym = <Symbol>s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.ambientEnclosedTypes) {
                this.ambientEnclosedTypes.allMembers.map(function (key, s, context) {
                    var sym = <Symbol>s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.enclosedTypes) {
                this.enclosedTypes.allMembers.map(function (key, s, context) {
                    var sym = <Symbol>s;
                    outfile.WriteLine("  " + key);
                }, null);
            }
            if (this.parent) {
                this.parent.print(outfile);
            }
        }

        public find(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var table = (this.valueMembers === null) ? null :
                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers === null) ? null :
                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes === null) ? null :
                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes === null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {
                return sym;
            }
            if (table && ((sym = table.lookup(name)) != null)) {
                return sym;
            }
            if (this.parent) {
                return this.parent.find(name, publicOnly, typespace);
            }
            return null;
        }

        public findAmbient(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var ambientTable = (this.ambientValueMembers === null) ? null :
                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                ambientTable = (this.ambientEnclosedTypes === null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (ambientTable && ((sym = ambientTable.lookup(name)) != null)) {
                return sym;
            }
            if (this.parent) {
                return this.parent.findAmbient(name, publicOnly, typespace);
            }
            return null;
        }

        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym: Symbol = null;
            var table = (this.valueMembers === null) ? null :
                            publicOnly ? this.valueMembers.publicMembers : this.valueMembers.allMembers;
            var ambientTable = (this.ambientValueMembers === null) ? null :
                                publicOnly ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.allMembers;
            if (typespace) {
                table = (this.enclosedTypes === null) ? null :
                            publicOnly ? this.enclosedTypes.publicMembers : this.enclosedTypes.allMembers;
                ambientTable = (this.ambientEnclosedTypes === null) ? null :
                                    publicOnly ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.allMembers;
            }
            if (table) {
                if ((sym = table.lookup(name)) != null) {
                    if (sym) { return sym; }
                }
            }
            if (ambientTable) {
                if ((sym = ambientTable.lookup(name)) != null) {
                    if (sym) { return sym; }
                }
            }
            return null;
        }

        public enter(container: Symbol, ast: AST, symbol: Symbol, errorReporter: ErrorReporter, insertAsPublic: bool, typespace: bool, ambient: bool): void {
            var table = null;

            if (ambient) {
                if (typespace) {
                    table = (this.ambientEnclosedTypes === null) ? null :
                                    insertAsPublic ? this.ambientEnclosedTypes.publicMembers : this.ambientEnclosedTypes.privateMembers;
                }
                else {
                    table = (this.ambientValueMembers === null) ? null :
                                insertAsPublic ? this.ambientValueMembers.publicMembers : this.ambientValueMembers.privateMembers;
                }
            }
            else {
                if (typespace) {
                    table = (this.enclosedTypes === null) ? null :
                                insertAsPublic ? this.enclosedTypes.publicMembers : this.enclosedTypes.privateMembers;
                }
                else {
                    table = (this.valueMembers === null) ? null :
                                insertAsPublic ? this.valueMembers.publicMembers : this.valueMembers.privateMembers;
                }
            }

            if (table) {
                if (!table.add(symbol.name, symbol)) {
                    errorReporter.duplicateIdentifier(ast, symbol.name);
                }
            }
            else {
                CompilerDiagnostics.Alert("YYYYY");  // REVIEW: Surely we can do better than this...
            }
            symbol.container = container;
        }

        public getTable() { return this.valueMembers.allMembers; }
    }

    export class FilteredSymbolScope extends SymbolScope {
        constructor (public scope: SymbolScope, container: Symbol, public filter: ScopeSearchFilter) {
            super(container);
        }
        public print(outfile: ITextWriter) {
            this.scope.print(outfile);
        }

        public find(name: string, publicOnly: bool, typespace: bool) {
            this.filter.reset();
            return this.scope.search(this.filter, name, publicOnly, typespace);
        }
        public findLocal(name: string, publicOnly: bool, typespace: bool) { return this.scope.findLocal(name, publicOnly, typespace); }
    }

    export class FilteredSymbolScopeBuilder extends SymbolScopeBuilder {
        constructor (valueMembers: ScopedMembers, parent: SymbolScope, container: Symbol, public filter: (sym: Symbol) =>bool) {
            super(valueMembers, null, null, null, parent, container);
        }
        public findLocal(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym = super.findLocal(name, publicOnly, typespace);
            if (sym) {
                if (!this.filter(sym)) {
                    return null;
                }
            }
            return sym;
        }

        public search(filter: ScopeSearchFilter, name: string, publicOnly: bool, typespace: bool):Symbol {
            throw new Error("please implement");
        }

        public find(name: string, publicOnly: bool, typespace: bool): Symbol {
            var sym = super.findLocal(name, publicOnly, typespace);
            if (sym) {
                if (!this.filter(sym)) {
                    return null;
                }
            }
            return super.find(name, publicOnly, typespace);
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export enum TokenID {
        // Keywords
        Any,
        Bool,
        Break,
        Case,
        Catch,
        Class,
        Const,
        Continue,
        Debugger,
        Default,
        Delete,
        Do,
        Else,
        Enum,
        Export,
        Extends,
        Declare,
        False,
        Finally,
        For,
        Function,
        Constructor,
        Get,
        If,
        Implements,
        Import,
        In,
        InstanceOf,
        Interface,
        Let,
        Module,
        New,
        Number,
        Null,
        Package,
        Private,
        Protected,
        Public,
        Return,
        Set,
        Static,
        String,
        Super,
        Switch,
        This,
        Throw,
        True,
        Try,
        TypeOf,
        Var,
        Void,
        With,
        While,
        Yield,
        // Punctuation
        Semicolon,
        OpenParen,
        CloseParen,
        OpenBracket,
        CloseBracket,
        OpenBrace,
        CloseBrace,
        Comma,
        Equals,
        PlusEquals,
        MinusEquals,
        AsteriskEquals,
        SlashEquals,
        PercentEquals,
        AmpersandEquals,
        CaretEquals,
        BarEquals,
        LessThanLessThanEquals,
        GreaterThanGreaterThanEquals,
        GreaterThanGreaterThanGreaterThanEquals,
        Question,
        Colon,
        BarBar,
        AmpersandAmpersand,
        Bar,
        Caret,
        And,
        EqualsEquals,
        ExclamationEquals,
        EqualsEqualsEquals,
        ExclamationEqualsEquals,
        LessThan,
        LessThanEquals,
        GreaterThan,
        GreaterThanEquals,
        LessThanLessThan,
        GreaterThanGreaterThan,
        GreaterThanGreaterThanGreaterThan,
        Plus,
        Minus,
        Asterisk,
        Slash,
        Percent,
        Tilde,
        Exclamation,
        PlusPlus,
        MinusMinus,
        Dot,
        DotDotDot,
        Error,
        EndOfFile,
        EqualsGreaterThan,
        Identifier,
        StringLiteral,
        RegularExpressionLiteral,
        NumberLiteral,
        Whitespace,
        Comment,
        Lim,
        LimFixed = EqualsGreaterThan,
        LimKeyword = Yield,
    }

    export var tokenTable: TokenInfo[] = [];
    export var nodeTypeTable: string[] = [];
    export var nodeTypeToTokTable: number[] = [];
    export var noRegexTable: bool[] = [];

    noRegexTable[TokenID.Identifier] = true;
    noRegexTable[TokenID.StringLiteral] = true;
    noRegexTable[TokenID.NumberLiteral] = true;
    noRegexTable[TokenID.RegularExpressionLiteral] = true;
    noRegexTable[TokenID.This] = true;
    noRegexTable[TokenID.PlusPlus] = true;
    noRegexTable[TokenID.MinusMinus] = true;
    noRegexTable[TokenID.CloseParen] = true;
    noRegexTable[TokenID.CloseBracket] = true;
    noRegexTable[TokenID.CloseBrace] = true;
    noRegexTable[TokenID.True] = true;
    noRegexTable[TokenID.False] = true;

    export enum OperatorPrecedence {
        None,
        Comma,
        Assignment,
        Conditional,
        LogicalOr,
        LogicalAnd,
        BitwiseOr,
        BitwiseExclusiveOr,
        BitwiseAnd,
        Equality,
        Relational,
        Shift,
        Additive,
        Multiplicative,
        Unary,
        Lim
    }

    export class TokenInfo {
        constructor(public binopPrecedence: number,
                    public binopNodeType: number,
                    public unopPrecedence: number,
                    public unopNodeType: number,
                    public text: string) {
        }
    }

    function setTokenInfo(tokenId: TokenID, binopPrecedence: number,
        binopNodeType: number, unopPrecedence: number, unopNodeType: number,
        text: string) {
        if (tokenId !== undefined) {
            tokenTable[tokenId] = new TokenInfo(binopPrecedence, binopNodeType, unopPrecedence, unopNodeType, text);
            if (binopNodeType != NodeType.None) {
                nodeTypeTable[binopNodeType] = text;
                nodeTypeToTokTable[binopNodeType] = tokenId;
            }
            if (unopNodeType != NodeType.None) {
                nodeTypeTable[unopNodeType] = text;
            }
        }
    }

    setTokenInfo(TokenID.Any, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "any");
    setTokenInfo(TokenID.Bool, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "bool");
    setTokenInfo(TokenID.Break, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "break");
    setTokenInfo(TokenID.Case, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "case");
    setTokenInfo(TokenID.Catch, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "catch");
    setTokenInfo(TokenID.Class, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "class");
    setTokenInfo(TokenID.Const, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "const");
    setTokenInfo(TokenID.Continue, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "continue");
    setTokenInfo(TokenID.Debugger, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.Debugger, "debugger");
    setTokenInfo(TokenID.Default, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "default");
    setTokenInfo(TokenID.Delete, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Delete, "delete");
    setTokenInfo(TokenID.Do, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "do");
    setTokenInfo(TokenID.Else, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "else");
    setTokenInfo(TokenID.Enum, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "enum");
    setTokenInfo(TokenID.Export, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "export");
    setTokenInfo(TokenID.Extends, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "extends");
    setTokenInfo(TokenID.Declare, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "declare");
    setTokenInfo(TokenID.False, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "false");
    setTokenInfo(TokenID.Finally, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "finally");
    setTokenInfo(TokenID.For, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "for");
    setTokenInfo(TokenID.Function, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "function");
    setTokenInfo(TokenID.Constructor, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "constructor");
    setTokenInfo(TokenID.Get, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "get");
    setTokenInfo(TokenID.Set, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "set");
    setTokenInfo(TokenID.If, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "if");
    setTokenInfo(TokenID.Implements, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "implements");
    setTokenInfo(TokenID.Import, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "import");
    setTokenInfo(TokenID.In, OperatorPrecedence.Relational, NodeType.In, OperatorPrecedence.None, NodeType.None, "in");
    setTokenInfo(TokenID.InstanceOf, OperatorPrecedence.Relational, NodeType.InstOf, OperatorPrecedence.None, NodeType.None, "instanceof");
    setTokenInfo(TokenID.Interface, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "interface");
    setTokenInfo(TokenID.Let, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "let");
    setTokenInfo(TokenID.Module, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "module");
    setTokenInfo(TokenID.New, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "new");
    setTokenInfo(TokenID.Number, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "number");
    setTokenInfo(TokenID.Null, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "null");
    setTokenInfo(TokenID.Package, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "package");
    setTokenInfo(TokenID.Private, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "private");
    setTokenInfo(TokenID.Protected, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "protected");
    setTokenInfo(TokenID.Public, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "public");
    setTokenInfo(TokenID.Return, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "return");
    setTokenInfo(TokenID.Static, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "static");
    setTokenInfo(TokenID.String, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "string");
    setTokenInfo(TokenID.Super, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "super");
    setTokenInfo(TokenID.Switch, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "switch");
    setTokenInfo(TokenID.This, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "this");
    setTokenInfo(TokenID.Throw, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "throw");
    setTokenInfo(TokenID.True, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "true");
    setTokenInfo(TokenID.Try, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "try");
    setTokenInfo(TokenID.TypeOf, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Typeof, "typeof");
    setTokenInfo(TokenID.Var, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "var");
    setTokenInfo(TokenID.Void, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Void, "void");
    setTokenInfo(TokenID.With, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.With, "with");
    setTokenInfo(TokenID.While, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "while");
    setTokenInfo(TokenID.Yield, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "yield");

    setTokenInfo(TokenID.Identifier, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "identifier");
    setTokenInfo(TokenID.NumberLiteral, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "numberLiteral");
    setTokenInfo(TokenID.RegularExpressionLiteral, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "regex");
    setTokenInfo(TokenID.StringLiteral, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "qstring");

    // Non-operator non-identifier tokens
    setTokenInfo(TokenID.Semicolon, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ";"); // ;
    setTokenInfo(TokenID.CloseParen, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ")"); // )
    setTokenInfo(TokenID.CloseBracket, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "]"); // ]
    setTokenInfo(TokenID.OpenBrace, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "{"); // {
    setTokenInfo(TokenID.CloseBrace, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "}"); // }
    setTokenInfo(TokenID.DotDotDot, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "..."); // ...

    // Operator non-identifier tokens
    setTokenInfo(TokenID.Comma, OperatorPrecedence.Comma, NodeType.Comma, OperatorPrecedence.None, NodeType.None, ","); // ,
    setTokenInfo(TokenID.Equals, OperatorPrecedence.Assignment, NodeType.Asg, OperatorPrecedence.None, NodeType.None, "="); // =
    setTokenInfo(TokenID.PlusEquals, OperatorPrecedence.Assignment, NodeType.AsgAdd, OperatorPrecedence.None, NodeType.None, "+="); // +=
    setTokenInfo(TokenID.MinusEquals, OperatorPrecedence.Assignment, NodeType.AsgSub, OperatorPrecedence.None, NodeType.None, "-="); // -=
    setTokenInfo(TokenID.AsteriskEquals, OperatorPrecedence.Assignment, NodeType.AsgMul, OperatorPrecedence.None, NodeType.None, "*="); // *=

    setTokenInfo(TokenID.SlashEquals, OperatorPrecedence.Assignment, NodeType.AsgDiv, OperatorPrecedence.None, NodeType.None, "/="); // /=
    setTokenInfo(TokenID.PercentEquals, OperatorPrecedence.Assignment, NodeType.AsgMod, OperatorPrecedence.None, NodeType.None, "%="); // %=
    setTokenInfo(TokenID.AmpersandEquals, OperatorPrecedence.Assignment, NodeType.AsgAnd, OperatorPrecedence.None, NodeType.None, "&="); // &=
    setTokenInfo(TokenID.CaretEquals, OperatorPrecedence.Assignment, NodeType.AsgXor, OperatorPrecedence.None, NodeType.None, "^="); // ^=
    setTokenInfo(TokenID.BarEquals, OperatorPrecedence.Assignment, NodeType.AsgOr, OperatorPrecedence.None, NodeType.None, "|="); // |=
    setTokenInfo(TokenID.LessThanLessThanEquals, OperatorPrecedence.Assignment, NodeType.AsgLsh, OperatorPrecedence.None, NodeType.None, "<<="); // <<=
    setTokenInfo(TokenID.GreaterThanGreaterThanEquals, OperatorPrecedence.Assignment, NodeType.AsgRsh, OperatorPrecedence.None, NodeType.None, ">>="); // >>=
    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThanEquals, OperatorPrecedence.Assignment, NodeType.AsgRs2, OperatorPrecedence.None, NodeType.None, ">>>="); // >>>=
    setTokenInfo(TokenID.Question, OperatorPrecedence.Conditional, NodeType.ConditionalExpression, OperatorPrecedence.None, NodeType.None, "?"); // ?
    setTokenInfo(TokenID.Colon, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, ":"); // :
    setTokenInfo(TokenID.BarBar, OperatorPrecedence.LogicalOr, NodeType.LogOr, OperatorPrecedence.None, NodeType.None, "||"); // ||
    setTokenInfo(TokenID.AmpersandAmpersand, OperatorPrecedence.LogicalAnd, NodeType.LogAnd, OperatorPrecedence.None, NodeType.None, "&&"); // &&
    setTokenInfo(TokenID.Bar, OperatorPrecedence.BitwiseOr, NodeType.Or, OperatorPrecedence.None, NodeType.None, "|"); // |
    setTokenInfo(TokenID.Caret, OperatorPrecedence.BitwiseExclusiveOr, NodeType.Xor, OperatorPrecedence.None, NodeType.None, "^"); // ^
    setTokenInfo(TokenID.And, OperatorPrecedence.BitwiseAnd, NodeType.And, OperatorPrecedence.None, NodeType.None, "&"); // &
    setTokenInfo(TokenID.EqualsEquals, OperatorPrecedence.Equality, NodeType.Eq, OperatorPrecedence.None, NodeType.None, "=="); // ==
    setTokenInfo(TokenID.ExclamationEquals, OperatorPrecedence.Equality, NodeType.Ne, OperatorPrecedence.None, NodeType.None, "!="); // !=
    setTokenInfo(TokenID.EqualsEqualsEquals, OperatorPrecedence.Equality, NodeType.Eqv, OperatorPrecedence.None, NodeType.None, "==="); // ===
    setTokenInfo(TokenID.ExclamationEqualsEquals, OperatorPrecedence.Equality, NodeType.NEqv, OperatorPrecedence.None, NodeType.None, "!=="); // !==
    setTokenInfo(TokenID.LessThan, OperatorPrecedence.Relational, NodeType.Lt, OperatorPrecedence.None, NodeType.None, "<"); // <
    setTokenInfo(TokenID.LessThanEquals, OperatorPrecedence.Relational, NodeType.Le, OperatorPrecedence.None, NodeType.None, "<="); // <=
    setTokenInfo(TokenID.GreaterThan, OperatorPrecedence.Relational, NodeType.Gt, OperatorPrecedence.None, NodeType.None, ">"); // >
    setTokenInfo(TokenID.GreaterThanEquals, OperatorPrecedence.Relational, NodeType.Ge, OperatorPrecedence.None, NodeType.None, ">="); // >=
    setTokenInfo(TokenID.LessThanLessThan, OperatorPrecedence.Shift, NodeType.Lsh, OperatorPrecedence.None, NodeType.None, "<<"); // <<
    setTokenInfo(TokenID.GreaterThanGreaterThan, OperatorPrecedence.Shift, NodeType.Rsh, OperatorPrecedence.None, NodeType.None, ">>"); // >>
    setTokenInfo(TokenID.GreaterThanGreaterThanGreaterThan, OperatorPrecedence.Shift, NodeType.Rs2, OperatorPrecedence.None, NodeType.None, ">>>"); // >>>
    setTokenInfo(TokenID.Plus, OperatorPrecedence.Additive, NodeType.Add, OperatorPrecedence.Unary, NodeType.Pos, "+"); // +
    setTokenInfo(TokenID.Minus, OperatorPrecedence.Additive, NodeType.Sub, OperatorPrecedence.Unary, NodeType.Neg, "-"); // -
    setTokenInfo(TokenID.Asterisk, OperatorPrecedence.Multiplicative, NodeType.Mul, OperatorPrecedence.None, NodeType.None, "*"); // *
    setTokenInfo(TokenID.Slash, OperatorPrecedence.Multiplicative, NodeType.Div, OperatorPrecedence.None, NodeType.None, "/"); // /
    setTokenInfo(TokenID.Percent, OperatorPrecedence.Multiplicative, NodeType.Mod, OperatorPrecedence.None, NodeType.None, "%"); // %
    setTokenInfo(TokenID.Tilde, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.Not, "~"); // ~
    setTokenInfo(TokenID.Exclamation, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.LogNot, "!"); // !
    setTokenInfo(TokenID.PlusPlus, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.IncPre, "++"); // ++
    setTokenInfo(TokenID.MinusMinus, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.Unary, NodeType.DecPre, "--"); // --
    setTokenInfo(TokenID.OpenParen, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "("); // (
    setTokenInfo(TokenID.OpenBracket, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "["); // [
    setTokenInfo(TokenID.Dot, OperatorPrecedence.Unary, NodeType.None, OperatorPrecedence.None, NodeType.None, "."); // .
    setTokenInfo(TokenID.EndOfFile, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "<EOF>"); // EOF
    setTokenInfo(TokenID.EqualsGreaterThan, OperatorPrecedence.None, NodeType.None, OperatorPrecedence.None, NodeType.None, "=>"); // =>

    export function lookupToken(tokenId: TokenID): TokenInfo {
        return tokenTable[tokenId];
    }

    export enum TokenClass {
        Punctuation,
        Keyword,
        Operator,
        Comment,
        Whitespace,
        Identifier,
        NumberLiteral,
        StringLiteral,
        RegExpLiteral,
    }

    export class SavedToken {
        constructor (public tok: Token, public minChar: number, public limChar: number) { }
    }

    export class Token {
        constructor (public tokenId: TokenID) {
        }

        public toString() {
            return "token: " + this.tokenId + " " + this.getText() + " (" + (<any>TokenID)._map[this.tokenId] + ")";
        }

        public print(line: number, outfile) {
            outfile.WriteLine(this.toString() + ",on line" + line);
        }

        public getText(): string {
            return tokenTable[this.tokenId].text;
        }

        public classification(): TokenClass {
            if (this.tokenId <= TokenID.LimKeyword) {
                return TokenClass.Keyword;
            }
            else {
                var tokenInfo = lookupToken(this.tokenId);
                if (tokenInfo != undefined) {
                    if ((tokenInfo.unopNodeType != NodeType.None) ||
                        (tokenInfo.binopNodeType != NodeType.None)) {
                        return TokenClass.Operator;
                    }
                }
            }

            return TokenClass.Punctuation;
        }
    }

    export class NumberLiteralToken extends Token {
        constructor (public value: number, public text: string) {
            super(TokenID.NumberLiteral);
        }

        public getText(): string {
            return this.text;
        }

        public classification(): TokenClass {
            return TokenClass.NumberLiteral;
        }
    }

    export class StringLiteralToken extends Token {
        constructor (public value: string) {
            super(TokenID.StringLiteral);
        }

        public getText(): string {
            return this.value;
        }
        
        public classification(): TokenClass {
            return TokenClass.StringLiteral;
        }
    }

    export class IdentifierToken extends Token {
        constructor (public value: string, public hasEscapeSequence : bool) {
            super(TokenID.Identifier);
        }
        public getText(): string {
            return this.value;
        }
        public classification(): TokenClass {
            return TokenClass.Identifier;
        }
    }

    export class WhitespaceToken extends Token {
        constructor (tokenId: TokenID, public value: string) {
            super(tokenId);
        }

        public getText(): string {
            return this.value;
        }

        public classification(): TokenClass {
            return TokenClass.Whitespace;
        }
    }

    export class CommentToken extends Token {
        constructor(public value: string,
                    public isBlock: bool,
                    public startPos: number,
                    public line: number,
                    public endsLine: bool) {
            super(TokenID.Comment);
        }

        public getText(): string {
            return this.value;
        }

        public classification(): TokenClass {
            return TokenClass.Comment;
        }
    }

    export class RegularExpressionLiteralToken extends Token {
        constructor(public text: string) {
            super(TokenID.RegularExpressionLiteral);
        }

        public getText(): string {
            return this.text;
        }

        public classification(): TokenClass {
            return TokenClass.RegExpLiteral;
        }
    }

    // TODO: new with length TokenID.LimFixed
    export var staticTokens: Token[] = [];
    export function initializeStaticTokens() {
        for (var i = 0; i <= TokenID.LimFixed; i++) {
            staticTokens[i] = new Token(i);
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class ArrayCache {
        public arrayType: Type;
        public arrayBase: Type = null;

        public specialize(arrInstType: Type, checker: TypeChecker): Type {
            if (this.arrayBase === null) {
                this.arrayBase = arrInstType.specializeType(checker.wildElm.type, this.arrayType.elementType,
                                                   checker, true);
            }
            return this.arrayBase;
        }
    }

    export class TypeComparisonInfo {
        public onlyCaptureFirstError = false;
        public flags: TypeRelationshipFlags = TypeRelationshipFlags.SuccessfulComparison;
        public message = "";

        public addMessageToFront(message) {
            if (!this.onlyCaptureFirstError) {
                this.message = this.message ? message + ":\n\t" + this.message : message;
            }
            else {
                this.setMessage(message);
            }
        }

        public setMessage(message) {
            this.message = message;
        }
    }

    export interface SignatureData {
        parameters: ParameterSymbol[];
        nonOptionalParameterCount: number;
    }

    export interface ApplicableSignature {
        signature: Signature;
        hadProvisionalErrors: bool;
    }

    export enum TypeCheckCollectionMode {
        Resident,
        Transient
    }

    export class PersistentGlobalTypeState {
        public importedGlobalsTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
        public importedGlobalsTypeTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));

        public importedGlobals: SymbolScopeBuilder;

        // transient state
        public globals: IHashTable = null;
        public globalTypes: IHashTable = null;
        public ambientGlobals: IHashTable = null;
        public ambientGlobalTypes: IHashTable = null;

        // resident state
        public residentGlobalValues = new StringHashTable();
        public residentGlobalTypes = new StringHashTable();
        public residentGlobalAmbientValues = new StringHashTable();
        public residentGlobalAmbientTypes = new StringHashTable();

        // dual resident/transient state

        // REVIEW: We shouldn't need to allocate private hash tables for these, since there's no private global scope
        // REVIEW: In general, we should audit each instance of DualStringHashTable to ensure that both the primary
        // and secondary tables are necessary.  If it's not necessary, we should sub in a constant sentinel value.
        public dualGlobalValues: DualStringHashTable;
        public dualGlobalTypes: DualStringHashTable;
        public dualAmbientGlobalValues: DualStringHashTable;
        public dualAmbientGlobalTypes: DualStringHashTable;

        public globalScope: SymbolScope;

        public voidType: Type;
        public booleanType: Type;
        public doubleType: Type;

        public stringType: Type;
        public anyType: Type;
        public nullType: Type;
        public undefinedType: Type;

        // Use this flag to turn resident checking on and off
        public residentTypeCheck: bool = true;

        public mod: ModuleType = null;
        public gloMod: TypeSymbol = null;

        public wildElm: TypeSymbol = null;

        constructor (public errorReporter: ErrorReporter, private compilationSettings: CompilationSettings) {
            this.importedGlobals = new SymbolScopeBuilder(null, this.importedGlobalsTable, null, this.importedGlobalsTypeTable, null, null);

            this.dualGlobalValues = new DualStringHashTable(this.residentGlobalValues, new StringHashTable());
            this.dualGlobalTypes = new DualStringHashTable(this.residentGlobalTypes, new StringHashTable());
            this.dualAmbientGlobalValues = new DualStringHashTable(this.residentGlobalAmbientValues, new StringHashTable());
            this.dualAmbientGlobalTypes = new DualStringHashTable(this.residentGlobalAmbientTypes, new StringHashTable());

            var dualGlobalScopedMembers = new ScopedMembers(new DualStringHashTable(this.dualGlobalValues, new StringHashTable()));
            var dualGlobalScopedAmbientMembers = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalValues, new StringHashTable()));
            var dualGlobalScopedEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualGlobalTypes, new StringHashTable()));
            var dualGlobalScopedAmbientEnclosedTypes = new ScopedMembers(new DualStringHashTable(this.dualAmbientGlobalTypes, new StringHashTable()));

            this.globalScope = new SymbolScopeBuilder(dualGlobalScopedMembers, dualGlobalScopedAmbientMembers, dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes, this.importedGlobals, null);

            this.voidType = this.enterPrimitive(Primitive.Void, "void");
            this.booleanType = this.enterPrimitive(Primitive.Boolean, "bool");
            this.doubleType = this.enterPrimitive(Primitive.Double, "number");
            this.importedGlobals.ambientEnclosedTypes.addPublicMember("number", this.doubleType.symbol);

            this.stringType = this.enterPrimitive(Primitive.String, "string");
            this.anyType = this.enterPrimitive(Primitive.Any, "any");
            this.nullType = this.enterPrimitive(Primitive.Null, "null");
            this.undefinedType = this.enterPrimitive(Primitive.Undefined, "undefined");

            // shared global state is resident
            this.setCollectionMode(TypeCheckCollectionMode.Resident);

            this.wildElm = new TypeSymbol("_element", -1, 0, unknownLocationInfo.fileName, new Type(), this.compilationSettings.optimizeModuleCodeGen);
            this.importedGlobalsTypeTable.addPublicMember(this.wildElm.name, this.wildElm);

            this.mod = new ModuleType(dualGlobalScopedEnclosedTypes, dualGlobalScopedAmbientEnclosedTypes);
            this.mod.members = dualGlobalScopedMembers;
            this.mod.ambientMembers = dualGlobalScopedAmbientMembers;
            this.mod.containedScope = this.globalScope;

            this.gloMod = new TypeSymbol(globalId, -1, 0, unknownLocationInfo.fileName, this.mod, this.compilationSettings.optimizeModuleCodeGen);
            this.mod.members.addPublicMember(this.gloMod.name, this.gloMod);

            this.defineGlobalValue("undefined", this.undefinedType);
        }

        public enterPrimitive(flags: number, name: string) {
            var primitive = new Type();
            primitive.primitiveTypeClass = flags;
            var symbol = new TypeSymbol(name, -1, name.length, unknownLocationInfo.fileName, primitive, this.compilationSettings.optimizeModuleCodeGen);
            symbol.typeCheckStatus = TypeCheckStatus.Finished;
            primitive.symbol = symbol;
            this.importedGlobals.enter(null, null, symbol, this.errorReporter, true, true, true);
            return primitive;
        }

        public setCollectionMode(mode: TypeCheckCollectionMode) {
            this.residentTypeCheck =
                this.dualGlobalValues.insertPrimary =
                    this.dualGlobalTypes.insertPrimary =
                        this.dualAmbientGlobalValues.insertPrimary =
                            this.dualAmbientGlobalTypes.insertPrimary = mode === TypeCheckCollectionMode.Resident;
        }

        public refreshPersistentState() {
            this.globals = new StringHashTable();
            this.globalTypes = new StringHashTable();
            this.ambientGlobals = new StringHashTable();
            this.ambientGlobalTypes = new StringHashTable();

            // add global types to the global scope
            this.globalTypes.add(this.voidType.symbol.name, this.voidType.symbol);
            this.globalTypes.add(this.booleanType.symbol.name, this.booleanType.symbol);
            this.globalTypes.add(this.doubleType.symbol.name, this.doubleType.symbol);
            this.globalTypes.add("number", this.doubleType.symbol);
            this.globalTypes.add(this.stringType.symbol.name, this.stringType.symbol);
            this.globalTypes.add(this.anyType.symbol.name, this.anyType.symbol);
            this.globalTypes.add(this.nullType.symbol.name, this.nullType.symbol);
            this.globalTypes.add(this.undefinedType.symbol.name, this.undefinedType.symbol);

            this.dualGlobalValues.secondaryTable = this.globals;
            this.dualGlobalTypes.secondaryTable = this.globalTypes;
            this.dualAmbientGlobalValues.secondaryTable = this.ambientGlobals;
            this.dualAmbientGlobalTypes.secondaryTable = this.ambientGlobalTypes;
        }

        public defineGlobalValue(name: string, type: Type) {
            var valueLocation = new ValueLocation();
            valueLocation.typeLink = new TypeLink();
            var sym = new VariableSymbol(name, 0, unknownLocationInfo.fileName, valueLocation);
            sym.setType(type);
            sym.typeCheckStatus = TypeCheckStatus.Finished;
            sym.container = this.gloMod;
            this.importedGlobalsTable.addPublicMember(name, sym);
        }
    }

    export class ContextualTypeContext {
        public targetSig: Signature = null;
        public targetThis: Type = null;
        public targetAccessorType: Type = null;

        constructor (public contextualType: Type,
            public provisional: bool, public contextID: number) { }
    }

    export class ContextualTypingContextStack {
        private contextStack: ContextualTypeContext[] = [];
        static contextID = TypeCheckStatus.Finished + 1;
        public pushContextualType(type: Type, provisional: bool) { this.contextStack.push(new ContextualTypeContext(type, provisional, ContextualTypingContextStack.contextID++)); this.checker.errorReporter.pushToErrorSink = provisional; }
        public hadProvisionalErrors = false; // somewhere in the chain a provisional typecheck error was thrown
        public popContextualType() {
            var tc = this.contextStack.pop();
            this.checker.errorReporter.pushToErrorSink = this.isProvisional();
            this.hadProvisionalErrors = this.hadProvisionalErrors || (tc.provisional && (this.checker.errorReporter.getCapturedErrors().length));
            this.checker.errorReporter.freeCapturedErrors();
            return tc;
        }
        public getContextualType(): ContextualTypeContext { return (!this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1]); }
        public getContextID() { return (!this.contextStack.length ? TypeCheckStatus.Finished : this.contextStack[this.contextStack.length - 1].contextID); }
        public isProvisional() { return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional); }

        constructor (public checker: TypeChecker) { }
    }

    export class TypeChecker {
        public errorReporter: ErrorReporter = null;
        public globalScope: SymbolScope;

        public checkControlFlow = false;
        public printControlFlowGraph = false;
        public checkControlFlowUseDef = false;
        public styleSettings: StyleSettings = null;

        public fileNameToLocationInfo: StringHashTable = null;

        public voidType: Type;
        public booleanType: Type;
        public numberType: Type;
        public stringType: Type;
        public anyType: Type;
        public nullType: Type;
        public undefinedType: Type;

        public anon = "_anonymous";

        public globals: DualStringHashTable;
        public globalTypes: DualStringHashTable;
        public ambientGlobals: DualStringHashTable;
        public ambientGlobalTypes: DualStringHashTable;
        public gloModType: ModuleType;
        public gloMod: TypeSymbol;
        public wildElm: TypeSymbol;

        public locationInfo: LocationInfo = null;
        public typeFlow: TypeFlow = null;

        public currentCompareA: Symbol = null;
        public currentCompareB: Symbol = null;

        public currentModDecl: ModuleDeclaration = null;

        public inBind = false;
        public inWith = false;
        public errorsOnWith = true;

        public typingContextStack: ContextualTypingContextStack;
        public currentContextualTypeContext: ContextualTypeContext = null;

        public resolvingBases = false;

        public canCallDefinitionSignature = false;

        public assignableCache: any[] = <any>{};
        public subtypeCache: any[] = <any>{};
        public identicalCache: any[] = <any>{};

        public provisionalStartedTypecheckObjects: PhasedTypecheckObject[] = [];

        public mustCaptureGlobalThis = false;

        constructor(public persistentState: PersistentGlobalTypeState,
                    public compilationSettings: CompilationSettings) {
            this.voidType = this.persistentState.voidType;
            this.booleanType = this.persistentState.booleanType;
            this.numberType = this.persistentState.doubleType;
            this.stringType = this.persistentState.stringType;
            this.anyType = this.persistentState.anyType;
            this.nullType = this.persistentState.nullType;
            this.undefinedType = this.persistentState.undefinedType;

            this.globals = this.persistentState.dualGlobalValues;
            this.globalTypes = this.persistentState.dualGlobalTypes;
            this.ambientGlobals = this.persistentState.dualAmbientGlobalValues;
            this.ambientGlobalTypes = this.persistentState.dualAmbientGlobalTypes;
            this.gloModType = this.persistentState.mod;
            this.gloMod = this.persistentState.gloMod;
            this.wildElm = this.persistentState.wildElm;

            this.globalScope = this.persistentState.globalScope;

            this.typingContextStack = new ContextualTypingContextStack(this);
        }

        public setStyleOptions(style: StyleSettings) {
            this.styleSettings = style;
        }

        // Contextual typing
        public setContextualType(type: Type, provisional: bool) {
            this.typingContextStack.pushContextualType(type, provisional);
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
        }

        public unsetContextualType() {
            var lastTC = this.typingContextStack.popContextualType();
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
            return lastTC;
        }

        public hadProvisionalErrors() {
            return this.typingContextStack.hadProvisionalErrors;
        }
        public resetProvisionalErrors() {
            if (!this.typingContextStack.getContextualType()) {
                this.typingContextStack.hadProvisionalErrors = false;
            }
        }

        public typeCheckWithContextualType(contextType: Type, provisional: bool, condition: bool, ast: AST) {
            if (condition) {
                this.setContextualType(contextType, this.typingContextStack.isProvisional() || provisional);
            }
            this.typeFlow.typeCheck(ast);
            if (condition) {
                this.unsetContextualType();
            }
        }

        public resetTargetType() {
            this.currentContextualTypeContext = this.typingContextStack.getContextualType();
        }

        // Unset the current contextual type without disturbing the stack, effectively "killing" the contextual typing process
        public killCurrentContextualType() { this.currentContextualTypeContext = null; this.errorReporter.pushToErrorSink = false; }
        public hasTargetType() { return this.currentContextualTypeContext && this.currentContextualTypeContext.contextualType; }
        public getTargetTypeContext() { return this.currentContextualTypeContext; }

        public inProvisionalTypecheckMode() {
            return this.typingContextStack.isProvisional();
        }

        public getTypeCheckFinishedStatus() {
            if (this.inProvisionalTypecheckMode()) {
                return this.typingContextStack.getContextID();
            }
            return TypeCheckStatus.Finished;
        }

        public typeStatusIsFinished(status: TypeCheckStatus) {

            return status === TypeCheckStatus.Finished ||
                   (this.inProvisionalTypecheckMode() && status === this.typingContextStack.getContextID());
        }

        public addStartedPTO(pto: PhasedTypecheckObject) {
            if (this.inProvisionalTypecheckMode()) {
                this.provisionalStartedTypecheckObjects[this.provisionalStartedTypecheckObjects.length] = pto;
            }
        }

        public cleanStartedPTO() {
            for (var i = 0; i < this.provisionalStartedTypecheckObjects.length; i++) {
                if (this.provisionalStartedTypecheckObjects[i].typeCheckStatus >= this.typingContextStack.getContextID()) {
                    this.provisionalStartedTypecheckObjects[i].typeCheckStatus = TypeCheckStatus.NotStarted;
                }
            }
            this.provisionalStartedTypecheckObjects = [];
        }

        // type collection      
        public collectTypes(ast: AST): void {
            if (ast.nodeType === NodeType.Script) {
                var script = <Script>ast;
                this.locationInfo = script.locationInfo;
            }
            var globalChain = new ScopeChain(this.gloMod, null, this.globalScope);
            var context = new TypeCollectionContext(globalChain, this);
            getAstWalkerFactory().walk(ast, preCollectTypes, postCollectTypes, null, context);
        }

        public makeArrayType(type: Type): Type {
            if (!type.arrayCache) {
                type.arrayCache = new ArrayCache();
                type.arrayCache.arrayType = new Type();
                type.arrayCache.arrayType.elementType = type;
                type.arrayCache.arrayType.symbol = type.symbol;
            }
            return type.arrayCache.arrayType;
        }

        public getParameterList(funcDecl: FuncDecl, container: Symbol): SignatureData {
            var args = funcDecl.arguments;
            var parameterTable = null;
            var parameterBuilder = null;
            var len = args.members.length;
            var nonOptionalParams = 0;
            var result: ParameterSymbol[] = [];

            if (len > 0) {
                parameterTable = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                parameterBuilder = new SymbolScopeBuilder(parameterTable, null, null, null, null, container);

                for (var i = 0; i < len; i++) {
                    var parameter = <ArgDecl>args.members[i];
                    var paramDef = new ValueLocation();
                    var parameterSymbol = new ParameterSymbol(parameter.id.text, parameter.minChar,
                                                            this.locationInfo.fileName, paramDef);
                    parameterSymbol.declAST = parameter;
                    parameterSymbol.funcDecl = funcDecl;
                    parameter.id.sym = parameterSymbol;
                    parameter.sym = parameterSymbol;
                    paramDef.symbol = parameterSymbol;
                    paramDef.typeLink = getTypeLink(parameter.typeExpr, this, false);
                    parameterBuilder.enter(null, parameter, parameterSymbol, this.errorReporter, true, false, false); // REVIEW: Should this be entered into the private scope?
                    result[result.length] = parameterSymbol;
                    if (!parameter.isOptionalArg()) {
                        nonOptionalParams++;
                    }
                }
            }
            return { parameters: result, nonOptionalParameterCount: nonOptionalParams };
        }

        // Create a signature for a function definition
        //  (E.g., has a function body - function declarations, property declarations, lambdas)
        public createFunctionSignature(funcDecl: FuncDecl, container: Symbol, scope: SymbolScope, overloadGroupSym: Symbol, addToScope: bool): Signature {

            var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported) || container === this.gloMod;
            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);
            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);
            var isDefinition = !hasFlag(funcDecl.fncFlags, FncFlags.Signature);
            var isAmbient = hasFlag(funcDecl.fncFlags, FncFlags.Ambient);
            var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;
            var isGlobal = container === this.gloMod;

            var signature: Signature = new Signature();
            var isLambda = funcDecl.fncFlags & FncFlags.IsFunctionExpression;

            // If a return type has been declared for the signature, set the type link.
            // Otherwise:
            //  if it's a signature, its type will be 'any'
            //  if it's a definition, the return type will be inferred  
            if (funcDecl.returnTypeAnnotation || isDefinition) {
                signature.returnType = getTypeLink(funcDecl.returnTypeAnnotation, this, false);
            }
            else {
                signature.returnType = new TypeLink();
                signature.returnType.type = this.anyType;
            }

            signature.hasVariableArgList = funcDecl.variableArgList;

            var sigData = this.getParameterList(funcDecl, container);

            signature.parameters = sigData.parameters;
            signature.nonOptionalParameterCount = sigData.nonOptionalParameterCount;

            funcDecl.signature = signature;
            signature.declAST = funcDecl;

            var useOverloadGroupSym =
                overloadGroupSym &&
                overloadGroupSym.getType() &&
                !overloadGroupSym.isAccessor() &&
                (funcDecl.isSignature() || (isAmbient === hasFlag(overloadGroupSym.flags, SymbolFlags.Ambient)));

            if (useOverloadGroupSym && isPrivate != hasFlag(overloadGroupSym.flags, SymbolFlags.Private)) {
                this.errorReporter.simpleError(funcDecl, "Public/Private visibility of overloads does not agree");
            }

            var groupType = useOverloadGroupSym ? overloadGroupSym.getType() : new Type();

            if (isConstructor) {
                if (groupType.construct === null) {
                    groupType.construct = new SignatureGroup();
                }
                groupType.construct.addSignature(signature);
                groupType.construct.hasImplementation = !(funcDecl.isSignature());
                if (groupType.construct.hasImplementation) {
                    groupType.setHasImplementation();
                }
            }
            else if (funcDecl.isIndexerMember()) {
                if (groupType.index === null) {
                    groupType.index = new SignatureGroup();
                    groupType.index.flags |= SignatureFlags.IsIndexer;
                }

                groupType.index.addSignature(signature);
                groupType.index.hasImplementation = !(funcDecl.isSignature());
                if (groupType.index.hasImplementation) {
                    groupType.setHasImplementation();
                }
            }
            else {
                if (groupType.call === null) {
                    groupType.call = new SignatureGroup();
                }
                groupType.call.addSignature(signature);

                groupType.call.hasImplementation = !(funcDecl.isSignature());
                if (groupType.call.hasImplementation) {
                    groupType.setHasImplementation();
                }
            }

            var instanceType = groupType.instanceType;

            // Ensure that the function's symbol is properly configured
            // (If there were overloads, we'll already have a symbol, otherwise we need to create one)
            var funcName: string = null;

            // Set the function's name:
            //  In the case of anonymous or functions resulting from error
            //  correction in the parser (isMissing() === true), we do not
            //  want to set a function name, since they shouldn't be inserted
            //  into the enclosing scope

            // usedHint prevents functions bound to object literal fields from being added to the
            // enclosing scope
            var usedHint = false;
            if (funcDecl.name && !funcDecl.name.isMissing()) {
                funcName = funcDecl.name.text;
            }
            else if (funcDecl.hint) {
                funcName = funcDecl.hint;
                usedHint = true;
            }

            if (!groupType.symbol) {
                groupType.symbol =
                    new TypeSymbol(funcName ? funcName : this.anon,
                                    funcDecl.minChar, funcDecl.limChar - funcDecl.minChar,
                                    this.locationInfo.fileName,
                                    groupType, this.compilationSettings.optimizeModuleCodeGen);
                if (!useOverloadGroupSym) {
                    groupType.symbol.declAST = funcDecl;
                }
            }

            // REVIEW: Are we missing any other flags?
            if (isStatic) {
                groupType.symbol.flags |= SymbolFlags.Static;
            }

            if (isAmbient) {
                groupType.symbol.flags |= SymbolFlags.Ambient;
            }

            if (isPrivate) {
                groupType.symbol.flags |= SymbolFlags.Private;
            }

            groupType.symbol.isMethod = funcDecl.isMethod();
            if (groupType.symbol.isMethod) {
                groupType.symbol.flags |= SymbolFlags.Property;
            }

            funcDecl.type = groupType;

            // Add the function symbol to the appropriate scope
            // if the funcDecl is a constructor, it will be added to the enclosing scope as a class
            if (!isConstructor) {
                // Add the function's symbol to its enclosing scope
                if (funcName && !isLambda && !funcDecl.isAccessor() && !usedHint) {

                    // REVIEW: We're not setting the isDecl flags for fuctions bound to object literal properties
                    // so removing the isDefiniton clause would break object literals
                    if (addToScope) {  // REVIEW: If we combine this with createFunctionDeclarationSignature, we'll need to broaden this for both decls and defs                      
                        // if it's a static method, enter directly into the container's scope
                        if (funcDecl.isMethod() && isStatic) {

                            // REVIEW: What about private statics?
                            if (!(<TypeSymbol>container).type.members.publicMembers.add(funcName, groupType.symbol)) {
                                this.errorReporter.duplicateIdentifier(funcDecl, funcName);
                            }

                            groupType.symbol.container = container;
                        } // REVIEW: Another check for overloads...
                        else if (overloadGroupSym === null || (overloadGroupSym.declAST && !(<FuncDecl>overloadGroupSym.declAST).isOverload && (container.isType()))) {
                            scope.enter(container, funcDecl, groupType.symbol, this.errorReporter, !isPrivate && (isExported || isStatic || isGlobal), false, isAmbient);
                        }
                    }
                    else if (!funcDecl.isSpecialFn()) {
                        groupType.symbol.container = container; // REVIEW: Set container for overloads or anonymous?
                    }
                }
                else if (!funcDecl.isSpecialFn()) {
                    groupType.symbol.container = container; // REVIEW: Set container for lambdas and accessors?
                }
            }

            // If, say, a call signature overload was declared before the class type was, we want to reuse
            // the type that's already been instantiated for the class type, rather than allocate a new one
            if (useOverloadGroupSym) {
                var overloadGroupType = overloadGroupSym ? overloadGroupSym.getType() : null;
                var classType = groupType;

                if (classType != overloadGroupType) {
                    if (classType.construct === null) {
                        if (overloadGroupType && overloadGroupType.construct) {
                            classType.construct = overloadGroupType.construct;
                        }
                        else {
                            classType.construct = new SignatureGroup();
                        }
                    }
                    else if (overloadGroupType) {
                        if (overloadGroupType.construct) {
                            classType.construct.signatures.concat(overloadGroupType.construct.signatures);
                        }
                    }

                    // sync call and index signatures as well, but don't allocate should they not
                    // already exist
                    if (overloadGroupType) {
                        if (classType.call === null) {
                            classType.call = overloadGroupType.call;
                        }
                        else if (overloadGroupType.call) {
                            classType.call.signatures.concat(overloadGroupType.call.signatures);
                        }

                        // if the function is not static, we need to add any call overloads onto the
                        // instance type's call signature list
                        if (!isStatic) {

                            if (classType.instanceType === null) {
                                classType.instanceType = overloadGroupType.instanceType;
                            }

                            instanceType = classType.instanceType;

                            if (instanceType) {
                                if (instanceType.call === null) {
                                    instanceType.call = overloadGroupType.call;
                                }
                                else if (overloadGroupType.call) {
                                    instanceType.call.signatures.concat(overloadGroupType.call.signatures);
                                }
                            }
                        }

                        if (classType.index === null) {
                            classType.index = overloadGroupType.index;
                        }
                        else if (overloadGroupType.index) {
                            classType.index.signatures.concat(overloadGroupType.index.signatures);
                        }
                    }
                }
            }

            return signature;
        }

        // Creates a new symbol for an accessor property
        // Note that funcDecl.type.symbol and fgSym may not be the same (E.g., in the case of type collection)
        public createAccessorSymbol(funcDecl: FuncDecl, fgSym: Symbol, enclosingClass: Type, addToMembers: bool, isClassProperty: bool, scope: SymbolScope, container: Symbol) {
            var accessorSym: FieldSymbol = null
            var sig = funcDecl.signature;
            var nameText = funcDecl.name.text;
            var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);
            var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);

            if (fgSym === null) {
                var field = new ValueLocation();
                accessorSym = new FieldSymbol(nameText, funcDecl.minChar, this.locationInfo.fileName, false, field);
                field.symbol = accessorSym;
                accessorSym.declAST = funcDecl; // REVIEW: need to reset for getters and setters

                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                    if (accessorSym.getter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");
                    }
                    accessorSym.getter = <TypeSymbol>sig.declAST.type.symbol;
                }
                else {
                    if (accessorSym.setter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");
                    }
                    accessorSym.setter = <TypeSymbol>sig.declAST.type.symbol;
                }

                field.typeLink = getTypeLink(null, this, false);

                // if it's static, enter it into the class's member list directly
                if (addToMembers) {
                    if (enclosingClass) {
                        if (!enclosingClass.members.publicMembers.add(nameText, accessorSym)) {
                            this.errorReporter.duplicateIdentifier(funcDecl, accessorSym.name);
                        }
                        accessorSym.container = enclosingClass.symbol;
                    }
                    else {
                        this.errorReporter.simpleError(funcDecl, "Accessor property may not be added in this context");
                    }
                }
                else {
                    scope.enter(container, funcDecl, accessorSym, this.errorReporter, !isPrivate || isStatic, false, false);
                }

                // We set the flags here, instead of below, because the accessor symbol does not yet have a type
                if (isClassProperty) {
                    accessorSym.flags |= SymbolFlags.Property;
                }
                if (isStatic) {
                    accessorSym.flags |= SymbolFlags.Static;
                }

                if (isPrivate) {
                    accessorSym.flags |= SymbolFlags.Private;
                }
                else {
                    accessorSym.flags |= SymbolFlags.Public;
                }
            }
            else {
                accessorSym = <FieldSymbol>(<any>fgSym);

                if (isPrivate != hasFlag(accessorSym.flags, SymbolFlags.Private)) {
                    this.errorReporter.simpleError(funcDecl, "Getter and setter accessors do not agree in visibility");
                }

                if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                    if (accessorSym.getter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property getter");
                    }
                    accessorSym.getter = <TypeSymbol>funcDecl.type.symbol;
                }
                else {
                    if (accessorSym.setter) {
                        this.errorReporter.simpleError(funcDecl, "Redeclaration of property setter");
                    }
                    accessorSym.setter = <TypeSymbol>funcDecl.type.symbol;
                }
            }

            return accessorSym;
        }

        public addBases(resultScope: SymbolAggregateScope, type: Type, baseContext: { base: string; baseId: number; }): void {
            resultScope.addParentScope(new SymbolTableScope(type.members, type.ambientMembers, type.getAllEnclosedTypes(), type.getAllAmbientEnclosedTypes(), type.symbol));
            var i = 0;
            var parent: Type;
            if (type.extendsList) {
                for (var len = type.extendsList.length; i < len; i++) {
                    parent = type.extendsList[i];
                    if (baseContext.baseId === parent.typeID) {
                        this.errorReporter.reportErrorFromSym(parent.symbol, "Type '" + baseContext.base + "' is recursively referenced as a base class of itself");
                        parent.symbol.flags |= SymbolFlags.RecursivelyReferenced;
                        break;
                    }
                    this.addBases(resultScope, parent, baseContext);
                }
            }
        }

        public scopeOf(type: Type): SymbolScope {
            var resultScope = new SymbolAggregateScope(type.symbol);
            var baseContext = { base: type.symbol && type.symbol.name ? type.symbol.name : "{}", baseId: type.typeID };
            this.addBases(resultScope, type, baseContext);
            return resultScope;
        }

        public lookupMemberTypeSymbol(containingType: Type, name: string): Symbol {
            var symbol: Symbol = null;
            if (containingType.containedScope) {
                symbol = containingType.containedScope.find(name, false, true);
            }
            else if (containingType.members) {
                symbol = containingType.members.allMembers.lookup(name);

                if (symbol === null && containingType.ambientMembers) {
                    symbol = containingType.ambientMembers.allMembers.lookup(name);
                }
            }
            if (symbol === null || !symbol.isType()) {
                var typeMembers = containingType.getAllEnclosedTypes();
                var ambientTypeMembers = containingType.getAllAmbientEnclosedTypes();
                if (typeMembers) {
                    symbol = typeMembers.allMembers.lookup(name);

                    if (symbol === null && ambientTypeMembers) {
                        symbol = ambientTypeMembers.allMembers.lookup(name);
                    }

                }
            }
            if (symbol && symbol.isType()) {
                return symbol;
            }
            else {
                return null;
            }
        }

        public findSymbolForDynamicModule(idText: string, currentFileName: string, search: (id: string) =>Symbol): Symbol {
            var originalIdText = idText;
            var symbol = search(idText);
           
            if (symbol === null) {
                // perhaps it's a dynamic module?
                if (!symbol) {
                    idText = swapQuotes(originalIdText);
                    symbol = search(idText);
                }

                // Check the literal path first
                if (!symbol) {
                    idText = stripQuotes(originalIdText) + ".ts";
                    symbol = search(idText);
                }

                // Check check for .d.str
                if (!symbol) {
                    idText = stripQuotes(originalIdText) + ".d.ts";
                    symbol = search(idText);
                }

                // If the literal path doesn't work, begin the search
                if (!symbol && !isRelative(originalIdText)) {
                    // check the full path first, as this is the most likely scenario
                    idText = originalIdText;

                    var strippedIdText = stripQuotes(idText);

                    // REVIEW: Technically, we shouldn't have to normalize here - we should normalize in addUnit.
                    // Still, normalizing here alows any language services to be free of assumptions
                    var path = getRootFilePath(switchToForwardSlashes(currentFileName));

                    while (symbol === null && path != "") {
                        idText = normalizePath(path + strippedIdText + ".ts");
                        symbol = search(idText);

                        // check for .d.ts
                        if (symbol === null) {
                            idText = changePathToDTS(idText);
                            symbol = search(idText);
                        }

                        if (symbol === null) {
                            if (path === '/') {
                                path = '';
                            } else {
                                path = normalizePath(path + "..");
                                path = path && path != '/' ? path + '/' : path;
                            }
                        }
                    }
                }
            }

            return symbol;
        }

        public resolveTypeMember(scope: SymbolScope, dotNode: BinaryExpression): Type {
            var lhs = dotNode.operand1;
            var rhs = dotNode.operand2;
            var resultType = this.anyType;
            var lhsType = this.anyType;

            if (lhs && rhs && (rhs.nodeType === NodeType.Name)) {
                if (lhs.nodeType === NodeType.Dot) {
                    lhsType = this.resolveTypeMember(scope, <BinaryExpression>lhs);
                }
                else if (lhs.nodeType === NodeType.Name) {
                    var identifier = <Identifier>lhs;
                    var symbol = scope.find(identifier.text, false, true);
                    if (symbol === null) {
                        this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);
                    }
                    else if (symbol.isType()) {

                        var typeSymbol = <TypeSymbol> symbol;

                        if (typeSymbol.aliasLink && !typeSymbol.type && typeSymbol.aliasLink.alias.nodeType === NodeType.Name) {
                            var modPath = (<Identifier>typeSymbol.aliasLink.alias).text;
                            var modSym = this.findSymbolForDynamicModule(modPath, this.locationInfo.fileName, (id) => scope.find(id, false, true));
                            if (modSym) {
                                typeSymbol.type = modSym.getType();
                            }
                        }

                        if (this.compilationSettings.optimizeModuleCodeGen && symbol) {
                            var symType = symbol.getType();
                            // Once the type has been referenced outside of a type ref position, there's
                            // no going back                        
                            if (symType && typeSymbol.aliasLink && typeSymbol.onlyReferencedAsTypeRef) {

                                var modDecl = <ModuleDeclaration>symType.symbol.declAST;
                                if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic)) {
                                    typeSymbol.onlyReferencedAsTypeRef = !this.resolvingBases;
                                }
                            }
                        }
                        if (!symbol.visible(scope, this)) {
                            this.errorReporter.simpleError(lhs, "The symbol '" + identifier.actualText + "' is not visible at this point");
                        }
                        lhsType = symbol.getType();

                        identifier.sym = symbol;
                    }
                    else {
                        this.errorReporter.simpleError(lhs, "Expected type");
                    }

                }

                // if the LHS type is a module alias, we won't be able to resolve it until
                // typecheck type.  If this is called during binding, lhsType will be null
                if (!lhsType) {
                    lhsType = this.anyType;
                }

                if (lhsType != this.anyType) {
                    var rhsIdentifier = <Identifier>rhs;
                    var resultSymbol = this.lookupMemberTypeSymbol(lhsType, rhsIdentifier.text);
                    if (resultSymbol === null) {
                        resultType = this.anyType;
                        this.errorReporter.simpleError(dotNode, "Expected type");
                    }
                    else {
                        resultType = resultSymbol.getType();
                        if (!resultSymbol.visible(scope, this)) {
                            this.errorReporter.simpleError(lhs, "The symbol '" + (<Identifier>rhs).actualText + "' is not visible at this point");
                        }
                    }
                    rhsIdentifier.sym = resultType.symbol;
                }
            }
            if (resultType.isClass()) {
                resultType = resultType.instanceType;
            }
            return resultType;
        }

        public resolveFuncDecl(funcDecl: FuncDecl, scope: SymbolScope,
            fgSym: TypeSymbol): Symbol {
            var functionGroupSymbol = this.createFunctionSignature(funcDecl, scope.container, scope, fgSym, false).declAST.type.symbol;
            var signatures: Signature[];
            if (funcDecl.isConstructMember()) {
                signatures = functionGroupSymbol.type.construct.signatures;
            }
            else if (funcDecl.isIndexerMember()) {
                signatures = functionGroupSymbol.type.getInstanceType().index.signatures;
            }
            else {
                signatures = functionGroupSymbol.type.call.signatures;
            }

            var signature = signatures[signatures.length - 1];
            var len = signature.parameters.length;
            for (var i = 0; i < len; i++) {
                var paramSym: ParameterSymbol = signature.parameters[i];
                this.resolveTypeLink(scope, paramSym.parameter.typeLink, true);
            }

            // If a vararg list is present, check that the type is an array type
            if (len && funcDecl.variableArgList) {
                if (!signature.parameters[len - 1].parameter.typeLink.type.elementType) {
                    this.errorReporter.simpleErrorFromSym(signature.parameters[len - 1].parameter.symbol, "... parameter must have array type");
                    signature.parameters[len - 1].parameter.typeLink.type = this.makeArrayType(signature.parameters[len - 1].parameter.typeLink.type);
                }
            }
            this.resolveTypeLink(scope, signature.returnType,
                            funcDecl.isSignature());
            return functionGroupSymbol;
        }

        public resolveVarDecl(varDecl: VarDecl, scope: SymbolScope): Symbol {
            var field = new ValueLocation();
            var fieldSymbol =
                new FieldSymbol(varDecl.id.text, varDecl.minChar, this.locationInfo.fileName,
                                (varDecl.varFlags & VarFlags.Readonly) === VarFlags.None,
                                field);
            fieldSymbol.transferVarFlags(varDecl.varFlags);
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = varDecl;
            field.typeLink = getTypeLink(varDecl.typeExpr, this, varDecl.init === null);
            this.resolveTypeLink(scope, field.typeLink, true);
            varDecl.sym = fieldSymbol;
            varDecl.type = field.typeLink.type;
            return fieldSymbol;
        }

        public resolveTypeLink(scope: SymbolScope, typeLink: TypeLink, supplyVar: bool): void {
            var arrayCount = 0;
            if (typeLink.type === null) {
                var ast: AST = typeLink.ast;
                if (ast) {
                    while (typeLink.type === null) {
                        switch (ast.nodeType) {
                            case NodeType.Name:
                                var identifier = <Identifier>ast;
                                var symbol = scope.find(identifier.text, false, true);
                                if (symbol === null) {
                                    typeLink.type = this.anyType;
                                    this.errorReporter.unresolvedSymbol(identifier, identifier.actualText);
                                }
                                else if (symbol.isType()) {
                                    if (!symbol.visible(scope, this)) {
                                        this.errorReporter.simpleError(ast, "The symbol '" + identifier.actualText + "' is not visible at this point");
                                    }
                                    identifier.sym = symbol;
                                    typeLink.type = symbol.getType();
                                    if (typeLink.type) {
                                        if (typeLink.type.isClass()) {
                                            typeLink.type = typeLink.type.instanceType;
                                        }
                                    }
                                    else {
                                        typeLink.type = this.anyType;
                                    }
                                }
                                else {
                                    typeLink.type = this.anyType;
                                    this.errorReporter.simpleError(ast, "Expected type");
                                }
                                break;
                            case NodeType.Dot:
                                typeLink.type = this.resolveTypeMember(scope, <BinaryExpression>ast);
                                break;
                            case NodeType.TypeRef:
                                var typeRef = <TypeReference>ast;
                                arrayCount = typeRef.arrayCount;
                                ast = typeRef.term;
                                if (ast === null) {
                                    typeLink.type = this.anyType;
                                }
                                break;
                            case NodeType.InterfaceDeclaration:
                                var interfaceDecl = <InterfaceDeclaration>ast;
                                var interfaceType = new Type();
                                var interfaceSymbol = new TypeSymbol((<Identifier>interfaceDecl.name).text,
                                                                   ast.minChar,
                                                                   ast.limChar - ast.minChar,
                                                                   this.locationInfo.fileName,
                                                                   interfaceType, this.compilationSettings.optimizeModuleCodeGen);
                                interfaceType.symbol = interfaceSymbol;
                                interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));

                                interfaceType.containedScope =
                                    new SymbolTableScope(interfaceType.members, null, null, null,
                                                         interfaceSymbol);

                                interfaceType.containedScope.container = interfaceSymbol;
                                interfaceType.memberScope = interfaceType.containedScope;

                                var memberList = <ASTList>interfaceDecl.members;
                                var props: AST[] = memberList.members;
                                var propsLen = props.length;

                                for (var j = 0; j < propsLen; j++) {
                                    var propDecl = props[j];
                                    var propSym: Symbol = null;
                                    var addMember = true;
                                    var id: Identifier = null;
                                    if (propDecl.nodeType === NodeType.FuncDecl) {
                                        var funcDecl = <FuncDecl>propDecl;
                                        id = funcDecl.name;
                                        propSym = interfaceType.members.allMembers.lookup(funcDecl.getNameText());
                                        addMember = (propSym === null);
                                        if (funcDecl.isSpecialFn()) {
                                            addMember = false;
                                            propSym = this.resolveFuncDecl(funcDecl, scope, interfaceSymbol);
                                        }
                                        else {
                                            propSym = this.resolveFuncDecl(funcDecl, scope, <TypeSymbol>propSym);
                                        }
                                        funcDecl.type = (<TypeSymbol>propSym).type;
                                    }
                                    else {
                                        id = (<VarDecl>propDecl).id;
                                        propSym = this.resolveVarDecl(<VarDecl>propDecl, scope);

                                        // Don't add the member if it was missing a name.  This 
                                        // generally just leads to cascading errors that make things
                                        // more confusing for the user.
                                        addMember = !id.isMissing();
                                    }

                                    if (addMember) {
                                        if (id && hasFlag(id.flags, ASTFlags.OptionalName)) {
                                            propSym.flags |= SymbolFlags.Optional;
                                        }
                                        if (!interfaceType.members.allMembers.add(propSym.name, propSym)) {
                                            this.errorReporter.duplicateIdentifier(ast, propSym.name);
                                        }
                                    }
                                }

                                ast.type = interfaceType;
                                typeLink.type = interfaceType;

                                break;
                            case NodeType.FuncDecl:
                                var tsym = <TypeSymbol>this.resolveFuncDecl(<FuncDecl>ast, scope, null);
                                typeLink.type = tsym.type;
                                break;
                            default:
                                typeLink.type = this.anyType;
                                this.errorReporter.simpleError(ast, "Expected type");
                                break;
                        }
                    }
                }
                for (var count = arrayCount; count > 0; count--) {
                    typeLink.type = this.makeArrayType(typeLink.type);
                }
                if (supplyVar && (typeLink.type === null)) {
                    typeLink.type = this.anyType;
                }
                if (typeLink.ast) {
                    typeLink.ast.type = typeLink.type;
                }
            }
            // else wait for type inference
        }

        public resolveBaseTypeLink(typeLink: TypeLink, scope: SymbolScope) {
            this.resolvingBases = true;
            this.resolveTypeLink(scope, typeLink, true);
            this.resolvingBases = false;
            var extendsType: Type = null;
            if (typeLink.type.isClass()) {
                extendsType = typeLink.type.instanceType;
            }
            else {
                extendsType = typeLink.type;
            }

            return extendsType;
        }

        public findMostApplicableSignature(signatures: ApplicableSignature[], args: ASTList): { sig: Signature; ambiguous: bool; } {

            if (signatures.length === 1) {
                return { sig: signatures[0].signature, ambiguous: false };
            }

            var best: ApplicableSignature = signatures[0];
            var Q: ApplicableSignature = null;
            var AType: Type = null;
            var PType: Type = null;
            var QType: Type = null;
            var ambiguous = false;

            for (var qSig = 1; qSig < signatures.length; qSig++) {
                Q = signatures[qSig];
                var i = 0;
                // find the better conversion
                for (i = 0; args && i < args.members.length; i++) {
                    AType = args.members[i].type;
                    PType = i < best.signature.parameters.length ? best.signature.parameters[i].getType() : best.signature.parameters[best.signature.parameters.length - 1].getType().elementType;
                    QType = i < Q.signature.parameters.length ? Q.signature.parameters[i].getType() : Q.signature.parameters[Q.signature.parameters.length - 1].getType().elementType;

                    if (this.typesAreIdentical(PType, QType)) {
                        continue;
                    }
                    else if (this.typesAreIdentical(AType, PType)) {
                        break;
                    }
                    else if (this.typesAreIdentical(AType, QType)) {
                        best = Q;
                        break;
                    }
                    else if (this.sourceIsSubtypeOfTarget(PType, QType)) {
                        break;
                    }
                    else if (this.sourceIsSubtypeOfTarget(QType, PType)) {
                        best = Q;
                        break;
                    }
                    else if (Q.hadProvisionalErrors) {
                        break;
                    }
                    else if (best.hadProvisionalErrors) {
                        best = Q;
                        break;
                    }
                }

                if (!args || i === args.members.length) {
                    var collection: ITypeCollection = {
                        getLength: () => { return 2; },
                        setTypeAtIndex: (index: number, type: Type) => { }, // no contextual typing here, so no need to do anything
                        getTypeAtIndex: (index: number) => { return index ? Q.signature.returnType.type : best.signature.returnType.type; } // we only want the "second" type - the "first" is skipped
                    }
                    var bct = this.findBestCommonType(best.signature.returnType.type, null, collection, true);
                    ambiguous = !bct;
                }
                else {
                    ambiguous = false;
                }
            }

            return { sig: best.signature, ambiguous: ambiguous };
        }

        public getApplicableSignatures(signatures: Signature[], args: ASTList, comparisonInfo: TypeComparisonInfo): ApplicableSignature[] {

            var applicableSigs: ApplicableSignature[] = [];
            var memberType: Type = null;
            var miss = false;
            var cxt: ContextualTypeContext = null;
            var hadProvisionalErrors = false;

            for (var i = 0; i < signatures.length; i++) {
                miss = false;

                for (var j = 0; j < args.members.length; j++) {

                    if (j >= signatures[i].parameters.length) {
                        continue;
                    }
                    memberType = signatures[i].parameters[j].getType();

                    // account for varargs
                    if (signatures[i].declAST.variableArgList && (j >= signatures[i].nonOptionalParameterCount - 1) && memberType.isArray()) {
                        memberType = memberType.elementType;
                    }

                    if (memberType === this.anyType) {
                        continue;
                    }
                    else if (args.members[j].nodeType === NodeType.FuncDecl) {
                        if (this.typeFlow.functionInterfaceType && memberType === this.typeFlow.functionInterfaceType) {
                            continue;
                        }
                        if (!this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], true)) {
                            // if it's just annotations that are blocking us, typecheck the function and add it to the list
                            if (this.canContextuallyTypeFunction(memberType, <FuncDecl>args.members[j], false)) {
                                this.typeFlow.typeCheck(args.members[j]);
                                if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                                    break;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        else { // if it can be contextually typed, try it out...

                            this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                            this.cleanStartedPTO();
                            hadProvisionalErrors = this.hadProvisionalErrors();

                            if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                                if (comparisonInfo) {
                                    comparisonInfo.setMessage("Could not apply type '" + memberType.getTypeName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                                }
                                miss = true;
                            }

                            // clean the type
                            //if (hadProvisionalErrors) {
                            //    cxt = this.currentContextualTypeContext;
                            //    this.typeCheckWithContextualType(null, true, true, args.members[j]);
                            //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {
                            //        miss = true;
                            //    }
                            //    this.cleanStartedPTO();
                            //}

                            this.resetProvisionalErrors();
                            if (miss) {
                                break;
                            }
                        }
                    }
                    else if (args.members[j].nodeType === NodeType.ObjectLit) {
                        // now actually attempt to typecheck as the contextual type
                        if (this.typeFlow.objectInterfaceType && memberType === this.typeFlow.objectInterfaceType) {
                            continue;
                        }

                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                        this.cleanStartedPTO();
                        hadProvisionalErrors = this.hadProvisionalErrors(); 

                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.getTypeName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                            }
                            miss = true;
                        }

                        // clean the type
                        //if (hadProvisionalErrors) {
                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);

                        //    // is the "cleaned" type even assignable?
                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {
                        //        miss = true;
                        //    }

                        //    this.cleanStartedPTO();
                        //}

                        this.resetProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    }
                    else if (args.members[j].nodeType === NodeType.ArrayLit) {
                        // attempt to contextually type the array literal
                        if (this.typeFlow.arrayInterfaceType && memberType === this.typeFlow.arrayInterfaceType) {
                            continue;
                        }

                        this.typeCheckWithContextualType(memberType, true, true, args.members[j]);
                        this.cleanStartedPTO();
                        hadProvisionalErrors = this.hadProvisionalErrors(); 

                        if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.getTypeName() + "' to argument " + (j + 1) + ", which is of type '" + args.members[j].type.getTypeName() + "'");
                            }
                            break;
                        }

                        // clean the type
                        //if (hadProvisionalErrors) {
                        //    this.typeCheckWithContextualType(null, true, true, args.members[j]);
                        //    if (!this.sourceIsAssignableToTarget(args.members[j].type, memberType)) {
                        //        miss = true;
                        //    }

                        //    this.cleanStartedPTO();
                        //}

                        this.resetProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    }
                }

                if (j === args.members.length) {
                    applicableSigs[applicableSigs.length] = { signature: signatures[i], hadProvisionalErrors: hadProvisionalErrors };
                }
                hadProvisionalErrors = false;
            }

            return applicableSigs;
        }

        public canContextuallyTypeFunction(candidateType: Type, funcDecl: FuncDecl, beStringent: bool): bool {

            // in these cases, we do not attempt to apply a contextual type
            //  RE: isInlineCallLiteral - if the call target is a function literal, we don't want to apply the target type
            //  to its body - instead, it should be applied to its return type
            if (funcDecl.isParenthesized ||
                funcDecl.isMethod() ||
                beStringent && funcDecl.returnTypeAnnotation ||
                funcDecl.isInlineCallLiteral) {
                return false;
            }

            beStringent = beStringent || (this.typeFlow.functionInterfaceType === candidateType);

            // At this point, if we're not being stringent, there's no need to check for multiple call sigs
            // or count parameters - we just want to unblock typecheck
            if (!beStringent) {
                return true;
            }

            // If we're coming from an in-scope typecheck, lambdas may not have had function signatures created for them
            // REVIEW: Should we search out the overload group here?
            if (!funcDecl.signature) {
                this.createFunctionSignature(funcDecl, this.typeFlow.scope.container, this.typeFlow.scope, null, null);
                this.typeFlow.typeCheck(funcDecl);
            }

            var signature = funcDecl.signature;
            var paramLen = signature.parameters.length;

            // Check that the argument declarations have no type annotations
            for (var i = 0; i < paramLen; i++) {
                var param = signature.parameters[i];
                var symbol = <ParameterSymbol>param;
                var argDecl = <ArgDecl>symbol.declAST;

                // REVIEW: a valid typeExpr is a requirement for varargs,
                // so we may want to revise our invariant
                if (beStringent && argDecl.typeExpr) {
                    return false;
                }
            }

            if (candidateType.construct && candidateType.call) {
                return false;
            }

            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;

            if (!candidateSigs || candidateSigs.signatures.length > 1) {
                return false;
            }

            // if we're here, the contextual type can be applied to the function
            return true;
        }

        public canContextuallyTypeObjectLiteral(targetType: Type, objectLit: UnaryExpression): bool {

            if (targetType === this.typeFlow.objectInterfaceType) {
                return true;
            }

            var memberDecls = <ASTList>objectLit.operand;

            if (!(memberDecls && targetType.memberScope)) {
                return false;
            }

            var id: AST = null;
            var targetMember: Symbol = null;
            var text = "";
            var foundSyms = {};
            var i = 0;

            // Check that each property in the object literal is present in the target
            // type
            for (i = 0; i < memberDecls.members.length; i++) {
                id = (<BinaryExpression>memberDecls.members[i]).operand1;

                if (id.nodeType === NodeType.Name) {
                    text = (<Identifier>id).text;
                }
                else if (id.nodeType === NodeType.QString) {
                    // TODO: set text to unescaped string
                    var idText = (<StringLiteral>id).text;
                    text = idText.substring(1, idText.length - 1);
                }
                else {
                    return false;
                }

                targetMember = targetType.memberScope.find(text, true, false);

                if (!targetMember) {
                    return false;
                }

                foundSyms[text] = true;
            }

            // Check that all members in the target type are present in the object literal
            var targetMembers = targetType.memberScope.getAllValueSymbolNames(true);

            for (i = 0; i < targetMembers.length; i++) {
                var memberName = targetMembers[i];
                var memberSym = targetType.memberScope.find(memberName, true, false);

                if (!foundSyms[targetMembers[i]] &&
                    !hasFlag(memberSym.flags, SymbolFlags.Optional)) {
                    return false;
                }
            }

            return true;
        }

        public widenType(t: Type) {
            if (t === this.undefinedType || t === this.nullType) { // REVIEW: not isNullOrUndefinedType for perf reasons
                return this.anyType;
            }

            return t;
        }

        public isNullOrUndefinedType(t: Type) {
            return t === this.undefinedType || t === this.nullType;
        }

        public findBestCommonType(initialType: Type, targetType: Type, collection: ITypeCollection, acceptVoid:bool, comparisonInfo?: TypeComparisonInfo) {
            var i = 0;
            var len = collection.getLength();
            var nlastChecked = 0;
            var bestCommonType = initialType;

            if (targetType) {
                bestCommonType = bestCommonType ? bestCommonType.mergeOrdered(targetType, this, acceptVoid) : targetType;
            }

            // it's important that we set the convergence type here, and not in the loop,
            // since the first element considered may be the contextual type
            var convergenceType: Type = bestCommonType;

            while (nlastChecked < len) {

                for (i = 0; i < len; i++) {

                    // no use in comparing a type against itself
                    if (i === nlastChecked) {
                        continue;
                    }

                    if (convergenceType && (bestCommonType = convergenceType.mergeOrdered(collection.getTypeAtIndex(i), this, acceptVoid, comparisonInfo))) {
                        convergenceType = bestCommonType;
                    }

                    if (bestCommonType === this.anyType || bestCommonType === null) {
                        break;
                    }
                    else if (targetType) { // set the element type to the target type
                        collection.setTypeAtIndex(i, targetType);
                    }
                }

                // use the type if we've agreed upon it
                if (convergenceType && bestCommonType) {
                    break;
                }

                nlastChecked++;
                if (nlastChecked < len) {
                    convergenceType = collection.getTypeAtIndex(nlastChecked);
                }
            }

            return acceptVoid ? bestCommonType : (bestCommonType === this.voidType ? null : bestCommonType);
        }

        // Type Identity

        public typesAreIdentical(t1: Type, t2: Type) {

            // This clause will cover both primitive types (since the type objects are shared),
            // as well as shared brands
            if (t1 === t2) {
                return true;
            }

            if (!t1 || !t2) {
                return false;
            }

            if (t1.isClass() || t1.isClassInstance()) {
                return false;
            }

            var comboId = (t2.typeID << 16) | t1.typeID;

            if (this.identicalCache[comboId]) {
                return true;
            }

            // If one is an enum, and they're not the same type, they're not identical
            if ((t1.typeFlags & TypeFlags.IsEnum) || (t2.typeFlags & TypeFlags.IsEnum)) {
                return false;
            }

            if (t1.isArray() || t2.isArray()) {
                if (!(t1.isArray() && t2.isArray())) {
                    return false;
                }
                this.identicalCache[comboId] = false;
                var ret = this.typesAreIdentical(t1.elementType, t2.elementType);
                if (ret) {
                    this.subtypeCache[comboId] = true;
                }
                else {
                    this.subtypeCache[comboId] = undefined;
                }

                return ret;
            }

            if (t1.primitiveTypeClass != t2.primitiveTypeClass) {
                return false;
            }

            this.identicalCache[comboId] = false;

            // properties are identical in name, optionality, and type
            // REVIEW: TypeChanges - The compiler does not currently check against the members of parent types!
            // REVIEW: TypeChanges - What about ambientMembers?
            if (t1.memberScope && t2.memberScope) {
                var t1MemberKeys = t1.memberScope.getAllValueSymbolNames(true).sort();
                var t2MemberKeys = t2.memberScope.getAllValueSymbolNames(true).sort();

                if (t1MemberKeys.length != t2MemberKeys.length) {
                    this.identicalCache[comboId] = undefined;
                    return false;
                }

                var t1MemberSymbol: Symbol = null;
                var t2MemberSymbol: Symbol = null;

                var t1MemberType: Type = null;
                var t2MemberType: Type = null;

                for (var iMember = 0; iMember < t1MemberKeys.length; iMember++) {
                    if (t1MemberKeys[iMember] != t2MemberKeys[iMember]) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }

                    t1MemberSymbol = <Symbol>t1.memberScope.find(t1MemberKeys[iMember], false, false);
                    t2MemberSymbol = <Symbol>t2.memberScope.find(t2MemberKeys[iMember], false, false);

                    if ((t1MemberSymbol.flags & SymbolFlags.Optional) != (t2MemberSymbol.flags & SymbolFlags.Optional)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }

                    t1MemberType = t1MemberSymbol.getType();
                    t2MemberType = t2MemberSymbol.getType();

                    // catch the mutually recursive or cached cases
                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.typeID << 16) | t1MemberType.typeID] != undefined)) {
                        continue;
                    }

                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                }
            }
            else if (t1.memberScope || t2.memberScope) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1.call, t2.call)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1.construct, t2.construct)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1.index, t2.index)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            this.identicalCache[comboId] = true;
            return true;
        }

        public signatureGroupsAreIdentical(sg1: SignatureGroup, sg2: SignatureGroup) {

            // covers the null case
            if (sg1 === sg2) {
                return true;
            }

            // covers the mixed-null case
            if (!sg1 || !sg2) {
                return false;
            }

            if (sg1.signatures.length != sg2.signatures.length) {
                return false;
            }

            var sig1: Signature = null;
            var sig2: Signature = null;
            var sigsMatch = false;

            // The signatures in the signature group may not be ordered...
            // REVIEW: Should definition signatures be required to be identical as well?
            for (var iSig1 = 0; iSig1 < sg1.signatures.length; iSig1++) {
                sig1 = sg1.signatures[iSig1];

                for (var iSig2 = 0; iSig2 < sg2.signatures.length; iSig2++) {
                    sig2 = sg2.signatures[iSig2];

                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }

                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }

                // no match found for a specific signature
                return false;
            }

            return true;
        }

        public signaturesAreIdentical(s1: Signature, s2: Signature) {

            if (s1.hasVariableArgList != s2.hasVariableArgList) {
                return false;
            }

            if (s1.nonOptionalParameterCount != s2.nonOptionalParameterCount) {
                return false;
            }

            if (s1.parameters.length != s2.parameters.length) {
                return false;
            }

            if (!this.typesAreIdentical(s1.returnType.type, s2.returnType.type)) {
                return false;
            }

            for (var iParam = 0; iParam < s1.parameters.length; iParam++) {
                if (!this.typesAreIdentical(s1.parameters[iParam].parameter.typeLink.type, s2.parameters[iParam].parameter.typeLink.type)) {
                    return false;
                }
            }

            return true;
        }

        // Subtyping and Assignment compatibility

        public sourceIsSubtypeOfTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, comparisonInfo); }
        public signatureGroupIsSubtypeOfTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, comparisonInfo); }
        public signatureIsSubtypeOfTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, comparisonInfo); }

        public sourceIsAssignableToTarget(source: Type, target: Type, comparisonInfo?: TypeComparisonInfo) { return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, comparisonInfo); }
        public signatureGroupIsAssignableToTarget(sg1: SignatureGroup, sg2: SignatureGroup, comparisonInfo?: TypeComparisonInfo) { return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, comparisonInfo); }
        public signatureIsAssignableToTarget(s1: Signature, s2: Signature, comparisonInfo?: TypeComparisonInfo) { return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, comparisonInfo); }

        public sourceIsRelatableToTarget(source: Type, target: Type, assignableTo: bool, comparisonCache: any, comparisonInfo: TypeComparisonInfo) {

            // REVIEW: Does this check even matter?
            //if (this.typesAreIdentical(source, target)) {
            //    return true;
            //}
            if (source === target) {
                return true;
            }

            // An error has already been reported in this case
            if (!(source && target)) {
                return true;
            }

            var comboId = (source.typeID << 16) | target.typeID;

            // In the case of a 'false', we want to short-circuit a recursive typecheck
            if (comparisonCache[comboId] != undefined) {
                return true;
            }

            // this is one difference between subtyping and assignment compatibility
            if (assignableTo) {
                if (source === this.anyType || target === this.anyType) {
                    return true;
                }
            }
            else {
                // This is one difference between assignment compatibility and subtyping
                if (target === this.anyType) {
                    return true;
                }
            }

            if (source === this.undefinedType) {
                return true;
            }

            if ((source === this.nullType) && (target != this.undefinedType && target != this.voidType)) {
                return true;
            }

            // REVIEW: enum types aren't explicitly covered in the spec
            if (target === this.numberType && (source.typeFlags & TypeFlags.IsEnum)) {
                return true;
            }
            if (source === this.numberType && (target.typeFlags & TypeFlags.IsEnum)) {
                return true;
            }
            if ((source.typeFlags & TypeFlags.IsEnum) || (target.typeFlags & TypeFlags.IsEnum)) {
                return false;
            }

            if (source.isArray() || target.isArray()) {
                if (!(source.isArray() && target.isArray())) {
                    return false;
                }
                comparisonCache[comboId] = false;
                var ret = this.sourceIsRelatableToTarget(source.elementType, target.elementType, assignableTo, comparisonCache, comparisonInfo);
                if (ret) {
                    comparisonCache[comboId] = true;
                }
                else {
                    comparisonCache[comboId] = undefined;
                }

                return ret;
            }

            // this check ensures that we only operate on object types from this point forward,
            // since the checks involving primitives occurred above
            if (source.primitiveTypeClass != target.primitiveTypeClass) {

                if (target.primitiveTypeClass === Primitive.None) {
                    if (source === this.numberType && this.typeFlow.numberInterfaceType) {
                        source = this.typeFlow.numberInterfaceType;
                    }
                    else if (source === this.stringType && this.typeFlow.stringInterfaceType) {
                        source = this.typeFlow.stringInterfaceType;
                    }
                    else if (source === this.booleanType && this.typeFlow.booleanInterfaceType) {
                        source = this.typeFlow.booleanInterfaceType;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }

            comparisonCache[comboId] = false;

            if (source.hasBase(target)) {
                comparisonCache[comboId] = true;
                return true;
            }

            if (this.typeFlow.objectInterfaceType && target === this.typeFlow.objectInterfaceType) {
                return true;
            }

            if (this.typeFlow.functionInterfaceType && (source.call || source.construct) && target === this.typeFlow.functionInterfaceType) {
                return true;
            }

            // REVIEW: We should perhaps do this, though it wouldn't be quite right without generics support
            //if (this.typeFlow.arrayInterfaceType && (source.index) && target === this.typeFlow.arrayInterfaceType) {
            //    return true;
            //}

            // At this point, if the target is a class, but not the source or a parent of the source, bail
            if (target.isClass() || target.isClassInstance()) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (target.memberScope && source.memberScope) {
                var mPropKeys = target.memberScope.getAllValueSymbolNames(true);
                var mProp: Symbol = null;
                var nProp: Symbol = null;
                var mPropType: Type = null;
                var nPropType: Type = null;
                var inferenceSymbol: InferenceSymbol = null;

                for (var iMProp = 0; iMProp < mPropKeys.length; iMProp++) {
                    mProp = target.memberScope.find(mPropKeys[iMProp], false, false);
                    nProp = source.memberScope.find(mPropKeys[iMProp], false, false);

                    // methods do not have the "arguments" field
                    if (mProp.name === "arguments" &&
                        this.typeFlow.iargumentsInterfaceType &&
                        (this.typeFlow.iargumentsInterfaceType.symbol.flags & SymbolFlags.CompilerGenerated) &&
                        mProp.kind() === SymbolKind.Variable &&
                        (<VariableSymbol>mProp).variable.typeLink.type === this.typeFlow.iargumentsInterfaceType) {
                        continue;
                    }

                    if (mProp.isInferenceSymbol()) {
                        inferenceSymbol = <InferenceSymbol>mProp;
                        if (inferenceSymbol.typeCheckStatus === TypeCheckStatus.NotStarted) {
                            // REVIEW: TypeChanges: Does this ever really happen?  Maybe for out-of-order typecheck?
                            this.typeFlow.typeCheck(mProp.declAST);
                        }
                    }
                    mPropType = mProp.getType();

                    if (!nProp) {
                        // If it's not present on the type in question, look for the property on 'Object'
                        if (this.typeFlow.objectInterfaceType) {
                            nProp = this.typeFlow.objectInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);
                        }

                        if (!nProp) {
                            // Now, the property was not found on Object, but the type in question is a function, look
                            // for it on function
                            if (this.typeFlow.functionInterfaceType && (mPropType.call || mPropType.construct)) {
                                nProp = this.typeFlow.functionInterfaceType.memberScope.find(mPropKeys[iMProp], false, false);
                            }

                            // finally, check to see if the property is optional
                            if (!nProp) {
                                if (!(mProp.flags & SymbolFlags.Optional)) {
                                    comparisonCache[comboId] = undefined;
                                    if (comparisonInfo) { // only surface the first error
                                        comparisonInfo.flags |= TypeRelationshipFlags.RequiredPropertyIsMissing;
                                        comparisonInfo.addMessageToFront("Type '" + source.getTypeName() + "' is missing property '" + mPropKeys[iMProp] + "' from type '" + target.getTypeName() + "'");
                                    }
                                    return false;
                                }
                                else {
                                    continue;
                                }
                            }
                        }
                    }

                    if (nProp.isInferenceSymbol()) {
                        inferenceSymbol = <InferenceSymbol>nProp;
                        if (inferenceSymbol.typeCheckStatus === TypeCheckStatus.NotStarted) {
                            this.typeFlow.typeCheck(nProp.declAST);
                        }
                    }


                    nPropType = nProp.getType();

                    // catch the mutually recursive or cached cases
                    if (mPropType && nPropType && (comparisonCache[(nPropType.typeID << 16) | mPropType.typeID] != undefined)) {
                        continue;
                    }

                    if (!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, comparisonInfo)) {
                        comparisonCache[comboId] = undefined;
                        if (comparisonInfo) { // only surface the first error
                            comparisonInfo.flags |= TypeRelationshipFlags.IncompatiblePropertyTypes;
                            comparisonInfo.addMessageToFront("Types of property '" + mProp.name + "' of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        }
                        return false;
                    }
                }
            }

            // check signature groups
            var hasSig: string;
            var lacksSig: string;
            
            if (source.call || target.call) {
                if (!this.signatureGroupIsRelatableToTarget(source.call, target.call, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (source.call && target.call) {
                            comparisonInfo.addMessageToFront("Call signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        }
                        else {
                            hasSig = target.call ? target.getTypeName() : source.getTypeName();
                            lacksSig = !target.call ? target.getTypeName() : source.getTypeName();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a call signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            if (source.construct || target.construct) {
                if (!this.signatureGroupIsRelatableToTarget(source.construct, target.construct, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (source.construct && target.construct) {
                            comparisonInfo.addMessageToFront("Construct signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        }
                        else {
                            hasSig = target.construct ? target.getTypeName() : source.getTypeName();
                            lacksSig = !target.construct ? target.getTypeName() : source.getTypeName();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a construct signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            if (target.index) {
                var targetIndex = !target.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : target.index;
                var sourceIndex = !source.index && this.typeFlow.objectInterfaceType ? this.typeFlow.objectInterfaceType.index : source.index;

                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.addMessageToFront("Index signatures of types '" + source.getTypeName() + "' and '" + target.getTypeName() + "' are incompatible");
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            comparisonCache[comboId] = true;
            return true;
        }

        // REVIEW: TypeChanges: Return an error context object so the user can get better diagnostic info
        public signatureGroupIsRelatableToTarget(sourceSG: SignatureGroup, targetSG: SignatureGroup, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {
            if (sourceSG === targetSG) {
                return true;
            }

            if (!(sourceSG && targetSG)) {
                return false;
            }

            var mSig: Signature = null;
            var nSig: Signature = null;
            var foundMatch = false;

            for (var iMSig = 0; iMSig < targetSG.signatures.length; iMSig++) {
                mSig = targetSG.signatures[iMSig];

                for (var iNSig = 0; iNSig < sourceSG.signatures.length; iNSig++) {
                    nSig = sourceSG.signatures[iNSig];
                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, comparisonInfo)) {
                        foundMatch = true;
                        break;
                    }
                }

                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }

            return true;
        }

        public signatureIsRelatableToTarget(sourceSig: Signature, targetSig: Signature, assignableTo: bool, comparisonCache: any, comparisonInfo?: TypeComparisonInfo) {

            if (!sourceSig.parameters || !targetSig.parameters) {
                return false;
            }

            var targetVarArgCount = targetSig.hasVariableArgList ? targetSig.nonOptionalParameterCount - 1 : targetSig.nonOptionalParameterCount;
            var sourceVarArgCount = sourceSig.hasVariableArgList ? sourceSig.nonOptionalParameterCount - 1 : sourceSig.nonOptionalParameterCount;

            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableArgList) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= TypeRelationshipFlags.SourceSignatureHasTooManyParameters;
                    comparisonInfo.addMessageToFront("Call signature expects " + targetVarArgCount + " or fewer parameters");
                }
                return false;
            }

            var sourceReturnType = sourceSig.returnType.type;
            var targetReturnType = targetSig.returnType.type;

            if (targetReturnType != this.voidType) {
                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleReturnTypes;
                        // No need to print this one here - it's printed as part of the signature error in sourceIsRelatableToTarget
                        //comparisonInfo.addMessageToFront("Incompatible return types: '" + sourceReturnType.getTypeName() + "' and '" + targetReturnType.getTypeName() + "'");
                    }
                    return false;
                }
            }

            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableArgList) ? targetVarArgCount : sourceVarArgCount;
            var sourceParamType: Type = null;
            var targetParamType: Type = null;
            var sourceParamName = "";
            var targetParamName = "";

            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {

                if (!sourceSig.hasVariableArgList || iSource < sourceVarArgCount) {
                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;
                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;
                }
                else if (iSource === sourceVarArgCount) {
                    sourceParamType = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.typeLink.type;
                    if (sourceParamType.elementType) {
                        sourceParamType = sourceParamType.elementType;
                    }
                    sourceParamName = (<ParameterSymbol>sourceSig.parameters[iSource]).parameter.symbol.name;
                }

                if (iTarget < targetSig.parameters.length && iTarget < targetVarArgCount) {
                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;
                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;
                }
                else if (targetSig.hasVariableArgList && iTarget === targetVarArgCount) {
                    targetParamType = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.typeLink.type;
                    if (targetParamType.elementType) {
                        targetParamType = targetParamType.elementType;
                    }
                    targetParamName = (<ParameterSymbol>targetSig.parameters[iTarget]).parameter.symbol.name;
                }

                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, comparisonInfo) ||
                        this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, comparisonInfo))) {

                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleParameterTypes;
                    }
                    return false;
                }
            }
            return true;
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class Continuation {
        public exceptionBlock = -1;
        constructor (public normalBlock: number) { }
    }

    function getBaseTypeLinks(bases: ASTList, baseTypeLinks: TypeLink[]) {
        if (bases) {
            var len = bases.members.length;
            if (!baseTypeLinks) {
                baseTypeLinks = [];
            }
            for (var i = 0; i < len; i++) {
                var baseExpr = bases.members[i];
                var name = baseExpr;
                var typeLink = new TypeLink();
                typeLink.ast = name;
                baseTypeLinks[baseTypeLinks.length] = typeLink;
            }
        }
        return baseTypeLinks;
    }

    function getBases(type: Type, typeDecl: TypeDeclaration) {
        type.extendsTypeLinks = getBaseTypeLinks(typeDecl.extendsList, type.extendsTypeLinks);
        type.implementsTypeLinks = getBaseTypeLinks(typeDecl.implementsList, type.implementsTypeLinks);
    }

    function addPrototypeField(classType: Type, ast: AST, context: TypeCollectionContext) {
        var field = new ValueLocation();
        field.typeLink = new TypeLink();
        field.typeLink.ast = ast;
        field.typeLink.type = classType.instanceType;

        var fieldSymbol =
            new FieldSymbol("prototype", ast.minChar,
                            context.checker.locationInfo.fileName, true, field);
        fieldSymbol.flags |= (SymbolFlags.Property | SymbolFlags.BuiltIn);
        field.symbol = fieldSymbol;
        fieldSymbol.declAST = ast;
        classType.members.addPublicMember("prototype", fieldSymbol);
    }

    export function createNewConstructGroupForType(type: Type) {
        var signature = new Signature();
        signature.returnType = new TypeLink();
        signature.returnType.type = type.instanceType;
        signature.parameters = [];

        type.construct = new SignatureGroup();
        type.construct.addSignature(signature);     
    }

    export function cloneParentConstructGroupForChildType(child: Type, parent: Type) {
        child.construct = new SignatureGroup();
        var sig: Signature = null;

        if (!parent.construct) {
            createNewConstructGroupForType(parent);
        }

        for (var i = 0; i < parent.construct.signatures.length; i++) { 
            sig = new Signature();
            sig.parameters = parent.construct.signatures[i].parameters;
            sig.nonOptionalParameterCount = parent.construct.signatures[i].nonOptionalParameterCount;
            sig.typeCheckStatus = parent.construct.signatures[i].typeCheckStatus;
            sig.declAST = parent.construct.signatures[i].declAST;
            sig.returnType = new TypeLink();
            sig.returnType.type = child.instanceType;
            child.construct.addSignature(sig);
        }

    }

    export var globalId = "__GLO";

    export interface IAliasScopeContext {
        topLevelScope: ScopeChain;
        members: IHashTable;
        tcContext: TypeCollectionContext;
    }

    function findTypeSymbolInScopeChain(name: string, scopeChain: ScopeChain): Symbol {
        var symbol = scopeChain.scope.find(name, false, true);

        if (symbol === null && scopeChain.previous) {
            symbol = findTypeSymbolInScopeChain(name, scopeChain.previous);
        }

        return symbol;
    }

    function findSymbolFromAlias(alias: AST, context: IAliasScopeContext): Symbol {
        var symbol: Symbol = null;
        switch (alias.nodeType) {
            case NodeType.Name:
                var name = (<Identifier>alias).text;
                var isDynamic = isQuoted(name);

                var findSym = (id: string) => {
                    if (context.members) {
                        return context.members.lookup(name);
                    }
                    else {
                        return findTypeSymbolInScopeChain(name, context.topLevelScope);
                    }
                }

                if (isDynamic) {
                    symbol = context.tcContext.checker.findSymbolForDynamicModule(name, context.tcContext.script.locationInfo.fileName, findSym);
                }
                else {
                    symbol = findSym(name);
                }

                break;

            case NodeType.Dot:
                var dottedExpr = <BinaryExpression>alias;
                var op1Sym = findSymbolFromAlias(dottedExpr.operand1, context);

                if (op1Sym && op1Sym.getType()) {
                    symbol = findSymbolFromAlias(dottedExpr.operand2, context);
                }

                break;

            default:
                break;
        }

        if (symbol) {
            var symType = symbol.getType();
            if (symType) {
                var members = symType.members;
                if (members) {
                    context.members = members.publicMembers;
                }
            }
        }

        return symbol;
    }

    export function preCollectImportTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;
        var typeSymbol: TypeSymbol = null;
        var modType: ModuleType = null;
        var importDecl = <ImportDeclaration>ast;

        // REVIEW: technically, this call isn't strictly necessary, since we'll find the type during the call to resolveTypeMembers
        var aliasedModSymbol = findSymbolFromAlias(importDecl.alias, { topLevelScope: scopeChain, members: null, tcContext: context });
        var isGlobal = context.scopeChain.container === context.checker.gloMod;

        if (aliasedModSymbol) {
            var aliasedModType = aliasedModSymbol.getType();

            if (aliasedModType) {
                modType = <ModuleType>aliasedModType;
            }
        }

        typeSymbol = new TypeSymbol(importDecl.id.text, importDecl.id.minChar, importDecl.limChar - importDecl.minChar,
                                    context.checker.locationInfo.fileName, modType, context.checker.compilationSettings.optimizeModuleCodeGen);

        typeSymbol.aliasLink = importDecl;

        if (context.scopeChain.moduleDecl) {
            typeSymbol.flags |= SymbolFlags.ModuleMember;
            typeSymbol.declModule = context.scopeChain.moduleDecl;
        }

        typeSymbol.declAST = importDecl;
        importDecl.id.sym = typeSymbol;
        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,
                                context.checker.errorReporter, isGlobal, true, false);
        scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,
                                context.checker.errorReporter, isGlobal, false, false);
        return true;
    }

    export function preCollectModuleTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;

        var moduleDecl: ModuleDeclaration = <ModuleDeclaration>ast;

        var isAmbient = hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient);
        var isEnum = hasFlag(moduleDecl.modFlags, ModuleFlags.IsEnum);
        var isGlobal = context.scopeChain.container === context.checker.gloMod;
        var isExported = hasFlag(moduleDecl.modFlags, ModuleFlags.Exported);
        var modName = (<Identifier>moduleDecl.name).text;

        var isDynamic = isQuoted(modName);

        var symbol = scopeChain.scope.findLocal(modName, false, false);
        var typeSymbol: TypeSymbol = null;
        var modType: ModuleType = null;

        if (symbol && symbol.declAST && symbol.declAST.nodeType != NodeType.ModuleDeclaration) {
            context.checker.errorReporter.simpleError(moduleDecl, "Conflicting symbol name for module '" + modName + "'");
            // Create a new type symbol for the module but keep it anonyms
            symbol = null;
            modName = "";
        }

        if (symbol) {
            var modDeclAST = <ModuleDeclaration>symbol.declAST;
            var modDeclASTIsExported = hasFlag(modDeclAST.modFlags, ModuleFlags.Exported);
            if ((modDeclASTIsExported && !isExported) || (!modDeclASTIsExported && isExported)) {
                context.checker.errorReporter.simpleError(moduleDecl, 'All contributions to a module must be "export" or none');
            }
        }
        
        var enclosedTypes: ScopedMembers = null;
        var ambientEnclosedTypes: ScopedMembers = null;

        if ((symbol === null) || (symbol.kind() != SymbolKind.Type)) {

            if (modType === null) {
                enclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);
                if (isEnum) {
                    modType.typeFlags |= TypeFlags.IsEnum;
                }
                modType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                modType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                modType.setHasImplementation();
            }

            typeSymbol = new TypeSymbol(modName, moduleDecl.name.minChar, modName.length,
                                        context.checker.locationInfo.fileName, modType, context.checker.compilationSettings.optimizeModuleCodeGen);
            typeSymbol.isDynamic = isQuoted(moduleDecl.prettyName);

            if (context.scopeChain.moduleDecl) {
                typeSymbol.declModule = context.scopeChain.moduleDecl;
            }
            typeSymbol.declAST = moduleDecl;
            typeSymbol.prettyName = moduleDecl.prettyName;
            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,
                                    context.checker.errorReporter, isExported || isGlobal, true, isAmbient);
            scopeChain.scope.enter(scopeChain.container, ast, typeSymbol,
                                    context.checker.errorReporter, isExported || isGlobal, false, isAmbient);
            modType.symbol = typeSymbol;
        }
        else {
            typeSymbol = <TypeSymbol>symbol;

            // initialize new private scope for the type
            var publicEnclosedTypes = typeSymbol.type.getAllEnclosedTypes().publicMembers;
            var publicEnclosedTypesTable = (publicEnclosedTypes === null) ? new StringHashTable() : publicEnclosedTypes;
            enclosedTypes = new ScopedMembers(new DualStringHashTable(publicEnclosedTypesTable, new StringHashTable()));

            var publicEnclosedAmbientTypes = typeSymbol.type.getAllAmbientEnclosedTypes().publicMembers;
            var publicAmbientEnclosedTypesTable = (publicEnclosedAmbientTypes === null) ? new StringHashTable() : publicEnclosedAmbientTypes;
            ambientEnclosedTypes = new ScopedMembers(new DualStringHashTable(publicAmbientEnclosedTypesTable, new StringHashTable()));

            var publicMembers = typeSymbol.type.members.publicMembers;
            var publicMembersTable = (publicMembers === null) ? new StringHashTable() : publicMembers;
            var members = new ScopedMembers(new DualStringHashTable(publicMembersTable, new StringHashTable()));

            var publicAmbientMembers = typeSymbol.type.ambientMembers.publicMembers;
            var publicAmbientMembersTable = (publicAmbientMembers === null) ? new StringHashTable() : publicAmbientMembers;
            var ambientMembers = new ScopedMembers(new DualStringHashTable(publicAmbientMembersTable, new StringHashTable()));

            modType = new ModuleType(enclosedTypes, ambientEnclosedTypes);
            if (isEnum) {
                modType.typeFlags |= TypeFlags.IsEnum;
            }
            modType.members = members;
            modType.ambientMembers = ambientMembers;
            modType.setHasImplementation();
            modType.symbol = typeSymbol;

            typeSymbol.addLocation(moduleDecl.minChar);
            typeSymbol.expansions.push(modType);
            typeSymbol.expansionsDeclAST.push(moduleDecl);

        }
        if (context.scopeChain.moduleDecl) {
            context.scopeChain.moduleDecl.recordNonInterface();
        }
        // REVIEW: If multiple disparate module decls for the same module don't agree
        // in export privileges, how should we handle it?
        if (isExported) {
            typeSymbol.flags |= SymbolFlags.Exported;
        }
        if ((context.scopeChain.moduleDecl) ||
            (context.scopeChain.container === context.checker.gloMod)) {
            typeSymbol.flags |= SymbolFlags.ModuleMember;
        }

        moduleDecl.mod = modType;
        pushTypeCollectionScope(typeSymbol, modType.members,
                                modType.ambientMembers,
                                modType.enclosedTypes,
                                modType.ambientEnclosedTypes,
                                context, null, null, moduleDecl);

        return true;
    }

    export function preCollectClassTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;
        var classDecl = <ClassDeclaration>ast;

        var classType: Type;
        var instanceType: Type;
        var typeSymbol: TypeSymbol = null;
        var className = (<Identifier>classDecl.name).text;
        var alreadyInScope = false;
        var isAmbient = hasFlag(classDecl.varFlags, VarFlags.Ambient);
        var isExported = hasFlag(classDecl.varFlags, VarFlags.Exported);
        var isGlobal = context.scopeChain.container === context.checker.gloMod;
        var containerMod = <TypeSymbol>scopeChain.container;
        var foundValSymbol = false;

        typeSymbol = <TypeSymbol>scopeChain.scope.findLocal(className, false, true);
        
        // check the value space, since an override may have been declared with the type's name
        // REVIEW-CLASSES
        if (!typeSymbol) {
            var valTypeSymbol = scopeChain.scope.findLocal(className, false, false);
            
            if (valTypeSymbol &&
                valTypeSymbol.isType() &&
                valTypeSymbol.declAST &&
                valTypeSymbol.declAST.nodeType === NodeType.FuncDecl &&
                (<FuncDecl>valTypeSymbol.declAST).isSignature()) {
                
                typeSymbol = <TypeSymbol>valTypeSymbol;
                foundValSymbol = true;
                
                if (isExported) {
                    typeSymbol.flags |= SymbolFlags.Exported;
                }
            
                if (isAmbient) {
                    typeSymbol.flags |= SymbolFlags.Ambient;
                }                
                
                // the class was never entered into type space, so add it
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,
                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);                
            }
        }
        
        if (typeSymbol && !foundValSymbol && (typeSymbol.declAST != classDecl)) {
            typeSymbol = null;
        }

        if (typeSymbol === null) {
            var valueSymbol = scopeChain.scope.findLocal(className, false, false);
            classType = new Type();
            classType.setHasImplementation();
            instanceType = new Type();
            instanceType.setHasImplementation();
            classType.instanceType = instanceType;
            classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            addPrototypeField(classType, classDecl, context);
            instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            instanceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            typeSymbol = new TypeSymbol(className, classDecl.name.minChar, className.length,
                                        context.checker.locationInfo.fileName, classType, context.checker.compilationSettings.optimizeModuleCodeGen);
            typeSymbol.declAST = classDecl;
            typeSymbol.instanceType = instanceType;
            classType.symbol = typeSymbol;
            instanceType.symbol = typeSymbol;

            if (context.scopeChain.moduleDecl) {
                context.scopeChain.moduleDecl.recordNonInterface();
                typeSymbol.declModule = context.scopeChain.moduleDecl;
                typeSymbol.flags |= SymbolFlags.ModuleMember;
            }

            if (isExported) {
                typeSymbol.flags |= SymbolFlags.Exported;
            }
            
            if (isAmbient) {
                typeSymbol.flags |= SymbolFlags.Ambient;
            }

            ast.type = classType;

            // class in both name spaces (type for instance type; constructor representative in value space)
            context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,
                                            context.checker.errorReporter, isExported || isGlobal, true, isAmbient);

            if (valueSymbol === null) {
                context.scopeChain.scope.enter(context.scopeChain.container, ast, typeSymbol,
                                            context.checker.errorReporter, isExported || isGlobal, false, isAmbient);
            }
        }
        else {                            
            classType = typeSymbol.type;
            
            // If the instance type is null, a call overload was likely declared before the class constructor
            if (classType.instanceType === null) {
                classType.instanceType = new Type();
                classType.instanceType.setHasImplementation();
                classType.instanceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                classType.instanceType.symbol = classType.symbol;
                classType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                classType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            }
            
            instanceType = classType.instanceType;
            ast.type = classType;
        }
        
        // if the class has no declared constructor, either create a default signature or adapt 
        // it's base class's signature group
        if (!classDecl.constructorDecl) {

            if (typeSymbol && typeSymbol.declAST && typeSymbol.declAST.type && typeSymbol.declAST.type.call && !(<FuncDecl>typeSymbol.declAST).isOverload) {
                context.checker.errorReporter.duplicateIdentifier(typeSymbol.declAST, typeSymbol.name);
            }

            createNewConstructGroupForType(classDecl.type);
        }

        classType.typeFlags |= TypeFlags.IsClass;
        instanceType.typeFlags |= TypeFlags.IsClass;

        getBases(instanceType, classDecl);
        pushTypeCollectionScope(typeSymbol, instanceType.members, instanceType.ambientMembers, null, null,
                                context, instanceType, classType, null);
        return true;
    }

    export function preCollectInterfaceTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;
        var interfaceDecl = <InterfaceDeclaration>ast;
        var interfaceSymbol: TypeSymbol = null;
        var interfaceType: Type = null;
        var isExported = hasFlag(interfaceDecl.varFlags, VarFlags.Exported);
        var isGlobal = context.scopeChain.container === context.checker.gloMod;
        var alreadyInScope = true;

        alreadyInScope = false;
        var interfaceName = (<Identifier>interfaceDecl.name).text;
        interfaceSymbol = <TypeSymbol>scopeChain.scope.findLocal(interfaceName, false, true);
        if (interfaceSymbol === null) {
            interfaceType = new Type();
            interfaceSymbol = new TypeSymbol(interfaceName,
                                        interfaceDecl.name.minChar,
                                        interfaceName.length,
                                        context.checker.locationInfo.fileName,
                                        interfaceType, context.checker.compilationSettings.optimizeModuleCodeGen);
            interfaceType.symbol = interfaceSymbol;
            // REVIEW: Shouldn't allocate another table for interface privates
            interfaceType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            interfaceType.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            interfaceSymbol.declAST = interfaceDecl;
            interfaceSymbol.declModule = context.scopeChain.moduleDecl;
        }
        else {
            alreadyInScope = true;
            interfaceType = interfaceSymbol.type;
        }

        if (!interfaceType) {
            interfaceType = context.checker.anyType;
        }

        ast.type = interfaceType;
        getBases(interfaceType, interfaceDecl);

        if (isExported) {
            interfaceSymbol.flags |= SymbolFlags.Exported;
        }

        if (context.scopeChain.moduleDecl) {
            interfaceSymbol.flags |= SymbolFlags.ModuleMember;
        }

        if (!alreadyInScope) {
            context.scopeChain.scope.enter(context.scopeChain.container, ast,
                                            interfaceSymbol, context.checker.errorReporter, isGlobal || isExported, true, false); // REVIEW: Technically, interfaces should be ambient
        }
        pushTypeCollectionScope(interfaceSymbol, interfaceType.members, interfaceType.ambientMembers, null, null,
                                context, interfaceType, null, null);
        return true;
    }

    export function preCollectArgDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;
        var argDecl = <ArgDecl>ast;
        if (hasFlag(argDecl.varFlags, VarFlags.Public | VarFlags.Private)) {
            var field = new ValueLocation();
            var isPrivate = hasFlag(argDecl.varFlags, VarFlags.Private);
            var fieldSymbol =
                new FieldSymbol(argDecl.id.text, argDecl.id.minChar,
                                context.checker.locationInfo.fileName,
                                !hasFlag(argDecl.varFlags, VarFlags.Readonly),
                                field);
            fieldSymbol.transferVarFlags(argDecl.varFlags);
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = ast;
            argDecl.parameterPropertySym = fieldSymbol;

            context.scopeChain.scope.enter(context.scopeChain.container, ast,
                                            fieldSymbol, context.checker.errorReporter, !isPrivate, false, false);

            field.typeLink = getTypeLink(argDecl.typeExpr, context.checker, argDecl.init === null);
            argDecl.sym = fieldSymbol;
        }
        return false;
    }

    export function preCollectVarDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;
        var varDecl = <VarDecl>ast;
        var isAmbient = hasFlag(varDecl.varFlags, VarFlags.Ambient);
        var isExported = hasFlag(varDecl.varFlags, VarFlags.Exported);
        var isGlobal = context.scopeChain.container === context.checker.gloMod;
        var isProperty = hasFlag(varDecl.varFlags, VarFlags.Property);
        var isStatic = hasFlag(varDecl.varFlags, VarFlags.Static);
        var isPrivate = hasFlag(varDecl.varFlags, VarFlags.Private);
        var isOptional = hasFlag(varDecl.id.flags, ASTFlags.OptionalName);

        if (context.scopeChain.moduleDecl) {
            context.scopeChain.moduleDecl.recordNonInterface();
        }
        if (isProperty ||
            isExported ||
            (context.scopeChain.container === context.checker.gloMod) ||
            context.scopeChain.moduleDecl) {
            if (isAmbient) {
                var existingSym =
                    <FieldSymbol>scopeChain.scope.findLocal(varDecl.id.text, false, false);
                if (existingSym) {
                    varDecl.sym = existingSym;
                    return false;
                }
            }

            // Defensive error detection...
            if (varDecl.id === null) {
                context.checker.errorReporter.simpleError(varDecl, "Expected variable identifier at this location");
                return false;
            }

            var field = new ValueLocation();
            var fieldSymbol =
                new FieldSymbol(varDecl.id.text, varDecl.id.minChar,
                                context.checker.locationInfo.fileName,
                                (varDecl.varFlags & VarFlags.Readonly) === VarFlags.None,
                                field);
            fieldSymbol.transferVarFlags(varDecl.varFlags);
            if (isOptional) {
                fieldSymbol.flags |= SymbolFlags.Optional;
            }
            field.symbol = fieldSymbol;
            fieldSymbol.declAST = ast;
            if ((context.scopeChain.moduleDecl) ||
                (context.scopeChain.container === context.checker.gloMod)) {
                fieldSymbol.flags |= SymbolFlags.ModuleMember;
                fieldSymbol.declModule = context.scopeChain.moduleDecl;
            }

            // if it's static, enter it into the class's member list directly
            if (hasFlag(varDecl.varFlags, VarFlags.Property) && isStatic && context.scopeChain.classType) {
                if (!context.scopeChain.classType.members.publicMembers.add(varDecl.id.text, fieldSymbol)) {
                    context.checker.errorReporter.duplicateIdentifier(ast, fieldSymbol.name);
                }
                fieldSymbol.container = context.scopeChain.classType.symbol;
            }
            else {
                context.scopeChain.scope.enter(context.scopeChain.container,
                                                ast,
                                                fieldSymbol,
                                                context.checker.errorReporter,
                                                !isPrivate && (isProperty || isExported || isGlobal || isStatic),
                                                false,
                                                isAmbient);
            }

            if (hasFlag(varDecl.varFlags, VarFlags.Exported)) {
                fieldSymbol.flags |= SymbolFlags.Exported;
            }

            field.typeLink = getTypeLink(varDecl.typeExpr, context.checker,
                                        varDecl.init === null);
            varDecl.sym = fieldSymbol;
        }
        return false;
    }

    export function preCollectFuncDeclTypes(ast: AST, parent: AST, context: TypeCollectionContext) {
        var scopeChain = context.scopeChain;

        // REVIEW: This will have to change when we move to "export"
        if (context.scopeChain.moduleDecl) {
            context.scopeChain.moduleDecl.recordNonInterface();
        }

        var funcDecl = <FuncDecl>ast;
        var fgSym: TypeSymbol = null;
        var nameText = funcDecl.getNameText();
        var isExported = hasFlag(funcDecl.fncFlags, FncFlags.Exported | FncFlags.ClassPropertyMethodExported);
        var isStatic = hasFlag(funcDecl.fncFlags, FncFlags.Static);
        var isPrivate = hasFlag(funcDecl.fncFlags, FncFlags.Private);
        var isConstructor = funcDecl.isConstructMember() || funcDecl.isConstructor;
        var containerSym:TypeSymbol = <TypeSymbol> (((funcDecl.isMethod() && isStatic) || funcDecl.isAccessor()) && context.scopeChain.classType ? context.scopeChain.classType.symbol : context.scopeChain.container);
        var containerScope: SymbolScope = context.scopeChain.scope;
        var isGlobal = containerSym === context.checker.gloMod;
        var isOptional = funcDecl.name && hasFlag(funcDecl.name.flags, ASTFlags.OptionalName);
        var go = false;
        var foundSymbol = false; 

        // If this is a class constructor, the "container" is actually the class declaration
        if (isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
            containerSym = <TypeSymbol>containerSym.container;
            containerScope = scopeChain.previous.scope;
        }

        funcDecl.fileName = context.checker.locationInfo.fileName;
        
        // If the parent is the constructor, and this isn't an instance method, skip it.
        // That way, we'll set the type during scope assignment, and can be sure that the
        // function will be placed in the constructor-local scope
        if (!funcDecl.isConstructor &&
            containerSym &&
            containerSym.declAST &&
            containerSym.declAST.nodeType === NodeType.FuncDecl &&
            (<FuncDecl>containerSym.declAST).isConstructor &&
            !funcDecl.isMethod()) {
            return go;
        }        

        // Interfaces and overloads
        if (hasFlag(funcDecl.fncFlags, FncFlags.Signature)) {
            var instType = context.scopeChain.thisType;                       

            // If the function is static, search in the class type's
            if (nameText && nameText != "__missing") {
                if (isStatic) {
                    fgSym = containerSym.type.members.allMembers.lookup(nameText);
                }
                else {
                    // REVIEW: This logic should be symmetric with preCollectClassTypes
                    fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);
                    
                    // If we could not find the function symbol in the value context, look
                    // in the type context.
                    // This would be the case, for example, if a class constructor override
                    // were declared before a call override for a given class
                    if (fgSym === null) {
                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, true);
                    }
                }
                
                if (fgSym) {
                    foundSymbol = true;
                    
                    // We'll combine ambient and non-ambient funcdecls during typecheck (for contextual typing).,
                    // So, if they don't agree, don't use the symbol we've found                    
                    if (!funcDecl.isSignature() && (hasFlag(funcDecl.fncFlags, FncFlags.Ambient) != hasFlag(fgSym.flags, SymbolFlags.Ambient))) {
                       fgSym = null;
                    }
                }                
            }
            
            // a function with this symbol has not yet been declared in this scope
            // REVIEW: In the code below, we need to ensure that only function overloads are considered
            //  (E.g., if a vardecl has the same id as a function or class, we may use the vardecl symbol
            //  as the overload.)  Defensively, however, the vardecl won't have a type yet, so it should
            //  suffice to just check for a null type when considering the overload symbol in
            //  createFunctionSignature
            if (fgSym === null) {
                if (!(funcDecl.isSpecialFn())) {                    
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, null, !foundSymbol).declAST.type.symbol;
                }
                else {
                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, containerSym, false).declAST.type.symbol;                                                                         
                }
                
                // set the symbol's declAST, which will point back to the first declaration (symbol or otherwise)
                // related to this symbol
                if (fgSym.declAST === null || !funcDecl.isSpecialFn()) {
                    fgSym.declAST = ast;
                }
            }
            else { // there exists a symbol with this name
                
                if ((fgSym.kind() === SymbolKind.Type)) {

                    fgSym = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, false).declAST.type.symbol;
                }
                else {
                    context.checker.errorReporter.simpleError(funcDecl, "Function or method '" + funcDecl.name.actualText + "' already declared as a property");
                }
            }
         
            if (funcDecl.isSpecialFn() && !isStatic) {
                funcDecl.type = instType ? instType : fgSym.type; 
            }
            else {
                funcDecl.type = fgSym.type;
            }            
        }
        else {
            // declarations
            
            if (nameText) {
                if (isStatic) {
                    fgSym = containerSym.type.members.allMembers.lookup(nameText);
                }
                else {
                    // in the constructor case, we want to check the parent scope for overloads
                    if (funcDecl.isConstructor && context.scopeChain.previous) {
                        fgSym = <TypeSymbol>context.scopeChain.previous.scope.findLocal(nameText, false, false);
                    }
                    
                    if (fgSym === null) {
                        fgSym = <TypeSymbol>containerScope.findLocal(nameText, false, false);
                    }
                }
                if (fgSym) {
                    foundSymbol = true;
                    
                    if (!isConstructor && fgSym.declAST.nodeType === NodeType.FuncDecl && !(<FuncDecl>fgSym.declAST).isAccessor() && !(<FuncDecl>fgSym.declAST).isSignature()) {
                        fgSym = null;
                        foundSymbol = false;
                    }
                }                
            }

            // REVIEW: Move this check into the typecheck phase?  It's only being run over properties...
            if (fgSym &&
                !fgSym.isAccessor() &&
                fgSym.type &&
                fgSym.type.construct &&
                fgSym.type.construct.signatures != [] &&
                (fgSym.type.construct.signatures[0].declAST === null ||
                    !hasFlag(fgSym.type.construct.signatures[0].declAST.fncFlags, FncFlags.Ambient)) &&
                !funcDecl.isConstructor) {
                context.checker.errorReporter.simpleError(funcDecl, "Functions may not have class overloads");
            }

            if (fgSym && !(fgSym.kind() === SymbolKind.Type) && funcDecl.isMethod() && !funcDecl.isAccessor() && !funcDecl.isConstructor) {
                context.checker.errorReporter.simpleError(funcDecl, "Function or method '" + funcDecl.name.actualText + "' already declared as a property");
                fgSym.type = context.checker.anyType;
            }
            // If the current function is accessor and the existing symbol isnt, set the symbol to null so
            // we could error about duplicate symbol
            if (fgSym && !fgSym.isAccessor() && funcDecl.isAccessor()) {
                fgSym = null;
            }
            var sig = context.checker.createFunctionSignature(funcDecl, containerSym, containerScope, fgSym, !foundSymbol);

            // it's a getter or setter function                                   
            if (((!fgSym || fgSym.declAST.nodeType != NodeType.FuncDecl) && funcDecl.isAccessor()) || (fgSym && fgSym.isAccessor())) {
                funcDecl.accessorSymbol = context.checker.createAccessorSymbol(funcDecl, fgSym, containerSym.type, (funcDecl.isMethod() && isStatic), true, containerScope, containerSym);
            }

            funcDecl.type.symbol.declAST = ast;
            if (funcDecl.isConstructor) { // REVIEW: Remove when classes completely replace oldclass
                go = true;
            };
        }
        if (isExported) {
            if (funcDecl.type.call) {
                funcDecl.type.symbol.flags |= SymbolFlags.Exported;
            }
            
            // Accessors are set to 'exported' above
            if (fgSym && !fgSym.isAccessor() && fgSym.kind() === SymbolKind.Type && fgSym.type.call) {
                fgSym.flags |= SymbolFlags.Exported;
            }
        }
        if (context.scopeChain.moduleDecl && !funcDecl.isSpecialFn()) {
            funcDecl.type.symbol.flags |= SymbolFlags.ModuleMember;
            funcDecl.type.symbol.declModule = context.scopeChain.moduleDecl;
        }

        if (fgSym && isOptional) {
            fgSym.flags |= SymbolFlags.Optional;
        }

        return go;
    }

    export function preCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {
        var context: TypeCollectionContext = walker.state;
        var go = false;
        var scopeChain = context.scopeChain;

        if (ast.nodeType === NodeType.Script) {
            var script: Script = <Script>ast;
            context.script = script;
            go = true;
        }
        else if (ast.nodeType === NodeType.List) {
            go = true;
        }
        else if (ast.nodeType === NodeType.ImportDeclaration) {
            go = preCollectImportTypes(ast, parent, context);
        }
        else if (ast.nodeType === NodeType.With) {
            go = false;
        }
        else if (ast.nodeType === NodeType.ModuleDeclaration) {
            go = preCollectModuleTypes(ast, parent, context);
        }
        else if (ast.nodeType === NodeType.ClassDeclaration) {
            go = preCollectClassTypes(ast, parent, context);
        }
        else if (ast.nodeType === NodeType.Block) {
            go = true;
        }
        else if (ast.nodeType === NodeType.InterfaceDeclaration) {
            go = preCollectInterfaceTypes(ast, parent, context);
        }
        // This will be a constructor arg because this pass only traverses
        // constructor arg lists
        else if (ast.nodeType === NodeType.ArgDecl) {
            go = preCollectArgDeclTypes(ast, parent, context);
        }
        else if (ast.nodeType === NodeType.VarDecl) {
            go = preCollectVarDeclTypes(ast, parent, context);
        }
        else if (ast.nodeType === NodeType.FuncDecl) {
            go = preCollectFuncDeclTypes(ast, parent, context);
        }
        else {
            if (ast.isStatementOrExpression() && context.scopeChain.moduleDecl) {
                context.scopeChain.moduleDecl.recordNonInterface();
            }
        }
        walker.options.goChildren = go;
        return ast;
    }

    export function postCollectTypes(ast: AST, parent: AST, walker: IAstWalker) {
        var context: TypeCollectionContext = walker.state;

        if (ast.nodeType === NodeType.ModuleDeclaration) {
            popTypeCollectionScope(context);
        }
        else if (ast.nodeType === NodeType.ClassDeclaration) {
            popTypeCollectionScope(context);
        }
        else if (ast.nodeType === NodeType.InterfaceDeclaration) {
            popTypeCollectionScope(context);
        }
        return ast;
    }

}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class ScopeChain {
        public thisType: Type;
        public classType: Type;
        public fnc: FuncDecl;
        public moduleDecl: ModuleDeclaration;

        constructor(public container: Symbol, public previous: ScopeChain,
                     public scope: SymbolScope) { }
    }

    export class BBUseDefInfo {
        public defsBySymbol: bool[] = [];
        public gen: BitVector;
        public kill: BitVector;
        public top: BitVector;
        // use lists by symbol 
        public useIndexBySymbol: number[][] = [];

        constructor(public bb: BasicBlock) { }

        public updateTop() {
            var temp = new BitVector(this.top.bitCount);
            for (var i = 0, succLen = this.bb.successors.length; i < succLen; i++) {
                var succ = this.bb.successors[i];
                if (succ.useDef) {
                    temp.union(succ.useDef.top);
                }
            }
            temp.difference(this.kill);
            temp.union(this.gen);
            var changed = temp.notEq(this.top);
            this.top = temp;
            return changed;
        }


        public initialize(useDefContext: UseDefContext) {
            var defSym = (sym: Symbol, context: UseDefContext) => {
                if (context.isLocalSym(sym)) {
                    var index = context.getSymbolIndex(sym);
                    // clear pending uses
                    this.useIndexBySymbol[index] = [];
                    this.defsBySymbol[index] = true;
                }
            }

            var useSym = (sym: Symbol, context: UseDefContext, ast: AST) => {
                if (context.isLocalSym(sym)) {
                    var symIndex = context.getSymbolIndex(sym);
                    if (this.useIndexBySymbol[symIndex] === undefined) {
                        this.useIndexBySymbol[symIndex] = [];
                    }
                    var symUses = this.useIndexBySymbol[symIndex];
                    var astIndex = context.getUseIndex(ast);
                    context.addUse(symIndex, astIndex);
                    symUses.push(astIndex);
                }
            }

            function initUseDefPre(cur: AST, parent: AST, walker: IAstWalker) {
                var context: UseDefContext = walker.state;
                var asg: BinaryExpression;
                var id: Identifier;

                if (cur === null) {
                    cur = null;
                }
                if (cur.nodeType === NodeType.VarDecl) {
                    var varDecl = <BoundDecl>cur;
                    if (varDecl.init || hasFlag(varDecl.varFlags, VarFlags.AutoInit)) {
                        defSym(varDecl.sym, context);
                    }
                }
                else if (cur.nodeType === NodeType.Name) {
                    // use
                    if (parent) {
                        if (parent.nodeType === NodeType.Asg) {
                            asg = <BinaryExpression>parent;
                            if (asg.operand1 === cur) {
                                return cur;
                            }
                        }
                        else if (parent.nodeType === NodeType.VarDecl) {
                            var parentDecl = <BoundDecl>parent;
                            if (parentDecl.id === cur) {
                                return cur;
                            }
                        }
                    }
                    id = <Identifier>cur;
                    useSym(id.sym, context, cur);
                }
                else if ((cur.nodeType >= NodeType.Asg) && (cur.nodeType <= NodeType.LastAsg)) {
                    // def
                    asg = <BinaryExpression>cur;
                    if (asg.operand1 && (asg.operand1.nodeType === NodeType.Name)) {
                        id = <Identifier>asg.operand1;
                        defSym(id.sym, context);
                    }
                }
                else if (cur.nodeType === NodeType.FuncDecl) {
                    walker.options.goChildren = false;
                }

                return cur;
            }

            var options = new AstWalkOptions();
            // traverse ASTs in reverse order of execution (to match uses with preceding defs)
            options.reverseSiblings = true;

            getAstWalkerFactory().walk(this.bb.content, initUseDefPre, null, options, useDefContext);
        }

        public initializeGen(useDefContext: UseDefContext) {
            var symbolLen = this.useIndexBySymbol.length;
            var bitCount = useDefContext.uses.length;
            this.gen = new BitVector(bitCount);
            for (var s = 0; s < symbolLen; s++) {
                var symUses = this.useIndexBySymbol[s];
                if ((symUses !== undefined) && (symUses.length > 0)) {
                    for (var u = 0, uLen = symUses.length; u < uLen; u++) {
                        this.gen.set(symUses[u], true);
                    }
                }
            }
            this.top = this.gen;
        }

        public initializeKill(useDefContext: UseDefContext) {
            this.kill = new BitVector(this.gen.bitCount);
            for (var s = 0, symbolLen = this.defsBySymbol.length; s < symbolLen; s++) {
                if (this.defsBySymbol[s]) {
                    var globalSymUses = useDefContext.useIndexBySymbol[s];
                    if (globalSymUses) {
                        for (var u = 0, useLen = globalSymUses.length; u < useLen; u++) {
                            this.kill.set(globalSymUses[u], true);
                        }
                    }
                }
            }
        }
    }

    export class UseDefContext {
        // global use lists by symbol
        public useIndexBySymbol: number[][] = [];
        // global list of uses (flat)
        public uses: AST[] = [];
        public symbols: VariableSymbol[] = [];
        public symbolMap = new StringHashTable();
        public symbolCount = 0;
        public func: Symbol;

        constructor() {
        }

        public getSymbolIndex(sym: Symbol) {
            var name = sym.name;
            var index = <number>(this.symbolMap.lookup(name));
            if (index === null) {
                index = this.symbolCount++;
                this.symbols[index] = <VariableSymbol>sym;
                this.symbolMap.add(name, index);
            }
            return index;
        }

        public addUse(symIndex: number, astIndex: number) {
            var useBySym = this.useIndexBySymbol[symIndex];
            if (useBySym === undefined) {
                useBySym = [];
                this.useIndexBySymbol[symIndex] = useBySym;
            }
            useBySym[useBySym.length] = astIndex;
        }

        public getUseIndex(ast: AST) {
            this.uses[this.uses.length] = ast;
            return this.uses.length - 1;
        }

        public isLocalSym(sym: Symbol) { return (sym && (sym.container === this.func) && (sym.kind() === SymbolKind.Variable)); }

        public killSymbol(sym: VariableSymbol, bbUses: BitVector) {
            var index: number = this.symbolMap.lookup(sym.name);
            var usesOfSym = this.useIndexBySymbol[index];
            for (var k = 0, len = usesOfSym.length; k < len; k++) {
                bbUses.set(usesOfSym[k], true);
            }
        }
    }

    export class BitVector {
        static packBits = 30;
        public firstBits = 0;
        public restOfBits: number[] = null;

        constructor(public bitCount: number) {
            if (this.bitCount > BitVector.packBits) {
                this.restOfBits = [];
                var len = Math.floor(this.bitCount / BitVector.packBits);
                for (var i = 0; i < len; i++) {
                    this.restOfBits[i] = 0;
                }
            }
        }

        public set (bitIndex: number, value: bool) {
            if (bitIndex < BitVector.packBits) {
                if (value) {
                    this.firstBits |= (1 << bitIndex);
                }
                else {
                    this.firstBits &= (~(1 << bitIndex));
                }
            }
            else {
                var offset = Math.floor(bitIndex / BitVector.packBits) - 1;
                var localIndex = bitIndex % BitVector.packBits;
                if (value) {
                    this.restOfBits[offset] |= (1 << localIndex);
                }
                else {
                    this.restOfBits[offset] &= (~(1 << localIndex));
                }
            }
        }

        public map(fn: (index: number) => any) {
            var k: number;
            for (k = 0; k < BitVector.packBits; k++) {
                if (k === this.bitCount) {
                    return;
                }
                if (((1 << k) & this.firstBits) !== 0) {
                    fn(k);
                }
            }
            if (this.restOfBits) {
                var len: number;
                var cumu = BitVector.packBits;
                for (k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    for (var j = 0; j < BitVector.packBits; j++) {
                        if (((1 << j) & myBits) !== 0) {
                            fn(cumu);
                        }
                        cumu++;
                        if (cumu === this.bitCount) {
                            return;
                        }
                    }
                }
            }
        }

        // assume conforming sizes
        public union(b: BitVector) {
            this.firstBits |= b.firstBits;
            if (this.restOfBits) {
                for (var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] = myBits | bBits;
                }
            }
        }

        // assume conforming sizes
        public intersection(b: BitVector) {
            this.firstBits &= b.firstBits;
            if (this.restOfBits) {
                for (var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] = myBits & bBits;
                }
            }
        }

        // assume conforming sizes
        public notEq(b: BitVector) {
            if (this.firstBits !== b.firstBits) {
                return true;
            }
            if (this.restOfBits) {
                for (var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    if (myBits !== bBits) {
                        return true;
                    }
                }
            }
            return false;
        }

        public difference(b: BitVector) {
            var oldFirstBits = this.firstBits;
            this.firstBits &= (~b.firstBits);
            if (this.restOfBits) {
                for (var k = 0, len = this.restOfBits.length; k < len; k++) {
                    var myBits = this.restOfBits[k];
                    var bBits = b.restOfBits[k];
                    this.restOfBits[k] &= (~bBits);
                }
            }
        }
    }

    export class BasicBlock {
        // blocks that branch to the block after this one
        public predecessors: BasicBlock[] = [];
        public index = -1;
        public markValue = 0;
        public marked(markBase: number) { return this.markValue > markBase; }
        public mark() {
            this.markValue++;
        }
        public successors: BasicBlock[] = [];
        public useDef: BBUseDefInfo = null;
        public content = new ASTList();
        public addSuccessor(successor: BasicBlock): void {
            this.successors[this.successors.length] = successor;
            successor.predecessors[successor.predecessors.length] = this;
        }
    }

    export interface ITargetInfo {
        stmt: AST;
        continueBB: BasicBlock;
        breakBB: BasicBlock;
    }

    export class ControlFlowContext {
        public entry = null;
        // first unreachable ast for each unreachable code segment
        public unreachable: AST[] = null;
        public noContinuation = false;
        // statements enclosing the current statement
        public statementStack: ITargetInfo[] = [];
        public currentSwitch: BasicBlock[] = [];
        public walker: IAstWalker;

        constructor(public current: BasicBlock,
                     public exit: BasicBlock) {
            this.entry = this.current;
        }

        public walk(ast: AST, parent: AST) {
            return this.walker.walk(ast, parent);
        }

        public pushSwitch(bb: BasicBlock) {
            this.currentSwitch.push(bb);
        }

        public popSwitch() {
            return this.currentSwitch.pop();
        }

        public reportUnreachable(er: ErrorReporter) {
            if (this.unreachable && (this.unreachable.length > 0)) {
                var len = this.unreachable.length;
                for (var i = 0; i < len; i++) {
                    var unreachableAST = this.unreachable[i];
                    if (unreachableAST.nodeType !== NodeType.EndCode) {
                        er.simpleError(unreachableAST, "unreachable code");
                    }
                }
            }
        }

        private printAST(ast: AST, outfile: ITextWriter) {
            var printContext = new PrintContext(outfile);

            printContext.increaseIndent();
            //ast.walk(prePrintAST, postPrintAST, null, printContext);
            getAstWalkerFactory().walk(ast, prePrintAST, postPrintAST, null, printContext);

            printContext.decreaseIndent();
        }

        private printBlockContent(bb: BasicBlock, outfile: ITextWriter) {
            var content = bb.content;
            for (var i = 0, len = content.members.length; i < len; i++) {
                var ast = content.members[i];
                this.printAST(ast, outfile);
            }
        }

        public markBase = 0;

        public bfs(nodeFunc: (bb: BasicBlock) => void , edgeFunc: (node1: BasicBlock, node2: BasicBlock) => void ,
            preEdges: () => void , postEdges: () => void ) {
            var markValue = this.markBase++;
            var q: BasicBlock[] = [];
            q[q.length] = this.entry;

            while (q.length > 0) {
                var bb = q.pop();
                if (!(bb.marked(markValue))) {
                    bb.mark();
                    if (nodeFunc) {
                        nodeFunc(bb);
                    }
                    var succLen = bb.successors.length;
                    if (succLen > 0) {
                        if (preEdges) {
                            preEdges();
                        }
                        for (var j = succLen - 1; j >= 0; j--) {
                            var successor = bb.successors[j];
                            if (!(successor.marked(this.markBase))) {
                                if (edgeFunc) {
                                    edgeFunc(bb, successor);
                                }
                                q[q.length] = successor;
                            }
                        }
                        if (postEdges) {
                            postEdges();
                        }
                    }
                }
            }
        }

        public linearBBs: BasicBlock[] = [];

        public useDef(er: ErrorReporter, funcSym: Symbol) {
            var useDefContext = new UseDefContext();
            useDefContext.func = funcSym;
            var useDefInit = (bb: BasicBlock) => {
                bb.useDef = new BBUseDefInfo(bb);
                bb.useDef.initialize(useDefContext);
                this.linearBBs[this.linearBBs.length] = bb;
            }
            this.bfs(useDefInit, null, null, null);
            var i: number, bbLen: number;
            for (i = 0, bbLen = this.linearBBs.length; i < bbLen; i++) {
                this.linearBBs[i].useDef.initializeGen(useDefContext);
                this.linearBBs[i].useDef.initializeKill(useDefContext);
            }
            var changed = true;

            while (changed) {
                changed = false;
                for (i = 0; i < bbLen; i++) {
                    changed = this.linearBBs[i].useDef.updateTop() || changed;
                }
            }

            var top = this.entry.useDef.top;
            top.map((index) => {
                var ast = <Identifier>useDefContext.uses[<number>index];
                er.simpleError(ast, "use of variable '" + ast.actualText + "' that is not definitely assigned");
            });
        }

        public print(outfile: ITextWriter) {
            var index = 0;
            var node = (bb: BasicBlock) => {
                if (bb.index < 0) {
                    bb.index = index++;
                }
                if (bb === this.exit) {
                    outfile.WriteLine("Exit block with index " + bb.index);
                }
                else {
                    outfile.WriteLine("Basic block with index " + bb.index);
                    this.printBlockContent(bb, outfile);
                }
            }

            function preEdges() {
                outfile.Write("  Branches to ");
            }

            function postEdges() {
                outfile.WriteLine("");
            }

            function edge(node1: BasicBlock, node2: BasicBlock) {
                if (node2.index < 0) {
                    node2.index = index++;
                }
                outfile.Write(node2.index + " ");
            }

            this.bfs(node, edge, preEdges, postEdges);
            if (this.unreachable !== null) {
                for (var i = 0, len = this.unreachable.length; i < len; i++) {
                    outfile.WriteLine("Unreachable basic block ...");
                    this.printAST(this.unreachable[i], outfile);
                }
            }
        }

        public pushStatement(stmt: Statement, continueBB: BasicBlock, breakBB: BasicBlock) {
            this.statementStack.push({ stmt: stmt, continueBB: continueBB, breakBB: breakBB });
        }

        public popStatement() { return this.statementStack.pop(); }

        public returnStmt() {
            // TODO: make successor finally block if return stmt inside of try/finally 
            this.current.addSuccessor(this.exit);
            this.setUnreachable();
        }

        public setUnreachable() {
            this.current = null;
            this.noContinuation = true;
        }

        public addUnreachable(ast: AST) {
            if (this.unreachable === null) {
                this.unreachable = [];
            }
            this.unreachable[this.unreachable.length] = ast;
        }

        public unconditionalBranch(target: AST, isContinue: bool) {
            var targetBB = null;
            for (var i = 0, len = this.statementStack.length; i < len; i++) {
                var targetInfo = this.statementStack[i];
                if (targetInfo.stmt === target) {
                    if (isContinue) {
                        targetBB = targetInfo.continueBB;
                    }
                    else {
                        targetBB = targetInfo.breakBB;
                    }
                    break;
                }
            }
            if (targetBB) {
                this.current.addSuccessor(targetBB);
            }
            this.setUnreachable();
        }

        public addContent(ast: AST): void {
            if (this.current) {
                this.current.content.append(ast);
            }
        }
    }

    export interface IResolutionData {
        actuals: Type[];
        exactCandidates: Signature[];
        conversionCandidates: Signature[];
        id: number;
    }

    export class ResolutionDataCache {
        public cacheSize = 16;
        public rdCache: IResolutionData[] = [];
        public nextUp: number = 0;

        constructor() {
            for (var i = 0; i < this.cacheSize; i++) {
                this.rdCache[i] = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: i
                };
            }
        }

        public getResolutionData(): IResolutionData {
            var rd: IResolutionData = null;

            if (this.nextUp < this.cacheSize) {
                rd = this.rdCache[this.nextUp];
            }

            if (rd === null) {
                this.cacheSize++;
                rd = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: this.cacheSize
                };
                this.rdCache[this.cacheSize] = rd;
            }

            // cache operates as a stack - RD is always served up in-order
            this.nextUp++;

            return rd;
        }

        public returnResolutionData(rd: IResolutionData) {
            // Pop to save on array allocations, which are a bottleneck
            // REVIEW: On some VMs, Array.pop doesn't always pop the last value in the array
            rd.actuals.length = 0;
            rd.exactCandidates.length = 0;
            rd.conversionCandidates.length = 0;

            this.nextUp = rd.id;
        }
    }

    export class TypeFlow {
        public scope: SymbolScope;
        public globalScope: SymbolScope;

        public thisType: Type;
        public thisFnc: FuncDecl = null;
        public thisClassNode: TypeDeclaration = null;
        public enclosingFncIsMethod = false;

        // REVIEW: Prune in favor of typechecker fields
        public doubleType: Type;
        public booleanType: Type;
        public stringType: Type;
        public anyType: Type;
        public regexType: Type;
        public nullType: Type;
        public voidType: Type;
        public arrayAnyType: Type;

        public arrayInterfaceType: Type = null;
        public stringInterfaceType: Type = null;
        public objectInterfaceType: Type = null;
        public functionInterfaceType: Type = null;
        public numberInterfaceType: Type = null;
        public booleanInterfaceType: Type = null;
        public iargumentsInterfaceType: Type = null;

        public currentScript: Script = null;

        public inImportTypeCheck = false;
        public inTypeRefTypeCheck = false;
        public inArrayElementTypeCheck = false;
        public resolutionDataCache = new ResolutionDataCache();
        public nestingLevel = 0;
        public inSuperCall = false;

        constructor(public logger: ILogger,
                    public initScope: SymbolScope,
                    public checker: TypeChecker,
                    public compilationSettings: CompilationSettings) {
            this.checker.typeFlow = this;
            this.scope = this.initScope;
            this.globalScope = this.initScope;
            this.doubleType = this.checker.numberType;
            this.booleanType = this.checker.booleanType;
            this.stringType = this.checker.stringType;
            this.anyType = this.checker.anyType;
            this.regexType = this.anyType;
            this.nullType = this.checker.nullType;
            this.voidType = this.checker.voidType;
            this.arrayAnyType = this.checker.makeArrayType(this.anyType);
        }

        public initLibs() {
            var arraySym = this.globalScope.find("Array", false, true);
            if (arraySym && (arraySym.kind() === SymbolKind.Type)) {
                this.arrayInterfaceType = (<TypeSymbol>arraySym).type;
            }
            var stringSym = this.globalScope.find("String", false, true);
            if (stringSym && (stringSym.kind() === SymbolKind.Type)) {
                this.stringInterfaceType = (<TypeSymbol>stringSym).type;
            }
            var objectSym = this.globalScope.find("Object", false, true);
            if (objectSym && (objectSym.kind() === SymbolKind.Type)) {
                this.objectInterfaceType = (<TypeSymbol>objectSym).type;
            }
            var fnSym = this.globalScope.find("Function", false, true);
            if (fnSym && (fnSym.kind() === SymbolKind.Type)) {
                this.functionInterfaceType = (<TypeSymbol>fnSym).type;
            }
            var numberSym = this.globalScope.find("Number", false, true);
            if (numberSym && (numberSym.kind() === SymbolKind.Type)) {
                this.numberInterfaceType = (<TypeSymbol>numberSym).type;
            }
            var booleanSym = this.globalScope.find("Boolean", false, true);
            if (booleanSym && (booleanSym.kind() === SymbolKind.Type)) {
                this.booleanInterfaceType = (<TypeSymbol>booleanSym).type;
            }
            var regexSym = this.globalScope.find("RegExp", false, true);
            if (regexSym && (regexSym.kind() === SymbolKind.Type)) {
                this.regexType = (<TypeSymbol>regexSym).type;
            }
        }

        public cast(ast: AST, type: Type): AST {
            return this.castWithCoercion(ast, type, true, false);
        }

        public castWithCoercion(ast: AST, type: Type, applyCoercion: bool, typeAssertion: bool): AST {
            var comparisonInfo = new TypeComparisonInfo();
            if (this.checker.sourceIsAssignableToTarget(ast.type, type, comparisonInfo) || (typeAssertion && this.checker.sourceIsAssignableToTarget(type, ast.type, comparisonInfo))) {
                if (applyCoercion) {
                    if (type === null) {
                        ast.type = this.anyType;
                    }
                    else if (type.isClass()) {
                        ast.type = type.instanceType;
                    }
                    else {
                        ast.type = type;
                    }
                }
                return ast;
            }
            else {
                this.checker.errorReporter.incompatibleTypes(ast, ast.type, type, null, this.scope, comparisonInfo);
                return ast;
            }
        }

        public inScopeTypeCheck(ast: AST, enclosingScope: SymbolScope): AST {
            var prevScope = this.scope;
            this.scope = enclosingScope;
            var svThisFnc = this.thisFnc;
            var svThisType = this.thisType;
            var svThisClassNode = this.thisClassNode;
            var svCurrentModDecl = this.checker.currentModDecl;
            var prevMethodStatus = this.enclosingFncIsMethod;
            var container = this.scope.container;
            var fnc: FuncDecl = null;
            while (container) {
                if (container.kind() === SymbolKind.Type) {
                    var typeSym = <TypeSymbol>container;
                    var type = typeSym.type;
                    if (type.call) {
                        if (fnc === null) {
                            // use innermost function
                            this.enclosingFncIsMethod = typeSym.isMethod;
                            fnc = <FuncDecl>container.declAST;
                        }
                    }
                    if (type.isClass()) {
                        this.thisType = type.instanceType;
                        if (typeSym.declAST &&
                            (typeSym.declAST.nodeType === NodeType.ClassDeclaration)) {
                            this.thisClassNode = <TypeDeclaration>typeSym.declAST;
                        }
                        // use innermost class
                        break;
                    }
                    if (type.isModuleType()) {
                        this.checker.currentModDecl = <ModuleDeclaration>typeSym.declAST;
                        // use innermost module
                        break;
                    }
                }
                container = container.container;
            }
            this.thisFnc = fnc;

            var updated = this.typeCheck(ast);

            this.thisFnc = svThisFnc;
            this.thisType = svThisType;
            this.thisClassNode = svThisClassNode;
            this.checker.currentModDecl = svCurrentModDecl;
            this.enclosingFncIsMethod = prevMethodStatus;
            this.scope = prevScope;
            return updated;
        }

        public typeCheck(ast: AST): AST {
            if (ast) {
                return ast.typeCheck(this);
            }
            else {
                return null;
            }
        }

        public inScopeTypeCheckDecl(ast: AST) {
            if (ast.nodeType === NodeType.VarDecl || ast.nodeType === NodeType.ArgDecl) {
                this.inScopeTypeCheckBoundDecl(<BoundDecl>ast);
            }
            else if (ast.nodeType === NodeType.FuncDecl) {

                var funcDecl = <FuncDecl>ast;

                if (funcDecl.isAccessor()) {
                    this.typeCheckFunction(funcDecl);
                }
            }
        }

        public inScopeTypeCheckBoundDecl(varDecl: BoundDecl) {
            var sym = varDecl.sym;
            var svThisFnc = this.thisFnc;
            var svThisType = this.thisType;
            var prevMethodStatus = this.enclosingFncIsMethod;
            var prevLocationInfo = this.checker.locationInfo;
            if (sym && sym.container) {
                var instanceScope = hasFlag(varDecl.varFlags, VarFlags.ClassConstructorProperty) ? sym.container.getType().constructorScope : sym.container.instanceScope();
                if (hasFlag(varDecl.varFlags, VarFlags.Property) && sym.container.declAST.nodeType === NodeType.FuncDecl) {
                    this.thisFnc = <FuncDecl>sym.container.declAST;
                }
                if (instanceScope) {
                    var prevScope = this.scope;
                    this.scope = instanceScope;
                    var container = sym.container;
                    var svCurrentModDecl = this.checker.currentModDecl;
                    if (this.checker.fileNameToLocationInfo &&
                        (sym.fileName !== unknownLocationInfo.fileName) &&
                        this.checker.fileNameToLocationInfo.lookup(sym.fileName)) {
                        this.checker.locationInfo = this.checker.fileNameToLocationInfo.lookup(sym.fileName);
                    }
                    else {
                        this.checker.locationInfo = unknownLocationInfo;
                    }
                    // REVIEW: container linkage for function expressions
                    while (container) {
                        if (container.kind() === SymbolKind.Type) {
                            var typeSym = <TypeSymbol>container;
                            var type = typeSym.type;
                            if (type.call) {
                                this.enclosingFncIsMethod = typeSym.isMethod;
                            }
                            if (type.isClass()) {
                                this.thisType = type.instanceType;
                            }
                            if (type.isModuleType()) {
                                this.checker.currentModDecl = <ModuleDeclaration>container.declAST;
                                break;
                            }
                        }
                        container = container.container;
                    }

                    this.typeCheckBoundDecl(varDecl);
                    this.checker.currentModDecl = svCurrentModDecl;
                    this.scope = prevScope;
                }
            }
            this.thisFnc = svThisFnc;
            this.thisType = svThisType;
            this.checker.locationInfo = prevLocationInfo;
            this.enclosingFncIsMethod = prevMethodStatus;
        }

        public resolveBoundDecl(varDecl: BoundDecl) {
            if (varDecl.typeExpr) {
                if (varDecl.typeExpr.type === null ||
                    (varDecl.typeExpr.type && varDecl.typeExpr.type === this.anyType && this.scope) ||
                    (!varDecl.typeExpr.type.symbol) ||
                    !this.checker.typeStatusIsFinished(varDecl.typeExpr.type.symbol.typeCheckStatus)) {
                    this.typeCheck(varDecl.typeExpr);
                }
                varDecl.type = varDecl.typeExpr.type;
                if (varDecl.sym) {
                    varDecl.sym.setType(varDecl.type);
                }
            }
            else if (varDecl.init === null) {
                if (this.checker.styleSettings.implicitAny) {
                    this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                }
                varDecl.type = this.anyType;
                if (varDecl.sym) {
                    if (varDecl.sym.isType()) {
                        var tsym = <TypeSymbol>varDecl.sym;
                        if (tsym.isMethod) {
                            this.checker.errorReporter.simpleError(varDecl, "Cannot bind method group to variable.  (Did you mean to use 'declare function' instead of 'declare var'?)");
                            return;
                        }
                        else {
                            this.checker.errorReporter.simpleError(varDecl, "Cannot bind type to variable");
                            return;
                        }
                    }
                    varDecl.sym.setType(varDecl.type);
                }
            }
        }

        public typeCheckBoundDecl(varDecl: BoundDecl): VarDecl {
            // symbol has already been added to the scope
            var infSym = <InferenceSymbol>varDecl.sym;
            if (infSym === null) {
                if (varDecl.init) {
                    varDecl.init = this.typeCheck(varDecl.init);
                    varDecl.type = this.checker.widenType(varDecl.init.type);
                }
                else {
                    if (this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                    }
                    varDecl.type = this.anyType;
                }
            }
            else {
                if (infSym.typeCheckStatus === TypeCheckStatus.Started) {
                    if (this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(varDecl, "type implicitly set to 'any'");
                    }
                    varDecl.type = this.anyType;
                    infSym.setType(this.anyType);
                }
                else if (infSym.typeCheckStatus === TypeCheckStatus.NotStarted) {
                    infSym.typeCheckStatus = TypeCheckStatus.Started;
                    this.checker.addStartedPTO(infSym);
                    var resolved = false;
                    if (varDecl.type === null) {
                        // propagate declared type
                        if (varDecl.typeExpr) {
                            this.resolveBoundDecl(varDecl);
                            resolved = true;
                            varDecl.type = varDecl.typeExpr.type;
                            infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                        }
                    }

                    if (varDecl.init) {
                        // if the bound decl is a function-local static, we need to set the
                        // encapsulating scope to the function's member scope
                        var isLocalStatic = hasFlag(varDecl.varFlags, VarFlags.LocalStatic);
                        var prevScope = this.scope;
                        var applyTargetType = !varDecl.init.isParenthesized;
                        if (isLocalStatic) {
                            this.scope = varDecl.sym.container.getType().memberScope;
                        }

                        // Mark Lambda expressions with IsPropertyBound flag
                        if (hasFlag(varDecl.varFlags, VarFlags.Property) && this.thisClassNode) {
                            getAstWalkerFactory().walk(varDecl.init, (ast: AST, parent: AST, walker: IAstWalker) => {
                                if (ast && ast.nodeType === NodeType.FuncDecl) {
                                    if (hasFlag((<FuncDecl>ast).fncFlags, FncFlags.IsFatArrowFunction)) {
                                        // Found a Lambda, mark it
                                        (<FuncDecl>ast).fncFlags |= FncFlags.IsPropertyBound;
                                    }
                                    // Only mark the top level functions
                                    walker.options.goChildren = false;
                                }
                                return ast;
                            });
                        }

                        this.checker.typeCheckWithContextualType(varDecl.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, varDecl.init);

                        this.scope = prevScope;
                        if (varDecl.type) {
                            // If the cast is to a target type, in the case of a funcdecl,
                            // we may overwrite the init's type with one generated from a signature.
                            // In that case, we need to preserve the contained scope of the actual decl
                            var preserveScope = false;
                            var preservedContainedScope = null;

                            if (varDecl.init.type) {
                                preservedContainedScope = varDecl.init.type.containedScope;
                                preserveScope = true;
                                if (varDecl.init.type === this.voidType) {
                                    this.checker.errorReporter.simpleError(varDecl, "Cannot assign type 'void' to variable '" + varDecl.id.actualText + "'");
                                }
                            }

                            varDecl.init = this.castWithCoercion(varDecl.init, varDecl.type, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);

                            if (preserveScope && varDecl.init.type.containedScope === null) {
                                varDecl.init.type.containedScope = preservedContainedScope;
                            }
                        }
                        else {
                            varDecl.type = this.checker.widenType(varDecl.init.type);
                            if (varDecl.type === this.voidType) {
                                this.checker.errorReporter.simpleError(varDecl, "Cannot assign type 'void' to variable '" + varDecl.id.actualText + "'");
                                varDecl.type = this.anyType;
                            }
                        }
                        infSym.setType(varDecl.type);
                    }
                    else {
                        if (!resolved) {
                            this.resolveBoundDecl(varDecl);
                        }
                    }
                    infSym.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                }
                else if (this.checker.typeStatusIsFinished(infSym.typeCheckStatus) &&
                         (infSym.declAST !== varDecl)) {
                    if (varDecl.init) {
                        varDecl.init = this.typeCheck(varDecl.init);
                        varDecl.type = infSym.getType();
                        varDecl.init = this.cast(varDecl.init, varDecl.type);
                    }
                }
            }
            if (varDecl.id && varDecl.sym) {
                varDecl.id.sym = varDecl.sym;
            }

            // Check if variable satisfies type privacy
            if (varDecl.sym && varDecl.sym.container) {
                this.checkTypePrivacy(varDecl.sym.getType(), varDecl.sym, (typeName: string, isModuleName: bool) => this.varPrivacyErrorReporter(varDecl, typeName, isModuleName));
            }
            return <VarDecl>varDecl;
        }

        private varPrivacyErrorReporter(varDecl: BoundDecl, typeName: string, isModuleName: bool) {
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }

            if (hasFlag(varDecl.varFlags, VarFlags.Public)) {
                if (varDecl.sym.container.declAST.nodeType === NodeType.InterfaceDeclaration) {
                    this.checker.errorReporter.simpleError(varDecl, "property '" + varDecl.sym.name + "' of exported interface" + typestring);
                } else {
                    this.checker.errorReporter.simpleError(varDecl, "public member '" + varDecl.sym.name + "' of exported class" + typestring);
                }
            } else {
                this.checker.errorReporter.simpleError(varDecl, "exported variable '" + varDecl.sym.name + "'" + typestring);
            }
        }

        public typeCheckSuper(ast: AST): AST {
            if (this.thisType && (this.enclosingFncIsMethod && !this.thisFnc.isStatic()) && this.thisType.baseClass()) {
                ast.type = this.thisType.baseClass();
            }
            else {
                // redirect 'super' used within lambdas
                if (!this.enclosingFncIsMethod &&
                    this.thisType && this.thisType.baseClass() &&
                    this.thisFnc && hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {
                    // Find the closest non lambda function
                    var enclosingFnc = this.thisFnc.enclosingFnc;
                    while (hasFlag(enclosingFnc.fncFlags, FncFlags.IsFatArrowFunction)) {
                        enclosingFnc = enclosingFnc.enclosingFnc;
                    }

                    // If the lambda is enclosed is a valid member, use the base type
                    if (enclosingFnc && (enclosingFnc.isMethod() || enclosingFnc.isConstructor) && !enclosingFnc.isStatic()) {
                        ast.type = this.thisType.baseClass();
                        enclosingFnc.setHasSuperReferenceInFatArrowFunction();
                        return ast;
                    }
                }

                ast.type = this.anyType;
                this.checker.errorReporter.invalidSuperReference(ast);
            }
            return ast;
        }

        public typeCheckThis(ast: AST): AST {
            ast.type = this.anyType;
            var illegalThisRef = false;
            if (this.thisFnc === null) {
                // 'this' in class bodies should bind to 'any'
                if (this.thisType) {
                    if (this.thisClassNode && this.thisClassNode.nodeType === NodeType.ClassDeclaration) {
                        illegalThisRef = true;
                    }
                    else {
                        ast.type = this.thisType;
                    }
                }
                else if (this.checker.currentModDecl) {
                    this.checker.errorReporter.simpleError(ast, "'this' may not be referenced within module bodies");
                }
            }
            else {
                if (this.thisClassNode && (hasFlag(this.thisFnc.fncFlags, FncFlags.IsPropertyBound) || (this.inSuperCall && hasFlag((<ClassDeclaration>this.thisClassNode).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor)))) {
                    illegalThisRef = true;
                }
                if (this.thisFnc.isMethod() || this.thisFnc.isConstructor) {
                    if (this.thisType && !(this.thisFnc.fncFlags & FncFlags.Static)) {
                        ast.type = this.thisType;
                    }
                }
            }

            // redirect 'this' used within lambdas
            if (!this.enclosingFncIsMethod &&
                this.thisFnc &&
                hasFlag(this.thisFnc.fncFlags, FncFlags.IsFatArrowFunction)) {

                // if the enclosing function was bound to a property,
                // checkInitSelf would not have been able to mark the 
                // function for a self init
                if (this.thisFnc.boundToProperty) {
                    var container = this.thisFnc.boundToProperty.sym.container;
                    if (container.declAST.nodeType === NodeType.FuncDecl) {
                        (<FuncDecl>container.declAST).setHasSelfReference();
                    }
                }
                else {
                    var encFnc = this.thisFnc.enclosingFnc;
                    var firstEncFnc = encFnc;

                    while (encFnc) {
                        if (this.thisClassNode && hasFlag(encFnc.fncFlags, FncFlags.IsPropertyBound)) {
                            illegalThisRef = true;
                        }

                        if (!hasFlag(encFnc.fncFlags, FncFlags.IsFatArrowFunction) || encFnc.hasSelfReference()) {
                            encFnc.setHasSelfReference();
                            break;
                        }

                        encFnc = encFnc.enclosingFnc;
                    }

                    if (!encFnc && firstEncFnc) {
                        encFnc = firstEncFnc;
                        encFnc.setHasSelfReference();
                    }
                    else if (!encFnc) { // the lambda is bound at the top-level...
                        if (this.thisClassNode) {
                            (<ClassDeclaration>this.thisClassNode).varFlags |= VarFlags.MustCaptureThis;
                        }
                        else if (this.checker.currentModDecl) {
                            this.checker.currentModDecl.modFlags |= ModuleFlags.MustCaptureThis;
                        }
                        else {
                            this.checker.mustCaptureGlobalThis = true;
                        }
                    }

                    if (encFnc && (encFnc.isMethod() || encFnc.isConstructor) && this.thisType && !hasFlag(encFnc.fncFlags, FncFlags.Static)) {
                        ast.type = this.thisType;
                    }
                }
            }

            if (illegalThisRef) {
                this.checker.errorReporter.simpleError(ast, "Keyword 'this' cannot be referenced in initializers in a class body, or in super constructor calls");
            }
            return ast;
        }

        public setTypeFromSymbol(ast: AST, symbol: Symbol): void {
            if (symbol.isVariable()) {
                if (symbol.isInferenceSymbol()) {
                    var infSym = <InferenceSymbol>symbol;
                    if (infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {
                        if (infSym.typeCheckStatus === TypeCheckStatus.Started) {
                            // Since we have started the declAST type check, but not finished, it must be a recursive variable reference.
                            infSym.declAST.type = this.anyType;
                            infSym.setType(this.anyType);
                        }
                        else {
                            this.inScopeTypeCheckDecl(infSym.declAST);
                        }
                    }
                    if (!this.checker.styleSettings.innerScopeDeclEscape) {
                        if (infSym.declAST && (infSym.declAST.nodeType === NodeType.VarDecl)) {
                            if (this.nestingLevel < (<VarDecl>infSym.declAST).nestingLevel) {
                                this.checker.errorReporter.styleError(ast, "Illegal reference to a variable defined in more nested scope");
                            }
                        }
                    }
                }
                ast.type = symbol.getType();
                if (!symbol.writeable()) {
                    ast.flags = ast.flags & (~(ASTFlags.Writeable));
                }
            }
            else if (symbol.isType()) {
                ast.type = symbol.getType();
                ast.flags = ast.flags & (~(ASTFlags.Writeable));
            }
            else {
                ast.type = this.anyType;
                this.checker.errorReporter.symbolDoesNotReferToAValue(ast, symbol.name);
            }
        }

        public typeCheckName(ast: AST): AST {
            var identifier = <Identifier>ast;

            if (this.checker.inWith) {
                identifier.type = this.anyType;
            }
            else {
                var typespace = this.inTypeRefTypeCheck;
                var idText = identifier.text;
                var originalIdText = idText;
                var isDynamicModuleName = isQuoted(identifier.text);

                var symbol = this.scope.find(idText, false, typespace);

                if (symbol === null && isDynamicModuleName) {
                    symbol = this.checker.findSymbolForDynamicModule(idText, this.currentScript.locationInfo.fileName, (id) => this.scope.find(id, false, typespace));
                }

                if (!symbol) {
                    if (!identifier.isMissing()) {
                        this.checker.errorReporter.unresolvedSymbol(identifier, identifier.text);
                    }
                    identifier.type = this.anyType;
                }
                else {
                    if (this.compilationSettings.optimizeModuleCodeGen && symbol && symbol.isType()) {
                        var symType = symbol.getType();
                        // Once the type has been referenced outside of a type ref position, there's
                        // no going back                        
                        if (symType && (<TypeSymbol>symbol).aliasLink && (<TypeSymbol>symbol).onlyReferencedAsTypeRef) {

                            var modDecl = <ModuleDeclaration>symType.symbol.declAST;
                            if (modDecl && hasFlag(modDecl.modFlags, ModuleFlags.IsDynamic)) {
                                (<TypeSymbol>symbol).onlyReferencedAsTypeRef = this.inTypeRefTypeCheck;
                            }
                        }
                    }

                    if (symbol.declAST &&
                        symbol.declAST.nodeType === NodeType.FuncDecl &&
                        !(<FuncDecl>symbol.declAST).returnTypeAnnotation &&
                        (<FuncDecl>symbol.declAST).signature.typeCheckStatus === TypeCheckStatus.Started) {
                        (<FuncDecl>symbol.declAST).type.symbol.flags |= SymbolFlags.RecursivelyReferenced;
                        (<FuncDecl>symbol.declAST).signature.returnType.type = this.anyType;
                    }

                    this.setTypeFromSymbol(ast, symbol);
                    identifier.sym = symbol;
                    if (this.thisFnc) {
                        if (this.thisFnc.type && symbol.container !== this.thisFnc.type.symbol) {
                            this.thisFnc.freeVariables[this.thisFnc.freeVariables.length] = symbol;
                        }
                    }
                }
            }
            return ast;
        }

        public typeCheckScript(script: Script): Script {
            this.checker.locationInfo = script.locationInfo;
            this.scope = this.checker.globalScope;

            // if it's a top-level module, the globals have already been added to the implicit
            // module decl
            if (!script.topLevelMod) {
                this.addLocalsFromScope(this.scope, this.checker.gloMod,
                                   script.vars, this.checker.globals, true);
            }

            this.currentScript = script;
            script.bod = <ASTList>this.typeCheck(script.bod);
            this.currentScript = null;
            return script;
        }

        public typeCheckBitNot(ast: AST): AST {
            var unex = <UnaryExpression>ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.doubleType;
            return unex;
        }

        public typeCheckUnaryNumberOperator(ast: AST): AST {
            var unex = <UnaryExpression>ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.doubleType;
            return ast;
        }

        public typeCheckLogNot(ast: AST): AST {
            var unex = <UnaryExpression>ast;
            unex.operand = this.typeCheck(unex.operand);
            unex.type = this.booleanType;
            return unex;
        }

        public astIsWriteable(ast: AST): bool {
            return hasFlag(ast.flags, ASTFlags.Writeable);
        }

        public typeCheckIncOrDec(ast: AST): AST {
            var unex = <UnaryExpression>ast;
            var lval = unex.operand;
            if (!this.astIsWriteable(unex)) {
                this.checker.errorReporter.valueCannotBeModified(unex);
                unex.type = this.doubleType;
            }
            else {
                unex = <UnaryExpression> this.typeCheckUnaryNumberOperator(ast);
                if (unex.operand.type !== this.checker.numberType && unex.operand.type !== this.checker.anyType && !(unex.operand.type.typeFlags & TypeFlags.IsEnum)) {
                    this.checker.errorReporter.simpleError(ast, "'++' and '--' may only be applied to operands of type 'number' or 'any'");
                }
            }
            return unex;
        }

        public typeCheckBitwiseOperator(ast: AST, assignment: bool): AST {
            var binex = <BinaryExpression>ast;
            var resultType: Type = null;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;

            if (assignment && (!this.astIsWriteable(binex))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }

            if (this.checker.styleSettings.bitwise) {
                this.checker.errorReporter.styleError(ast, "use of " + nodeTypeTable[binex.nodeType]);
            }

            if (this.checker.sourceIsSubtypeOfTarget(leftType, this.doubleType) && (this.checker.sourceIsSubtypeOfTarget(rightType, this.doubleType))) {
                resultType = this.doubleType;
            }
            else if ((leftType === this.booleanType) &&
                     (rightType === this.booleanType)) {
                resultType = this.booleanType;
            }
            else if (leftType === this.anyType) {
                if ((rightType === this.anyType) ||
                    (rightType === this.doubleType) ||
                    (rightType === this.booleanType)) {
                    resultType = this.anyType;
                }
            }
            else if (rightType === this.anyType) {
                if ((leftType === this.anyType) ||
                    (leftType === this.doubleType) ||
                    (leftType === this.booleanType)) {
                    resultType = this.anyType;
                }
            }
            if (resultType === null) {
                resultType = this.anyType;
                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,
                                                        binex.printLabel(), this.scope);
            }
            binex.type = resultType;
            return binex;
        }

        public typeCheckArithmeticOperator(ast: AST, assignment: bool): AST {
            var binex = <BinaryExpression>ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;

            if (assignment && (!this.astIsWriteable(binex.operand1))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }

            if (this.checker.styleSettings.bitwise &&
                ((binex.nodeType === NodeType.And) ||
                (binex.nodeType === NodeType.Or) ||
                (binex.nodeType === NodeType.AsgAnd) ||
                (binex.nodeType === NodeType.AsgOr))) {
                this.checker.errorReporter.styleError(ast, "use of " + nodeTypeTable[binex.nodeType]);
            }

            var nodeType = binex.nodeType;

            if (this.checker.isNullOrUndefinedType(leftType)) {
                leftType = rightType;
            }
            if (this.checker.isNullOrUndefinedType(rightType)) {
                rightType = leftType;
            }
            leftType = this.checker.widenType(leftType);
            rightType = this.checker.widenType(rightType);

            if (nodeType === NodeType.Add || nodeType === NodeType.AsgAdd) {

                if (leftType === this.checker.stringType || rightType === this.checker.stringType) {
                    binex.type = this.checker.stringType;
                }
                else if (leftType === this.checker.numberType && rightType === this.checker.numberType) {
                    binex.type = this.checker.numberType;
                }
                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {
                    binex.type = this.checker.numberType;
                }
                else if (leftType === this.checker.anyType || rightType === this.checker.anyType) {
                    binex.type = this.checker.anyType;
                }
                else {
                    binex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,
                                                            binex.printLabel(), this.scope);
                }
            }
            else {
                if (leftType === this.checker.numberType && rightType === this.checker.numberType) {
                    binex.type = this.checker.numberType;
                }
                else if (this.checker.sourceIsSubtypeOfTarget(leftType, this.checker.numberType) && this.checker.sourceIsSubtypeOfTarget(rightType, this.checker.numberType)) {
                    binex.type = this.checker.numberType;
                }
                else if (leftType === this.checker.anyType || rightType === this.checker.anyType) {
                    binex.type = this.checker.numberType;
                }
                else {
                    binex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType,
                                                            binex.printLabel(), this.scope);
                }
            }

            return binex;
        }

        public typeCheckDotOperator(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            var leftIsFnc = false;
            binex.operand1 = this.typeCheck(binex.operand1);
            var leftType = binex.operand1.type;
            var leftScope: SymbolScope = null;
            // REVIEW: replace with get member scope
            if (leftType) {
                if (leftType === this.anyType) {
                    binex.type = this.anyType;
                    return binex;
                }
                else if (leftType === this.stringType) {
                    if (this.stringInterfaceType) {
                        leftScope = this.stringInterfaceType.memberScope;
                    }
                    else {
                        binex.type = this.anyType;
                        return binex;
                    }
                }
                else if (leftType === this.doubleType) {
                    if (this.numberInterfaceType) {
                        leftScope = this.numberInterfaceType.memberScope;
                    }
                    else {
                        binex.type = this.anyType;
                        return binex;
                    }
                }
                else if (leftType === this.booleanType) {
                    if (this.booleanInterfaceType) {
                        leftScope = this.booleanInterfaceType.memberScope;
                    }
                    else {
                        binex.type = this.anyType;
                        return binex;
                    }
                }
                else if ((leftType.call || leftType.construct) && !leftType.members) {
                    if (this.functionInterfaceType) {
                        leftScope = this.functionInterfaceType.memberScope;
                    }
                    else {
                        binex.type = this.anyType;
                        return binex;
                    }
                }
                else if (leftType.elementType) {
                    if (this.arrayInterfaceType) {
                        var arrInstType = leftType.elementType.getArrayBase(this.arrayInterfaceType, this.checker);
                        leftScope = arrInstType.memberScope;
                    }
                    else {
                        binex.type = this.anyType;
                        return binex;
                    }
                }
                else {
                    leftScope = leftType.memberScope;
                }
            }
            if (!leftScope) {
                this.checker.errorReporter.expectedClassOrInterface(binex);
                binex.type = this.anyType;
            }
            else {
                var propertyName = <Identifier>binex.operand2;
                var lhsIsEnclosingType = (this.thisClassNode && binex.operand1.type === this.thisClassNode.type.instanceType) || this.inTypeRefTypeCheck;
                var symbol = leftScope.find(propertyName.text, !lhsIsEnclosingType, this.inTypeRefTypeCheck); // only search the public members, unless the rhs is a 'this' pointer

                // If the symbol wasn't found, delegate to the appropriate 'virtual' parent type
                if (!symbol) {
                    if (this.objectInterfaceType && leftType) {
                        // check 'Object' for the symbol
                        if (leftType.isReferenceType()) {
                            symbol = this.objectInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);
                        }
                        if (!symbol) {
                            // check 'Function', if appropriate
                            if (this.functionInterfaceType && (leftType.call || leftType.construct)) {
                                symbol = this.functionInterfaceType.memberScope.find(propertyName.text, false, this.inTypeRefTypeCheck);
                            }
                        }
                    }
                }

                if (!symbol || (!symbol.visible(leftScope, this.checker))) {
                    binex.type = this.anyType;

                    if (symbol === null) {
                        this.checker.errorReporter.simpleError(propertyName, "The property '" + propertyName.actualText + "' does not exist on value of type '" + leftType.getScopedTypeName(this.scope) + "'");
                    }
                    else if (!this.inTypeRefTypeCheck) {  // if it's a dotted type reference, we'll catch the visibility error during binding
                        this.checker.errorReporter.simpleError(binex, "The property '" + propertyName.actualText + " on type '" + leftType.getScopedTypeName(this.scope) + "' is not visible");
                    }
                }
                else {
                    if (symbol.isVariable()) {
                        if (symbol.isInferenceSymbol()) {
                            var infSym = <InferenceSymbol>symbol;
                            if (infSym.declAST && !this.checker.typeStatusIsFinished(infSym.typeCheckStatus)) {
                                this.inScopeTypeCheckDecl(infSym.declAST);
                            }
                        }
                    }
                    propertyName.sym = symbol;
                    binex.type = symbol.getType();
                }
            }
            if (binex.type === null) {
                binex.type = this.anyType;
            }

            return binex;
        }

        public typeCheckBooleanOperator(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;
            if ((!(this.checker.sourceIsAssignableToTarget(leftType, rightType))) &&
                (!(this.checker.sourceIsAssignableToTarget(rightType, leftType)))) {
                this.checker.errorReporter.incompatibleTypes(binex, leftType, rightType, binex.printLabel(), this.scope);
            }
            binex.type = this.booleanType;
            return binex;
        }

        public typeCheckAsgOperator(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            var applyTargetType = !binex.operand2.isParenthesized;
            binex.operand1 = this.typeCheck(binex.operand1);

            this.checker.typeCheckWithContextualType(binex.operand1.type, this.checker.inProvisionalTypecheckMode(), applyTargetType, binex.operand2);

            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;

            if (!(this.astIsWriteable(binex.operand1))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }
            if (binex.operand1.nodeType === NodeType.Call) {
                var callEx = <CallExpression>binex.operand1;
            }
            var preserveScope = false;
            var preservedContainedScope = null;
            if (binex.operand2.type) {
                preservedContainedScope = binex.operand2.type.containedScope;
                preserveScope = true;
            }
            // Do not re-write the AST in provisional typecheck mode
            binex.operand2 = this.castWithCoercion(binex.operand2, leftType, applyTargetType && !this.checker.inProvisionalTypecheckMode(), false);
            if (preserveScope && binex.operand2.type.containedScope === null) {
                binex.operand2.type.containedScope = preservedContainedScope;
            }
            binex.type = rightType;
            return binex;
        }

        public typeCheckIndex(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            binex.operand1 = this.typeCheck(binex.operand1); // ObjExpr
            binex.operand2 = this.typeCheck(binex.operand2); // IndexExpr

            if (!this.checker.styleSettings.literalSubscript) {
                if (binex.operand2.nodeType === NodeType.QString) {
                    this.checker.errorReporter.styleError(ast, "use literal subscript ('.') notation instead)");
                }
            }

            var objExprType = binex.operand1.type;
            var indexExprType = binex.operand2.type;

            if (objExprType.elementType) { // arrays
                if (indexExprType === this.checker.anyType || indexExprType === this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)) {
                    binex.type = objExprType.elementType;
                }
                else if (indexExprType === this.checker.stringType) {
                    binex.type = this.checker.anyType;
                }
                else {
                    this.checker.errorReporter.simpleError(binex, "Illegal property access");
                    binex.type = this.checker.anyType;
                }
            }
            else if (objExprType.index) { // types with index sigs

                if (indexExprType === this.checker.anyType ||
                    !((objExprType.index.flags & SignatureFlags.IsStringIndexer) || (objExprType.index.flags & SignatureFlags.IsNumberIndexer)) || // REVIEW: unvalidated type expression
                    ((objExprType.index.flags & SignatureFlags.IsStringIndexer) && indexExprType === this.checker.stringType) ||
                    ((objExprType.index.flags & SignatureFlags.IsNumberIndexer) && (indexExprType === this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) {
                    var sig = this.resolveOverload(ast, objExprType.index);
                    if (sig) {
                        binex.type = sig.returnType.type;//objExprType.index.signatures[0].returnType.type;
                    }
                    else {
                        binex.type = this.checker.anyType;
                    }
                }
                else if (indexExprType === this.checker.stringType) {
                    binex.type = this.checker.anyType;
                }
                else {
                    this.checker.errorReporter.simpleError(binex, "Illegal property access");
                    binex.type = this.checker.anyType;
                }
            }
            else if ((objExprType === this.checker.anyType ||
                     objExprType === this.checker.stringType ||
                     objExprType === this.checker.numberType ||
                     objExprType === this.checker.booleanType ||
                     objExprType.isReferenceType()) &&
                     (indexExprType === this.checker.anyType ||
                      indexExprType === this.checker.stringType ||
                      (indexExprType === this.checker.numberType || hasFlag(indexExprType.typeFlags, TypeFlags.IsEnum)))) { // REVIEW: Do we want to allow indexes of type 'number'?
                binex.type = this.checker.anyType;
            }
            else {
                this.checker.errorReporter.simpleError(binex, "Illegal property access");
                binex.type = this.checker.anyType;
            }

            return binex;
        }

        public typeCheckInOperator(binex: BinaryExpression): BinaryExpression {
            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.stringType);
            binex.operand2 = this.typeCheck(binex.operand2);

            if (!((binex.operand1.type === this.checker.anyType || binex.operand1.type === this.checker.stringType) &&
                    (binex.operand2.type === this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.objectInterfaceType)))) {
                this.checker.errorReporter.simpleError(binex, "The in operator requires the left operand to be of type Any or the String primitive type, and the right operand to be of type Any or an object type");
            }

            binex.type = this.booleanType;
            return binex;
        }

        public typeCheckShift(binex: BinaryExpression, assignment: bool): BinaryExpression {
            binex.operand1 = this.cast(this.typeCheck(binex.operand1), this.doubleType);
            binex.operand2 = this.cast(this.typeCheck(binex.operand2), this.doubleType);
            if (assignment && (!(this.astIsWriteable(binex.operand1)))) {
                this.checker.errorReporter.valueCannotBeModified(binex);
            }
            binex.type = this.doubleType;
            return binex;
        }

        public typeCheckQMark(trinex: ConditionalExpression): ConditionalExpression {
            trinex.operand1 = this.typeCheck(trinex.operand1);
            trinex.operand2 = this.typeCheck(trinex.operand2);
            trinex.operand3 = this.typeCheck(trinex.operand3);
            var leftType = trinex.operand2.type;
            var rightType = trinex.operand3.type;

            if (leftType === rightType) {
                trinex.type = leftType;
            }
            else {
                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {
                    trinex.type = rightType;
                }
                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {
                    trinex.type = leftType;
                }
                else {
                    trinex.type = this.anyType;
                    this.checker.errorReporter.incompatibleTypes(trinex, leftType, rightType, trinex.printLabel(), this.scope);
                }
            }

            return trinex;
        }

        public addFormals(container: Symbol, signature: Signature,
            table: IHashTable) {
            var len = signature.parameters.length;
            for (var i = 0; i < len; i++) {
                var symbol = <ParameterSymbol>signature.parameters[i];
                symbol.container = container;
                table.add(symbol.name, symbol);
            }
        }

        // REVIEW: We use isModContainer instead of container.getType().isModuleType because container.type may be null at this
        // juncture
        public addLocalsFromScope(scope: SymbolScope, container: Symbol, vars: ASTList, table: IHashTable, isModContainer: bool) {
            var len = vars.members.length;
            var hasArgsDef = false;
            for (var i = 0; i < len; i++) {
                var local = <VarDecl>vars.members[i];
                if (((local.sym === null) || (local.sym.kind() !== SymbolKind.Field))) {
                    var result: Symbol = null;
                    if ((result = table.lookup(local.id.text)) === null) {
                        var localVar: ValueLocation = new ValueLocation();
                        localVar.typeLink = new TypeLink();
                        var varSym = null;

                        if (hasFlag(local.varFlags, VarFlags.Static)) {
                            local.varFlags |= VarFlags.LocalStatic;
                            varSym = new FieldSymbol(local.id.text, local.minChar,
                                                      this.checker.locationInfo.fileName,
                                                      true, localVar);
                        }
                        else {
                            varSym = new VariableSymbol(local.id.text, local.minChar,
                                                      this.checker.locationInfo.fileName,
                                                      localVar);
                        }
                        varSym.transferVarFlags(local.varFlags);
                        localVar.symbol = varSym;
                        varSym.declAST = local;
                        localVar.typeLink.ast = local.typeExpr;
                        this.checker.resolveTypeLink(scope, localVar.typeLink, false);
                        if ((local.type === null) && (local.init === null)) {
                            local.type = this.anyType;
                        }
                        localVar.typeLink.type = local.type;
                        localVar.symbol.container = container;
                        local.sym = localVar.symbol;
                        table.add(local.id.text, varSym);
                        if (local.id.text === "arguments") {
                            hasArgsDef = true;
                        }
                    }
                    else {
                        local.type = result.getType();
                        local.sym = result;
                    }
                }
            }
            if (!isModContainer) {
                if (!hasArgsDef) {
                    var argLoc = new ValueLocation();
                    argLoc.typeLink = new TypeLink();
                    var theArgSym = new VariableSymbol("arguments", vars.minChar,
                                                     this.checker.locationInfo.fileName,
                                                     argLoc);

                    // if the user is using a custom lib.d.ts where IArguments has not been defined
                    // (or they're compiling with the --nolib option), use 'any' as the argument type
                    if (!this.iargumentsInterfaceType) {
                        var argumentsSym = scope.find("IArguments", false, true);

                        if (argumentsSym) {
                            argumentsSym.flags |= SymbolFlags.CompilerGenerated;
                            this.iargumentsInterfaceType = argumentsSym.getType();
                        }
                        else {
                            this.iargumentsInterfaceType = this.anyType;
                        }
                    }
                    argLoc.typeLink.type = this.iargumentsInterfaceType;
                    table.add("arguments", theArgSym);
                }
            }
        }

        // REVIEW: isClass param may now be redundant
        public addConstructorLocalArgs(constructorDecl: FuncDecl, table: IHashTable, isClass: bool): void {
            var container = constructorDecl.type.symbol;
            var args = constructorDecl.arguments;
            if (args) {
                var len = args.members.length;
                for (var i = 0; i < len; i++) {
                    var local = <ArgDecl>args.members[i];
                    if ((local.sym === null) ||
                        (isClass || (local.sym.kind() !== SymbolKind.Field))) {
                        var result: Symbol = null;
                        if ((result = table.lookup(local.id.text)) === null) {
                            this.resolveBoundDecl(local);
                            var localVar: ValueLocation = new ValueLocation();
                            localVar.typeLink = new TypeLink();
                            var varSym = new ParameterSymbol(local.id.text, local.minChar,
                                                                   this.checker.locationInfo.fileName,
                                                                   localVar);
                            varSym.funcDecl = constructorDecl;
                            varSym.declAST = local;
                            localVar.symbol = varSym;
                            localVar.typeLink.type = local.type;
                            localVar.symbol.container = container;
                            local.sym = localVar.symbol;
                            table.add(local.id.text, varSym);
                        }
                        else {
                            local.type = result.getType();
                            local.sym = result;
                        }
                    }
                }
            }
        }

        public checkInitSelf(funcDecl: FuncDecl): bool {
            if (!funcDecl.isMethod()) {
                var freeVars = funcDecl.freeVariables;
                for (var k = 0, len = freeVars.length; k < len; k++) {
                    var sym = freeVars[k];
                    if (sym.isInstanceProperty()) {
                        return true;
                    }
                }
            }
            var fns = funcDecl.scopes;
            var fnsLen = fns.members.length;

            for (var j = 0; j < fnsLen; j++) {
                var fn = <FuncDecl>fns.members[j];
                if (this.checkInitSelf(fn)) {
                    return true;
                }
            }
            return false;
        }

        public checkPromoteFreeVars(funcDecl: FuncDecl, constructorSym: Symbol): void {
            var freeVars = funcDecl.freeVariables;
            for (var k = 0, len = freeVars.length; k < len; k++) {
                var sym = freeVars[k];
                if ((!sym.isInstanceProperty()) && (sym.container === constructorSym)) {
                    instanceFilter.reset();
                    if (this.scope.search(instanceFilter, sym.name, false, false)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variable shadows class property '" + sym.name + "'. To access the class property, use 'self." + sym.name + "'");
                    }

                    this.checker.errorReporter.simpleError(funcDecl, "Constructor-local variables may not be accessed from instance method bodies. Consider changing local variable '" + sym.name + "' to a class property")
                }
            }
        }

        public allReturnsAreVoid(funcDecl: FuncDecl) {
            // in the case of a function or method with no declared return type, walk the body to 
            // pre-emptively determine if the function has a return type of void
            //
            // REVIEW: Eventually, we'll want to perform exit graph analysis to determine
            // if the function ever "escapes" without a return expression
            // This would require moving some of this logic into the function's typecheck-proper,
            // which would slow things down a fair bit, but would open up more analysis opportunities
            var allReturnsAreVoid = true;

            if (funcDecl.signature.returnType.type === null) {
                var preFindReturnExpressionTypes = function (ast: AST, parent: AST, walker: IAstWalker) {
                    var go = true;
                    switch (ast.nodeType) {
                        case NodeType.FuncDecl:
                            // don't recurse into a function decl - we don't want to confuse a nested
                            // return type with the top-level function's return type
                            go = false;
                            break;
                        case NodeType.Return:
                            var returnStmt: ReturnStatement = <ReturnStatement>ast;

                            if (returnStmt.returnExpression) {
                                allReturnsAreVoid = false;
                                go = false;
                            }

                        default:
                            break;
                    }
                    walker.options.goChildren = go;
                    walker.options.goNextSibling = go;
                    return ast;
                }

                getAstWalkerFactory().walk(funcDecl.bod, preFindReturnExpressionTypes);
            }

            return allReturnsAreVoid;
        }

        public classConstructorHasSuperCall(funcDecl: FuncDecl) {
            var foundSuper = false;

            var preFindSuperCall = function (ast: AST, parent: AST, walker: IAstWalker) {

                var go = true;

                switch (ast.nodeType) {
                    case NodeType.FuncDecl:
                        go = false;
                        break;
                    case NodeType.Call:
                        var call = <CallExpression>ast;

                        if (call.target.nodeType === NodeType.Super) {
                            go = false;
                            foundSuper = true;
                            break;
                        }
                        break;
                    default:
                        break;
                }
                walker.options.goChildren = go;
                return ast;
            }

            getAstWalkerFactory().walk(funcDecl.bod, preFindSuperCall);

            return foundSuper;
        }

        private baseListPrivacyErrorReporter(bases: ASTList, i: number, declSymbol: Symbol, extendsList: bool, typeName: string, isModuleName: bool) {
            var baseSymbol = bases.members[i].type.symbol;
            var declTypeString = (declSymbol.declAST.nodeType === NodeType.InterfaceDeclaration) ? "interface" : "class";
            var baseListTypeString = extendsList ? "extends" : "implements";
            var baseTypeString = (baseSymbol.declAST.nodeType === NodeType.InterfaceDeclaration) ? "interface" : "class";
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module ";
                baseTypeString = " " + baseTypeString + " from private module " + quotestring + typeName + quotestring;
            } else {
                baseTypeString = " private " + baseTypeString + " '" + typeName + "'";
            }
            this.checker.errorReporter.simpleError(bases.members[i], "exported " + declTypeString + " '" + declSymbol.name + "' " + baseListTypeString + baseTypeString);
        }

        // Check if declSymbol can satisfy baselist privacy
        private typeCheckBaseListPrivacy(bases: ASTList, declSymbol: Symbol, extendsList: bool) {
            if (bases) {
                var basesLen = bases.members.length;
                for (var i = 0; i < basesLen; i++) {
                    if (!bases.members[i].type || bases.members[i].type === this.checker.anyType) {
                        // This type is coming from external module so it has to be exported, or we're recovering from an
                        // error condition
                        continue;
                    }

                    this.checkSymbolPrivacy(bases.members[i].type.symbol, declSymbol, (typeName: string, isModuleName: bool) => this.baseListPrivacyErrorReporter(bases, i, declSymbol, extendsList, typeName, isModuleName));
                }
            }
        }

        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container
        private checkSymbolPrivacy(typeSymbol: TypeSymbol, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName: bool) => void ) {
            var externalModuleSymbol: TypeSymbol = null;
            var declSymbolPath: Symbol[] = null;

            // Type is visible type, so this can be used by anyone.
            if (typeSymbol.isExternallyVisible(this.checker)) {
                // Symbol could be from external module, go ahead and find the external module
                var typeSymbolPath = typeSymbol.pathToRoot();
                declSymbolPath = declSymbol.pathToRoot();
                var typeSymbolLength = typeSymbolPath.length;
                var declSymbolPathLength = declSymbolPath.length;

                if (typeSymbolLength > 0) {
                    if (typeSymbolPath[typeSymbolLength - 1].getType().isModuleType() &&
                        (<TypeSymbol>typeSymbolPath[typeSymbolLength - 1]).isDynamic &&
                        typeSymbolPath[typeSymbolLength - 1] !== declSymbolPath[declSymbolPathLength - 1]) {
                        // Symbol from external module that was imported using one of the import statement
                        externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 1];
                    } else if (typeSymbolLength > 1) {
                        // Is symbol from declared quoted module
                        if (typeSymbolPath[typeSymbolLength - 2].getType().isModuleType() &&
                            (<TypeSymbol>typeSymbolPath[typeSymbolLength - 2]).isDynamic &&
                            (declSymbolPathLength === 1 || typeSymbolPath[typeSymbolLength - 2] !== declSymbolPath[declSymbolPathLength - 2])) {
                            // From quoted module name
                            externalModuleSymbol = <TypeSymbol>typeSymbolPath[typeSymbolLength - 2];
                        }
                    }
                }

                if (externalModuleSymbol === null) {
                    return;
                }
            }

            // Interface symbol doesn't reflect correct Exported state so use AST instead
            var interfaceDecl: InterfaceDeclaration = declSymbol.getInterfaceDeclFromSymbol(this.checker);
            if (interfaceDecl && !hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {
                return;
            }

            var checkVisibilitySymbol = declSymbol;
            // Var decl symbol doesnt reflect correct exported state so use AST instead
            var varDecl = declSymbol.getVarDeclFromSymbol();
            if (varDecl) {
                if (hasFlag(varDecl.varFlags, VarFlags.Private)) {
                    return;
                } else if (hasFlag(varDecl.varFlags, VarFlags.Public)) {
                    // Its a member from class so check visibility of its container
                    checkVisibilitySymbol = declSymbol.container;
                }
            }

            // If the container is visible from global scrope it is error
            if (checkVisibilitySymbol.isExternallyVisible(this.checker)) {
                var privateSymbolName = typeSymbol.name;

                // If imported typeSymbol mark it as visible externally and verify that the symbol it imports is visible externally
                if (externalModuleSymbol !== null) {
                    var prettyName = externalModuleSymbol.getPrettyNameOfDynamicModule(declSymbolPath);
                    if (prettyName !== null) {
                        this.currentScript.AddExternallyVisibleImportedSymbol(prettyName.symbol, this.checker);
                        return;
                    } else {
                        privateSymbolName = externalModuleSymbol.prettyName;
                    }
                }

                // Visible declaration using non visible type.
                errorCallback(privateSymbolName, typeSymbol.name !== privateSymbolName);
            }
        }

        // Checks if the privacy is satisfied by type that is used in the declaration inside container
        private checkTypePrivacy(type: Type, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName: bool) => void ) {
            // Primitive types
            if (!(type && type.primitiveTypeClass === Primitive.None)) {
                return;
            }


            // If type is array, check element type
            if (type.isArray()) {
                return this.checkTypePrivacy(type.elementType, declSymbol, errorCallback);
            }

            // Going to be printing symbol name, verify if symbol can be emitted
            if (type.symbol && type.symbol.name && type.symbol.name !== "_anonymous" &&
                        (((type.call === null) && (type.construct === null) && (type.index === null)) ||
                        (type.members && (!type.isClass())))) {
                return this.checkSymbolPrivacy(<TypeSymbol>type.symbol, declSymbol, errorCallback);
            }

            if (type.members) {
                // Verify symbols for members
                type.members.allMembers.map((key, s, unused) => {
                    var sym = <Symbol>s;
                    if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {
                        this.checkTypePrivacy(sym.getType(), declSymbol, errorCallback);
                    }
                }, null);
            }

            this.checkSignatureGroupPrivacy(type.call, declSymbol, errorCallback);
            this.checkSignatureGroupPrivacy(type.construct, declSymbol, errorCallback);
            this.checkSignatureGroupPrivacy(type.index, declSymbol, errorCallback);
        }

        // Checks if the privacy is satisfied by typeSymbol that is used in the declaration inside container
        private checkSignatureGroupPrivacy(sgroup: SignatureGroup, declSymbol: Symbol, errorCallback: (typeName: string, isModuleName: bool) => void ) {
            if (sgroup) {
                var len = sgroup.signatures.length;
                for (var i = 0; i < sgroup.signatures.length; i++) {
                    var signature = sgroup.signatures[i];
                    if (len > 1 && signature === sgroup.definitionSignature) {
                        // In case of overloads don't look up for overload defintion types.
                        continue;
                    }

                    if (signature.returnType) {
                        this.checkTypePrivacy(signature.returnType.type, declSymbol, errorCallback);
                    }

                    var paramLen = signature.parameters.length;
                    for (var j = 0; j < paramLen; j++) {
                        var param = signature.parameters[j];
                        this.checkTypePrivacy(param.getType(), declSymbol, errorCallback);
                    }
                }
            }
        }

        private functionArgumentPrivacyErrorReporter(funcDecl: FuncDecl, p: number, paramSymbol: Symbol, typeName: string, isModuleName: bool) {
            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);
            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);
            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);
            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) !== null;
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }

            if (!isContainerInterface) {
                if (funcDecl.isConstructor) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported class's constructor parameter '" + paramSymbol.name + "'" + typestring);
                } else if (isSetter) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " setter parameter '" + paramSymbol.name + "'" + typestring);
                } else if (!isGetter) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], (isPublicFunc ? "public" : "exported") + " function parameter '" + paramSymbol.name + "'" + typestring);
                }
            } else {
                if (funcDecl.isConstructMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's constructor parameter '" + paramSymbol.name + "'" + typestring);
                } else if (funcDecl.isCallMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's call parameter '" + paramSymbol.name + "'" + typestring);
                } else if (!funcDecl.isIndexerMember()) {
                    this.checker.errorReporter.simpleError(funcDecl.arguments.members[p], "exported interface's function parameter '" + paramSymbol.name + "'" + typestring);
                }
            }
        }

        private returnTypePrivacyError(astError: AST, funcDecl: FuncDecl, typeName: string, isModuleName: bool) {
            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);
            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);
            var isPublicFunc = hasFlag(funcDecl.fncFlags, FncFlags.Public);
            var isContainerInterface = funcDecl.type.symbol.getInterfaceDeclFromSymbol(this.checker) !== null;
            var typestring = "";
            if (isModuleName) {
                var quotestring = "";
                if (!isQuoted(typeName)) {
                    quotestring = "'";
                }
                typestring = " is using inaccessible module " + quotestring + typeName + quotestring;
            } else {
                typestring = " has or is using private type '" + typeName + "'";
            }
            if (!isContainerInterface) {
                if (isGetter) {
                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " getter return type" + typestring);
                } else if (!isSetter) {
                    this.checker.errorReporter.simpleError(astError, (isPublicFunc ? "public" : "exported") + " function return type" + typestring);
                }
            } else {
                if (funcDecl.isConstructMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's constructor return type" + typestring);
                } else if (funcDecl.isCallMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's call return type" + typestring);
                } else if (funcDecl.isIndexerMember()) {
                    this.checker.errorReporter.simpleError(astError, "exported interface's indexer return type" + typestring);
                } else {
                    this.checker.errorReporter.simpleError(astError, "exported interface's function return type" + typestring);
                }
            }
        }

        private functionReturnTypePrivacyErrorReporter(funcDecl: FuncDecl, signature: Signature, typeName: string, isModuleName: bool) {
            var reportOnFuncDecl = false;

            // Error coming from return annotation
            if (funcDecl.returnTypeAnnotation !== null &&
                funcDecl.returnTypeAnnotation.type === signature.returnType.type) {
                this.returnTypePrivacyError(funcDecl.returnTypeAnnotation, funcDecl, typeName, isModuleName);
            }

            // Check if return statement's type matches the one that we concluded
            for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {
                if (funcDecl.returnStatementsWithExpressions[i].type === signature.returnType.type) {
                    this.returnTypePrivacyError(funcDecl.returnStatementsWithExpressions[i], funcDecl, typeName, isModuleName);
                } else {
                    reportOnFuncDecl = true;
                }
            }

            if (reportOnFuncDecl) {
                // Show on function decl
                this.returnTypePrivacyError(funcDecl, funcDecl, typeName, isModuleName);
            }
        }

        public typeCheckFunction(funcDecl: FuncDecl): FuncDecl {
            this.nestingLevel = 0;
            var fnType = funcDecl.type;

            var fgSym = fnType.symbol;
            var signature = funcDecl.signature;

            if (this.checker.typeStatusIsFinished(signature.typeCheckStatus)) {
                return funcDecl;
            }
            else if (signature.typeCheckStatus === TypeCheckStatus.Started) {
                if (!funcDecl.returnTypeAnnotation &&
                    funcDecl.bod &&
                       !funcDecl.isSignature() &&
                       !(funcDecl.isConstructor) &&
                       this.allReturnsAreVoid(funcDecl)) {

                    signature.returnType.type = this.voidType;
                    return funcDecl;
                }
                else {
                    if (funcDecl.returnTypeAnnotation === null) {
                        if (this.checker.styleSettings.implicitAny) {
                            this.checker.errorReporter.styleError(funcDecl, "type implicitly set to 'any'");
                        }
                        signature.returnType.type = this.anyType;
                        fgSym.flags |= SymbolFlags.RecursivelyReferenced;
                    }
                    return funcDecl;
                }
            }

            signature.typeCheckStatus = TypeCheckStatus.Started;
            this.checker.addStartedPTO(signature);
            var prevScope = this.scope;
            var prevFnc = this.thisFnc;
            var prevMethodStatus = this.enclosingFncIsMethod;
            var prevClassNode = this.thisClassNode;
            this.enclosingFncIsMethod = funcDecl.isMethod() || funcDecl.isConstructor;
            this.thisFnc = funcDecl;
            var container = funcDecl.type.symbol;
            var prevThisType = this.thisType;
            var prevLocationInfo = this.checker.locationInfo;
            var funcTable: IHashTable = null;
            var acceptedContextualType = false;
            var targetParams: ParameterSymbol[] = null;
            var targetReturnType: Type = null;
            var isGetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor);
            var isSetter = funcDecl.isAccessor() && hasFlag(funcDecl.fncFlags, FncFlags.SetAccessor);
            var accessorType: Type = (isGetter || isSetter) && funcDecl.accessorSymbol ? funcDecl.accessorSymbol.getType() : null;
            var prevModDecl = this.checker.currentModDecl;
            var ssb: SymbolScopeBuilder;

            if (funcDecl.isConstructor && !funcDecl.isOverload) {
                if (fnType.instanceType === null) {
                    this.checker.errorReporter.simpleError(funcDecl, "Malformed function body (is this a class named the same as an existing interface?)");
                    return funcDecl;
                }
                if (funcDecl.classDecl.type.construct === null) {
                    this.checker.errorReporter.simpleError(funcDecl, "Malformed constructor (is this a class named the same as an existing class?)");
                    return funcDecl;
                }
                this.scope = fnType.instanceType.constructorScope;
                ssb = <SymbolScopeBuilder>this.scope;
                funcTable = ssb.valueMembers.allMembers;
            }
            else if ((funcDecl.isSpecialFn() && !(funcDecl.fncFlags & FncFlags.Signature)) || funcDecl.isOverload) {
                funcTable = funcDecl.symbols;
                // if the function is static, we just want to use the 
                // current scope
                if (!hasFlag(funcDecl.fncFlags, FncFlags.Static) && fnType.containedScope) {
                    this.scope = fnType.containedScope;
                }
            }
            else {
                if (funcDecl.bod) {
                    this.scope = fnType.containedScope;
                }
                ssb = <SymbolScopeBuilder>this.scope;

                // If it is null, it's an ambient declaration with no body, so it doesn't strictly matter
                // if funcTable is not set
                if (ssb && ssb.valueMembers) {
                    funcTable = ssb.valueMembers.allMembers;
                }
            }

            // If it's a class constructor, we need to check for the presence (or absense) of calls
            // to the 'super' constructor
            //
            // A super constructor call must exist if:
            //  - the class has a base class
            //
            // A super constructor call must be the first statement in the function body if:
            //  - the constructor has parameter properties or
            //  - the class body has initialized property decls
            //
            // A super constructor call may not exist if:
            //  - The class has no base type, or inherits directly from 'Object'
            if (funcDecl.isConstructor && funcDecl.bod && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {

                var hasBaseType = hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseType);
                var noSuperCallAllowed = !hasBaseType || hasFlag(funcDecl.classDecl.type.instanceType.typeFlags, TypeFlags.HasBaseTypeOfObject);
                var superCallMustBeFirst = hasFlag((<ClassDeclaration>funcDecl.classDecl).varFlags, VarFlags.ClassSuperMustBeFirstCallInConstructor);

                if (noSuperCallAllowed && this.classConstructorHasSuperCall(funcDecl)) {
                    this.checker.errorReporter.simpleError(funcDecl, "Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class");
                }
                else if (hasBaseType) {
                    if (superCallMustBeFirst) {
                        if (!funcDecl.bod ||
                            !funcDecl.bod.members.length ||
                            !((funcDecl.bod.members[0].nodeType === NodeType.Call && (<CallExpression>funcDecl.bod.members[0]).target.nodeType === NodeType.Super) ||
                            (hasFlag(funcDecl.bod.flags, ASTFlags.StrictMode) && funcDecl.bod.members.length > 1 &&
                             funcDecl.bod.members[1].nodeType === NodeType.Call && (<CallExpression>funcDecl.bod.members[1]).target.nodeType === NodeType.Super))) {
                            this.checker.errorReporter.simpleError(funcDecl, "If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor");
                        }
                    }
                    else if (!this.classConstructorHasSuperCall(funcDecl)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Constructors for derived classes must contain a call to the class's 'super' constructor");
                    }
                }
            }

            // If we've typechecked this method "out of order" (not by walking the class, but through a method call somewhere else),
            // we need to reset the current class node in question, so that visibility checks on class members don't fail
            if (funcDecl.isMethod() && funcDecl.type.enclosingType) {

                var enclosingClassNode: TypeDeclaration = null;

                if (funcDecl.type.enclosingType.symbol.declAST.nodeType === NodeType.FuncDecl) {
                    enclosingClassNode = <TypeDeclaration>(<FuncDecl>funcDecl.type.enclosingType.symbol.declAST).classDecl;
                }
                else if (funcDecl.type.enclosingType.symbol.declAST.nodeType === NodeType.ClassDeclaration) {
                    enclosingClassNode = <TypeDeclaration>funcDecl.type.enclosingType.symbol.declAST;
                }

                if (enclosingClassNode) {
                    this.thisClassNode = enclosingClassNode;
                }
            }

            // if this function is contained in a module, we may be in the midst of a recursive typecheck operation
            // should that be the case, we need to properly set the current module (for visibility tests)
            if (fnType.enclosingType) {;
                var enclosingSym = fnType.symbol.container;

                // if the enclosing type is a class, grab the parent module
                if (enclosingSym && enclosingSym.isType() && enclosingSym.getType().isClass()) {
                    enclosingSym = enclosingSym.container;
                }

                if (enclosingSym && enclosingSym.declAST && enclosingSym.declAST.nodeType === NodeType.ModuleDeclaration) {
                    this.checker.currentModDecl = <ModuleDeclaration>enclosingSym.declAST;
                }
            }

            if (funcDecl.fileName !== unknownLocationInfo.fileName) {
                if (this.checker.fileNameToLocationInfo &&
                    this.checker.fileNameToLocationInfo.lookup(funcDecl.fileName)) {
                    this.checker.locationInfo = this.checker.fileNameToLocationInfo.lookup(funcDecl.fileName);
                }
                else {
                    this.checker.locationInfo = unknownLocationInfo;
                }
            }

            if (fnType.enclosingType) {
                this.thisType = fnType.enclosingType;
            }
            else {
                this.thisType = prevThisType;
            }

            var paramLen = signature.parameters.length;
            var candidateTypeContext: ContextualTypeContext;
            var p = 0;

            if (!funcDecl.isConstructor && funcDecl.bod && !funcDecl.isSignature()) {
                var tmpParamScope = this.scope;
                ssb = <SymbolScopeBuilder>this.scope;

                // Attempt to contextually type the function declaration             
                if (!funcDecl.isMethod() && funcDecl.returnTypeAnnotation === null) {

                    // the funcDecl may be a candidate for contextual typing                 
                    // REVIEW: prevScope will only be null in the case of an upstream error
                    if (prevScope && funcDecl.name && !funcDecl.name.isMissing()) {
                        // Go ahead and check for an ambient symbol
                        var considerSym: Symbol = prevScope.findAmbient(funcDecl.name.text, false, false);

                        if (considerSym && considerSym.declAST && considerSym.declAST.type) {
                            // REVIEW: Ambients beget signatures, and signatures don't need to be typechecked
                            //typeCheck(considerSym.declAST);
                            this.checker.setContextualType(considerSym.declAST.type, false);
                        }
                    }

                    if (this.checker.hasTargetType()) {
                        candidateTypeContext = this.checker.getTargetTypeContext();
                        var candidateType = candidateTypeContext.contextualType;

                        if (this.checker.canContextuallyTypeFunction(candidateType, funcDecl, true)) {

                            // Safe to do this, since the indices and fields are guaranteed to be
                            // non-null and valid by the above call to canContextuallyTypeFunction
                            var candidateSigs = candidateType.construct ? candidateType.construct : candidateType.call;
                            candidateTypeContext.targetSig = candidateSigs.signatures[0];
                            var candidateParams = candidateTypeContext.targetSig.parameters;

                            // the target type has been accepted
                            targetParams = candidateParams;
                            targetReturnType = candidateTypeContext.targetSig.returnType.type;

                            fgSym.type = candidateTypeContext.contextualType;
                            acceptedContextualType = true;
                        }
                        else if (candidateType && funcDecl.isAccessor()) {
                            accessorType = candidateType;
                            candidateTypeContext.targetAccessorType = accessorType;
                        }
                        else {
                            this.checker.killCurrentContextualType();
                        }
                    }
                }

                // typecheck parameters
                // Add parameter symbols to current scope for typechecking (in case default params reference each other)
                // Order matters here - default parameters can reference previously defined parameters
                var paramTable = ssb.valueMembers;
                this.scope = new SymbolScopeBuilder(paramTable, null, null, null, prevScope, container);

                for (p = 0; p < paramLen; p++) {
                    var symbol = signature.parameters[p];
                    var ast = <ArgDecl>symbol.declAST

                    if (this.checker.hasTargetType() && (targetParams && (this.checker.getTargetTypeContext().targetSig.hasVariableArgList || p < targetParams.length))) {
                        candidateTypeContext = this.checker.getTargetTypeContext();
                        var hasVarArgList = candidateTypeContext.targetSig.hasVariableArgList;
                        ast.type = hasVarArgList && p >= targetParams.length - 1 ? targetParams[targetParams.length - 1].getType().elementType : targetParams[p].getType();
                        ast.sym.setType(ast.type);
                        (<InferenceSymbol>ast.sym).typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                    }
                    else {
                        this.typeCheck(ast);
                    }

                    // infer the setter type, if necessary
                    if (isSetter && accessorType) {
                        ast = <ArgDecl>this.cast(ast, accessorType);
                    }

                    symbol.container = container;
                    // Verify the parameter for the privacy
                    this.checkTypePrivacy(symbol.getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, symbol, typeName, isModuleName));
                    paramTable.publicMembers.add(symbol.name, symbol);
                }
                this.scope = tmpParamScope;
            }
            else {
                this.typeCheck(funcDecl.arguments)

                // Because some terms were not yet type-checkable during binding, ensure that
                // param symbols are updated with the proper argument types
                for (p = 0; p < paramLen; p++) {
                    signature.parameters[p].parameter.typeLink.type = funcDecl.arguments.members[p].type;
                    // Verify the parameter for the privacy
                    this.checkTypePrivacy(signature.parameters[p].getType(), container, (typeName: string, isModuleName: bool) => this.functionArgumentPrivacyErrorReporter(funcDecl, p, signature.parameters[p], typeName, isModuleName));
                    if ((<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym) {
                        (<ArgDecl>funcDecl.arguments.members[p]).parameterPropertySym.setType(funcDecl.arguments.members[p].type);
                    }
                }

                if ((funcDecl.fncFlags & FncFlags.IndexerMember)) {
                    if (!paramLen || paramLen > 1) {
                        this.checker.errorReporter.simpleError(funcDecl, "Index signatures may take one and only one parameter");
                    }
                    else if (funcDecl.arguments.members[0].type === this.checker.numberType) {
                        fnType.index.flags |= SignatureFlags.IsNumberIndexer;
                    }
                    else if (funcDecl.arguments.members[0].type === this.checker.stringType) {
                        fnType.index.flags |= SignatureFlags.IsStringIndexer;
                    }
                    else {
                        this.checker.errorReporter.simpleError(funcDecl.arguments.members[0], "Index signatures may only take 'string' or 'number' as their parameter");
                    }

                }
            }

            // typecheck body
            if (funcDecl.bod && (!funcDecl.isSignature())) {
                if (!(funcDecl.isConstructor)) {
                    this.addFormals(container, signature, funcTable);
                }
                else {
                    this.addConstructorLocalArgs(funcDecl, funcTable, hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod));

                    if (this.thisClassNode && this.thisClassNode.extendsList) {
                        var tmpScope = this.scope;
                        var funcMembers = new ScopedMembers(<DualStringHashTable>funcTable);
                        this.scope = new FilteredSymbolScopeBuilder(funcMembers, prevScope, funcDecl.type.symbol,
                                                             function (sym) {
                                                                 return sym.kind() === SymbolKind.Parameter;
                                                             });
                        this.typeCheckBaseCalls(this.thisClassNode.extendsList);
                        this.scope = tmpScope;
                    }
                }

                // Because this function may have been typechecked in a different visiblity context as its caller (e.g., this
                // function is being typechecked as a result of a call, before the declaration could be typechecked), we need
                // to set the enclosing module
                var prevMod = this.checker.currentModDecl;
                if (funcDecl.type &&
                    funcDecl.type.symbol &&
                    !funcDecl.isMethod() &&
                    funcDecl.type.symbol.declModule) {
                    this.checker.currentModDecl = funcDecl.type.symbol.declModule;
                }


                // unset the contextual type before typechecking the function body
                if (acceptedContextualType) {
                    this.checker.setContextualType(null, this.checker.inProvisionalTypecheckMode());
                }

                this.typeCheck(funcDecl.bod);

                if (acceptedContextualType) {
                    this.checker.unsetContextualType();
                }

                this.checker.currentModDecl = prevMod;

                if (this.checker.checkControlFlow) {
                    var cfg = funcDecl.buildControlFlow();
                    if (this.checker.printControlFlowGraph) {
                        cfg.print(this.checker.errorReporter.outfile);
                    }
                    cfg.reportUnreachable(this.checker.errorReporter);
                    if (this.checker.checkControlFlowUseDef) {
                        cfg.useDef(this.checker.errorReporter, funcDecl.type.symbol);
                    }
                }

                if (funcDecl.isConstructor) {
                    var fns: ASTList = funcDecl.scopes;
                    var fnsLen = fns.members.length;
                    var freeVars: Symbol[];
                    var sym: Symbol;
                    var j = 0;
                    for (; j < fnsLen; j++) {
                        var fn = <FuncDecl>fns.members[j];
                        if (!fn.isSignature()) {
                            if (hasFlag(fn.fncFlags, FncFlags.Method) && (!hasFlag(fn.fncFlags, FncFlags.Static))) {
                                this.checkPromoteFreeVars(fn, funcDecl.type.symbol);
                            }
                        }
                    }
                }
            }

            this.scope = prevScope;
            this.thisFnc = prevFnc;
            this.thisClassNode = prevClassNode;
            this.enclosingFncIsMethod = prevMethodStatus;
            this.thisType = prevThisType;
            this.checker.locationInfo = prevLocationInfo;
            this.checker.currentModDecl = prevModDecl;

            signature.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();

            // set the return type
            if (funcDecl.returnTypeAnnotation) {
                this.checkForVoidConstructor(funcDecl.returnTypeAnnotation.type, funcDecl.returnTypeAnnotation);

                if (signature.returnType.type === null) {
                    this.checker.resolveTypeLink(this.scope, signature.returnType, false);
                }
            }
            else if (targetReturnType) {
                signature.returnType.type = targetReturnType;
            }

            // If no return type annotation has been applied to the function declaration
            // unify the return types from the given return statements

            if (!(fgSym.flags & SymbolFlags.RecursivelyReferenced) && funcDecl.returnStatementsWithExpressions.length > 0) {
                var collection: ITypeCollection = {
                    getLength: () => { return funcDecl.returnStatementsWithExpressions.length; },
                    setTypeAtIndex: (index: number, type: Type) => { funcDecl.returnStatementsWithExpressions[index].type = type; },
                    getTypeAtIndex: (index: number) => { return funcDecl.returnStatementsWithExpressions[index].type; }
                }

                var bestCommonReturnType = funcDecl.returnStatementsWithExpressions[0].type;
                bestCommonReturnType = this.checker.findBestCommonType(bestCommonReturnType, null, collection, true);

                if (bestCommonReturnType) {
                    signature.returnType.type = this.checker.widenType(bestCommonReturnType);
                }
                else {
                    for (var i = 0; i < funcDecl.returnStatementsWithExpressions.length; i++) {
                        this.checker.errorReporter.simpleError(funcDecl.returnStatementsWithExpressions[i], "Incompatible return type");
                    }
                    signature.returnType.type = this.anyType;
                }
            }

            var onlyHasThrow = false;

            if (signature.returnType.type === null) {
                if (hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {
                    if (this.checker.styleSettings.implicitAny) {
                        this.checker.errorReporter.styleError(funcDecl, "type implicitly set to 'any'");
                    }
                    signature.returnType.type = this.anyType;
                }
                else {
                    signature.returnType.type = this.voidType;
                }
            }
            else if (signature.returnType.type === this.nullType || signature.returnType.type === this.checker.undefinedType) {
                signature.returnType.type = this.anyType;
            }
            else if ((signature.returnType.type !== this.voidType && signature.returnType.type !== this.checker.undefinedType && signature.returnType.type !== this.anyType)) {
                // the signature declared a non-void type, but there's no return statement
                if (!funcDecl.isSignature() &&
                    !funcDecl.isConstructor &&
                    !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression) &&
                    !hasFlag(funcDecl.fncFlags, FncFlags.IsFatArrowFunction)) {
                    // relax the restriction if the method only contains a single "throw" statement
                    onlyHasThrow = (funcDecl.bod.members.length > 0) && (funcDecl.bod.members[0].nodeType === NodeType.Throw)

                    if (!onlyHasThrow) {
                        this.checker.errorReporter.simpleError(funcDecl.returnTypeAnnotation || funcDecl,
                             "Function declared a non-void return type, but has no return expression");
                    }
                }

                // Type check for return type Privacy
                this.checkTypePrivacy(signature.returnType.type, container, (typeName: string, isModuleName: bool) => this.functionReturnTypePrivacyErrorReporter(funcDecl, signature, typeName, isModuleName));
            }

            // if the function declaration is a getter or a setter, set the type of the associated getter/setter symbol
            if (funcDecl.accessorSymbol) {
                accessorType = funcDecl.accessorSymbol.getType();
                if (!onlyHasThrow && hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && !hasFlag(funcDecl.fncFlags, FncFlags.HasReturnExpression)) {
                    this.checker.errorReporter.simpleError(funcDecl, "Getters must return a value");
                }
                if (accessorType) {
                    if ((hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor) && accessorType !== signature.returnType.type) ||
                        (funcDecl.arguments.members.length > 0 && accessorType !== funcDecl.arguments.members[0].type)) {
                        this.checker.errorReporter.simpleError(funcDecl, "Getter and setter types do not agree");
                    }
                }
                else {
                    if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                        funcDecl.accessorSymbol.setType(signature.returnType.type);
                    }
                    else {
                        if (funcDecl.arguments.members.length !== 1) {
                            this.checker.errorReporter.simpleError(funcDecl, "Setters may have one and only one argument");
                        }
                        else {
                            funcDecl.accessorSymbol.setType(funcDecl.arguments.members[0].type);
                        }
                    }
                }
            }

            this.typeCheckOverloadSignatures(fnType, funcDecl);
            return funcDecl;
        }

        public typeCheckBases(type: Type) {
            var seenInterface = false;
            var bases = type.extendsList;
            var baseLinks = type.extendsTypeLinks;
            if (bases) {
                var len = bases.length;

                if (len > 0) {
                    type.typeFlags |= TypeFlags.HasBaseType;
                }

                for (var i = 0; i < len; i++) {
                    if (bases[i] === this.checker.anyType) {
                        // This may be the type from imported module and hence the type was not really resolved to the correct one.
                        // Try resolving it again
                        baseLinks[i].type = null;
                        // There are no contextual errors when trying to verify the base class
                        var oldErrors = this.checker.errorReporter.getCapturedErrors();
                        CompilerDiagnostics.assert(oldErrors.length === 0, "There shouldnt be any contextual errors when typechecking base type names");
                        this.checker.errorReporter.pushToErrorSink = true;
                        bases[i] = this.checker.resolveBaseTypeLink(baseLinks[i], type.containedScope);
                        this.checker.errorReporter.pushToErrorSink = false;
                        this.checker.errorReporter.freeCapturedErrors();
                    }

                    var base = bases[i];
                    var baseRef = baseLinks[i].ast;

                    // make sure it's the global 'Object' and not some alias
                    var baseTypeOfObject = base.symbol && base.symbol.name === "Object" && base.symbol.container === this.checker.gloMod;

                    if (baseTypeOfObject) {
                        type.typeFlags |= TypeFlags.HasBaseTypeOfObject;
                    }

                    if (base.isClassInstance()) {
                        if (!(type.isClassInstance())) {
                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");
                        }
                        else {
                            if (seenInterface) {
                                this.checker.errorReporter.simpleError(baseRef, "Class may not follow interface as base type");
                            }
                        }
                    }
                    else if (base.isModuleType()) {
                        this.checker.errorReporter.simpleError(baseRef, "Types may not be derived from module types");
                    }
                    else if (base.members) {
                        if (!seenInterface) {
                            seenInterface = true;
                        }
                    }
                    else {
                        if (!(type.isClassInstance())) {
                            this.checker.errorReporter.simpleError(baseRef, "Interface base type must be interface");
                        }
                        else {
                            this.checker.errorReporter.simpleError(baseRef, "Base type must be interface or class");
                        }
                        break;
                    }
                }
            }
        }

        public checkMembersImplementInterfaces(implementingType: Type) {
            var instanceType = implementingType.getInstanceType();
            if (instanceType.implementsList) {
                var len = instanceType.implementsList.length;

                for (var i = 0; i < len; i++) {
                    var interfaceType = instanceType.implementsList[i];
                    var comparisonInfo = new TypeComparisonInfo();
                    if (!this.checker.sourceIsSubtypeOfTarget(instanceType, interfaceType, comparisonInfo)) {
                        var emsg = "Class '" + instanceType.getTypeName() +
                              "' declares interface '" + interfaceType.getTypeName() +
                              "' but does not implement it";
                        if (!comparisonInfo.message) {
                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg);
                        }
                        else {
                            this.checker.errorReporter.simpleErrorFromSym(instanceType.symbol, emsg + ": " + comparisonInfo.message);
                        }
                    }
                }
            }
        }

        public typeCheckBaseCalls(bases: ASTList) {
            if (bases === null) {
                return;
            }
            var basesLen = bases.members.length;
            for (var i = 0; i < basesLen; i++) {
                var baseExpr = bases.members[i];
                var baseSymbol: Symbol = null;
                if (baseExpr.nodeType === NodeType.Call) {
                    this.typeCheckNew(baseExpr);
                }
            }
        }

        public assertUniqueNamesInBaseTypes(names: IHashTable, type: Type, classDecl: InterfaceDeclaration, checkUnique: bool): void {
            if (type) {
                if (type.members) {
                    type.members.publicMembers.map((key, s, c) => {
                        var sym = <Symbol>s;
                        var dup = names.lookup(sym.name);
                        if (dup) {
                            if (checkUnique) {
                                this.checker.errorReporter.simpleError(classDecl,
                                                                  "duplicate member name in bases for " + classDecl.name.actualText + ": " + type.symbol.name + " and " + dup.container.name + " both contain member with name " + sym.name);
                            }
                        }
                        else {
                            names.add(sym.name, sym);
                        }
                    }, null);
                }
                if (type.extendsList) {
                    var len = type.extendsList.length;
                    for (var i = 0; i < len; i++) {
                        if (!(type.extendsList[i].symbol.flags & SymbolFlags.RecursivelyReferenced)) {
                            this.assertUniqueNamesInBaseTypes(names, type.extendsList[i], classDecl, checkUnique);
                        }
                    }
                }
            }
        }

        public checkBaseTypeMemberInheritance(derivedType: Type, derivedTypeDecl: AST): void {
            var instanceType = derivedType.getInstanceType();
            if (!instanceType.extendsList) {
                return;
            }

            var len = instanceType.extendsList.length;
            if (len > 0) {
                var names = new StringHashTable();
                if (instanceType.isClassInstance()) {
                    for (var i = 0; i < len; i++) {
                        this.assertUniqueNamesInBaseTypes(names, instanceType.extendsList[i], <InterfaceDeclaration>derivedTypeDecl, i > 0);
                    }
                }

                if (instanceType.members) {
                    instanceType.members.publicMembers.map((key, s, c) => {
                        var sym = <Symbol>s;
                        for (var j = 0; j < len; j++) {
                            var base = instanceType.extendsList[j];
                            if (!base.memberScope) {
                                this.checker.errorReporter.simpleError(derivedTypeDecl, "Base type '" + base.symbol.name + "' lacks an implementation.")
                            }
                            else {
                                var bSym = base.memberScope.find(sym.name, false, false);
                                if (bSym) {
                                    var aType = sym.getType();
                                    var bType = bSym.getType();
                                    if (!(this.checker.sourceIsSubtypeOfTarget(aType, bType))) {
                                        this.checker.errorReporter.simpleErrorFromSym(sym,
                                                                          "Type of overridden member '" + sym.name + "' is not subtype of original member defined by type '" + bSym.container.name + "'");
                                    }
                                    else if ((sym.kind() === SymbolKind.Type) &&
                                             (bSym.kind() === SymbolKind.Field)) {
                                        this.checker.errorReporter.simpleErrorFromSym(sym,
                                                                          "Cannot override field '" + sym.name + "' with method");
                                    }
                                }
                            }
                        }
                    }, null);
                }
            }
        }

        public typeCheckClass(classDecl: ClassDeclaration): ClassDeclaration {
            var typeSymbol = <TypeSymbol>classDecl.type.symbol;

            if (typeSymbol.typeCheckStatus === TypeCheckStatus.Finished) {
                return classDecl;
            }
            else if (typeSymbol.typeCheckStatus === TypeCheckStatus.Started) {
                // REVIEW: report this recursion
                //checker.errorReporter.recursionRequiresTypeAnnotation(classDecl);
                return classDecl;
            }
            else {
                typeSymbol.typeCheckStatus = TypeCheckStatus.Started;
                this.checker.addStartedPTO(typeSymbol);
            }

            var prevScope = this.scope;
            var svClassNode = this.thisClassNode;
            this.thisClassNode = classDecl;
            var classType = classDecl.type;
            this.typeCheckBases(classType.instanceType);

            this.typeCheckBaseListPrivacy(classDecl.extendsList, typeSymbol, true);
            this.typeCheckBaseListPrivacy(classDecl.implementsList, typeSymbol, false);

            var prevThisType = this.thisType;
            this.thisType = classType.instanceType;
            this.scope = classType.instanceType.containedScope;

            // Add the constructor locals, if necessary
            if (classDecl.constructorDecl) {
                this.scope = classType.instanceType.constructorScope;
                var ssb = <SymbolScopeBuilder>this.scope;
                var funcTable = ssb.valueMembers.allMembers;

                this.addConstructorLocalArgs(classDecl.constructorDecl, funcTable, true);
            }

            this.typeCheck(classDecl.members);
            typeSymbol.typeCheckStatus = TypeCheckStatus.Finished;
            this.checkBaseTypeMemberInheritance(classType, classDecl);
            this.checkMembersImplementInterfaces(classType);

            this.typeCheckOverloadSignatures(classType, classDecl);
            this.typeCheckOverloadSignatures(classType.instanceType, classDecl);

            // if the class has no declared constructor, adapt its base class's signature group, if necessary
            if (!classDecl.constructorDecl) {
                if (classDecl.extendsList &&
                    classDecl.extendsList.members.length &&
                    classDecl.extendsList.members[0].type &&
                    classDecl.extendsList.members[0].type.symbol.type.isClass()) {
                    cloneParentConstructGroupForChildType(classDecl.type, classDecl.extendsList.members[0].type.symbol.type);
                }
            }

            this.thisType = prevThisType;
            this.thisClassNode = svClassNode;
            this.scope = prevScope;
            return classDecl;
        }

        public typeCheckOverloadSignatures(type: Type, ast: AST) {
            if (type.call) {
                type.call.typeCheck(this.checker, ast, type.construct !== null);
            }
            if (type.construct) {
                type.construct.typeCheck(this.checker, ast, false);
            }
            if (type.index) {
                type.index.typeCheck(this.checker, ast, false);
            }
        }

        public typeCheckInterface(interfaceDecl: InterfaceDeclaration): InterfaceDeclaration {
            // overloads will be typechecked inline by the members
            //this.typeCheckOverloadSignatures(interfaceDecl.type, interfaceDecl);
            this.typeCheckBases(interfaceDecl.type);
            this.typeCheckBaseListPrivacy(interfaceDecl.extendsList, interfaceDecl.type.symbol, true);
            this.typeCheck(interfaceDecl.members);
            this.checkBaseTypeMemberInheritance(interfaceDecl.type, interfaceDecl);

            // propagate base type signatures
            if (interfaceDecl.extendsList) {
                for (var i = 0; i < interfaceDecl.extendsList.members.length; i++) {
                    if (interfaceDecl.extendsList.members[i].type.call) {
                        if (interfaceDecl.type.call) {
                            interfaceDecl.type.call.signatures = interfaceDecl.type.call.signatures.concat(interfaceDecl.extendsList.members[i].type.call.signatures);
                        }
                        else {
                            interfaceDecl.type.call = interfaceDecl.extendsList.members[i].type.call;
                        }
                    }
                    if (interfaceDecl.extendsList.members[i].type.construct) {
                        if (interfaceDecl.type.construct) {
                            interfaceDecl.type.construct.signatures = interfaceDecl.type.construct.signatures.concat(interfaceDecl.extendsList.members[i].type.construct.signatures);
                        }
                        else {
                            interfaceDecl.type.construct = interfaceDecl.extendsList.members[i].type.construct;
                        }
                    }
                    if (interfaceDecl.extendsList.members[i].type.index) {
                        if (interfaceDecl.type.index) {
                            interfaceDecl.type.index.signatures = interfaceDecl.type.index.signatures.concat(interfaceDecl.extendsList.members[i].type.index.signatures);
                        }
                        else {
                            interfaceDecl.type.index = interfaceDecl.extendsList.members[i].type.index;
                        }
                    }
                }
            }

            return interfaceDecl;
        }

        public typeCheckImportDecl(importDecl: ImportDeclaration) {
            var mod: ModuleType = <ModuleType>importDecl.alias.type;
            var sym: TypeSymbol = null;
            var prevInImportTC = this.inImportTypeCheck;
            this.inImportTypeCheck = true;

            this.typeCheck(importDecl.alias);
            mod = <ModuleType>importDecl.alias.type;

            if (mod === null) {
                this.checker.errorReporter.simpleError(importDecl.alias, "Could not resolve module alias '" + importDecl.id.actualText + "'");
                mod = <ModuleType>this.checker.anyType;
                (<TypeSymbol>importDecl.id.sym).type = mod;
            }

            importDecl.id.type = mod;
            sym = mod.symbol;

            if (!mod.isModuleType()) {
                this.checker.errorReporter.simpleError(importDecl.alias, "A module cannot be aliased to a non-module type");
            }
            else {
                sym.type = mod;

                // Add the imported module to the AMD dependency list
                if (this.checker.typeFlow.currentScript &&
                    this.checker.typeFlow.currentScript.topLevelMod &&
                    this.checker.typeFlow.currentScript.topLevelMod.mod) {
                    this.checker.typeFlow.currentScript.topLevelMod.mod.importedModules.push(importDecl);
                }

                (<TypeSymbol>importDecl.id.sym).type = mod;

                if (mod.symbol && mod.symbol.declAST) {
                    (<ModuleDeclaration>mod.symbol.declAST).modFlags &= ~ModuleFlags.ShouldEmitModuleDecl;
                }

                //importDecl.id.sym = sym;
                // REVIEW: Uncomment when you can toggle module codegen targets from the language service
                //else if (typeFlow.checker.currentModDecl === null && 
                //            hasFlag((<ModuleDecl>sym.declAST).modFlags,ModuleFlags.IsDynamic) &&
                //            moduleGenTarget === ModuleGenTarget.Asynchronous) 
                //{
                //    typeFlow.checker.errorReporter.simpleError(alias, "In AMD codegen mode, dynamic modules may not be referenced from global scope.  (Wrap the file in a module declaration.)");
                //}
            }
            this.inImportTypeCheck = prevInImportTC;
            return importDecl;
        }

        public typeCheckModule(moduleDecl: ModuleDeclaration): ModuleDeclaration {

            // In some really nasty cases of error recovery, we may not have a type
            if (!moduleDecl.mod) {
                return moduleDecl;
            }

            if (this.currentScript) {
                this.currentScript.requiresGlobal = true;
            }
            var mod = moduleDecl.mod;
            var sym: TypeSymbol = null;

            var prevScope = this.scope;
            var prevThisType = this.thisType;
            var prevCurrentModDecl = this.checker.currentModDecl;
            this.checker.currentModDecl = moduleDecl;

            this.thisType = null;
            this.scope = mod.containedScope;
            this.typeCheck(moduleDecl.members);
            sym = mod.symbol;

            this.checker.currentModDecl = prevCurrentModDecl;
            this.thisType = prevThisType;
            this.scope = prevScope;

            moduleDecl.type = mod;

            if (sym) {
                sym.typeCheckStatus = TypeCheckStatus.Finished;
            }
            return moduleDecl;
        }

        public typeCheckFor(forStmt: ForStatement): ForStatement {
            forStmt.init = this.typeCheck(forStmt.init);
            this.nestingLevel++;
            forStmt.cond = this.typeCheck(forStmt.cond);
            this.typeCheckCondExpr(forStmt.cond);
            forStmt.incr = this.typeCheck(forStmt.incr);
            this.nestingLevel--;
            forStmt.body = this.typeCheck(forStmt.body);
            this.typeCheckCompoundStmtBlock(forStmt.body, "for statement");
            forStmt.type = this.voidType;
            return forStmt;
        }

        public typeCheckWith(withStmt: WithStatement): WithStatement {
            if (this.checker.errorsOnWith) {
                this.checker.errorReporter.simpleError(withStmt.expr, "All symbols within a 'with' block will be typed as 'any'");
            }
            withStmt.expr = this.typeCheck(withStmt.expr);
            this.checker.inWith = true;
            withStmt.body = this.typeCheck(withStmt.body);
            this.typeCheckCompoundStmtBlock(withStmt.body, "with statement");
            this.checker.inWith = false;
            return withStmt;
        }

        public typeCheckForIn(forInStmt: ForInStatement): ForInStatement {
            forInStmt.obj = this.typeCheck(forInStmt.obj);
            forInStmt.lval = this.cast(this.typeCheck(forInStmt.lval), this.checker.stringType);
            if (forInStmt.lval.nodeType === NodeType.VarDecl) {

                var varDecl = <VarDecl>forInStmt.lval;
                if (varDecl.typeExpr) {
                    this.checker.errorReporter.simpleError(varDecl, "Variable declarations for for/in expressions may not contain a type annotation");
                }

                if (varDecl.sym) {
                    varDecl.sym.setType(this.checker.stringType);
                }
            }
            forInStmt.body = this.typeCheck(forInStmt.body);
            this.typeCheckCompoundStmtBlock(forInStmt.body, "for in statement");
            return forInStmt;
        }

        public typeCheckWhile(whileStmt: WhileStatement): WhileStatement {
            whileStmt.cond = this.typeCheck(whileStmt.cond);
            this.typeCheckCondExpr(whileStmt.cond);
            whileStmt.body = this.typeCheck(whileStmt.body);
            this.typeCheckCompoundStmtBlock(whileStmt.body, "while statement");
            whileStmt.type = this.voidType;
            return whileStmt;
        }

        public typeCheckDoWhile(doWhileStmt: DoWhileStatement): DoWhileStatement {
            doWhileStmt.cond = this.typeCheck(doWhileStmt.cond);
            this.typeCheckCondExpr(doWhileStmt.cond);
            doWhileStmt.body = this.typeCheck(doWhileStmt.body);
            this.typeCheckCompoundStmtBlock(doWhileStmt.body, "do while statement");
            doWhileStmt.type = this.voidType;
            return doWhileStmt;
        }

        public typeCheckCondExpr(cond: AST) {
            if (this.checker.styleSettings.assignmentInCond) {
                if ((cond !== null) &&
                    (cond.nodeType >= NodeType.Asg) &&
                    (cond.nodeType <= NodeType.LastAsg)) {
                    this.checker.errorReporter.simpleError(cond, "top-level assignment statement in conditional expression");
                }
            }
        }

        public typeCheckCompoundStmtBlock(stmts: AST, stmtType: string) {
            if (this.checker.styleSettings.blockInCompoundStmt && stmts) {
                if (stmts.nodeType !== NodeType.Block) {
                    this.checker.errorReporter.styleError(stmts, stmtType + " requires a block");
                }
            }
        }

        public typeCheckIf(ifStmt: IfStatement): IfStatement {
            ifStmt.cond = this.typeCheck(ifStmt.cond);
            this.typeCheckCondExpr(ifStmt.cond);
            ifStmt.thenBod = this.typeCheck(ifStmt.thenBod);
            ifStmt.elseBod = this.typeCheck(ifStmt.elseBod);
            this.typeCheckCompoundStmtBlock(ifStmt.thenBod, "if statement");
            this.typeCheckCompoundStmtBlock(ifStmt.elseBod, "if statement");
            ifStmt.type = this.voidType;
            return ifStmt;
        }

        public typeFromAccessorFuncDecl(funcDecl: FuncDecl) {
            if (!funcDecl.isAccessor()) {
                return null;
            }

            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                return funcDecl.type.call.signatures[0].returnType.type;
            }
            else {
                return funcDecl.type.call.signatures[0].parameters[0].getType();
            }
        }

        public typeCheckObjectLit(objectLit: UnaryExpression): void {

            var resultType = new Type();
            resultType.symbol = new TypeSymbol(this.checker.anon, objectLit.minChar,
                                             objectLit.limChar - objectLit.minChar,
                                             this.checker.locationInfo.fileName,
                                             resultType, this.compilationSettings.optimizeModuleCodeGen);

            resultType.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
            resultType.memberScope = new SymbolTableScope(resultType.members, null, null, null, null);

            var aggScope = new SymbolAggregateScope(resultType.symbol);
            aggScope.addParentScope(resultType.memberScope);
            aggScope.addParentScope(this.scope);
            resultType.containedScope = aggScope;
            var memberDecls = <ASTList>objectLit.operand;
            var prevThisType = this.thisType;
            var acceptTargetType = false;
            var targetType: Type = null;

            if (this.checker.hasTargetType()) {
                targetType = this.checker.getTargetTypeContext().contextualType;

                if (targetType && targetType.symbol && !this.checker.typeStatusIsFinished(targetType.symbol.typeCheckStatus)) {
                    if (targetType.symbol.declAST) {
                        this.typeCheck(targetType.symbol.declAST);
                    }
                }
                acceptTargetType = true;
            }

            if (memberDecls) {
                for (var i = 0, len = memberDecls.members.length; i < len; i++) {

                    var binex = <BinaryExpression>memberDecls.members[i];

                    var id = binex.operand1;
                    var text: string;
                    var targetMember: Symbol = null;
                    var fieldSymbol: FieldSymbol = null;

                    if (id.nodeType === NodeType.Name) {
                        text = (<Identifier>id).text;
                    }
                    else if (id.nodeType === NodeType.QString) {
                        // TODO: set text to unescaped string
                        var idText = (<StringLiteral>id).text;
                        text = idText.substring(1, idText.length - 1);
                    }
                    else {
                        this.checker.errorReporter.simpleError(objectLit,
                                                          "malformed object literal");
                        resultType = this.anyType;
                        break;
                    }

                    if (acceptTargetType && targetType.memberScope) {
                        targetMember = targetType.memberScope.find(text, false, false);
                    }

                    // before typechecking an accessor function member, we need to initialize its accessor symbol
                    if (binex.operand2.nodeType === NodeType.FuncDecl && (<FuncDecl>binex.operand2).isAccessor()) {

                        var funcDecl = <FuncDecl>binex.operand2;
                        var accessorSym: FieldSymbol = resultType.members.publicMembers.lookup(text);

                        accessorSym = this.checker.createAccessorSymbol(funcDecl, accessorSym, resultType, true, false, resultType.memberScope, null);
                        funcDecl.accessorSymbol = accessorSym;
                        fieldSymbol = accessorSym;
                        if (id.nodeType === NodeType.Name) {
                            (<Identifier>id).sym = accessorSym;
                        }
                    }

                    this.checker.typeCheckWithContextualType(acceptTargetType && targetMember ? targetMember.getType() : null, false, acceptTargetType, binex.operand2);

                    if (acceptTargetType && targetMember) {
                        // Note that we accept 'any' in place of a valid subtype                     
                        if ((binex.operand2.type === this.anyType || this.checker.sourceIsAssignableToTarget(binex.operand2.type, targetMember.getType())) ||
                            (binex.operand2.nodeType === NodeType.FuncDecl &&
                            (<FuncDecl>binex.operand2).isAccessor() &&
                                this.typeFromAccessorFuncDecl(<FuncDecl>binex.operand2) === targetMember.getType())) {
                            // set the field type to the proper contextual type
                            // this is especially important in the 'any' case, so that
                            // fields typed to 'any' aren't accepted for contextual typing,
                            // but never properly set to the target type
                            binex.operand1.type = targetMember.getType();
                        }
                    }
                    else {
                        // here we sub in 'any' for 'undefined' to account for field initialization to
                        // 'undefined'  
                        binex.operand2.type = binex.operand2.type === this.checker.undefinedType ? this.anyType : binex.operand2.type;
                    }

                    // the field symbol hasn't been set by a getter or setter
                    if (fieldSymbol === null) {
                        var memberType = binex.operand2.type;
                        var field = new ValueLocation();
                        fieldSymbol =
                            new FieldSymbol(text, id.minChar,
                                            this.checker.locationInfo.fileName,
                                            true, field);
                        fieldSymbol.flags |= SymbolFlags.Property;
                        field.symbol = fieldSymbol;
                        fieldSymbol.typeCheckStatus = this.checker.getTypeCheckFinishedStatus();
                        field.typeLink = new TypeLink();
                        field.typeLink.type = memberType;
                        resultType.members.publicMembers.add(text, fieldSymbol);
                    }
                    fieldSymbol.isObjectLitField = true;
                }
            }

            this.thisType = prevThisType;
            objectLit.type = resultType;
            if (targetType) {
                objectLit.targetType = targetType;
            }
        }

        public typeCheckArrayLit(arrayLit: UnaryExpression): void {
            var elements = <ASTList>arrayLit.operand;
            var elementType = this.anyType;
            var targetElementType: Type = null;
            var comparisonInfo = new TypeComparisonInfo();
            comparisonInfo.onlyCaptureFirstError = true;

            // if the target type is an array type, extract the element type
            if (this.checker.hasTargetType()) {
                var targetType = this.checker.getTargetTypeContext().contextualType;
                if (targetType.elementType) {
                    targetElementType = targetType.elementType;
                }
            }

            if (elements) {

                var prevInArrayElemTypeCheck = this.inArrayElementTypeCheck;

                this.inArrayElementTypeCheck = true;
                this.checker.typeCheckWithContextualType(targetElementType, this.checker.inProvisionalTypecheckMode(), targetElementType !== null, elements);
                this.inArrayElementTypeCheck = prevInArrayElemTypeCheck;

                elementType = elements.members[0].type;

                var collection: ITypeCollection = {
                    getLength: () => { return elements.members.length; },
                    setTypeAtIndex: (index: number, type: Type) => { elements.members[index].type = type; },
                    getTypeAtIndex: (index: number) => { return elements.members[index].type; }
                }

                elementType = this.checker.findBestCommonType(elementType, targetElementType, collection, false, comparisonInfo);

                // if the array type is the undefined type, we should widen it to any
                // if it's of the null type, only widen it if it's not in a nested array element, so as not to 
                // short-circuit any checks for the best common type
                if (elementType === this.checker.undefinedType || (!prevInArrayElemTypeCheck && elementType === this.nullType)) {
                    elementType = this.anyType;
                }
            }
            if (!elementType) {
                var emsg = "Incompatible types in array literal expression";
                if (!comparisonInfo.message) {
                    this.checker.errorReporter.simpleError(arrayLit, emsg);
                }
                else {
                    this.checker.errorReporter.simpleError(arrayLit, emsg + ": " + comparisonInfo.message);
                }
                elementType = this.anyType;
            }
            else if (targetElementType) {
                // for the case of zero-length 'any' arrays, we still want to set the contextual type, if
                // need be
                if (this.checker.sourceIsAssignableToTarget(elementType, targetElementType)) {
                    elementType = targetElementType;
                }
            }

            arrayLit.type = this.checker.makeArrayType(elementType);

        }

        public checkForVoidConstructor(type: Type, ast: AST) {
            if (type &&
                type.construct &&
                type.construct.signatures.length > 0) {

                for (var i = 0; i < type.construct.signatures.length; i++) {
                    if (type.construct.signatures[i].returnType.type === this.checker.voidType) {
                        this.checker.errorReporter.simpleError(ast, "Constructors may not have a return type of 'void'");
                        break;
                    }
                }
            }
        }

        // REVIEW: the code below could set the signature type of the function to the current return
        // type, which would have a benefit of reducing the risk of a recursive typecheck scenario, but is
        // is technically wrong - mergeOrdered will only work properly if the best common supertype
        // comes before any sibling types.  This would mean that if a function, "color()", returned
        // three types (in order) - "Red", "Blue", and "IColor", an "Incompatible return type" error 
        // would be triggered.  However, if "color()" returned (in order) "Red", "IColor" and "Blue"
        // no error would be triggered, and the return type of the function would be "IColor"
        public typeCheckReturn(returnStmt: ReturnStatement): ReturnStatement {

            if (this.thisFnc) {
                var targetType: Type = null;

                // determine the target type
                if (this.checker.hasTargetType()) {
                    var tcContext = this.checker.getTargetTypeContext();
                    var accessorType = tcContext.targetAccessorType;

                    if (accessorType) {
                        targetType = accessorType;
                    }
                    else {
                        var targetSig = this.checker.getTargetTypeContext().targetSig;
                        if (targetSig && targetSig.returnType.type !== this.voidType) {
                            targetType = targetSig.returnType.type;
                        }
                    }
                }

                if (returnStmt.returnExpression) {
                    this.thisFnc.fncFlags |= FncFlags.HasReturnExpression;

                    if (targetType === null && this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type && this.thisFnc.returnTypeAnnotation.type !== this.voidType) {
                        targetType = this.thisFnc.returnTypeAnnotation.type;
                    }

                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), targetType !== null, returnStmt.returnExpression);

                    var expectedReturnType: Type =
                        (this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ?
                            this.thisFnc.returnTypeAnnotation.type :
                            targetType;
                    if (expectedReturnType) {
                        if (expectedReturnType === this.voidType && returnStmt.returnExpression.type !== this.voidType) {
                            this.checker.errorReporter.simpleError(returnStmt,
                                                              "Return with value expression in void function");

                            // even though we've raised an error, use the more specific type
                            returnStmt.type = returnStmt.returnExpression.type;
                        }
                        else {
                            returnStmt.returnExpression = this.cast(returnStmt.returnExpression, expectedReturnType);
                            returnStmt.type = expectedReturnType;
                        }
                    }
                    else {
                        if (targetType) {
                            if (returnStmt.returnExpression.type !== this.voidType) {
                                returnStmt.returnExpression = this.cast(returnStmt.returnExpression, targetType);
                            }
                            else {
                                returnStmt.returnExpression.type = targetType;
                            }
                        }
                        returnStmt.type = returnStmt.returnExpression.type;
                    }
                    this.thisFnc.returnStatementsWithExpressions[this.thisFnc.returnStatementsWithExpressions.length] = returnStmt;
                }
                else {
                    returnStmt.type = targetType === null ? this.checker.voidType : targetType; //((this.thisFnc.returnTypeAnnotation && this.thisFnc.returnTypeAnnotation.type) ? this.thisFnc.returnTypeAnnotation.type : this.checker.voidType) : targetType;
                }
            }

            return returnStmt;
        }

        public typeCheckInstOf(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);

            if (!((binex.operand1.type === this.checker.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand1.type, this.objectInterfaceType)) &&
                    (binex.operand2.type === this.anyType || this.checker.sourceIsSubtypeOfTarget(binex.operand2.type, this.functionInterfaceType)))) {
                this.checker.errorReporter.simpleError(ast, "The instanceof operator requires the left operand to be of type Any or an object type, and the right operand to be of type Any or a subtype of the Function interface type");
            }
            binex.type = this.booleanType;
            return binex;
        }

        public typeCheckCommaOperator(ast: AST): AST {
            var binex = <BinaryExpression>ast;
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            binex.type = binex.operand2.type;
            return binex;
        }

        public typeCheckLogOr(binex: BinaryExpression): BinaryExpression {
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            var leftType = binex.operand1.type;
            var rightType = binex.operand2.type;

            if (leftType === this.checker.anyType || rightType === this.checker.anyType) {
                binex.type = this.checker.anyType;
            }
            else if (leftType === this.checker.booleanType) {
                if (rightType === this.checker.booleanType) {
                    binex.type = this.checker.booleanType;
                }
                else {
                    binex.type = this.checker.anyType;
                }
            }
            else if (leftType === this.checker.numberType) {
                if (rightType === this.checker.numberType) {
                    binex.type = this.checker.numberType;
                }
                else {
                    binex.type = this.checker.anyType;
                }
            }
            else if (leftType === this.checker.stringType) {
                if (rightType === this.checker.stringType) {
                    binex.type = this.checker.stringType;
                }
                else {
                    binex.type = this.checker.anyType;
                }
            }
            else {
                if (this.checker.sourceIsSubtypeOfTarget(leftType, rightType)) {
                    binex.type = rightType;
                }
                else if (this.checker.sourceIsSubtypeOfTarget(rightType, leftType)) {
                    binex.type = leftType;
                }
                else {
                    binex.type = this.checker.anyType;
                }
            }
            return binex;
        }

        public typeCheckLogAnd(binex: BinaryExpression): BinaryExpression {
            binex.operand1 = this.typeCheck(binex.operand1);
            binex.operand2 = this.typeCheck(binex.operand2);
            binex.type = binex.operand2.type;
            return binex;
        }

        public tryAddCandidates(signature: Signature, actuals: Type[], exactCandidates: Signature[], conversionCandidates: Signature[], comparisonInfo: TypeComparisonInfo): void {
            var lowerBound = signature.nonOptionalParameterCount; // required parameters
            var upperBound = signature.parameters.length; // required and optional parameters
            var formalLen = lowerBound;
            var acceptable = false;

            if ((actuals.length >= lowerBound) && (signature.hasVariableArgList || actuals.length <= upperBound)) {
                formalLen = (signature.hasVariableArgList ? signature.parameters.length : actuals.length);
                acceptable = true;
            }

            var repeatType: Type = null;

            if (acceptable || signature.hasVariableArgList) {
                // assumed structure here is checked when signature is formed
                if (signature.hasVariableArgList) {
                    formalLen -= 1;
                    repeatType = (<ParameterSymbol>signature.parameters[formalLen]).parameter.typeLink.type;
                    repeatType = repeatType.elementType;
                    acceptable = actuals.length >= formalLen;
                }
                var len = actuals.length;

                var exact = acceptable;
                var convert = acceptable;
                for (var i = 0; i < len; i++) {
                    var typeA: Type;
                    if (i < formalLen) {
                        typeA =
                            (<ParameterSymbol>signature.parameters[i]).parameter.typeLink.type;
                    }
                    else {
                        typeA = repeatType;
                    }

                    var typeB = actuals[i];
                    if (!typeA || !typeB || !(this.checker.typesAreIdentical(typeA, typeB))) {
                        exact = false;
                    }
                    // is the argument assignable to the parameter?
                    if (!this.checker.sourceIsAssignableToTarget(typeB, typeA, comparisonInfo)) {
                        convert = false;
                    }
                    if (!(exact || convert)) {
                        break;
                    }
                }
                if (exact) {
                    exactCandidates[exactCandidates.length] = signature;
                }
                else if (convert && (exactCandidates.length === 0)) {
                    conversionCandidates[conversionCandidates.length] = signature;
                }

            }
        }

        public resolveOverload(application: AST, group: SignatureGroup): Signature {
            var rd = this.resolutionDataCache.getResolutionData();
            var actuals = rd.actuals;
            var exactCandidates = rd.exactCandidates;
            var conversionCandidates = rd.conversionCandidates;
            var candidate: Signature = null;
            var hasOverloads = group.signatures.length > 1;
            var comparisonInfo = new TypeComparisonInfo();
            var args: ASTList = null;
            var target: AST = null;
            var i = 0;

            if (application.nodeType === NodeType.Call || application.nodeType === NodeType.New) {
                var callEx = <CallExpression>application;
                args = callEx.arguments;
                target = callEx.target;
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    for (i = 0; i < len; i++) {
                        actuals[i] = callEx.arguments.members[i].type;
                    }
                }
            }
            else if (application.nodeType === NodeType.Index) {
                var binExp = <BinaryExpression>application;
                target = binExp.operand1;
                args = new ASTList();
                args.members[0] = binExp.operand2;
                actuals[0] = binExp.operand2.type;
            }

            for (var j = 0, groupLen = group.signatures.length; j < groupLen; j++) {
                var signature = group.signatures[j];
                if (hasOverloads && signature === group.definitionSignature && !this.checker.canCallDefinitionSignature) {
                    continue;
                }
                if (!signature.returnType.type && signature.declAST &&
                    (signature.typeCheckStatus !== TypeCheckStatus.Finished)) {
                    this.typeCheckFunction(signature.declAST);
                }
                this.tryAddCandidates(signature, actuals, exactCandidates, conversionCandidates, comparisonInfo);
            }

            // For error reporting, we want to use the span of just the function's name if it is a method or a field of some object, so go to the right child if the node is a dot.
            // No need to recurse since dots are left associative
            var apparentTarget = target.nodeType === NodeType.Dot ? (<BinaryExpression> target).operand2 : target;
            if (exactCandidates.length === 0) {
                var candidateInfo: { sig: Signature; ambiguous: bool; };
                var applicableCandidates = this.checker.getApplicableSignatures(conversionCandidates, args, comparisonInfo);
                if (applicableCandidates.length > 0) {
                    candidateInfo = this.checker.findMostApplicableSignature(applicableCandidates, args);
                    if (candidateInfo.ambiguous) {
                        this.checker.errorReporter.simpleError(apparentTarget, "Ambiguous call expression - could not choose overload");
                    }
                    candidate = candidateInfo.sig;
                }
                else {
                    var emsg = "Supplied parameters do not match any signature of call target";
                    if (comparisonInfo.message) {
                        this.checker.errorReporter.simpleError(apparentTarget, emsg + ":\n\t" + comparisonInfo.message);
                    }
                    else {
                        this.checker.errorReporter.simpleError(apparentTarget, emsg);
                    }
                }
            }
            else {
                if (exactCandidates.length > 1) {
                    var applicableSigs: ApplicableSignature[] = [];
                    for (i = 0; i < exactCandidates.length; i++) {
                        applicableSigs[i] = { signature: exactCandidates[i], hadProvisionalErrors: false };
                    }
                    candidateInfo = this.checker.findMostApplicableSignature(applicableSigs, args);
                    if (candidateInfo.ambiguous) {
                        this.checker.errorReporter.simpleError(apparentTarget, "Ambiguous call expression - could not choose overload");
                    }
                    candidate = candidateInfo.sig;
                }
                else {
                    candidate = exactCandidates[0];
                }
            }

            this.resolutionDataCache.returnResolutionData(rd);
            return candidate;
        }

        public typeCheckNew(ast: AST): AST {
            var callEx = <CallExpression>ast;
            var signature: Signature;

            callEx.target = this.typeCheck(callEx.target);
            var target = callEx.target;
            if (target.type.construct || target.type.call) {
                this.preTypeCheckCallArgs(callEx.arguments);
            }
            else {
                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);
            }

            if (target.type === this.anyType) {
                callEx.type = this.anyType;
                callEx.arguments = <ASTList>this.typeCheck(callEx.arguments);
            }
            else {
                if (target.type.construct) {
                    signature = this.resolveOverload(callEx, target.type.construct);
                    if (signature === null) {
                        callEx.type = this.anyType;
                    }
                    else if (signature.returnType.type === this.voidType) {
                        callEx.type = this.anyType;
                        callEx.signature = signature;
                    }
                    else {
                        callEx.type = signature.returnType.type;
                        callEx.signature = signature;
                    }
                }
                else if (target.type.call) {
                    signature = this.resolveOverload(callEx, target.type.call);
                    if (signature === null) {
                        callEx.type = this.anyType;
                    }
                    else if ((signature.returnType.type === this.voidType) || (signature.returnType.type === this.anyType)) {
                        callEx.type = this.anyType;
                        callEx.signature = signature;
                    }
                    else {
                        this.checker.errorReporter.simpleError(callEx.target,
                           "new expression only valid on constructors");
                    }
                }
                else if (target.type.elementType) {
                    callEx.type = target.type;
                }
                else {
                    this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);
                    callEx.type = this.anyType;
                }
            }

            this.postTypeCheckCallArgs(callEx);

            return callEx;
        }

        // Typecheck all args that cannot be affected by contextual typing of overloads
        public preTypeCheckCallArgs(args: ASTList) {

            if (!args) {
                return;
            }

            for (var i = 0; i < args.members.length; i++) {
                switch (args.members[i].nodeType) {
                    case NodeType.FuncDecl:
                    case NodeType.ObjectLit:
                    case NodeType.ArrayLit:
                        continue;
                    default:
                        this.typeCheck(args.members[i]);
                        break;
                }
            }
        }

        public postTypeCheckCallArgs(callEx: CallExpression) {

            var acceptedTargetType = false;
            var i = 0;

            if (callEx.target &&
                callEx.target.type &&
                callEx.signature &&
                callEx.arguments) {
                var sig = callEx.signature;

                if (sig && callEx.arguments.members.length >= sig.nonOptionalParameterCount) {
                    acceptedTargetType = true;
                    var targetType: Type = null;
                    var nonVarArgFormalParamLength = sig.hasVariableArgList ? sig.parameters.length - 1 : sig.parameters.length;
                    var nonVarArgActualParamLength = callEx.arguments.members.length < nonVarArgFormalParamLength ? callEx.arguments.members.length : nonVarArgFormalParamLength

                    for (i = 0; i < nonVarArgActualParamLength; i++) {
                        targetType = sig.parameters[i].getType();
                        switch (callEx.arguments.members[i].nodeType) {
                            case NodeType.FuncDecl:
                            case NodeType.ObjectLit:
                            case NodeType.ArrayLit:
                                this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), !sig.parameters[i].declAST.isParenthesized, callEx.arguments.members[i]);
                                break;
                        }
                    }

                    if (sig.hasVariableArgList) {
                        var varArgParamIndex = sig.nonOptionalParameterCount - 1;
                        targetType = sig.parameters[varArgParamIndex].getType();
                        if (targetType) {
                            targetType = targetType.elementType;
                        }
                        var isParenthesized = !sig.parameters[varArgParamIndex].declAST.isParenthesized;
                        for (i = nonVarArgActualParamLength; i < callEx.arguments.members.length; i++) {
                            switch (callEx.arguments.members[i].nodeType) {
                                case NodeType.FuncDecl:
                                case NodeType.ObjectLit:
                                case NodeType.ArrayLit:
                                    this.checker.typeCheckWithContextualType(targetType, this.checker.inProvisionalTypecheckMode(), isParenthesized, callEx.arguments.members[i]);
                                    break;
                            }
                        }
                    }
                }
            }

            if (!acceptedTargetType && callEx.arguments) {
                this.checker.killCurrentContextualType();

                for (i = 0; i < callEx.arguments.members.length; i++) {
                    switch (callEx.arguments.members[i].nodeType) {
                        case NodeType.FuncDecl:
                        case NodeType.ObjectLit:
                        case NodeType.ArrayLit:
                            this.typeCheck(callEx.arguments.members[i]);
                            break;
                        default:
                            continue;
                    }
                }
            }
        }

        public typeCheckCall(ast: AST): AST {
            var callEx = <CallExpression>ast;
            if (this.checker.styleSettings.newMustBeUsed && (ast.nodeType === NodeType.New)) {
                if (hasFlag(ast.flags, ASTFlags.IsStatement)) {
                    this.checker.errorReporter.styleError(ast, "use of new expression as a statement");
                }
            }
            else if ((!this.checker.styleSettings.evalOK) && (ast.nodeType === NodeType.Call)) {
                if ((callEx.target.nodeType === NodeType.Name) && ((<Identifier>callEx.target).text === "eval")) {
                    this.checker.errorReporter.styleError(callEx, "eval not permitted");
                }
            }

            if (callEx.target.nodeType === NodeType.FuncDecl) {
                (<FuncDecl>callEx.target).isInlineCallLiteral = true;
            }

            var prevInSuperCall = this.inSuperCall;

            if (callEx.target.nodeType === NodeType.Super) {
                this.inSuperCall = true;
            }

            callEx.target = this.typeCheck(callEx.target);
            this.preTypeCheckCallArgs(callEx.arguments);

            var target = callEx.target;
            var signature: Signature;

            if ((target.type === null) || (target.type === this.anyType) || (this.functionInterfaceType && target.type === this.functionInterfaceType)) {
                callEx.type = this.anyType;
            }
            else {
                var fnType = target.type;
                if (fnType.call) {
                    signature = this.resolveOverload(callEx, fnType.call);
                    if (signature === null) {
                        callEx.type = this.anyType;
                    }
                    else {
                        callEx.type = signature.returnType.type;
                        callEx.signature = signature;
                    }
                }
                else {
                    // track calls to class base class
                    if (callEx.target.nodeType === NodeType.Super &&
                        this.thisFnc &&
                        this.thisFnc.isConstructor &&
                        hasFlag(this.thisFnc.fncFlags, FncFlags.ClassMethod)) {

                        // Need to use the class type for the construct signature, not the instance type
                        signature = fnType.symbol.type.construct ? this.resolveOverload(callEx, fnType.symbol.type.construct) : null;

                        if (signature === null) {
                            callEx.type = this.anyType;
                        }
                        else {
                            callEx.flags |= ASTFlags.ClassBaseConstructorCall;
                            callEx.type = signature.returnType.type;
                            callEx.signature = signature;
                        }
                    }
                    else {
                        callEx.type = this.anyType;
                        this.checker.errorReporter.invalidCall(callEx, callEx.nodeType, this.scope);
                    }
                }
            }
            this.postTypeCheckCallArgs(callEx);

            this.inSuperCall = prevInSuperCall;

            return callEx;
        }

        public assignScopes(ast: AST) {
            var script = <Script>ast;
            this.checker.locationInfo = script.locationInfo;
            var globalChain = new ScopeChain(this.checker.gloMod, null, this.globalScope);
            var context = new AssignScopeContext(globalChain, this, [this.checker.currentModDecl]);
            getAstWalkerFactory().walk(ast, preAssignScopes, postAssignScopes, null, context);
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export enum Primitive {
        None = 0,
        Void = 1,
        Double = 2,
        String = 4,
        Boolean = 8,
        Any = 16,
        Null = 32,
        Undefined = 64,
    }

    export class MemberName {
        public prefix: string = "";
        public suffix: string = "";

        public isString() { return false; }
        public isArray() { return false; }

        public toString(): string {
            return MemberName.memberNameToString(this);
        }

        static memberNameToString(memberName: MemberName): string {
            var result = memberName.prefix;

            if (memberName.isString()) {
                result += (<MemberNameString>memberName).text;
            }
            else {
                var ar = <MemberNameArray>memberName;
                for (var index = 0; index < ar.entries.length; index++) {

                    result += MemberName.memberNameToString(ar.entries[index]);
                    result += ar.delim;
                }
            }

            result += memberName.suffix;
            return result;
        }

        static create(text: string): MemberName;
        static create(entry: MemberName, prefix: string, suffix: string): MemberName;
        static create(arg1: any, arg2?: any, arg3?: any): MemberName {
            if (typeof arg1 === "string") {
                return new MemberNameString(arg1);
            }
            else {
                var result = new MemberNameArray();
                if (arg2)
                    result.prefix = arg2;
                if (arg3)
                    result.suffix = arg3;
                result.entries.push(arg1);
                return result;
            }
        }

        constructor() {
        }
    }

    export class MemberNameString extends MemberName {
        constructor (public text: string) {
            super();
        }

        public isString() { return true; }
    }

    export class MemberNameArray extends MemberName {
        public delim: string = "";
        public entries: MemberName[] = [];

        public isArray() { return true; }

        public add(entry: MemberName) {
            this.entries.push(entry);
        }

        public addAll(entries: MemberName[]) {
            for (var i = 0 ; i < entries.length; i++) {
                this.entries.push(entries[i]);
            }
        }

        constructor() {
            super();
        }
    }

    var currentTypeID = -1;

    export class Type {
        public typeID = currentTypeID++;

        public members: ScopedMembers;
        public ambientMembers: ScopedMembers;

        public construct: SignatureGroup = null;
        public call: SignatureGroup = null;
        public index: SignatureGroup = null;

        // REVIEW: for either of the below, why do we have lists of types and lists of type links?
        // interface can only extend
        public extendsList: Type[];
        public extendsTypeLinks: TypeLink[];

        // class can also implement
        public implementsList: Type[];
        public implementsTypeLinks: TypeLink[];

        public passTypeCreated: number = CompilerDiagnostics.analysisPass;

        public baseClass(): Type {
            if (this.extendsList && (this.extendsList.length > 0)) {
                return this.extendsList[0];
            }
            else {
                return null;
            }
        }

        public elementType: Type;

        public getArrayBase(arrInstType: Type, checker: TypeChecker): Type {
            return this.arrayCache.specialize(arrInstType, checker);
        }

        public primitiveTypeClass: number = Primitive.None;

        // REVIEW: Prune constructorScope
        public constructorScope: SymbolScope;
        public containedScope: SymbolScope;
        public memberScope: SymbolScope;

        public arrayCache: ArrayCache;

        public typeFlags = TypeFlags.None;

        public symbol: TypeSymbol;

        public enclosingType: Type;
        public instanceType: Type;

        // REVIEW: Prune
        public isClass() { return this.instanceType != null; }
        public isArray() { return this.elementType != null; }
        public isClassInstance() {
            return this.symbol && !this.elementType && (<TypeSymbol>this.symbol).type.isClass();
        }

        public getInstanceType() {
            if (this.isClass()) {
                return this.instanceType;
            }
            else {
                return this;
            }
        }

        public hasImplementation() { return hasFlag(this.typeFlags, TypeFlags.HasImplementation); }
        public setHasImplementation() { this.typeFlags |= TypeFlags.HasImplementation; }

        public isDouble() { return hasFlag(this.primitiveTypeClass, Primitive.Double); }
        public isString() { return hasFlag(this.primitiveTypeClass, Primitive.String); }
        public isBoolean() { return hasFlag(this.primitiveTypeClass, Primitive.Boolean); }
        public isNull() { return hasFlag(this.primitiveTypeClass, Primitive.Null); }

        // REVIEW: No need for this to be a method
        public getTypeName(): string {
            return this.getMemberTypeName("", true, false, null);
        }

        public getScopedTypeName(scope: SymbolScope, getPrettyTypeName?: bool) {
            return this.getMemberTypeName("", true, false, scope, getPrettyTypeName);
        }

        public getScopedTypeNameEx(scope: SymbolScope, getPrettyTypeName?: bool) {
            return this.getMemberTypeNameEx("", true, false, scope, getPrettyTypeName);
        }

        // REVIEW: No need for this to be a method
        public callCount() {
            var total = 0;
            if (this.call) {
                total += this.call.signatures.length;
            }
            if (this.construct) {
                total += this.construct.signatures.length;
            }
            if (this.index) {
                total += this.index.signatures.length;
            }
            return total;
        }

        // REVIEW: No need for this to be a method
        public getMemberTypeName(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope, getPrettyTypeName?: bool): string {
            var memberName = this.getMemberTypeNameEx(prefix, topLevel, isElementType, scope, getPrettyTypeName);
            return memberName.toString();
        }

        // REVIEW: No need for this to be a method
        public getMemberTypeNameEx(prefix: string, topLevel: bool, isElementType: bool, scope: SymbolScope, getPrettyTypeName?: bool): MemberName {
            if (this.elementType) {
                return MemberName.create(this.elementType.getMemberTypeNameEx(prefix, false, true, scope), "", "[]");
            }
            else if (this.symbol && this.symbol.name && this.symbol.name != "_anonymous" &&
                     (((this.call === null) && (this.construct === null) && (this.index === null)) ||
                      (hasFlag(this.typeFlags, TypeFlags.BuildingName)) ||
                      (this.members && (!this.isClass())))) {
                var tn = this.symbol.scopeRelativeName(scope);
                return MemberName.create(tn === "null" ? "any" : tn); // REVIEW: GROSS!!!
            }
            else {
                if (this.members || this.call || this.construct) {
                    if (hasFlag(this.typeFlags, TypeFlags.BuildingName)) {
                        return MemberName.create("this");
                    }
                    this.typeFlags |= TypeFlags.BuildingName;
                    var builder = "";
                    var allMemberNames = new MemberNameArray();
                    var curlies = isElementType || this.index != null;
                    var memCount = 0;
                    var delim = "; ";
                    if (this.members) {
                        this.members.allMembers.map((key, s, unused) => {
                            var sym = <Symbol>s;
                            if (!hasFlag(sym.flags, SymbolFlags.BuiltIn)) {
                                // Remove the delimiter character from the generated type name, since
                                // our "allMemberNames" array takes care of storing delimiters
                                var typeNameMember = sym.getTypeNameEx(scope);
                                if (typeNameMember.isArray() && (<MemberNameArray>typeNameMember).delim === delim) {
                                    allMemberNames.addAll((<MemberNameArray>typeNameMember).entries);
                                } else {
                                    allMemberNames.add(typeNameMember);
                                }
                                memCount++;
                                curlies = true;
                            }
                        }, null);
                    }

                    var signatureCount = this.callCount();
                    var j: number;
                    var len = 0;
                    var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.call && this.call.signatures.length > 1 && !this.members && !this.construct;
                    var shortform = !curlies && (signatureCount === 1 || getPrettyFunctionOverload) && topLevel;
                    if (this.call) {
                        allMemberNames.addAll(this.call.toStrings(prefix, shortform, scope, getPrettyFunctionOverload));
                    }

                    if (this.construct) {
                        allMemberNames.addAll(this.construct.toStrings("new", shortform, scope));
                    }

                    if (this.index) {
                        allMemberNames.addAll(this.index.toStrings("", shortform, scope));
                    }

                    if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                        allMemberNames.prefix = "{ ";
                        allMemberNames.suffix = "}";
                        allMemberNames.delim = delim;
                    } else if (allMemberNames.entries.length > 1) {
                        allMemberNames.delim = delim;
                    }

                    this.typeFlags &= (~TypeFlags.BuildingName);
                    if ((signatureCount === 0) && (memCount === 0)) {
                        return MemberName.create("{}");
                    }
                    else {
                        return allMemberNames;
                    }
                }
                else {
                    return MemberName.create("{}");
                }
            }
        }

        public checkDecl(checker: TypeChecker) {
            if (this.isClassInstance() || this.isClass()) {
                if (this.symbol.declAST) {
                    checker.typeFlow.inScopeTypeCheckDecl(this.symbol.declAST);
                }
            }
        }

        public getMemberScope(flow: TypeFlow) {
            if (this === flow.anyType) {
                return null;
            }
            else if (this.isDouble()) {
                if (flow.numberInterfaceType) {
                    return flow.numberInterfaceType.memberScope;
                }
                else {
                    return null;
                }
            }
            else if (this.isBoolean()) {
                if (flow.booleanInterfaceType) {
                    return flow.booleanInterfaceType.memberScope;
                }
                else {
                    return null;
                }
            }
            else if (this === flow.stringType) {
                if (flow.stringInterfaceType) {
                    return flow.stringInterfaceType.memberScope;
                }
                else {
                    return null;
                }
            }
            else if (this.elementType) {
                if (flow.arrayInterfaceType) {
                    var arrInstType = this.elementType.getArrayBase(flow.arrayInterfaceType, flow.checker);
                    return arrInstType.memberScope;
                }
                else {
                    return null;
                }
            }
            else {
                return this.memberScope;
            }
        }

        public isReferenceType() {
            return this.members || this.extendsList ||
                this.construct || this.call || this.index ||
                this.elementType;
        }

        public specializeType(pattern: Type, replacement: Type, checker: TypeChecker, membersOnly: bool): Type {
            if (pattern === this) {
                return replacement;
            }
            var result = this;
            if (membersOnly) {
                // assume interface type without bases
                if (this.isReferenceType()) {
                    result = new Type();
                    if (this.members) {
                        result.members = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));

                        this.members.publicMembers.map((key, s, unused) => {
                            var sym = <Symbol>s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.members.addPublicMember(bSym.name, bSym);
                        }, null);

                        this.members.privateMembers.map((key, s, unused) => {
                            var sym = <Symbol>s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.members.addPrivateMember(bSym.name, bSym);
                        }, null);
                    }
                    if (this.ambientMembers) {
                        result.ambientMembers = new ScopedMembers(new DualStringHashTable(new StringHashTable(), new StringHashTable()));
                        this.ambientMembers.publicMembers.map((key, s, unused) => {
                            var sym = <Symbol>s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.ambientMembers.addPublicMember(bSym.name, bSym);
                        }, null);

                        this.ambientMembers.privateMembers.map((key, s, unused) => {
                            var sym = <Symbol>s;
                            var bSym = sym.specializeType(pattern, replacement, checker);
                            result.ambientMembers.addPrivateMember(bSym.name, bSym);
                        }, null);
                    }
                    result.containedScope = checker.scopeOf(result);
                    result.memberScope = result.containedScope;
                }
            }
            else {
                if (this.elementType) {
                    if (this.elementType === pattern) {
                        result = checker.makeArrayType(replacement);
                    }
                    else {
                        if (this.elementType.elementType === pattern) {
                            result = checker.makeArrayType(checker.makeArrayType(replacement));
                        }
                    }
                }
                else if (this.call) {
                    result = new Type();
                    result.call = this.call.specializeType(pattern, replacement, checker);
                }
            }
            return result;
        }

        public hasBase(baseType: Type): bool {
            if (baseType === this) {
                return true;
            }
            else {
                if (this.extendsList) {
                    for (var i = 0, len = this.extendsList.length; i < len; i++) {
                        if (this.extendsList[i].hasBase(baseType)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        public mergeOrdered(b: Type, checker: TypeChecker, acceptVoid: bool, comparisonInfo?: TypeComparisonInfo): Type {
            if ((this === checker.anyType) || (b === checker.anyType)) {
                return checker.anyType;
            }
            else if (this === b) {
                return this;
            }
            else if ((b === checker.nullType) && this != checker.nullType) {
                return this;
            }
            else if ((this === checker.nullType) && (b != checker.nullType)) {
                return b;
            }
            else if (acceptVoid && (b === checker.voidType) && this != checker.voidType) {
                return this;
            }
            else if (acceptVoid && (this === checker.voidType) && (b != checker.voidType)) {
                return b;
            }
            else if ((b === checker.undefinedType) && this != checker.undefinedType) {
                return this;
            }
            else if ((this === checker.undefinedType) && (b != checker.undefinedType)) {
                return b;
            }
            else if (this.elementType && b.elementType) {
                if (this.elementType === b.elementType) {
                    return this;
                }
                else {
                    var mergedET = this.elementType.mergeOrdered(b.elementType, checker, acceptVoid, comparisonInfo);
                    if (mergedET === null) {
                        return checker.makeArrayType(checker.anyType);
                    }
                    else {
                        return checker.makeArrayType(mergedET);
                    }
                }
            }
            else if (checker.sourceIsSubtypeOfTarget(this, b, comparisonInfo)) {
                return b;
            }
            else if (checker.sourceIsSubtypeOfTarget(b, this, comparisonInfo)) {
                return this;
            }
            else {
                return null;
            }
        }

        public isModuleType() { return false; }
        public hasMembers() { return this.members != null; }
        public getAllEnclosedTypes(): ScopedMembers { return null; }
        public getAllAmbientEnclosedTypes(): ScopedMembers { return null; }
        public getPublicEnclosedTypes(): ScopedMembers { return null; }
        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }

        public getDocComments(): Comment[]{
            if (this.elementType || !this.symbol) {
                return [];
            }

            if (this.isClassInstance() || this.isClass()) {
                if (this.symbol.declAST.nodeType === NodeType.FuncDecl) {
                    // Its a constructor - use the class declaration instead
                    return (<FuncDecl>this.symbol.declAST).classDecl.getDocComments();
                } else {
                    // Its a class without constructor
                    return this.symbol.getDocComments();
                }
            }

            if (this.symbol.name && this.symbol.name != "_anonymous" &&
                (((this.call === null) && (this.construct === null) && (this.index === null))
                  || this.members)) {
                return this.symbol.getDocComments();
            }

            return [];
        }
    }

    export interface ITypeCollection {
        // returns null when types are exhausted
        getLength(): number;
        setTypeAtIndex(index: number, type: Type): void;
        getTypeAtIndex(index: number): Type;
    }

    export class ModuleType extends Type {

        constructor (public enclosedTypes: ScopedMembers, public ambientEnclosedTypes: ScopedMembers) {
            super();
        }

        public isModuleType() { return true; }
        public hasMembers() { return this.members != null || this.enclosedTypes != null; }
        public getAllEnclosedTypes() { return this.enclosedTypes; }
        public getAllAmbientEnclosedTypes() { return this.ambientEnclosedTypes; }
        public getPublicEnclosedTypes(): ScopedMembers { return null; }
        public getpublicAmbientEnclosedTypes(): ScopedMembers { return null; }
        public importedModules: ImportDeclaration[] = [];

        // Finds the dynamic module name of moduleType in the members
        // ignoreSymbols define list of symbols already visited - to avoid recursion
        static findDynamicModuleNameInHashTable(moduleType: Type, members: IHashTable) {
            var moduleName: { name: string; symbol: Symbol; } = null;
            members.map((key, s, c) => {
                if (moduleName === null && !isQuoted(key)) {
                    var symbol = <Symbol>s;
                    var type = symbol.getType();
                    if (type === moduleType) {
                        // If this is the module type we were looking for
                        moduleName = { name: key, symbol: symbol };
                    }
                }
            }, null);

            return moduleName;
        }

        // Finds the Dynamic module name of the moduleType in this moduleType
        // onlyPublic tells if we are looking for module name in public members only
        public findDynamicModuleName(moduleType: Type): { name: string; symbol: Symbol; } {
            var moduleName: { name: string; symbol: Symbol; } = null;
            // Not cached, so seach and add to the cache
            moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.members.allMembers);
            if (moduleName === null) {
                moduleName = ModuleType.findDynamicModuleNameInHashTable(moduleType, this.ambientMembers.allMembers);
            }
            return moduleName;
        }
    }

    export class TypeLink {
        public type: Type = null;
        public ast: AST = null;
    }

    export function getTypeLink(ast: AST, checker: TypeChecker, autoVar: bool): TypeLink {
        var result = new TypeLink();

        result.ast = ast;

        if ((ast === null) && (autoVar)) {
            result.type = checker.anyType;
        }
        else {
            result.type = null;
        }

        return result;
    }

}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    // We need to catch both left and right quotes
    // (depending on your editor's font, this may not be clear...)    
    export function stripQuotes(str: string) {
        return str.replace("\"", "").replace("'", "").replace("'", "").replace("\"", "")
    }

    export function isSingleQuoted(str: string) {
        return str.indexOf("'") != -1;
    }

    export function isQuoted(str: string) {
        return str.indexOf("\"") != -1 || isSingleQuoted(str);
    }

    export function quoteStr(str: string) {
        return "\"" + str + "\"";
    }

    export function swapQuotes(str: string) {

        if (str.indexOf("\"") != -1) {
            str = str.replace("\"", "'");
            str = str.replace("\"", "'");
        }
        else {
            str = str.replace("'", "\"");
            str = str.replace("'", "\"");
        }

        return str;
    }

    export function changeToSingleQuote(str: string) {
        if (str.indexOf("\"") != -1) {
            str = str.replace("\"", "'");
            str = str.replace("\"", "'");
        }
        return str;
    }

    export function switchToForwardSlashes(path: string) {
        return path.replace(/\\/g, "/");
    }

    export function trimModName(modName: string) {
        // in case's it's a declare file...
        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) == ".d.ts") {
            return modName.substring(0, modName.length - 5);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".ts") {
            return modName.substring(0, modName.length - 3);
        }
        // in case's it's a .js file
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) == ".js") {
            return modName.substring(0, modName.length - 3);
        }

        return modName;
    }

    export function getDeclareFilePath(fname: string) {
        return isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);
    }

    function isFileOfExtension(fname: string, ext: string) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) == invariantExt;
    }

    export function isJSFile(fname: string) {
        return isFileOfExtension(fname, ".js");
    }

    export function isTSFile(fname: string) {
        return isFileOfExtension(fname, ".ts");
    }

    export function isDTSFile(fname: string) {
        return isFileOfExtension(fname, ".d.ts");
    }

    export function getPrettyName(modPath: string, quote?=true, treatAsFileName?=false) { 
        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripQuotes(modPath));
        var components = this.getPathComponents(modName);
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;
    }

    export function getPathComponents(path: string) {
        return path.split("/");
    }

    export function getRelativePathToFixedPath(fixedModFilePath: string, absoluteModPath: string) {
        absoluteModPath = switchToForwardSlashes(absoluteModPath);

        var modComponents = this.getPathComponents(absoluteModPath);
        var fixedModComponents = this.getPathComponents(fixedModFilePath);

        // Find the component that differs
        var joinStartIndex = 0;
        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length ; joinStartIndex++) {
            if (fixedModComponents[joinStartIndex] != modComponents[joinStartIndex]) {
                break;
            }
        }

        // Get the relative path
        if (joinStartIndex != 0) {
            var relativePath = "";
            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {
                if (fixedModComponents[joinStartIndex] != "") {
                    relativePath = relativePath + "../";
                }
            }

            return relativePath + relativePathComponents.join("/");
        }

        return absoluteModPath;
    }

    export function quoteBaseName(modPath: string) {
        var modName = trimModName(stripQuotes(modPath));
        var path = getRootFilePath(modName);
        if (path == "") {
            return modPath;
        }
        else {
            var components = modName.split(path);
            var fileIndex = components.length > 1 ? 1 : 0;
            return quoteStr(components[fileIndex]);
        }
    }

    export function changePathToTS(modPath: string) {
        return trimModName(stripQuotes(modPath)) + ".ts";
    }

    export function changePathToDTS(modPath: string) {
        return trimModName(stripQuotes(modPath)) + ".d.ts";
    }

    export function isRelative(path: string) {
        return path.charAt(0) == ".";
    }
    export function isRooted(path: string) {
        return path.charAt(0) == "\\" || path.charAt(0) == "/" || (path.indexOf(":\\") != -1) || (path.indexOf(":/") != -1);
    }

    export function getRootFilePath(outFname: string) {
        if (outFname == "") {
            return outFname;
        }
        else {
            var isPath = outFname.indexOf("/") != -1;
            return isPath ? filePath(outFname) : "";
        }
    }

    export function filePathComponents(fullPath: string) {
        fullPath = switchToForwardSlashes(fullPath);
        var components = getPathComponents(fullPath);
        return components.slice(0, components.length - 1);
    }

    export function filePath(fullPath: string) {
        var path = filePathComponents(fullPath);
        return path.join("/") + "/";
    }

    export function normalizeURL(url: string): string {
        var hostDomainAndPortRegex = /^(https?:\/\/[\-\w\.]+(:\d+)?\/)(.*)$/i;
        var matches = hostDomainAndPortRegex.exec(url);
        if (matches) {
            var hostDomainAndPort = matches[1];
            var actualPath = matches[3];
            return hostDomainAndPort + normalizePath(actualPath);
        }
        return normalizePath(url);
    }

    export var pathNormalizeRegExp = /\//g;

    export function normalizePath(path: string): string {
        path = switchToForwardSlashes(path);
        var startedWithSep = path.charAt(0) === "/";
        var parts = this.getPathComponents(path);
        for (var i = 0; i < parts.length; i++) {
            if (parts[i] === "." || parts[i] === "") {
                parts.splice(i, 1);
                i--;
            }
            if (i > 0 && parts[i] === ".." && parts[i - 1] !== "..") {
                parts.splice(i - 1, 2);
                i -= 2;
            }
        }
        return (startedWithSep ? "/" : "") + parts.join("/");
    }

    export function normalizeImportPath(path: string): string {
        return normalizePath(path);
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export interface IResolvedFile {
        content: string;
        path: string;
    }

    /// This class acts as a convenience class to store path and content information in places
    /// where we need an ISourceText object
    export class SourceUnit implements IScriptSnapshot, IResolvedFile {
        public referencedFiles: IFileReference[] = null;
        private lineStarts: number[] = null;

        constructor(public path: string,
                    public content: string) {
        }

        public getText(start: number, end: number): string {
            return this.content.substring(start, end);
        }

        public getLength(): number {
            return this.content.length;
        }

        public getLineStartPositions(): number[]{
            if (this.lineStarts === null) {
                this.lineStarts = LineMap.fromString(this.content).lineStarts();
            }

            return this.lineStarts;
        }

        public getTextChangeRangeSinceVersion(scriptVersion: number): TypeScript.TextChangeRange {
            throw Errors.notYetImplemented();
        }
    }

    // Note: This is being using by the host (VS) and is marshaled back and forth. When changing this make sure the changes 
    // are reflected in the managed side as well.
    export interface IFileReference extends ILineAndCharacter {
        path: string;
        isResident: bool;
        position: number;
        length: number;
    }

    /// Limited API for file system manipulation
    export interface IFileSystemObject {
        resolvePath(path: string): string;
        readFile(path: string): string;
        findFile(rootPath: string, partialFilePath: string): IResolvedFile;
        dirName(path: string): string;
    }

    export class CompilationEnvironment {
        constructor (public compilationSettings: CompilationSettings, public ioHost: IFileSystemObject) { }
        public code: SourceUnit[] = [];
        public inputFileNameToOutputFileName = new StringHashTable();
    }

    export interface IResolutionDispatcher {
        postResolutionError(errorFile: string, fileReference: IFileReference, errorMessage: string): void;
        postResolution(path: string, source: IScriptSnapshot): void;
    }

    export interface ICodeResolver {
        resolveCode(referencePath: string, rootPath: string, performSearch:bool, state: IResolutionDispatcher): void;
    }

    export interface IResolverHost {
        resolveCompilationEnvironment(preEnvironment: CompilationEnvironment, resolver: ICodeResolver, traceDependencies: bool): CompilationEnvironment;
    }

    export class CodeResolver implements TypeScript.ICodeResolver {
        public visited: any = { };

        constructor (public environment: CompilationEnvironment) { }

        public resolveCode(referencePath: string, parentPath: string, performSearch: bool, resolutionDispatcher: TypeScript.IResolutionDispatcher): bool {
            
            var resolvedFile: IResolvedFile = { content: null, path: referencePath };
            
            var ioHost = this.environment.ioHost;
            
            // If the path is relative, normalize it, based on the root
            var isRelativePath = TypeScript.isRelative(referencePath);
            var isRootedPath = isRelativePath ? false : isRooted(referencePath);
            var normalizedPath: string = 
                isRelativePath ? ioHost.resolvePath(parentPath + "/" + referencePath) : 
                // we only follow the second clause if the path is a non-rooted triple-slash reference path
                (isRootedPath || !parentPath || performSearch ? referencePath : parentPath + "/" + referencePath);

            // We use +=.ts to make sure we don't accidentally pick up ".js" files or the like
            if (!isTSFile(normalizedPath)) {
                normalizedPath += ".ts";  //changePathToSTR(normalizedPath);
            }

            normalizedPath = switchToForwardSlashes(stripQuotes(normalizedPath));
            var absoluteModuleID = this.environment.compilationSettings.useCaseSensitiveFileResolution ? normalizedPath : normalizedPath.toLocaleUpperCase();

            // read the file contents - if it doesn't exist, trigger a resolution error
            if (!this.visited[absoluteModuleID]) {
                // if the path is relative, or came from a reference tag, we don't perform a search
                if (isRelativePath || isRootedPath || !performSearch) {
                    try {
                        CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                            
                        // Look for the .ts file first - if not present, the .d.ts
                        try {
                            resolvedFile.content = ioHost.readFile(normalizedPath);
                        }
                        catch (err1) {
                            if (isTSFile(normalizedPath)) {
                                normalizedPath = changePathToDTS(normalizedPath);
                                CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                                resolvedFile.content = ioHost.readFile(normalizedPath);
                            }
                        }
                        CompilerDiagnostics.debugPrint("   Found code at " + normalizedPath);

                        resolvedFile.path = normalizedPath;
                        this.visited[absoluteModuleID] = true;
                    }
                    catch (err4) {
                        CompilerDiagnostics.debugPrint("   Did not find code for " + referencePath);
                        // Resolution failed
                        return false;
                    }
                }
                else {

                    // if the path is non-relative, we should attempt to search on the relative path
                    resolvedFile = ioHost.findFile(parentPath, normalizedPath);

                    if (!resolvedFile) {
                        if (isTSFile(normalizedPath)) {
                            normalizedPath = changePathToDTS(normalizedPath);
                            resolvedFile = ioHost.findFile(parentPath, normalizedPath);
                        }
                    }

                    if (resolvedFile) {
                        resolvedFile.path = switchToForwardSlashes(TypeScript.stripQuotes(resolvedFile.path));
                        CompilerDiagnostics.debugPrint(referencePath + " resolved to: " + resolvedFile.path);
                        resolvedFile.content = resolvedFile.content;
                        this.visited[absoluteModuleID] = true;
                    }
                    else {
                        CompilerDiagnostics.debugPrint("Could not find " + referencePath);
                    }
                }

                if (resolvedFile && resolvedFile.content != null) {
                    // preprocess the file, to gather dependencies
                    var rootDir = ioHost.dirName(resolvedFile.path);
                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.content);
                    var preProcessedFileInfo = preProcessFile(resolvedFile.path, sourceUnit, this.environment.compilationSettings);
                    var resolvedFilePath = ioHost.resolvePath(resolvedFile.path);
                    var i = 0;
                    var resolutionResult: bool;

                    sourceUnit.referencedFiles = preProcessedFileInfo.referencedFiles;

                    // resolve explicit references
                    for (i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {
                        var fileReference = preProcessedFileInfo.referencedFiles[i];

                        normalizedPath = isRooted(fileReference.path) ? fileReference.path : rootDir + "/" + fileReference.path;
                        normalizedPath = ioHost.resolvePath(normalizedPath);

                        if (resolvedFilePath == normalizedPath) {
                            resolutionDispatcher.postResolutionError(normalizedPath, fileReference, "Incorrect reference: File contains reference to itself.");
                            continue;
                        }

                        resolutionResult = this.resolveCode(fileReference.path, rootDir, false, resolutionDispatcher);

                        if (!resolutionResult) {
                            resolutionDispatcher.postResolutionError(resolvedFilePath, fileReference, "Incorrect reference: referenced file: \"" + fileReference.path + "\" cannot be resolved.");
                        }
                    }
                    
                    // resolve imports
                    for (i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {
                        var fileImport = preProcessedFileInfo.importedFiles[i];

                        resolutionResult = this.resolveCode(fileImport.path, rootDir, true, resolutionDispatcher);

                        if (!resolutionResult) {
                            resolutionDispatcher.postResolutionError(resolvedFilePath, fileImport, "Incorrect reference: imported file: \"" + fileImport.path + "\" cannot be resolved.");
                        }
                    }

                    // add the file to the appropriate code list
                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit);
                }
            }
            return true;
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />
///<reference path='Text\IScriptSnapshot.ts' />

module TypeScript {

    /// Compiler settings

    export class StyleSettings {
        // bitwise operations not permitted
        public bitwise = false;  
        // disallow non-block statements as bodies of compound statements
        public blockInCompoundStmt = false;
        // disallow == and !=
        public eqeqeq = false;
        // require body of for in loop to start with a filter
        public forin = false;
        // empty blocks permitted
        public emptyBlocks = true;
        // require result of new expression to be used (no new just for side-effects)
        public newMustBeUsed = false;
        // require semicolons to terminate statements
        public requireSemi = false;
        // no top-level assignment in conditionals if (a=b) { ...
        public assignmentInCond = false;
        // no == null or != null
        public eqnull = false;
        // permit eval
        public evalOK = true;
        // permit var use if decl in inner scope as in if (c) { var v=10; } v=11;
        public innerScopeDeclEscape = true;
        // permit functions in loops
        public funcInLoop = true;
        // permit re-declaration of local variable 
        public reDeclareLocal = true;
        // permit obj['x'] in addition to obj.x
        public literalSubscript = true;
        // flag implicit 'any'
        public implicitAny = false;

        public setOption(opt: string, val: bool): bool {
            var optExists = this[opt];
            if (optExists !== undefined) {
                this[opt] = val;
                return true;
            }
            else {
                return false;
            }
        }
        
        public parseOptions(str: string) {
            var opts=str.split(";");
            for (var i = 0, len = opts.length; i < len; i++) {
                var opt = opts[i];
                var val = true;
                var colonIndex=opt.lastIndexOf(":");
                if (colonIndex >= 0) {
                    var valStr = opt.substring(colonIndex+1);
                    opt = opt.substring(0, colonIndex);
                    if (valStr == "off") {
                        val = false;
                    }
                }
                if (!this.setOption(opt, val)) {
                    return false;
                }
            }
            return true;
        }
    }
    
    export class CompilationSettings {
        public styleSettings = new StyleSettings();
        public propagateConstants = false;
        public minWhitespace = false;
        public emitComments = false;
        public watch = false;
        public exec = false;
        public resolve = true;
        public controlFlow = false;
        public printControlFlow = false;
        public controlFlowUseDef = false;
        public errorOnWith = true;
        public canCallDefinitionSignature = false;

        public useDefaultLib = true;

        public codeGenTarget = LanguageVersion.EcmaScript3;
        public moduleGenTarget = ModuleGenTarget.Synchronous;
        public optimizeModuleCodeGen = true;

        // --out option passed. 
        // Default is the "" which leads to multiple files generated next to the.ts files
        public outputOption: string = "";
        public mapSourceFiles = false;
        public emitFullSourceMapPath = false; // By default emit relative path of the soucemap
        public generateDeclarationFiles = false;

        public useCaseSensitiveFileResolution = false;
        public gatherDiagnostics = false;

        public setStyleOptions(str: string) {
            this.styleSettings.parseOptions(str);
        }
    }

    ///
    /// Preprocessing
    ///
    export interface IPreProcessedFileInfo {
        settings: CompilationSettings;
        referencedFiles: IFileReference[];
        importedFiles: IFileReference[];
        isLibFile: bool;
    }

    export interface ITripleSlashDirectiveProperties {
        noDefaultLib: bool;
    }

    function getFileReferenceFromReferencePath(comment: string): IFileReference {
        var referencesRegEx = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/gim;
        var match = referencesRegEx.exec(comment);

        if (match) {
            var path: string = normalizePath(match[3]);
            var adjustedPath = normalizePath(path);
    
            var isResident = match.length >= 7 && match[6] == "true";
            if (isResident) {
                CompilerDiagnostics.debugPrint(path + " is resident");
            }
            return {
                line: 0,
                character: 0,
                position: 0,
                length: 0,
                path: switchToForwardSlashes(adjustedPath),
                isResident: isResident
            };
        }
        else {
            return null;
        }
    }

    // used in the parser, but kept here in case we want to reintegrate it with preprocessing
    export function getAdditionalDependencyPath(comment: string): string {
        var amdDependencyRegEx = /^(\/\/\/\s*<amd-dependency\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/gim;
        var match = amdDependencyRegEx.exec(comment);

        if (match) {
            var path: string = match[3];
            return path;
        }
        else {
            return null;
        }
    }

    export function getImplicitImport(comment: string): bool {
        var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
        var match = implicitImportRegEx.exec(comment);

        if (match) {
            return true;
        }
        
        return false;
    }

    export function getStyleSettings(comment: string, styleSettings: StyleSettings) {
        var styleRegEx = /^(\/\/\/\s*<style\s+)(([a-zA-Z])+=('|").+('|"))\s*\/>/gim;

        var settings = styleRegEx.exec(comment);

        if (settings) {
            var settingsRegEx = /^([a-zA-Z]+=['"]on['|"])/gim;
            settings = settingsRegEx.exec(settings[2]);
                
            if (settings) {
                for (var i = 0; i < settings.length; i++) {
                    var setting = (<string>settings[i]).split("=");
                    var on = "\"on\"";

                    switch (setting[0]) {
                        case "blockInCompoundStmt": styleSettings.blockInCompoundStmt = setting[1] == on; break;
                        case "eqeqeq": styleSettings.eqeqeq = setting[1] == on; break;
                        case "forin": styleSettings.forin = setting[1] == on; break;
                        case "emptyBlocks": styleSettings.emptyBlocks = setting[1] == on; break;
                        case "newMustBeUsed": styleSettings.newMustBeUsed = setting[1] == on; break;
                        case "requireSemi": styleSettings.requireSemi = setting[1] == on; break;
                        case "assignmentInCond": styleSettings.assignmentInCond = setting[1] == on; break;
                        case "eqnull": styleSettings.eqnull = setting[1] == on; break;
                        case "evalOK": styleSettings.evalOK = setting[1] == on; break;
                        case "innerScopeDeclEscape": styleSettings.innerScopeDeclEscape = setting[1] == on; break;
                        case "funcInLoop": styleSettings.funcInLoop = setting[1] == on; break;
                        case "reDeclareLocal": styleSettings.reDeclareLocal = setting[1] == on; break;
                        case "literalSubscript": styleSettings.literalSubscript = setting[1] == on; break;
                        case "implicitAny": styleSettings.implicitAny = setting[1] == on; break;                               
                    }
                }
            }
        }
    }

    export function getReferencedFiles(fileName: string, sourceText: IScriptSnapshot): IFileReference[] {
        var preProcessInfo = preProcessFile(fileName, sourceText, null, false);
        return preProcessInfo.referencedFiles;
    }

    var scannerWindow = ArrayUtilities.createArray(2048, 0);
    var scannerDiagnostics = [];

    function processImports(lineMap: LineMap, scanner: Scanner1, token: ISyntaxToken, importedFiles: IFileReference[]): void {
        var position = 0;
        var lineChar = { line: -1, character: -1 };

        // Look for: 
        // import foo = module("foo")
        while (token.tokenKind !== SyntaxKind.EndOfFileToken) {
            if (token.tokenKind === SyntaxKind.ImportKeyword) {
                var importStart = position + token.leadingTriviaWidth();
                token = scanner.scan(scannerDiagnostics, /*allowRegularExpression:*/ false);

                if (SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    token = scanner.scan(scannerDiagnostics, /*allowRegularExpression:*/ false);

                    if (token.tokenKind === SyntaxKind.EqualsToken) {
                        token = scanner.scan(scannerDiagnostics, /*allowRegularExpression:*/ false);

                        if (token.tokenKind === SyntaxKind.ModuleKeyword) {
                            token = scanner.scan(scannerDiagnostics, /*allowRegularExpression:*/ false);

                            if (token.tokenKind === SyntaxKind.OpenParenToken) {
                                var afterOpenParenPosition = scanner.absoluteIndex();
                                token = scanner.scan(scannerDiagnostics, /*allowRegularExpression:*/ false);

                                lineMap.fillLineAndCharacterFromPosition(importStart, lineChar);

                                if (token.tokenKind === SyntaxKind.StringLiteral) {
                                    var ref = {
                                        line: lineChar.line,
                                        character: lineChar.character,
                                        position: afterOpenParenPosition + token.leadingTriviaWidth(),
                                        length: token.width(),
                                        path: stripQuotes(switchToForwardSlashes(token.text())),
                                        isResident: false
                                    };
                                    importedFiles.push(ref);
                                }
                            }
                        }
                    }
                }
            }

            position = scanner.absoluteIndex();
            token = scanner.scan(scannerDiagnostics, /*allowRegularExpression:*/ false);
        }
    }

    export function processTripleSlashDirectives(lineMap: LineMap, firstToken: ISyntaxToken, settings: CompilationSettings, referencedFiles: IFileReference[]): ITripleSlashDirectiveProperties {
        var leadingTrivia = firstToken.leadingTrivia();

        var position = 0;
        var lineChar = { line: -1, character: -1 };
        var noDefaultLib = false;

        for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
            var trivia = leadingTrivia.syntaxTriviaAt(i);

            if (trivia.kind() === SyntaxKind.SingleLineCommentTrivia) {
                var triviaText = trivia.fullText();
                var referencedCode = getFileReferenceFromReferencePath(triviaText);

                if (referencedCode) {
                    lineMap.fillLineAndCharacterFromPosition(position, lineChar);
                    referencedCode.line = lineChar.line;
                    referencedCode.character = lineChar.character;

                    referencedFiles.push(referencedCode);
                }

                if (settings) {
                    getStyleSettings(triviaText, settings.styleSettings);

                    // is it a lib file?
                    var isNoDefaultLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
                    var isNoDefaultLibMatch: any = isNoDefaultLibRegex.exec(triviaText);
                    if (isNoDefaultLibMatch) {
                        noDefaultLib = (isNoDefaultLibMatch[3] == "true");
                    }
                }
            }

            position += trivia.fullWidth();
        }

        return { noDefaultLib: noDefaultLib};
    }

    export function preProcessFile(fileName: string, sourceText: IScriptSnapshot, settings?: CompilationSettings = new CompilationSettings(), readImportFiles? = true): IPreProcessedFileInfo {
        var text = SimpleText.fromScriptSnapshot(sourceText);
        var scanner = new Scanner1(fileName, text, LanguageVersion.EcmaScript5, scannerWindow);

        var firstToken = scanner.scan(scannerDiagnostics, /*allowRegularExpression:*/ false);

        // only search out dynamic mods
        // if you find a dynamic mod, ignore every other mod inside, until you balance rcurlies
        // var position

        var importedFiles: IFileReference[] = [];
        if (readImportFiles) {
            processImports(text.lineMap(), scanner, firstToken, importedFiles);
        }
        
        var referencedFiles: IFileReference[] = [];
        var properties  = processTripleSlashDirectives(text.lineMap(), firstToken, settings, referencedFiles);

        scannerDiagnostics.length = 0;
        return { settings:settings, referencedFiles: referencedFiles, importedFiles: importedFiles, isLibFile: properties.noDefaultLib };
    }

} // Tools
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export class DeclFileWriter {
        public onNewLine = true;
        constructor(private declFile: ITextWriter) {
        }

        public Write(s: string) {
            this.declFile.Write(s);
            this.onNewLine = false;
        }

        public WriteLine(s: string) {
            this.declFile.WriteLine(s);
            this.onNewLine = true;
        }

        public Close() {
            try {
                this.declFile.Close();
            }
            catch (e) {
                Emitter.throwEmitterError(e);
            }
        }
    }
    
    export class DeclarationEmitter implements AstWalkerWithDetailCallback.AstWalkerDetailCallback {
        public locationInfo: LocationInfo = null;
        public declFile: DeclFileWriter = null;
        private indenter = new Indenter();
        private declarationContainerStack: AST[] = [];
        private isDottedModuleName: bool[] = [];
        private dottedModuleEmit: string;
        private ignoreCallbackAst: AST = null;
        private singleDeclFile: DeclFileWriter = null;
        private varListCount: number = 0;

        constructor(private emittingFileName: string,
                    isUTF8: bool,
                    public checker: TypeChecker,
                    public emitOptions: EmitOptions) {
            // Creating files can cause exceptions, report them.   
            var file = this.createFile(emittingFileName, isUTF8);
            this.declFile = new DeclFileWriter(file);
        }

        public close() {
            try {
                this.declFile.Close();
            }
            catch (e) {
                Emitter.throwEmitterError(e);
            }
        }

        private createFile(fileName: string, useUTF8: bool): ITextWriter {
            try {
                return this.emitOptions.ioHost.createFile(fileName, useUTF8);
            }
            catch (e) {
                Emitter.throwEmitterError(e);
            }
        }

        public emitDeclarations(script: TypeScript.Script): void {
            this.locationInfo = script.locationInfo;

            AstWalkerWithDetailCallback.walk(script, this);
        }

        public getAstDeclarationContainer() {
            return this.declarationContainerStack[this.declarationContainerStack.length - 1];
        }

        private emitDottedModuleName() {
            return (this.isDottedModuleName.length === 0) ? false : this.isDottedModuleName[this.isDottedModuleName.length - 1];
        }

        private getIndentString(declIndent? = false) {
            if (this.emitOptions.compilationSettings.minWhitespace) {
                return "";
            }
            else {
                return this.indenter.getIndent();
            }
        }

        private emitIndent() {
            this.declFile.Write(this.getIndentString());
        }

        private canEmitSignature(declFlags: DeclFlags, canEmitGlobalAmbientDecl?: bool = true, useDeclarationContainerTop?: bool = true) {
            var container: AST;
            if (useDeclarationContainerTop) {
                container = this.getAstDeclarationContainer();
            } else {
                container = this.declarationContainerStack[this.declarationContainerStack.length - 2];
            }

            if (container.nodeType === NodeType.ModuleDeclaration && !hasFlag(declFlags, DeclFlags.Exported)) {
                return false;
            }

            if (!canEmitGlobalAmbientDecl && container.nodeType === NodeType.Script && hasFlag(declFlags, DeclFlags.Ambient)) {
                return false;
            }

            return true;
        }

        private canEmitPrePostAstSignature(declFlags: DeclFlags, astWithPrePostCallback: AST, preCallback: bool) {
            if (this.ignoreCallbackAst) {
                CompilerDiagnostics.assert(this.ignoreCallbackAst != astWithPrePostCallback, "Ignore Callback AST mismatch");
                this.ignoreCallbackAst = null;
                return false;
            } else if (preCallback &&
                !this.canEmitSignature(declFlags, true, preCallback)) {
                this.ignoreCallbackAst = astWithPrePostCallback;
                return false;
            }

            return true;
        }

        private getDeclFlagsString(declFlags: DeclFlags, typeString: string) {
            var result = this.getIndentString();

            // Emit export only for global export statements. The container for this would be dynamic module which is whole file
            var container = this.getAstDeclarationContainer();
            if (container.nodeType === NodeType.ModuleDeclaration &&
                hasFlag((<ModuleDeclaration>container).modFlags, ModuleFlags.IsWholeFile) &&
                hasFlag(declFlags, DeclFlags.Exported)) {
                result += "export ";
            }

            // Static/public/private/global declare
            if (hasFlag(declFlags, DeclFlags.LocalStatic) || hasFlag(declFlags, DeclFlags.Static)) {
                if (hasFlag(declFlags, DeclFlags.Private)) {
                    result += "private ";
                }
                result += "static ";
            }
            else {
                if (hasFlag(declFlags, DeclFlags.Private)) {
                    result += "private ";
                }
                else if (hasFlag(declFlags, DeclFlags.Public)) {
                    result += "public ";
                }
                else {
                    result += typeString + " ";
                }
            }

            return result;
        }

        private emitDeclFlags(declFlags: DeclFlags, typeString: string) {
            this.declFile.Write(this.getDeclFlagsString(declFlags, typeString));
        }

        private canEmitTypeAnnotationSignature(declFlag: DeclFlags = DeclFlags.None) {
            // Private declaration, shouldnt emit type any time.
            return !hasFlag(declFlag, DeclFlags.Private);
        }

        private pushDeclarationContainer(ast: AST) {
            this.declarationContainerStack.push(ast);
        }

        private popDeclarationContainer(ast: AST) {
            CompilerDiagnostics.assert(ast != this.getAstDeclarationContainer(), 'Declaration container mismatch');
            this.declarationContainerStack.pop();
        }

        public emitTypeNamesMember(memberName: MemberName, emitIndent? : bool = false) {
            if (memberName.prefix === "{ ") {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.WriteLine("{");
                this.indenter.increaseIndent();
                emitIndent = true;
            } else if (memberName.prefix != "") {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.Write(memberName.prefix);
                emitIndent = false;
            }

            if (memberName.isString()) {
                if (emitIndent) {
                    this.emitIndent();
                }
                this.declFile.Write((<MemberNameString>memberName).text);
            } else {
                var ar = <MemberNameArray>memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    this.emitTypeNamesMember(ar.entries[index], emitIndent);
                    if (ar.delim === "; ") {
                        this.declFile.WriteLine(";");
                    }
                }
            }

            if (memberName.suffix === "}") {
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.declFile.Write(memberName.suffix);
            } else {
                this.declFile.Write(memberName.suffix);
            }
        }

        private emitTypeSignature(type: Type) {
            var containingScope: SymbolScope = null;
            var declarationContainerAst = this.getAstDeclarationContainer();
            switch (declarationContainerAst.nodeType) {
                case NodeType.ModuleDeclaration:
                case NodeType.InterfaceDeclaration:
                case NodeType.FuncDecl:
                    if (declarationContainerAst.type) {
                        containingScope = declarationContainerAst.type.containedScope;
                    }
                    break;

                case NodeType.Script:
                    var script = <Script>declarationContainerAst;
                    if (script.bod) {
                        containingScope = script.bod.enclosingScope;
                    }
                    break;

                case NodeType.ClassDeclaration:
                    if (declarationContainerAst.type) {
                        containingScope = declarationContainerAst.type.instanceType.containedScope;
                    }
                    break;

                default:
                    CompilerDiagnostics.debugPrint("Unknown containing scope");
            }

            var typeNameMembers = type.getScopedTypeNameEx(containingScope);
            this.emitTypeNamesMember(typeNameMembers);
        }

        private emitComment(comment: Comment) {
            var text = comment.getText();
            if (this.declFile.onNewLine) {
                this.emitIndent();
            } else if (!comment.isBlockComment) {
                this.declFile.WriteLine("");
                this.emitIndent();
            }
            
            this.declFile.Write(text[0]);

            for (var i = 1; i < text.length; i++) {
                this.declFile.WriteLine("");
                this.emitIndent();
                this.declFile.Write(text[i]);
            }

            if (comment.endsLine || !comment.isBlockComment) {
                this.declFile.WriteLine("");
            } else {
                this.declFile.Write(" ");
            }
        }

        private emitDeclarationComments(ast: AST, endLine?: bool);
        private emitDeclarationComments(symbol: Symbol, endLine?: bool);
        private emitDeclarationComments(astOrSymbol, endLine = true) {
            if (!this.emitOptions.compilationSettings.emitComments) {
                return;
            }

            var declComments = <Comment[]>astOrSymbol.getDocComments();
            this.writeDeclarationComments(declComments, endLine);
        }

        public writeDeclarationComments(declComments: Comment[], endLine = true) {
            if (declComments.length > 0) {
                for (var i = 0; i < declComments.length; i++) {
                    this.emitComment(declComments[i]);
                }

                if (endLine) {
                    if (!this.declFile.onNewLine) {
                        this.declFile.WriteLine("");
                    }
                } else {
                    if (this.declFile.onNewLine) {
                        this.emitIndent();
                    }
                }
            }
        }

        public emitTypeOfBoundDecl(boundDecl: BoundDecl) {
            var type: Type = null;
            if (boundDecl.typeExpr && boundDecl.typeExpr.type) {
                type = boundDecl.typeExpr.type;
            }
            else if (boundDecl.sym) {
                type = (<FieldSymbol>boundDecl.sym).getType();
                // Dont emit inferred any
                if (type === this.checker.anyType) {
                    type = null;
                }
            }

            if (type) {
                this.declFile.Write(": ");
                this.emitTypeSignature(type);
            }
        }

        public VarDeclCallback(pre: bool, varDecl: VarDecl): bool {
            if (pre && this.canEmitSignature(ToDeclFlags(varDecl.varFlags), false)) {
                var interfaceMember = (this.getAstDeclarationContainer().nodeType === NodeType.InterfaceDeclaration);
                this.emitDeclarationComments(varDecl);
                if (!interfaceMember) {
                    // If it is var list of form var a, b, c = emit it only if count > 0 - which will be when emitting first var
                    // If it is var list of form  var a = varList count will be 0
                    if (this.varListCount >= 0) {
                        this.emitDeclFlags(ToDeclFlags(varDecl.varFlags), "var");
                        this.varListCount = -this.varListCount;
                    }
                    this.declFile.Write(varDecl.id.text);
                } else {
                    this.emitIndent();
                    this.declFile.Write(varDecl.id.text);
                    if (hasFlag(varDecl.id.flags, ASTFlags.OptionalName)) {
                        this.declFile.Write("?");
                    }
                }

                if (this.canEmitTypeAnnotationSignature(ToDeclFlags(varDecl.varFlags))) {
                    this.emitTypeOfBoundDecl(varDecl);
                }
               
                // emitted one var decl
                if (this.varListCount > 0) { this.varListCount--; } else if (this.varListCount < 0) { this.varListCount++; }

                // Write ; or ,
                if (this.varListCount < 0) {
                    this.declFile.Write(", ");
                } else {
                    this.declFile.WriteLine(";");
                }
            }
            return false;
        }

        public BlockCallback(pre: bool, block: Block): bool {
            if (!block.isStatementBlock) {
                if (pre) {
                    this.varListCount = block.statements.members.length;
                } else {
                    this.varListCount = 0;
                }
                return true;
            }
            return false;
        }

        private emitArgDecl(argDecl: ArgDecl, funcDecl: FuncDecl) {
            this.emitDeclarationComments(argDecl, false);
            this.declFile.Write(argDecl.id.text);
            if (argDecl.isOptionalArg()) {
                this.declFile.Write("?");
            }
            if (this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {
                this.emitTypeOfBoundDecl(argDecl);
            }
        }

        public isOverloadedConstructorSignature(funcDecl: FuncDecl) {
            if (funcDecl.isConstructor && funcDecl.type.construct && funcDecl.type.construct.signatures.length > 1) {
                return true;
            }

            return false;
        }

        public isOverloadedCallSignature(funcDecl: FuncDecl) {
            if (!funcDecl.isConstructor && funcDecl.type.call && funcDecl.type.call.signatures.length > 1) {
                return true;
            }

            return false;
        }

        public getFirstCallOverloadFuncDecl(funcDecl: FuncDecl) {
            var signatures = funcDecl.type.call.signatures;
            var firstSignature = signatures[0].declAST;
            if (firstSignature.bod) {
                // Its a implementation, use next one
                firstSignature = signatures[1].declAST;
            }

            return firstSignature;
        }

        public emitReturnTypeOfFuncDecl(funcDecl: FuncDecl) {
            if (funcDecl.returnTypeAnnotation || funcDecl.signature.returnType.type != this.checker.anyType) {
                this.declFile.Write(": ");
                this.emitTypeSignature(funcDecl.signature.returnType.type);
            }
        }

        public FuncDeclCallback(pre: bool, funcDecl: FuncDecl): bool {
            if (!pre) {
                return false;
            }

            if (funcDecl.isAccessor()) {
                return this.emitPropertyAccessorSignature(funcDecl);
            }

            var isInterfaceMember = (this.getAstDeclarationContainer().nodeType === NodeType.InterfaceDeclaration);
            if (funcDecl.bod) {
                if (this.isOverloadedConstructorSignature(funcDecl)) {
                    return false;
                }
                else if (this.isOverloadedCallSignature(funcDecl)) {
                    // This means its implementation of overload signature. do not emit
                    return false;
                }
            } else if (!isInterfaceMember && hasFlag(funcDecl.fncFlags, FncFlags.Private) && this.isOverloadedCallSignature(funcDecl)) {
                // Print only first overload of private function
                var firstSignature = this.getFirstCallOverloadFuncDecl(funcDecl);
                if (firstSignature != funcDecl) {
                    return false;
                }
            }

            if (!this.canEmitSignature(ToDeclFlags(funcDecl.fncFlags), false)) {
                return false;
            }

            this.emitDeclarationComments(funcDecl);
            if (funcDecl.isConstructor) {
                this.emitIndent();
                this.declFile.Write("constructor");
            }
            else {
                var id = funcDecl.getNameText();
                if (!isInterfaceMember) {
                    this.emitDeclFlags(ToDeclFlags(funcDecl.fncFlags), "function");
                    if (id != "__missing" || !funcDecl.name || !funcDecl.name.isMissing()) {
                        this.declFile.Write(id);
                    } else if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                    }
                } else {
                    this.emitIndent();
                    if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                    } else if (!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {
                        this.declFile.Write(id);
                        if (hasFlag(funcDecl.name.flags, ASTFlags.OptionalName)) {
                            this.declFile.Write("? ");
                        }
                    }
                }
            }

            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write("(");
            } else {
                this.declFile.Write("[");
            }

            this.indenter.increaseIndent();

            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length;
                if (funcDecl.variableArgList) {
                    argsLen--;
                }
                for (var i = 0; i < argsLen; i++) {
                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];
                    this.emitArgDecl(argDecl, funcDecl);
                    if (i < (argsLen - 1)) {
                        this.declFile.Write(", ");
                    }
                }
            }

            if (funcDecl.variableArgList) {
                var lastArg = <ArgDecl>funcDecl.arguments.members[funcDecl.arguments.members.length - 1];
                if (funcDecl.arguments.members.length > 1) {
                    this.declFile.Write(", ...");
                }
                else {
                    this.declFile.Write("...");
                }
                this.emitArgDecl(lastArg, funcDecl);
            }

            this.indenter.decreaseIndent();

            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write(")");
            } else {
                this.declFile.Write("]");
            }

            if (!funcDecl.isConstructor &&
                this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {
                this.emitReturnTypeOfFuncDecl(funcDecl); 
            }

            this.declFile.WriteLine(";");

            return false;
        }

        public emitBaseExpression(bases: ASTList, index: number, useExtendsList: bool) {
            var baseExpr = bases.members[index];
            var baseSymbol = baseExpr.type.symbol;
            var baseType = baseExpr.type;
            this.emitTypeSignature(baseType);
        }

        private emitBaseList(typeDecl: TypeDeclaration, useExtendsList: bool) {
            var bases = useExtendsList ? typeDecl.extendsList : typeDecl.implementsList;
            if (bases && (bases.members.length > 0)) {
                var qual = useExtendsList ? "extends" : "implements";
                this.declFile.Write(" " + qual + " ");
                var basesLen = bases.members.length;
                for (var i = 0; i < basesLen; i++) {
                    if (i > 0) {
                        this.declFile.Write(", ");
                    }
                    this.emitBaseExpression(bases, i, useExtendsList);
                }
            }
        }

        public hasGetterAndIsNotGetter(funcDecl: FuncDecl) {
            var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;
            if (accessorSymbol.getter && accessorSymbol.getter.declAST != funcDecl) {
                return true;
            }

            return false;
        }

        public emitAccessorDeclarationComments(funcDecl: FuncDecl) {
            var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;
            this.emitDeclarationComments(accessorSymbol);
        }

        public emitPropertyTypeOfProperty(funcDecl: FuncDecl) {
            var accessorSymbol = <FieldSymbol>funcDecl.accessorSymbol;
            var propertyType = accessorSymbol.getType();
            this.emitTypeSignature(propertyType);
        }
        
        public emitPropertyAccessorSignature(funcDecl: FuncDecl) {
            if (this.hasGetterAndIsNotGetter(funcDecl)) {
                // Setter is being used to emit the type info. 
                return false;
            }

            this.emitAccessorDeclarationComments(funcDecl);
            this.emitDeclFlags(ToDeclFlags(funcDecl.fncFlags), "var");
            this.declFile.Write(funcDecl.name.text);
            if (this.canEmitTypeAnnotationSignature(ToDeclFlags(funcDecl.fncFlags))) {
                this.declFile.Write(" : ");
                this.emitPropertyTypeOfProperty(funcDecl);
            }
            this.declFile.WriteLine(";");

            return false;
        }

        private emitClassMembersFromConstructorDefinition(funcDecl: FuncDecl) {
            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length; if (funcDecl.variableArgList) { argsLen--; }

                for (var i = 0; i < argsLen; i++) {
                    var argDecl = <ArgDecl>funcDecl.arguments.members[i];
                    if (hasFlag(argDecl.varFlags, VarFlags.Property)) {
                        this.emitDeclarationComments(argDecl);
                        this.emitDeclFlags(ToDeclFlags(argDecl.varFlags), "var");
                        this.declFile.Write(argDecl.id.text);

                        if (this.canEmitTypeAnnotationSignature(ToDeclFlags(argDecl.varFlags))) {
                            this.emitTypeOfBoundDecl(argDecl);
                        }
                        this.declFile.WriteLine(";");
                    }
                }
            }
        }

        public ClassDeclarationCallback(pre: bool, classDecl: ClassDeclaration): bool {
            if (!this.canEmitPrePostAstSignature(ToDeclFlags(classDecl.varFlags), classDecl, pre)) {
                return false;
            }

            if (pre) {
                var className = classDecl.name.text;
                this.emitDeclarationComments(classDecl);
                this.emitDeclFlags(ToDeclFlags(classDecl.varFlags), "class");
                this.declFile.Write(className);
                this.pushDeclarationContainer(classDecl);
                this.emitBaseList(classDecl, true);
                this.emitBaseList(classDecl, false);
                this.declFile.WriteLine(" {");

                this.indenter.increaseIndent();
                if (classDecl.constructorDecl) {
                    this.emitClassMembersFromConstructorDefinition(classDecl.constructorDecl);
                }
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(classDecl);

                this.emitIndent();
                this.declFile.WriteLine("}");
            }

            return true;
        }

        public InterfaceDeclarationCallback(pre: bool, interfaceDecl: InterfaceDeclaration): bool {
            if (!this.canEmitPrePostAstSignature(ToDeclFlags(interfaceDecl.varFlags), interfaceDecl, pre)) {
                return false;
            }

            if (pre) {
                var interfaceName = interfaceDecl.name.text;
                this.emitDeclarationComments(interfaceDecl);
                this.emitDeclFlags(ToDeclFlags(interfaceDecl.varFlags), "interface");
                this.declFile.Write(interfaceName);
                this.pushDeclarationContainer(interfaceDecl);
                this.emitBaseList(interfaceDecl, true);
                this.declFile.WriteLine(" {");

                this.indenter.increaseIndent();
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(interfaceDecl);

                this.emitIndent();
                this.declFile.WriteLine("}");
            }

            return true;
        }

        public ImportDeclarationCallback(pre: bool, importDecl: ImportDeclaration): bool {
            if (pre) {
                if ((<Script>this.declarationContainerStack[0]).isExternallyVisibleSymbol(importDecl.id.sym)) {
                    this.emitDeclarationComments(importDecl);
                    this.emitIndent();
                    this.declFile.Write("import ");

                    this.declFile.Write(importDecl.id.text + " = ");
                    if (importDecl.isDynamicImport) {
                        this.declFile.WriteLine("module (" + importDecl.getAliasName() + ");");
                    } else {
                        this.declFile.WriteLine(importDecl.getAliasName() + ";");
                    }
                }
            }

            return false;
        }

        private emitEnumSignature(moduleDecl: ModuleDeclaration) {
            if (!this.canEmitSignature(ToDeclFlags(moduleDecl.modFlags))) {
                return false;
            }

            this.emitDeclarationComments(moduleDecl);
            this.emitDeclFlags(ToDeclFlags(moduleDecl.modFlags), "enum");
            this.declFile.WriteLine(moduleDecl.name.text + " {");

            this.indenter.increaseIndent();
            var membersLen = moduleDecl.members.members.length;
            for (var j = 1; j < membersLen; j++) {
                var memberDecl: AST = moduleDecl.members.members[j];
                if (memberDecl.nodeType === NodeType.VarDecl) {
                    this.emitDeclarationComments(memberDecl);
                    this.emitIndent();
                    this.declFile.WriteLine((<VarDecl>memberDecl).id.text + ",");
                } else {
                    CompilerDiagnostics.assert(memberDecl.nodeType != NodeType.Asg, "We want to catch this");
                }
            }
            this.indenter.decreaseIndent();

            this.emitIndent();
            this.declFile.WriteLine("}");

            return false;
        }

        public ModuleDeclarationCallback(pre: bool, moduleDecl: ModuleDeclaration): bool {
            if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsWholeFile)) {
                // This is dynamic modules and we are going to outputing single file, 
                // we need to change the declFile because dynamic modules are always emitted to their corresponding .d.ts
                if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic)) {
                    if (pre) {
                        if (!this.emitOptions.outputMany) {
                            this.singleDeclFile = this.declFile;
                            CompilerDiagnostics.assert(this.indenter.indentAmt === 0, "Indent has to be 0 when outputing new file");
                            // Create new file
                            var tsFileName = (<Script>this.getAstDeclarationContainer()).locationInfo.fileName;
                            var declareFileName = this.emitOptions.mapOutputFileName(tsFileName, TypeScriptCompiler.mapToDTSFileName);
                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.compilationSettings.emitComments && moduleDecl.containsUnicodeCharInComment);

                            // Creating files can cause exceptions, they will be caught higher up in TypeScriptCompiler.emit
                            this.declFile = new DeclFileWriter(this.createFile(declareFileName, useUTF8InOutputfile));
                        }
                        this.pushDeclarationContainer(moduleDecl);
                    } else {
                        if (!this.emitOptions.outputMany) {
                            CompilerDiagnostics.assert(this.singleDeclFile != this.declFile, "singleDeclFile cannot be null as we are going to revert back to it");
                            CompilerDiagnostics.assert(this.indenter.indentAmt === 0, "Indent has to be 0 when outputing new file");

                            // Creating files can cause exceptions, they will be caught higher up in TypeScriptCompiler.emit
                            try {
                                this.declFile.Close();
                            }
                            catch (e) {
                                Emitter.throwEmitterError(e);
                            }

                            this.declFile = this.singleDeclFile;
                        }

                        this.popDeclarationContainer(moduleDecl);
                    }
                }

                return true;
            }

            if (moduleDecl.isEnum()) {
                if (pre) {
                    this.emitEnumSignature(moduleDecl);
                }
                return false;
            }

            if (!this.canEmitPrePostAstSignature(ToDeclFlags(moduleDecl.modFlags), moduleDecl, pre)) {
                return false;
            }

            if (pre) {
                if (this.emitDottedModuleName()) {
                    this.dottedModuleEmit += ".";
                } else {
                    this.dottedModuleEmit = this.getDeclFlagsString(ToDeclFlags(moduleDecl.modFlags), "module");
                }
                this.dottedModuleEmit += moduleDecl.name.text;

                var isCurrentModuleDotted = (moduleDecl.members.members.length === 1 &&
                    moduleDecl.members.members[0].nodeType === NodeType.ModuleDeclaration &&
                    !(<ModuleDeclaration>moduleDecl.members.members[0]).isEnum() &&
                    hasFlag((<ModuleDeclaration>moduleDecl.members.members[0]).modFlags, ModuleFlags.Exported));

                // Module is dotted only if it does not have doc comments for it
                var moduleDeclComments = moduleDecl.getDocComments();
                isCurrentModuleDotted = isCurrentModuleDotted && (moduleDeclComments === null || moduleDeclComments.length === 0);

                this.isDottedModuleName.push(isCurrentModuleDotted);
                this.pushDeclarationContainer(moduleDecl);

                if (!isCurrentModuleDotted) {
                    this.emitDeclarationComments(moduleDecl);
                    this.declFile.Write(this.dottedModuleEmit);
                    this.declFile.WriteLine(" {");
                    this.indenter.increaseIndent();
                }
            } else {
                if (!this.emitDottedModuleName()) {
                    this.indenter.decreaseIndent();
                    this.emitIndent();
                    this.declFile.WriteLine("}");
                }
                this.popDeclarationContainer(moduleDecl);
                this.isDottedModuleName.pop();
            }

            return true;
        }

        public ScriptCallback(pre: bool, script: Script): bool {
            if (pre) {
                if (this.emitOptions.outputMany) {
                    for (var i = 0; i < script.referencedFiles.length; i++) {
                        var referencePath = script.referencedFiles[i].path;
                        var declareFileName: string;
                        if (isRooted(referencePath)) {
                            declareFileName = this.emitOptions.mapOutputFileName(referencePath, TypeScriptCompiler.mapToDTSFileName)
                        } else {
                            declareFileName = getDeclareFilePath(script.referencedFiles[i].path);
                        }
                        this.declFile.WriteLine('/// <reference path="' + declareFileName + '" />');
                    }
                }
                this.pushDeclarationContainer(script);
            }
            else {
                this.popDeclarationContainer(script);
            }
            return true;
        }

        public DefaultCallback(pre: bool, ast: AST): bool {
            return !hasFlag(ast.flags, ASTFlags.IsStatement);
        }
    }
}
// If you change anything in this enum, make sure you run SyntaxGenerator again!

module TypeScript {
    export enum SyntaxKind {
        // Variable width tokens, trivia and lists.
        None,
        List,
        SeparatedList,
        TriviaList,

        // Trivia
        WhitespaceTrivia,
        NewLineTrivia,
        MultiLineCommentTrivia,
        SingleLineCommentTrivia,
        SkippedTextTrivia,

        // Note: all variable width tokens must come before all fixed width tokens.

        ErrorToken,
        EndOfFileToken,

        // Tokens
        IdentifierName,

        // LiteralTokens
        RegularExpressionLiteral,
        NumericLiteral,
        StringLiteral,

        // All fixed width tokens follow.

        // Keywords
        BreakKeyword,
        CaseKeyword,
        CatchKeyword,
        ContinueKeyword,
        DebuggerKeyword,
        DefaultKeyword,
        DeleteKeyword,
        DoKeyword,
        ElseKeyword,
        FalseKeyword,
        FinallyKeyword,
        ForKeyword,
        FunctionKeyword,
        IfKeyword,
        InKeyword,
        InstanceOfKeyword,
        NewKeyword,
        NullKeyword,
        ReturnKeyword,
        SwitchKeyword,
        ThisKeyword,
        ThrowKeyword,
        TrueKeyword,
        TryKeyword,
        TypeOfKeyword,
        VarKeyword,
        VoidKeyword,
        WhileKeyword,
        WithKeyword,

        // FutureReservedWords.
        ClassKeyword,
        ConstKeyword,
        EnumKeyword,
        ExportKeyword,
        ExtendsKeyword,
        ImportKeyword,
        SuperKeyword,

        // FutureReservedStrictWords.
        ImplementsKeyword,
        InterfaceKeyword,
        LetKeyword,
        PackageKeyword,
        PrivateKeyword,
        ProtectedKeyword,
        PublicKeyword,
        StaticKeyword,
        YieldKeyword,

        // TypeScript keywords.
        AnyKeyword,
        BooleanKeyword,
        BoolKeyword,
        ConstructorKeyword,
        DeclareKeyword,
        GetKeyword,
        ModuleKeyword,
        NumberKeyword,
        SetKeyword,
        StringKeyword,

        // Punctuators
        OpenBraceToken,
        CloseBraceToken,
        OpenParenToken,
        CloseParenToken,
        OpenBracketToken,
        CloseBracketToken,
        DotToken,
        DotDotDotToken,
        SemicolonToken,
        CommaToken,
        LessThanToken,
        GreaterThanToken,
        LessThanEqualsToken,
        GreaterThanEqualsToken,
        EqualsEqualsToken,
        EqualsGreaterThanToken,
        ExclamationEqualsToken,
        EqualsEqualsEqualsToken,
        ExclamationEqualsEqualsToken,
        PlusToken,
        MinusToken,
        AsteriskToken,
        PercentToken,
        PlusPlusToken,
        MinusMinusToken,
        LessThanLessThanToken,
        GreaterThanGreaterThanToken,
        GreaterThanGreaterThanGreaterThanToken,
        AmpersandToken,
        BarToken,
        CaretToken,
        ExclamationToken,
        TildeToken,
        AmpersandAmpersandToken,
        BarBarToken,
        QuestionToken,
        ColonToken,
        EqualsToken,
        PlusEqualsToken,
        MinusEqualsToken,
        AsteriskEqualsToken,
        PercentEqualsToken,
        LessThanLessThanEqualsToken,
        GreaterThanGreaterThanEqualsToken,
        GreaterThanGreaterThanGreaterThanEqualsToken,
        AmpersandEqualsToken,
        BarEqualsToken,
        CaretEqualsToken,
        SlashToken,
        SlashEqualsToken,

        // SyntaxNodes
        SourceUnit,

        // Names
        QualifiedName,

        // Types
        ObjectType,
        FunctionType,
        ArrayType,
        ConstructorType,
        GenericType,

        // Module elements.
        InterfaceDeclaration,
        FunctionDeclaration,
        ModuleDeclaration,
        ClassDeclaration,
        EnumDeclaration,
        ImportDeclaration,
        ExportAssignment,

        // ClassElements
        MemberFunctionDeclaration,
        MemberVariableDeclaration,
        ConstructorDeclaration,
        GetMemberAccessorDeclaration,
        SetMemberAccessorDeclaration,

        // Type members.
        PropertySignature,
        CallSignature,
        ConstructSignature,
        IndexSignature,
        MethodSignature,

        // Statements
        Block,
        IfStatement,
        VariableStatement,
        ExpressionStatement,
        ReturnStatement,
        SwitchStatement,
        BreakStatement,
        ContinueStatement,
        ForStatement,
        ForInStatement,
        EmptyStatement,
        ThrowStatement,
        WhileStatement,
        TryStatement,
        LabeledStatement,
        DoStatement,
        DebuggerStatement,
        WithStatement,

        // Expressions
        PlusExpression,
        NegateExpression,
        BitwiseNotExpression,
        LogicalNotExpression,
        PreIncrementExpression,
        PreDecrementExpression,
        DeleteExpression,
        TypeOfExpression,
        VoidExpression,
        CommaExpression,
        AssignmentExpression,
        AddAssignmentExpression,
        SubtractAssignmentExpression,
        MultiplyAssignmentExpression,
        DivideAssignmentExpression,
        ModuloAssignmentExpression,
        AndAssignmentExpression,
        ExclusiveOrAssignmentExpression,
        OrAssignmentExpression,
        LeftShiftAssignmentExpression,
        SignedRightShiftAssignmentExpression,
        UnsignedRightShiftAssignmentExpression,
        ConditionalExpression,
        LogicalOrExpression,
        LogicalAndExpression,
        BitwiseOrExpression,
        BitwiseExclusiveOrExpression,
        BitwiseAndExpression,
        EqualsWithTypeConversionExpression,
        NotEqualsWithTypeConversionExpression,
        EqualsExpression,
        NotEqualsExpression,
        LessThanExpression,
        GreaterThanExpression,
        LessThanOrEqualExpression,
        GreaterThanOrEqualExpression,
        InstanceOfExpression,
        InExpression,
        LeftShiftExpression,
        SignedRightShiftExpression,
        UnsignedRightShiftExpression,
        MultiplyExpression,
        DivideExpression,
        ModuloExpression,
        AddExpression,
        SubtractExpression,
        PostIncrementExpression,
        PostDecrementExpression,
        MemberAccessExpression,
        InvocationExpression,
        ArrayLiteralExpression,
        ObjectLiteralExpression,
        ObjectCreationExpression,
        ParenthesizedExpression,
        ParenthesizedArrowFunctionExpression,
        SimpleArrowFunctionExpression,
        CastExpression,
        ElementAccessExpression,
        FunctionExpression,
        OmittedExpression,

        // Variable declarations
        VariableDeclaration,
        VariableDeclarator,

        // Lists
        ArgumentList,
        ParameterList,
        TypeArgumentList,
        TypeParameterList,

        // Clauses
        ImplementsClause,
        ExtendsClause,
        EqualsValueClause,
        CaseSwitchClause,
        DefaultSwitchClause,
        ElseClause,
        CatchClause,
        FinallyClause,

        // Generics
        TypeParameter,
        Constraint,

        // Misc.
        Parameter,
        EnumElement,
        TypeAnnotation,
        SimplePropertyAssignment,
        ExternalModuleReference,
        ModuleNameModuleReference,
        GetAccessorPropertyAssignment,
        SetAccessorPropertyAssignment,

        FirstStandardKeyword = BreakKeyword,
        LastStandardKeyword = WithKeyword,

        FirstFutureReservedKeyword = ClassKeyword,
        LastFutureReservedKeyword = SuperKeyword,

        FirstFutureReservedStrictKeyword = ImplementsKeyword,
        LastFutureReservedStrictKeyword = YieldKeyword,

        FirstTypeScriptKeyword = AnyKeyword,
        LastTypeScriptKeyword = StringKeyword,

        FirstKeyword = FirstStandardKeyword,
        LastKeyword = LastTypeScriptKeyword,

        FirstToken = ErrorToken,
        LastToken = SlashEqualsToken,

        FirstPunctuation = OpenBraceToken,
        LastPunctuation = SlashEqualsToken,

        FirstFixedWidth = FirstKeyword,
        LastFixedWidth = LastPunctuation,
    }
}
///<reference path='References.ts' />

module TypeScript {
    export interface ISyntaxTrivia {
        kind(): SyntaxKind;

        isWhitespace(): bool;
        isComment(): bool;
        isNewLine(): bool;
        isSkippedText(): bool;

        // With of this trivia.
        fullWidth(): number;

        // Text for this trivia.
        fullText(): string;
    }
}
///<reference path='References.ts' />

module TypeScript {
    export interface ISyntaxTriviaList {
        count(): number;
        syntaxTriviaAt(index: number): ISyntaxTrivia;

        // With of this trivia list.
        fullWidth(): number;

        // Text for this trivia list.
        fullText(): string;

        hasComment(): bool;
        hasNewLine(): bool;
        hasSkippedText(): bool;

        last(): ISyntaxTrivia;
        toArray(): ISyntaxTrivia[];

        concat(trivia: ISyntaxTriviaList): ISyntaxTriviaList;

        collectTextElements(elements: string[]): void;
    }
}
﻿///<reference path='References.ts' />

module TypeScript {
    export class SyntaxRewriter implements ISyntaxVisitor {
        public visitToken(token: ISyntaxToken): ISyntaxToken {
            return token;
        }

        public visitNode(node: SyntaxNode): SyntaxNode {
            return node.accept(this);
        }

        public visitNodeOrToken(node: ISyntaxNodeOrToken): ISyntaxNodeOrToken {
            return node.isToken() ? <ISyntaxNodeOrToken>this.visitToken(<ISyntaxToken>node) : this.visitNode(<SyntaxNode>node);
        }

        public visitList(list: ISyntaxList): ISyntaxList {
            var newItems: ISyntaxNodeOrToken[] = null;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = this.visitNodeOrToken(item);

                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for (var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }

                if (newItems) {
                    newItems.push(newItem);
                }
            }

            // Debug.assert(newItems === null || newItems.length === list.childCount());
            return newItems === null ? list : Syntax.list(newItems);
        }

        public visitSeparatedList(list: ISeparatedSyntaxList): ISeparatedSyntaxList {
            var newItems: ISyntaxNodeOrToken[] = null;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = item.isToken() ? <ISyntaxNodeOrToken>this.visitToken(<ISyntaxToken>item) : this.visitNode(<SyntaxNode>item);

                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for (var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }

                if (newItems) {
                    newItems.push(newItem);
                }
            }

            // Debug.assert(newItems === null || newItems.length === list.childCount());
            return newItems === null ? list : Syntax.separatedList(newItems);
        }

        public visitSourceUnit(node: SourceUnitSyntax): any {
            return node.update(
                this.visitList(node.moduleElements),
                this.visitToken(node.endOfFileToken));
        }

        public visitExternalModuleReference(node: ExternalModuleReferenceSyntax): any {
            return node.update(
                this.visitToken(node.moduleKeyword),
                this.visitToken(node.openParenToken),
                this.visitToken(node.stringLiteral),
                this.visitToken(node.closeParenToken));
        }

        public visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): any {
            return node.update(
                <INameSyntax>this.visitNodeOrToken(node.moduleName));
        }

        public visitImportDeclaration(node: ImportDeclarationSyntax): any {
            return node.update(
                this.visitToken(node.importKeyword),
                this.visitToken(node.identifier),
                this.visitToken(node.equalsToken),
                <ModuleReferenceSyntax>this.visitNode(node.moduleReference),
                this.visitToken(node.semicolonToken));
        }

        public visitExportAssignment(node: ExportAssignmentSyntax): any {
            return node.update(
                this.visitToken(node.exportKeyword),
                this.visitToken(node.equalsToken),
                this.visitToken(node.identifier),
                this.visitToken(node.semicolonToken));
        }

        public visitClassDeclaration(node: ClassDeclarationSyntax): any {
            return node.update(
                node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
                node.declareKeyword === null ? null : this.visitToken(node.declareKeyword),
                this.visitToken(node.classKeyword),
                this.visitToken(node.identifier),
                node.typeParameterList === null ? null : <TypeParameterListSyntax>this.visitNode(node.typeParameterList),
                node.extendsClause === null ? null : <ExtendsClauseSyntax>this.visitNode(node.extendsClause),
                node.implementsClause === null ? null : <ImplementsClauseSyntax>this.visitNode(node.implementsClause),
                this.visitToken(node.openBraceToken),
                this.visitList(node.classElements),
                this.visitToken(node.closeBraceToken));
        }

        public visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): any {
            return node.update(
                node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
                this.visitToken(node.interfaceKeyword),
                this.visitToken(node.identifier),
                node.typeParameterList === null ? null : <TypeParameterListSyntax>this.visitNode(node.typeParameterList),
                node.extendsClause === null ? null : <ExtendsClauseSyntax>this.visitNode(node.extendsClause),
                <ObjectTypeSyntax>this.visitNode(node.body));
        }

        public visitExtendsClause(node: ExtendsClauseSyntax): any {
            return node.update(
                this.visitToken(node.extendsKeyword),
                this.visitSeparatedList(node.typeNames));
        }

        public visitImplementsClause(node: ImplementsClauseSyntax): any {
            return node.update(
                this.visitToken(node.implementsKeyword),
                this.visitSeparatedList(node.typeNames));
        }

        public visitModuleDeclaration(node: ModuleDeclarationSyntax): any {
            return node.update(
                node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
                node.declareKeyword === null ? null : this.visitToken(node.declareKeyword),
                this.visitToken(node.moduleKeyword),
                node.moduleName === null ? null : <INameSyntax>this.visitNodeOrToken(node.moduleName),
                node.stringLiteral === null ? null : this.visitToken(node.stringLiteral),
                this.visitToken(node.openBraceToken),
                this.visitList(node.moduleElements),
                this.visitToken(node.closeBraceToken));
        }

        public visitFunctionDeclaration(node: FunctionDeclarationSyntax): any {
            return node.update(
                node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
                node.declareKeyword === null ? null : this.visitToken(node.declareKeyword),
                this.visitToken(node.functionKeyword),
                this.visitToken(node.identifier),
                <CallSignatureSyntax>this.visitNode(node.callSignature),
                node.block === null ? null : <BlockSyntax>this.visitNode(node.block),
                node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        }

        public visitVariableStatement(node: VariableStatementSyntax): any {
            return node.update(
                node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
                node.declareKeyword === null ? null : this.visitToken(node.declareKeyword),
                <VariableDeclarationSyntax>this.visitNode(node.variableDeclaration),
                this.visitToken(node.semicolonToken));
        }

        public visitVariableDeclaration(node: VariableDeclarationSyntax): any {
            return node.update(
                this.visitToken(node.varKeyword),
                this.visitSeparatedList(node.variableDeclarators));
        }

        public visitVariableDeclarator(node: VariableDeclaratorSyntax): any {
            return node.update(
                this.visitToken(node.identifier),
                node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation),
                node.equalsValueClause === null ? null : <EqualsValueClauseSyntax>this.visitNode(node.equalsValueClause));
        }

        public visitEqualsValueClause(node: EqualsValueClauseSyntax): any {
            return node.update(
                this.visitToken(node.equalsToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.value));
        }

        public visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): any {
            return node.update(
                node.kind(),
                this.visitToken(node.operatorToken),
                <IUnaryExpressionSyntax>this.visitNodeOrToken(node.operand));
        }

        public visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): any {
            return node.update(
                this.visitToken(node.openBracketToken),
                this.visitSeparatedList(node.expressions),
                this.visitToken(node.closeBracketToken));
        }

        public visitOmittedExpression(node: OmittedExpressionSyntax): any {
            return node;
        }

        public visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): any {
            return node.update(
                this.visitToken(node.openParenToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.expression),
                this.visitToken(node.closeParenToken));
        }

        public visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): any {
            return node.update(
                this.visitToken(node.identifier),
                this.visitToken(node.equalsGreaterThanToken),
                <ISyntaxNodeOrToken>this.visitNodeOrToken(node.body));
        }

        public visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): any {
            return node.update(
                <CallSignatureSyntax>this.visitNode(node.callSignature),
                this.visitToken(node.equalsGreaterThanToken),
                <ISyntaxNodeOrToken>this.visitNodeOrToken(node.body));
        }

        public visitQualifiedName(node: QualifiedNameSyntax): any {
            return node.update(
                <INameSyntax>this.visitNodeOrToken(node.left),
                this.visitToken(node.dotToken),
                this.visitToken(node.right));
        }

        public visitTypeArgumentList(node: TypeArgumentListSyntax): any {
            return node.update(
                this.visitToken(node.lessThanToken),
                this.visitSeparatedList(node.typeArguments),
                this.visitToken(node.greaterThanToken));
        }

        public visitConstructorType(node: ConstructorTypeSyntax): any {
            return node.update(
                this.visitToken(node.newKeyword),
                node.typeParameterList === null ? null : <TypeParameterListSyntax>this.visitNode(node.typeParameterList),
                <ParameterListSyntax>this.visitNode(node.parameterList),
                this.visitToken(node.equalsGreaterThanToken),
                <ITypeSyntax>this.visitNodeOrToken(node.type));
        }

        public visitFunctionType(node: FunctionTypeSyntax): any {
            return node.update(
                node.typeParameterList === null ? null : <TypeParameterListSyntax>this.visitNode(node.typeParameterList),
                <ParameterListSyntax>this.visitNode(node.parameterList),
                this.visitToken(node.equalsGreaterThanToken),
                <ITypeSyntax>this.visitNodeOrToken(node.type));
        }

        public visitObjectType(node: ObjectTypeSyntax): any {
            return node.update(
                this.visitToken(node.openBraceToken),
                this.visitSeparatedList(node.typeMembers),
                this.visitToken(node.closeBraceToken));
        }

        public visitArrayType(node: ArrayTypeSyntax): any {
            return node.update(
                <ITypeSyntax>this.visitNodeOrToken(node.type),
                this.visitToken(node.openBracketToken),
                this.visitToken(node.closeBracketToken));
        }

        public visitGenericType(node: GenericTypeSyntax): any {
            return node.update(
                <INameSyntax>this.visitNodeOrToken(node.name),
                <TypeArgumentListSyntax>this.visitNode(node.typeArgumentList));
        }

        public visitTypeAnnotation(node: TypeAnnotationSyntax): any {
            return node.update(
                this.visitToken(node.colonToken),
                <ITypeSyntax>this.visitNodeOrToken(node.type));
        }

        public visitBlock(node: BlockSyntax): any {
            return node.update(
                this.visitToken(node.openBraceToken),
                this.visitList(node.statements),
                this.visitToken(node.closeBraceToken));
        }

        public visitParameter(node: ParameterSyntax): any {
            return node.update(
                node.dotDotDotToken === null ? null : this.visitToken(node.dotDotDotToken),
                node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword),
                this.visitToken(node.identifier),
                node.questionToken === null ? null : this.visitToken(node.questionToken),
                node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation),
                node.equalsValueClause === null ? null : <EqualsValueClauseSyntax>this.visitNode(node.equalsValueClause));
        }

        public visitMemberAccessExpression(node: MemberAccessExpressionSyntax): any {
            return node.update(
                <IExpressionSyntax>this.visitNodeOrToken(node.expression),
                this.visitToken(node.dotToken),
                this.visitToken(node.name));
        }

        public visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): any {
            return node.update(
                node.kind(),
                <IExpressionSyntax>this.visitNodeOrToken(node.operand),
                this.visitToken(node.operatorToken));
        }

        public visitElementAccessExpression(node: ElementAccessExpressionSyntax): any {
            return node.update(
                <IExpressionSyntax>this.visitNodeOrToken(node.expression),
                this.visitToken(node.openBracketToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.argumentExpression),
                this.visitToken(node.closeBracketToken));
        }

        public visitInvocationExpression(node: InvocationExpressionSyntax): any {
            return node.update(
                <IExpressionSyntax>this.visitNodeOrToken(node.expression),
                <ArgumentListSyntax>this.visitNode(node.argumentList));
        }

        public visitArgumentList(node: ArgumentListSyntax): any {
            return node.update(
                node.typeArgumentList === null ? null : <TypeArgumentListSyntax>this.visitNode(node.typeArgumentList),
                this.visitToken(node.openParenToken),
                this.visitSeparatedList(node.arguments),
                this.visitToken(node.closeParenToken));
        }

        public visitBinaryExpression(node: BinaryExpressionSyntax): any {
            return node.update(
                node.kind(),
                <IExpressionSyntax>this.visitNodeOrToken(node.left),
                this.visitToken(node.operatorToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.right));
        }

        public visitConditionalExpression(node: ConditionalExpressionSyntax): any {
            return node.update(
                <IExpressionSyntax>this.visitNodeOrToken(node.condition),
                this.visitToken(node.questionToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.whenTrue),
                this.visitToken(node.colonToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.whenFalse));
        }

        public visitConstructSignature(node: ConstructSignatureSyntax): any {
            return node.update(
                this.visitToken(node.newKeyword),
                <CallSignatureSyntax>this.visitNode(node.callSignature));
        }

        public visitMethodSignature(node: MethodSignatureSyntax): any {
            return node.update(
                this.visitToken(node.propertyName),
                node.questionToken === null ? null : this.visitToken(node.questionToken),
                <CallSignatureSyntax>this.visitNode(node.callSignature));
        }

        public visitIndexSignature(node: IndexSignatureSyntax): any {
            return node.update(
                this.visitToken(node.openBracketToken),
                this.visitToken(node.identifier),
                <TypeAnnotationSyntax>this.visitNode(node.parameterTypeAnnotation),
                this.visitToken(node.closeBracketToken),
                node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation));
        }

        public visitPropertySignature(node: PropertySignatureSyntax): any {
            return node.update(
                this.visitToken(node.propertyName),
                node.questionToken === null ? null : this.visitToken(node.questionToken),
                node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation));
        }

        public visitCallSignature(node: CallSignatureSyntax): any {
            return node.update(
                node.typeParameterList === null ? null : <TypeParameterListSyntax>this.visitNode(node.typeParameterList),
                <ParameterListSyntax>this.visitNode(node.parameterList),
                node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation));
        }

        public visitParameterList(node: ParameterListSyntax): any {
            return node.update(
                this.visitToken(node.openParenToken),
                this.visitSeparatedList(node.parameters),
                this.visitToken(node.closeParenToken));
        }

        public visitTypeParameterList(node: TypeParameterListSyntax): any {
            return node.update(
                this.visitToken(node.lessThanToken),
                this.visitSeparatedList(node.typeParameters),
                this.visitToken(node.greaterThanToken));
        }

        public visitTypeParameter(node: TypeParameterSyntax): any {
            return node.update(
                this.visitToken(node.identifier),
                node.constraint === null ? null : <ConstraintSyntax>this.visitNode(node.constraint));
        }

        public visitConstraint(node: ConstraintSyntax): any {
            return node.update(
                this.visitToken(node.extendsKeyword),
                <ITypeSyntax>this.visitNodeOrToken(node.type));
        }

        public visitElseClause(node: ElseClauseSyntax): any {
            return node.update(
                this.visitToken(node.elseKeyword),
                <IStatementSyntax>this.visitNodeOrToken(node.statement));
        }

        public visitIfStatement(node: IfStatementSyntax): any {
            return node.update(
                this.visitToken(node.ifKeyword),
                this.visitToken(node.openParenToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.condition),
                this.visitToken(node.closeParenToken),
                <IStatementSyntax>this.visitNodeOrToken(node.statement),
                node.elseClause === null ? null : <ElseClauseSyntax>this.visitNode(node.elseClause));
        }

        public visitExpressionStatement(node: ExpressionStatementSyntax): any {
            return node.update(
                <IExpressionSyntax>this.visitNodeOrToken(node.expression),
                this.visitToken(node.semicolonToken));
        }

        public visitConstructorDeclaration(node: ConstructorDeclarationSyntax): any {
            return node.update(
                this.visitToken(node.constructorKeyword),
                <ParameterListSyntax>this.visitNode(node.parameterList),
                node.block === null ? null : <BlockSyntax>this.visitNode(node.block),
                node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        }

        public visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): any {
            return node.update(
                node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword),
                node.staticKeyword === null ? null : this.visitToken(node.staticKeyword),
                this.visitToken(node.propertyName),
                <CallSignatureSyntax>this.visitNode(node.callSignature),
                node.block === null ? null : <BlockSyntax>this.visitNode(node.block),
                node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        }

        public visitGetMemberAccessorDeclaration(node: GetMemberAccessorDeclarationSyntax): any {
            return node.update(
                node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword),
                node.staticKeyword === null ? null : this.visitToken(node.staticKeyword),
                this.visitToken(node.getKeyword),
                this.visitToken(node.identifier),
                <ParameterListSyntax>this.visitNode(node.parameterList),
                node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation),
                <BlockSyntax>this.visitNode(node.block));
        }

        public visitSetMemberAccessorDeclaration(node: SetMemberAccessorDeclarationSyntax): any {
            return node.update(
                node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword),
                node.staticKeyword === null ? null : this.visitToken(node.staticKeyword),
                this.visitToken(node.setKeyword),
                this.visitToken(node.identifier),
                <ParameterListSyntax>this.visitNode(node.parameterList),
                <BlockSyntax>this.visitNode(node.block));
        }

        public visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): any {
            return node.update(
                node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword),
                node.staticKeyword === null ? null : this.visitToken(node.staticKeyword),
                <VariableDeclaratorSyntax>this.visitNode(node.variableDeclarator),
                this.visitToken(node.semicolonToken));
        }

        public visitThrowStatement(node: ThrowStatementSyntax): any {
            return node.update(
                this.visitToken(node.throwKeyword),
                <IExpressionSyntax>this.visitNodeOrToken(node.expression),
                this.visitToken(node.semicolonToken));
        }

        public visitReturnStatement(node: ReturnStatementSyntax): any {
            return node.update(
                this.visitToken(node.returnKeyword),
                node.expression === null ? null : <IExpressionSyntax>this.visitNodeOrToken(node.expression),
                this.visitToken(node.semicolonToken));
        }

        public visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): any {
            return node.update(
                this.visitToken(node.newKeyword),
                <IExpressionSyntax>this.visitNodeOrToken(node.expression),
                node.argumentList === null ? null : <ArgumentListSyntax>this.visitNode(node.argumentList));
        }

        public visitSwitchStatement(node: SwitchStatementSyntax): any {
            return node.update(
                this.visitToken(node.switchKeyword),
                this.visitToken(node.openParenToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.expression),
                this.visitToken(node.closeParenToken),
                this.visitToken(node.openBraceToken),
                this.visitList(node.switchClauses),
                this.visitToken(node.closeBraceToken));
        }

        public visitCaseSwitchClause(node: CaseSwitchClauseSyntax): any {
            return node.update(
                this.visitToken(node.caseKeyword),
                <IExpressionSyntax>this.visitNodeOrToken(node.expression),
                this.visitToken(node.colonToken),
                this.visitList(node.statements));
        }

        public visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): any {
            return node.update(
                this.visitToken(node.defaultKeyword),
                this.visitToken(node.colonToken),
                this.visitList(node.statements));
        }

        public visitBreakStatement(node: BreakStatementSyntax): any {
            return node.update(
                this.visitToken(node.breakKeyword),
                node.identifier === null ? null : this.visitToken(node.identifier),
                this.visitToken(node.semicolonToken));
        }

        public visitContinueStatement(node: ContinueStatementSyntax): any {
            return node.update(
                this.visitToken(node.continueKeyword),
                node.identifier === null ? null : this.visitToken(node.identifier),
                this.visitToken(node.semicolonToken));
        }

        public visitForStatement(node: ForStatementSyntax): any {
            return node.update(
                this.visitToken(node.forKeyword),
                this.visitToken(node.openParenToken),
                node.variableDeclaration === null ? null : <VariableDeclarationSyntax>this.visitNode(node.variableDeclaration),
                node.initializer === null ? null : <IExpressionSyntax>this.visitNodeOrToken(node.initializer),
                this.visitToken(node.firstSemicolonToken),
                node.condition === null ? null : <IExpressionSyntax>this.visitNodeOrToken(node.condition),
                this.visitToken(node.secondSemicolonToken),
                node.incrementor === null ? null : <IExpressionSyntax>this.visitNodeOrToken(node.incrementor),
                this.visitToken(node.closeParenToken),
                <IStatementSyntax>this.visitNodeOrToken(node.statement));
        }

        public visitForInStatement(node: ForInStatementSyntax): any {
            return node.update(
                this.visitToken(node.forKeyword),
                this.visitToken(node.openParenToken),
                node.variableDeclaration === null ? null : <VariableDeclarationSyntax>this.visitNode(node.variableDeclaration),
                node.left === null ? null : <IExpressionSyntax>this.visitNodeOrToken(node.left),
                this.visitToken(node.inKeyword),
                <IExpressionSyntax>this.visitNodeOrToken(node.expression),
                this.visitToken(node.closeParenToken),
                <IStatementSyntax>this.visitNodeOrToken(node.statement));
        }

        public visitWhileStatement(node: WhileStatementSyntax): any {
            return node.update(
                this.visitToken(node.whileKeyword),
                this.visitToken(node.openParenToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.condition),
                this.visitToken(node.closeParenToken),
                <IStatementSyntax>this.visitNodeOrToken(node.statement));
        }

        public visitWithStatement(node: WithStatementSyntax): any {
            return node.update(
                this.visitToken(node.withKeyword),
                this.visitToken(node.openParenToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.condition),
                this.visitToken(node.closeParenToken),
                <IStatementSyntax>this.visitNodeOrToken(node.statement));
        }

        public visitEnumDeclaration(node: EnumDeclarationSyntax): any {
            return node.update(
                node.exportKeyword === null ? null : this.visitToken(node.exportKeyword),
                this.visitToken(node.enumKeyword),
                this.visitToken(node.identifier),
                this.visitToken(node.openBraceToken),
                this.visitSeparatedList(node.enumElements),
                this.visitToken(node.closeBraceToken));
        }

        public visitEnumElement(node: EnumElementSyntax): any {
            return node.update(
                node.identifier === null ? null : this.visitToken(node.identifier),
                node.stringLiteral === null ? null : this.visitToken(node.stringLiteral),
                node.equalsValueClause === null ? null : <EqualsValueClauseSyntax>this.visitNode(node.equalsValueClause));
        }

        public visitCastExpression(node: CastExpressionSyntax): any {
            return node.update(
                this.visitToken(node.lessThanToken),
                <ITypeSyntax>this.visitNodeOrToken(node.type),
                this.visitToken(node.greaterThanToken),
                <IUnaryExpressionSyntax>this.visitNodeOrToken(node.expression));
        }

        public visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): any {
            return node.update(
                this.visitToken(node.openBraceToken),
                this.visitSeparatedList(node.propertyAssignments),
                this.visitToken(node.closeBraceToken));
        }

        public visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): any {
            return node.update(
                this.visitToken(node.propertyName),
                this.visitToken(node.colonToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.expression));
        }

        public visitGetAccessorPropertyAssignment(node: GetAccessorPropertyAssignmentSyntax): any {
            return node.update(
                this.visitToken(node.getKeyword),
                this.visitToken(node.propertyName),
                this.visitToken(node.openParenToken),
                this.visitToken(node.closeParenToken),
                node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation),
                <BlockSyntax>this.visitNode(node.block));
        }

        public visitSetAccessorPropertyAssignment(node: SetAccessorPropertyAssignmentSyntax): any {
            return node.update(
                this.visitToken(node.setKeyword),
                this.visitToken(node.propertyName),
                this.visitToken(node.openParenToken),
                <ParameterSyntax>this.visitNode(node.parameter),
                this.visitToken(node.closeParenToken),
                <BlockSyntax>this.visitNode(node.block));
        }

        public visitFunctionExpression(node: FunctionExpressionSyntax): any {
            return node.update(
                this.visitToken(node.functionKeyword),
                node.identifier === null ? null : this.visitToken(node.identifier),
                <CallSignatureSyntax>this.visitNode(node.callSignature),
                <BlockSyntax>this.visitNode(node.block));
        }

        public visitEmptyStatement(node: EmptyStatementSyntax): any {
            return node.update(
                this.visitToken(node.semicolonToken));
        }

        public visitTryStatement(node: TryStatementSyntax): any {
            return node.update(
                this.visitToken(node.tryKeyword),
                <BlockSyntax>this.visitNode(node.block),
                node.catchClause === null ? null : <CatchClauseSyntax>this.visitNode(node.catchClause),
                node.finallyClause === null ? null : <FinallyClauseSyntax>this.visitNode(node.finallyClause));
        }

        public visitCatchClause(node: CatchClauseSyntax): any {
            return node.update(
                this.visitToken(node.catchKeyword),
                this.visitToken(node.openParenToken),
                this.visitToken(node.identifier),
                node.typeAnnotation === null ? null : <TypeAnnotationSyntax>this.visitNode(node.typeAnnotation),
                this.visitToken(node.closeParenToken),
                <BlockSyntax>this.visitNode(node.block));
        }

        public visitFinallyClause(node: FinallyClauseSyntax): any {
            return node.update(
                this.visitToken(node.finallyKeyword),
                <BlockSyntax>this.visitNode(node.block));
        }

        public visitLabeledStatement(node: LabeledStatementSyntax): any {
            return node.update(
                this.visitToken(node.identifier),
                this.visitToken(node.colonToken),
                <IStatementSyntax>this.visitNodeOrToken(node.statement));
        }

        public visitDoStatement(node: DoStatementSyntax): any {
            return node.update(
                this.visitToken(node.doKeyword),
                <IStatementSyntax>this.visitNodeOrToken(node.statement),
                this.visitToken(node.whileKeyword),
                this.visitToken(node.openParenToken),
                <IExpressionSyntax>this.visitNodeOrToken(node.condition),
                this.visitToken(node.closeParenToken),
                this.visitToken(node.semicolonToken));
        }

        public visitTypeOfExpression(node: TypeOfExpressionSyntax): any {
            return node.update(
                this.visitToken(node.typeOfKeyword),
                <IExpressionSyntax>this.visitNodeOrToken(node.expression));
        }

        public visitDeleteExpression(node: DeleteExpressionSyntax): any {
            return node.update(
                this.visitToken(node.deleteKeyword),
                <IExpressionSyntax>this.visitNodeOrToken(node.expression));
        }

        public visitVoidExpression(node: VoidExpressionSyntax): any {
            return node.update(
                this.visitToken(node.voidKeyword),
                <IExpressionSyntax>this.visitNodeOrToken(node.expression));
        }

        public visitDebuggerStatement(node: DebuggerStatementSyntax): any {
            return node.update(
                this.visitToken(node.debuggerKeyword),
                this.visitToken(node.semicolonToken));
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class Errors {
        public static argument(argument: string, message?: string): Error {
            return new Error("Invalid argument: " + argument + "."  + (message ? (" " + message) : ""));
        }

        public static argumentOutOfRange(argument: string): Error {
            return new Error("Argument out of range: " + argument + ".");
        }

        public static argumentNull(argument: string): Error {
            return new Error("Argument null: " + argument + ".");
        }

        public static abstract(): Error {
            return new Error("Operation not implemented properly by subclass.");
        }

        public static notYetImplemented(): Error {
            return new Error("Not yet implemented.");
        }

        public static invalidOperation(message?: string): Error {
            return new Error(message ? ("Invalid operation: " + message) :"Invalid operation.");
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class SyntaxTokenReplacer extends SyntaxRewriter {
        constructor(private token1: ISyntaxToken,
                    private token2: ISyntaxToken) {
            super();
        }

        private visitToken(token: ISyntaxToken): ISyntaxToken {
            if (token === this.token1) {
                // Found the token to replace.  Return the new token and null out our state.  This will 
                // let the later visit methods bail out earlier.
                var result = this.token2;
                this.token1 = null;
                this.token2 = null;

                return result;
            }

            return token;
        }

        private visitNode(node: SyntaxNode): SyntaxNode {
            if (this.token1 === null) {
                return node;
            }

            return super.visitNode(node);
        }

        private visitList(list: ISyntaxList): ISyntaxList {
            if (this.token1 === null) {
                return list;
            }

            return super.visitList(list);
        }

        private visitSeparatedList(list: ISeparatedSyntaxList): ISeparatedSyntaxList {
            if (this.token1 === null) {
                return list;
            }

            return super.visitSeparatedList(list);
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class SyntaxNode implements ISyntaxNodeOrToken {
        private _data: number;

        constructor(parsedInStrictMode: bool) {
            this._data = parsedInStrictMode ? SyntaxConstants.NodeParsedInStrictModeMask : 0;
        }

        public isNode(): bool { return true; }
        public isToken(): bool { return false; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind {
            throw Errors.abstract();
        }

        public childCount(): number {
            throw Errors.abstract();
        }

        public childAt(slot: number): ISyntaxElement {
            throw Errors.abstract();
        }

        // Returns the first non-missing token inside this node (or null if there are no such token).
        public firstToken(): ISyntaxToken {
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element != null) {
                    if (element.fullWidth() > 0 || element.kind() === SyntaxKind.EndOfFileToken) {
                        return element.firstToken();
                    }
                }
            }

            return null;
        }

        // Returns the last non-missing token inside this node (or null if there are no such token).
        public lastToken(): ISyntaxToken {
            for (var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);

                if (element != null) {
                    if (element.fullWidth() > 0 || element.kind() === SyntaxKind.EndOfFileToken) {
                        return element.lastToken();
                    }
                }
            }

            return null;
        }

        public insertChildrenInto(array: ISyntaxElement[], index: number) {
            for (var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);

                if (element !== null) {
                    if (element.isNode() || element.isToken()) {
                        array.splice(index, 0, element);
                    }
                    else if (element.isList()) {
                        (<ISyntaxList>element).insertChildrenInto(array, index);
                    }
                    else if (element.isSeparatedList()) {
                        (<ISeparatedSyntaxList>element).insertChildrenInto(array, index);
                    }
                    else {
                        throw Errors.invalidOperation();
                    }
                }
            }
        }

        public leadingTrivia(): ISyntaxTriviaList {
            return this.firstToken().leadingTrivia();
        }

        public trailingTrivia(): ISyntaxTriviaList {
            return this.lastToken().trailingTrivia();
        }

        public toJSON(key) {
            var result: any = {
                kind: (<any>SyntaxKind)._map[this.kind()],
                fullWidth: this.fullWidth()
            };

            if (this.hasSkippedText()) {
                result.hasSkippedText = true;
            }

            if (this.hasZeroWidthToken()) {
                result.hasZeroWidthToken = true;
            }

            if (this.hasRegularExpressionToken()) {
                result.hasRegularExpressionToken = true;
            }

            if (this.parsedInStrictMode()) {
                result.parsedInStrictMode = true;
            }

            for (var i = 0, n = this.childCount(); i < n; i++) {
                var value = this.childAt(i);

                if (value) {
                    for (var name in this) {
                        if (value === this[name]) {
                            result[name] = value;
                            break;
                        }
                    }
                }
            }

            return result;
        }

        public accept(visitor: ISyntaxVisitor): any {
            throw Errors.abstract();
        }

        public fullText(): string {
            var elements: string[] = [];
            this.collectTextElements(elements);
            return elements.join("");
        }

        public collectTextElements(elements: string[]): void {
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    element.collectTextElements(elements)
                }
            }
        }

        public replaceToken(token1: ISyntaxToken, token2: ISyntaxToken): SyntaxNode {
            if (token1 === token2) {
                return this;
            }

            return this.accept(new SyntaxTokenReplacer(token1, token2));
        }

        public withLeadingTrivia(trivia: ISyntaxTriviaList): SyntaxNode {
            return this.replaceToken(this.firstToken(), this.firstToken().withLeadingTrivia(trivia));
        }

        public withTrailingTrivia(trivia: ISyntaxTriviaList): SyntaxNode {
            return this.replaceToken(this.lastToken(), this.lastToken().withTrailingTrivia(trivia));
        }

        public hasLeadingTrivia(): bool {
            return this.lastToken().hasLeadingTrivia();
        }

        public hasTrailingTrivia(): bool {
            return this.lastToken().hasTrailingTrivia();
        }

        public isTypeScriptSpecific(): bool {
            return false;
        }

        public hasSkippedText(): bool {
            return (this.data() & SyntaxConstants.NodeSkippedTextMask) !== 0;
        }

        public hasZeroWidthToken(): bool {
            return (this.data() & SyntaxConstants.NodeZeroWidthTokenMask) !== 0;
        }

        // True if this node contains a regex token somewhere under it.  A regex token is either a 
        // regex itself (i.e. /foo/), or is a token which could start a regex (i.e. "/" or "/=").  This
        // data is used by the incremental parser to decide if a node can be reused.  Due to the 
        // lookahead nature of regex tokens, a node containing a regex token cannot be reused.  Normally,
        // changes to text only affect the tokens directly intersected.  However, because regex tokens 
        // have such unbounded lookahead (technically bounded at the end of a line, but htat's minor), 
        // we need to recheck them to see if they've changed due to the edit.  For example, if you had:
        //
        //      while (true) /3; return;
        //
        // And you changed it to:
        //
        //      while (true) /3; return/;
        //
        // Then even though only the 'return' and ';' colons were touched, we'd want to rescan the '/'
        // token which we would then realize was a regex.
        public hasRegularExpressionToken(): bool {
            return (this.data() & SyntaxConstants.NodeRegularExpressionTokenMask) !== 0;
        }

        // True if this node was parsed while the parser was in 'strict' mode.  A node parsed in strict
        // mode cannot be reused if the parser is non-strict mode (and vice versa).  This is because 
        // the parser parses things differently in strict mode and thus the tokens may be interpretted
        // differently if the mode is changed. 
        public parsedInStrictMode(): bool {
            return (this.data() & SyntaxConstants.NodeParsedInStrictModeMask) !== 0;
        }

        public fullWidth(): number {
            return this.data() >>> SyntaxConstants.NodeFullWidthShift;
        }

        private computeData(): number {
            var slotCount = this.childCount();

            var fullWidth = 0;
            var childWidth = 0;
            var hasSkippedText = false;

            // If we have no children (like an OmmittedExpressionSyntax), we automatically have a zero 
            // width token.
            var hasZeroWidthToken = slotCount === 0;
            var hasRegularExpressionToken = false;

            for (var i = 0, n = slotCount; i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    childWidth = element.fullWidth();
                    fullWidth += childWidth;

                    if (!hasSkippedText) {
                        hasSkippedText = element.hasSkippedText();
                    }

                    if (!hasZeroWidthToken) {
                        hasZeroWidthToken = element.hasZeroWidthToken();
                    }

                    if (!hasRegularExpressionToken) {
                        hasRegularExpressionToken = element.hasRegularExpressionToken();
                    }
                }
            }

            return (fullWidth << SyntaxConstants.NodeFullWidthShift)
                 | (hasSkippedText ? SyntaxConstants.NodeSkippedTextMask : 0)
                 | (hasZeroWidthToken ? SyntaxConstants.NodeZeroWidthTokenMask : 0)
                 | (hasRegularExpressionToken ? SyntaxConstants.NodeRegularExpressionTokenMask : 0);
        }

        private data(): number {
            if (this._data === 0 || this._data === SyntaxConstants.NodeParsedInStrictModeMask) {
                this._data |= this.computeData();
            }

            return this._data;
        }

        /// <summary>
        /// Finds a token according to the following rules:
        /// 1) If position matches the End of the node/s FullSpan and the node is SourceUnit,
        ///    then the EOF token is returned. 
        /// 
        ///  2) If node.FullSpan.Contains(position) then the token that contains given position is
        ///     returned.
        /// 
        ///  3) Otherwise an ArgumentOutOfRangeException is thrown
        ///
        /// Note: findToken will always return a non missing token with width greater than or equal to
        /// 1 (except for EOF).  Empty tokens syntehsized by teh parser are never returned.
        /// </summary>
        public findToken(position: number): PositionedToken {
            var endOfFileToken = this.tryGetEndOfFileAt(position);
            if (endOfFileToken !== null) {
                return endOfFileToken;
            }

            if (position < 0 || position >= this.fullWidth()) {
                throw Errors.argumentOutOfRange("position");
            }

            return this.findTokenInternal(null, position, 0);
        }

        private tryGetEndOfFileAt(position: number): PositionedToken {
            if (this.kind() === SyntaxKind.SourceUnit && position === this.fullWidth()) {
                var sourceUnit = <SourceUnitSyntax>this;
                return new PositionedToken(
                    new PositionedNode(null, sourceUnit, 0),
                    sourceUnit.endOfFileToken, sourceUnit.moduleElements.fullWidth());
            }

            return null;
        }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            // Debug.assert(position >= 0 && position < this.fullWidth());

            parent = new PositionedNode(parent, this, fullStart);
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    var childWidth = element.fullWidth();

                    if (position < childWidth) {
                        return (<any>element).findTokenInternal(parent, position, fullStart);
                    }

                    position -= childWidth;
                    fullStart += childWidth;
                }
            }

            throw Errors.invalidOperation();
        }

        public findTokenOnLeft(position: number): PositionedToken {
            var positionedToken = this.findToken(position);
            var start = positionedToken.start();

            // Position better fall within this token.
            // Debug.assert(position >= positionedToken.fullStart());
            // Debug.assert(position < positionedToken.fullEnd() || positionedToken.token().tokenKind === SyntaxKind.EndOfFileToken);

            // if position is after the start of the token, then this token is the token on the left.
            if (position > start) {
                return positionedToken;
            }

            // we're in the trivia before the start of the token.  Need to return the previous token.
            if (positionedToken.fullStart() === 0) {
                // Already on the first token.  Nothing before us.
                return null;
            }

            var previousToken = this.findToken(positionedToken.fullStart() - 1);

            // Position better be after this token.
            // Debug.assert(previousToken.fullEnd() <= position);

            return previousToken;
        }

        public isModuleElement(): bool {
            return false;
        }

        public isClassElement(): bool {
            return false;
        }

        public isTypeMember(): bool {
            return false
        }

        public isStatement(): bool {
            return false;
        }

        public isSwitchClause(): bool {
            return false;
        }

        public structuralEquals(node: SyntaxNode): bool {
            if (this === node) { return true; }
            if (node === null) { return false; }
            if (this.kind() !== node.kind()) { return false; }

            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element1 = this.childAt(i);
                var element2 = node.childAt(i);

                if (!Syntax.elementStructuralEquals(element1, element2)) {
                    return false;
                }
            }

            return true;
        }

        public width(): number {
            return this.fullWidth() - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        }

        public leadingTriviaWidth() {
            var firstToken = this.firstToken();
            return firstToken === null ? 0 : firstToken.leadingTriviaWidth();
        }

        public trailingTriviaWidth() {
            var lastToken = this.lastToken();
            return lastToken === null ? 0 : lastToken.trailingTriviaWidth();
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export interface ISyntaxList extends ISyntaxElement {
        childAt(index: number): ISyntaxNodeOrToken;
        toArray(): ISyntaxNodeOrToken[];

        insertChildrenInto(array: ISyntaxElement[], index: number): void;
    }
}
///<reference path='References.ts' />

module TypeScript {
    export interface ISeparatedSyntaxList extends ISyntaxElement {
        childAt(index: number): ISyntaxNodeOrToken;

        toArray(): ISyntaxNodeOrToken[];
        toNonSeparatorArray(): ISyntaxNodeOrToken[];

        separatorCount();
        separatorAt(index: number): ISyntaxToken;

        nonSeparatorCount();
        nonSeparatorAt(index: number): ISyntaxNodeOrToken;

        insertChildrenInto(array: ISyntaxElement[], index: number): void;
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class IntegerUtilities {
        public static integerDivide(numerator: number, denominator: number): number {
            return (numerator / denominator) >> 0;
        }

        public static integerMultiplyLow32Bits(n1: number, n2: number): number {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;

            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;

            var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
            return resultLow32;
        }

        public static integerMultiplyHigh32Bits(n1: number, n2: number): number {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;

            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;

            var resultHigh32 = n1High16 * n2High16 + ((((n1Low16 * n2Low16) >>> 17) + n1Low16 * n2High16) >>> 15);
            return resultHigh32;
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class PositionedElement {
        private _parent: PositionedElement;
        private _element: ISyntaxElement;
        private _fullStart: number;

        constructor(parent: PositionedElement, element: ISyntaxElement, fullStart: number) {
            this._parent = parent;
            this._element = element;
            this._fullStart = fullStart;
        }

        public static create(parent: PositionedElement, element: ISyntaxElement, fullStart: number): PositionedElement {
            if (element === null) {
                return null;
            }

            if (element.isNode()) {
                return new PositionedNode(parent, <SyntaxNode>element, fullStart);
            }
            else if (element.isToken()) {
                return new PositionedToken(parent, <ISyntaxToken>element, fullStart);
            }
            else if (element.isList()) {
                return new PositionedList(parent, <ISyntaxList>element, fullStart);
            }
            else if (element.isSeparatedList()) {
                return new PositionedSeparatedList(parent, <ISeparatedSyntaxList>element, fullStart);
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        public parent(): PositionedElement {
            return this._parent;
        }

        public parentElement(): ISyntaxElement {
            return this._parent && this._parent._element;
        }

        public element(): ISyntaxElement {
            return this._element;
        }

        public kind(): SyntaxKind {
            return this.element().kind();
        }

        public childCount(): number {
            return this.element().childCount();
        }

        public childAt(index: number): PositionedElement {
            var offset = 0;

            for (var i = 0; i < index; i++) {
                offset += this.element().childAt(i).fullWidth();
            }

            return PositionedElement.create(this, this.element().childAt(index), offset);
        }

        public getPositionedChild(child: ISyntaxElement) {
            var offset = Syntax.childOffset(this.element(), child);

            return PositionedElement.create(this, child, offset);
        }

        public fullStart(): number {
            return this._fullStart;
        }

        public fullEnd(): number {
            return this.fullStart() + this.element().fullWidth();
        }

        public fullWidth(): number {
            return this.element().fullWidth();
        }

        public start(): number {
            return this.fullStart() + this.element().leadingTriviaWidth();
        }

        public end(): number {
            return this.fullStart() + this.element().leadingTriviaWidth() + this.element().width();
        }

        public root(): PositionedNode {
            var current = this;
            while (current.parent() !== null) {
                current = current.parent();
            }

            return <PositionedNode>current;
        }

        public containingNode(): PositionedNode {
            var current = this.parent();

            while (current !== null && !current.element().isNode()) {
                current = current.parent();
            }

            return <PositionedNode>current;
        }
    }

    export class PositionedNodeOrToken extends PositionedElement {
        constructor(parent: PositionedElement, nodeOrToken: ISyntaxNodeOrToken, fullStart: number) {
            super(parent, nodeOrToken, fullStart);
        }

        public nodeOrToken(): ISyntaxNodeOrToken {
            return <ISyntaxNodeOrToken>this.element();
        }
    }

    export class PositionedNode extends PositionedNodeOrToken {
        constructor(parent: PositionedElement, node: SyntaxNode, fullStart: number) {
            super(parent, node, fullStart);
        }

        public node(): SyntaxNode {
            return <SyntaxNode>this.element();
        }
    }

    export class PositionedToken extends PositionedNodeOrToken {
        constructor(parent: PositionedElement, token: ISyntaxToken, fullStart: number) {
            super(parent, token, fullStart);
        }

        public token(): ISyntaxToken {
            return <ISyntaxToken>this.element();
        }

        public previousToken(): PositionedToken {
            var fullStart = this.fullStart();
            if (fullStart === 0) {
                return null;
            }

            return this.root().node().findToken(fullStart - 1);
        }

        public nextToken(): PositionedToken {
            if (this.token().tokenKind === SyntaxKind.EndOfFileToken) {
                return null;
            }

            return this.root().node().findToken(this.fullEnd());
        }
    }

    export class PositionedList extends PositionedElement {
        constructor(parent: PositionedElement, list: ISyntaxList, fullStart: number) {
            super(parent, list, fullStart);
        }

        public list(): ISyntaxList {
            return <ISyntaxList>this.element();
        }
    }

    export class PositionedSeparatedList extends PositionedElement {
        constructor(parent: PositionedElement, list: ISeparatedSyntaxList, fullStart: number) {
            super(parent, list, fullStart);
        }

        public list(): ISeparatedSyntaxList {
            return <ISeparatedSyntaxList>this.element();
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class Debug {
        public static assert(expression: bool, message?: string): void {
            if (!expression) {
                throw new Error("Debug Failure. False expression." + (message ? message : ""));
            }
        }
    }
}
///<reference path='SyntaxKind.ts' />

module TypeScript.SyntaxFacts {
    var textToKeywordKind: any = {
        "any": SyntaxKind.AnyKeyword,
        "bool": SyntaxKind.BoolKeyword,
        "boolean": SyntaxKind.BooleanKeyword,
        "break": SyntaxKind.BreakKeyword,
        "case": SyntaxKind.CaseKeyword,
        "catch": SyntaxKind.CatchKeyword,
        "class": SyntaxKind.ClassKeyword,
        "continue": SyntaxKind.ContinueKeyword,
        "const": SyntaxKind.ConstKeyword,
        "constructor": SyntaxKind.ConstructorKeyword,
        "debugger": SyntaxKind.DebuggerKeyword,
        "declare": SyntaxKind.DeclareKeyword,
        "default": SyntaxKind.DefaultKeyword,
        "delete": SyntaxKind.DeleteKeyword,
        "do": SyntaxKind.DoKeyword,
        "else": SyntaxKind.ElseKeyword,
        "enum": SyntaxKind.EnumKeyword,
        "export": SyntaxKind.ExportKeyword,
        "extends": SyntaxKind.ExtendsKeyword,
        "false": SyntaxKind.FalseKeyword,
        "finally": SyntaxKind.FinallyKeyword,
        "for": SyntaxKind.ForKeyword,
        "function": SyntaxKind.FunctionKeyword,
        "get": SyntaxKind.GetKeyword,
        "if": SyntaxKind.IfKeyword,
        "implements": SyntaxKind.ImplementsKeyword,
        "import": SyntaxKind.ImportKeyword,
        "in": SyntaxKind.InKeyword,
        "instanceof": SyntaxKind.InstanceOfKeyword,
        "interface": SyntaxKind.InterfaceKeyword,
        "let": SyntaxKind.LetKeyword,
        "module": SyntaxKind.ModuleKeyword,
        "new": SyntaxKind.NewKeyword,
        "null": SyntaxKind.NullKeyword,
        "number":SyntaxKind.NumberKeyword,
        "package": SyntaxKind.PackageKeyword,
        "private": SyntaxKind.PrivateKeyword,
        "protected": SyntaxKind.ProtectedKeyword,
        "public": SyntaxKind.PublicKeyword,
        "return": SyntaxKind.ReturnKeyword,
        "set": SyntaxKind.SetKeyword,
        "static": SyntaxKind.StaticKeyword,
        "string": SyntaxKind.StringKeyword,
        "super": SyntaxKind.SuperKeyword,
        "switch": SyntaxKind.SwitchKeyword,
        "this": SyntaxKind.ThisKeyword,
        "throw": SyntaxKind.ThrowKeyword,
        "true": SyntaxKind.TrueKeyword,
        "try": SyntaxKind.TryKeyword,
        "typeof": SyntaxKind.TypeOfKeyword,
        "var": SyntaxKind.VarKeyword,
        "void": SyntaxKind.VoidKeyword,
        "while": SyntaxKind.WhileKeyword,
        "with": SyntaxKind.WithKeyword,
        "yield": SyntaxKind.YieldKeyword,

        "{": SyntaxKind.OpenBraceToken,
        "}": SyntaxKind.CloseBraceToken,
        "(": SyntaxKind.OpenParenToken,
        ")": SyntaxKind.CloseParenToken,
        "[": SyntaxKind.OpenBracketToken,
        "]": SyntaxKind.CloseBracketToken,
        ".": SyntaxKind.DotToken,
        "...": SyntaxKind.DotDotDotToken,
        ";": SyntaxKind.SemicolonToken,
        ",": SyntaxKind.CommaToken,
        "<": SyntaxKind.LessThanToken,
        ">": SyntaxKind.GreaterThanToken,
        "<=": SyntaxKind.LessThanEqualsToken,
        ">=": SyntaxKind.GreaterThanEqualsToken,
        "==": SyntaxKind.EqualsEqualsToken,
        "=>": SyntaxKind.EqualsGreaterThanToken,
        "!=": SyntaxKind.ExclamationEqualsToken,
        "===": SyntaxKind.EqualsEqualsEqualsToken,
        "!==": SyntaxKind.ExclamationEqualsEqualsToken,
        "+": SyntaxKind.PlusToken,
        "-": SyntaxKind.MinusToken,
        "*": SyntaxKind.AsteriskToken,
        "%": SyntaxKind.PercentToken,
        "++": SyntaxKind.PlusPlusToken,
        "--": SyntaxKind.MinusMinusToken,
        "<<": SyntaxKind.LessThanLessThanToken,
        ">>": SyntaxKind.GreaterThanGreaterThanToken,
        ">>>": SyntaxKind.GreaterThanGreaterThanGreaterThanToken,
        "&": SyntaxKind.AmpersandToken,
        "|": SyntaxKind.BarToken,
        "^": SyntaxKind.CaretToken,
        "!": SyntaxKind.ExclamationToken,
        "~": SyntaxKind.TildeToken,
        "&&": SyntaxKind.AmpersandAmpersandToken,
        "||": SyntaxKind.BarBarToken,
        "?": SyntaxKind.QuestionToken,
        ":": SyntaxKind.ColonToken,
        "=": SyntaxKind.EqualsToken,
        "+=": SyntaxKind.PlusEqualsToken,
        "-=": SyntaxKind.MinusEqualsToken,
        "*=": SyntaxKind.AsteriskEqualsToken,
        "%=": SyntaxKind.PercentEqualsToken,
        "<<=": SyntaxKind.LessThanLessThanEqualsToken,
        ">>=": SyntaxKind.GreaterThanGreaterThanEqualsToken,
        ">>>=": SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken,
        "&=": SyntaxKind.AmpersandEqualsToken,
        "|=": SyntaxKind.BarEqualsToken,
        "^=": SyntaxKind.CaretEqualsToken,
        "/": SyntaxKind.SlashToken,
        "/=": SyntaxKind.SlashEqualsToken,
    };

    var kindToText: string[] = [];

    for (var name in textToKeywordKind) {
        if (textToKeywordKind.hasOwnProperty(name)) {
            // Debug.assert(kindToText[textToKeywordKind[name]] === undefined);
            kindToText[textToKeywordKind[name]] = name;
        }
    }

    // Manually work around a bug in the CScript 5.8 runtime where 'constructor' is not
    // listed when SyntaxFacts.textToKeywordKind is enumerated because it is the name of
    // the constructor function.
    kindToText[SyntaxKind.ConstructorKeyword] = "constructor";

    export function getTokenKind(text: string): SyntaxKind {
        if (textToKeywordKind.hasOwnProperty(text)) {
            return textToKeywordKind[text];
        }

        return SyntaxKind.None;
    }

    export function getText(kind: SyntaxKind): string {
        var result = kindToText[kind];
        return result !== undefined ? result : null;
    }

    export function isTokenKind(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstToken && kind <= SyntaxKind.LastToken;
    }

    export function isAnyKeyword(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstKeyword && kind <= SyntaxKind.LastKeyword;
    }

    export function isStandardKeyword(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstStandardKeyword && kind <= SyntaxKind.LastStandardKeyword;
    }

    export function isFutureReservedKeyword(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstFutureReservedKeyword && kind <= SyntaxKind.LastFutureReservedKeyword;
    }

    export function isFutureReservedStrictKeyword(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstFutureReservedStrictKeyword && kind <= SyntaxKind.LastFutureReservedStrictKeyword;
    }

    export function isAnyPunctuation(kind: SyntaxKind): bool {
        return kind >= SyntaxKind.FirstPunctuation && kind <= SyntaxKind.LastPunctuation;
    }

    export function isPrefixUnaryExpressionOperatorToken(tokenKind: SyntaxKind): bool {
        return getPrefixUnaryExpressionFromOperatorToken(tokenKind) !== SyntaxKind.None;
    }

    export function isBinaryExpressionOperatorToken(tokenKind: SyntaxKind): bool {
        return getBinaryExpressionFromOperatorToken(tokenKind) !== SyntaxKind.None;
    }

    export function getPrefixUnaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind {
        switch (tokenKind) {
            case SyntaxKind.PlusToken:
                return SyntaxKind.PlusExpression;
            case SyntaxKind.MinusToken:
                return SyntaxKind.NegateExpression;
            case SyntaxKind.TildeToken:
                return SyntaxKind.BitwiseNotExpression;
            case SyntaxKind.ExclamationToken:
                return SyntaxKind.LogicalNotExpression;
            case SyntaxKind.PlusPlusToken:
                return SyntaxKind.PreIncrementExpression;
            case SyntaxKind.MinusMinusToken:
                return SyntaxKind.PreDecrementExpression;
            //case SyntaxKind.DeleteKeyword:
            //    return SyntaxKind.DeleteExpression;
            //case SyntaxKind.TypeOfKeyword:
            //    return SyntaxKind.TypeOfExpression;
            //case SyntaxKind.VoidKeyword:
            //    return SyntaxKind.VoidExpression;
            default:
                return SyntaxKind.None;
        }
    }

    export function getPostfixUnaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind {
        switch (tokenKind) {
            case SyntaxKind.PlusPlusToken:
                return SyntaxKind.PostIncrementExpression;
            case SyntaxKind.MinusMinusToken:
                return SyntaxKind.PostDecrementExpression;
            default:
                return SyntaxKind.None;
        }
    }

    export function getBinaryExpressionFromOperatorToken(tokenKind: SyntaxKind): SyntaxKind {
        switch (tokenKind) {
            case SyntaxKind.AsteriskToken:
                return SyntaxKind.MultiplyExpression;

            case SyntaxKind.SlashToken:
                return SyntaxKind.DivideExpression;

            case SyntaxKind.PercentToken:
                return SyntaxKind.ModuloExpression;

            case SyntaxKind.PlusToken:
                return SyntaxKind.AddExpression;

            case SyntaxKind.MinusToken:
                return SyntaxKind.SubtractExpression;

            case SyntaxKind.LessThanLessThanToken:
                return SyntaxKind.LeftShiftExpression;

            case SyntaxKind.GreaterThanGreaterThanToken:
                return SyntaxKind.SignedRightShiftExpression;

            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
                return SyntaxKind.UnsignedRightShiftExpression;

            case SyntaxKind.LessThanToken:
                return SyntaxKind.LessThanExpression;

            case SyntaxKind.GreaterThanToken:
                return SyntaxKind.GreaterThanExpression;

            case SyntaxKind.LessThanEqualsToken:
                return SyntaxKind.LessThanOrEqualExpression;

            case SyntaxKind.GreaterThanEqualsToken:
                return SyntaxKind.GreaterThanOrEqualExpression;

            case SyntaxKind.InstanceOfKeyword:
                return SyntaxKind.InstanceOfExpression;

            case SyntaxKind.InKeyword:
                return SyntaxKind.InExpression;

            case SyntaxKind.EqualsEqualsToken:
                return SyntaxKind.EqualsWithTypeConversionExpression;

            case SyntaxKind.ExclamationEqualsToken:
                return SyntaxKind.NotEqualsWithTypeConversionExpression;

            case SyntaxKind.EqualsEqualsEqualsToken:
                return SyntaxKind.EqualsExpression;

            case SyntaxKind.ExclamationEqualsEqualsToken:
                return SyntaxKind.NotEqualsExpression;

            case SyntaxKind.AmpersandToken:
                return SyntaxKind.BitwiseAndExpression;

            case SyntaxKind.CaretToken:
                return SyntaxKind.BitwiseExclusiveOrExpression;

            case SyntaxKind.BarToken:
                return SyntaxKind.BitwiseOrExpression;

            case SyntaxKind.AmpersandAmpersandToken:
                return SyntaxKind.LogicalAndExpression;

            case SyntaxKind.BarBarToken:
                return SyntaxKind.LogicalOrExpression;

            case SyntaxKind.BarEqualsToken:
                return SyntaxKind.OrAssignmentExpression;

            case SyntaxKind.AmpersandEqualsToken:
                return SyntaxKind.AndAssignmentExpression;

            case SyntaxKind.CaretEqualsToken:
                return SyntaxKind.ExclusiveOrAssignmentExpression;

            case SyntaxKind.LessThanLessThanEqualsToken:
                return SyntaxKind.LeftShiftAssignmentExpression;

            case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                return SyntaxKind.SignedRightShiftAssignmentExpression;

            case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                return SyntaxKind.UnsignedRightShiftAssignmentExpression;

            case SyntaxKind.PlusEqualsToken:
                return SyntaxKind.AddAssignmentExpression;

            case SyntaxKind.MinusEqualsToken:
                return SyntaxKind.SubtractAssignmentExpression;

            case SyntaxKind.AsteriskEqualsToken:
                return SyntaxKind.MultiplyAssignmentExpression;

            case SyntaxKind.SlashEqualsToken:
                return SyntaxKind.DivideAssignmentExpression;

            case SyntaxKind.PercentEqualsToken:
                return SyntaxKind.ModuloAssignmentExpression;

            case SyntaxKind.EqualsToken:
                return SyntaxKind.AssignmentExpression;

            case SyntaxKind.CommaToken:
                return SyntaxKind.CommaExpression;

            default:
                return SyntaxKind.None;
        }
    }

    export function isAnyDivideToken(kind: SyntaxKind): bool {
        switch (kind) {
            case SyntaxKind.SlashToken:
            case SyntaxKind.SlashEqualsToken:
                return true;
            default:
                return false;
        }
    }

    export function isAnyDivideOrRegularExpressionToken(kind: SyntaxKind): bool {
        switch (kind) {
            case SyntaxKind.SlashToken:
            case SyntaxKind.SlashEqualsToken:
            case SyntaxKind.RegularExpressionLiteral:
                return true;
            default:
                return false;
        }
    }

    export function isParserGenerated(kind: SyntaxKind): bool {
        switch (kind) {
            case SyntaxKind.GreaterThanGreaterThanToken:
            case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
            case SyntaxKind.GreaterThanEqualsToken:
            case SyntaxKind.GreaterThanGreaterThanEqualsToken:
            case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
                return true;
            default:
                return false;
        }
    }

    export function isAnyBinaryExpression(kind: SyntaxKind): bool {
        switch (kind) {
            case SyntaxKind.CommaExpression:
            case SyntaxKind.AssignmentExpression:
            case SyntaxKind.AddAssignmentExpression:
            case SyntaxKind.SubtractAssignmentExpression:
            case SyntaxKind.MultiplyAssignmentExpression:
            case SyntaxKind.DivideAssignmentExpression:
            case SyntaxKind.ModuloAssignmentExpression:
            case SyntaxKind.AndAssignmentExpression:
            case SyntaxKind.ExclusiveOrAssignmentExpression:
            case SyntaxKind.OrAssignmentExpression:
            case SyntaxKind.LeftShiftAssignmentExpression:
            case SyntaxKind.SignedRightShiftAssignmentExpression:
            case SyntaxKind.UnsignedRightShiftAssignmentExpression:
            case SyntaxKind.LogicalOrExpression:
            case SyntaxKind.LogicalAndExpression:
            case SyntaxKind.BitwiseOrExpression:
            case SyntaxKind.BitwiseExclusiveOrExpression:
            case SyntaxKind.BitwiseAndExpression:
            case SyntaxKind.EqualsWithTypeConversionExpression:
            case SyntaxKind.NotEqualsWithTypeConversionExpression:
            case SyntaxKind.EqualsExpression:
            case SyntaxKind.NotEqualsExpression:
            case SyntaxKind.LessThanExpression:
            case SyntaxKind.GreaterThanExpression:
            case SyntaxKind.LessThanOrEqualExpression:
            case SyntaxKind.GreaterThanOrEqualExpression:
            case SyntaxKind.InstanceOfExpression:
            case SyntaxKind.InExpression:
            case SyntaxKind.LeftShiftExpression:
            case SyntaxKind.SignedRightShiftExpression:
            case SyntaxKind.UnsignedRightShiftExpression:
            case SyntaxKind.MultiplyExpression:
            case SyntaxKind.DivideExpression:
            case SyntaxKind.ModuloExpression:
            case SyntaxKind.AddExpression:
            case SyntaxKind.SubtractExpression:
                return true;
        }

        return false;
    }
}
///<reference path='References.ts' />

module TypeScript.Syntax {
    export var emptySeparatedList: ISeparatedSyntaxList = {
        kind: () => SyntaxKind.SeparatedList,

        isNode: () => false,
        isToken: () => false,
        isList: () => false,
        isSeparatedList: () => true,

        toJSON: (key) => [],

        childCount: () => 0,
        nonSeparatorCount: () => 0,
        separatorCount: () => 0,

        toArray: () => [],
        toNonSeparatorArray: () => [],

        childAt: (index: number): ISyntaxNodeOrToken => {
            throw Errors.argumentOutOfRange("index");
        },

        nonSeparatorAt: (index: number): ISyntaxNodeOrToken => {
            throw Errors.argumentOutOfRange("index");
        },

        separatorAt: (index: number): ISyntaxToken => {
            throw Errors.argumentOutOfRange("index");
        },

        collectTextElements: (elements: string[]): void => { },

        firstToken: (): ISyntaxToken => null,
        lastToken: (): ISyntaxToken => null,

        fullWidth: () => 0,
        fullText: () => "",

        width: () => 0,

        isTypeScriptSpecific: () => false,
        hasSkippedText: () => false,
        hasZeroWidthToken: () => false,
        hasRegularExpressionToken: () => false,

        findTokenInternal: (parent: PositionedElement, position: number, fullStart: number): PositionedToken => {
            // This should never have been called on this list.  It has a 0 width, so the client 
            // should have skipped over this.
            throw Errors.invalidOperation();
        },

        insertChildrenInto: (array: ISyntaxElement[], index: number): void => {
        },

        leadingTrivia: () => Syntax.emptyTriviaList,
        trailingTrivia: () => Syntax.emptyTriviaList,

        leadingTriviaWidth: () => 0,
        trailingTriviaWidth:() => 0
    }

    class SingletonSeparatedSyntaxList implements ISeparatedSyntaxList {
        private item: ISyntaxNodeOrToken;

        constructor(item: ISyntaxNodeOrToken) {
            this.item = item;
        }

        public toJSON(key) {
            return [this.item];
        }

        public kind() { return SyntaxKind.SeparatedList; }

        public isNode(): bool { return false; }
        public isToken(): bool { return false; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return true; }

        public childCount() { return 1; }
        public nonSeparatorCount() { return 1; }
        public separatorCount() { return 0; }

        public toArray() { return [this.item]; }
        public toNonSeparatorArray() { return [this.item]; }

        public childAt(index: number): ISyntaxNodeOrToken {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.item;
        }

        public nonSeparatorAt(index: number): ISyntaxNodeOrToken {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.item;
        }

        public separatorAt(index: number): ISyntaxToken {
            throw Errors.argumentOutOfRange("index");
        }

        private collectTextElements(elements: string[]): void {
            this.item.collectTextElements(elements);
        }

        public firstToken(): ISyntaxToken {
            return this.item.firstToken();
        }

        public lastToken(): ISyntaxToken {
            return this.item.lastToken();
        }

        public fullWidth(): number {
            return this.item.fullWidth();
        }

        public width(): number {
            return this.item.width();
        }

        public fullText(): string {
            return this.item.fullText();
        }

        public leadingTrivia(): ISyntaxTriviaList {
            return this.item.leadingTrivia();
        }

        public trailingTrivia(): ISyntaxTriviaList {
            return this.item.trailingTrivia();
        }

        public leadingTriviaWidth(): number {
            return this.item.leadingTriviaWidth();
        }

        public trailingTriviaWidth(): number {
            return this.item.trailingTriviaWidth();
        }

        public isTypeScriptSpecific(): bool {
            return this.item.isTypeScriptSpecific();
        }

        public hasSkippedText(): bool {
            return this.item.hasSkippedText();
        }

        public hasZeroWidthToken(): bool {
            return this.item.hasZeroWidthToken();
        }

        public hasRegularExpressionToken(): bool {
            return this.item.hasRegularExpressionToken();
        }

        public findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            // Debug.assert(position >= 0 && position < this.item.fullWidth());
            return (<any>this.item).findTokenInternal(
                new PositionedSeparatedList(parent, this, fullStart), position, fullStart);
        }

        public insertChildrenInto(array: ISyntaxElement[], index: number): void {
            array.splice(index, 0, this.item);
        }
    }

    class NormalSeparatedSyntaxList implements ISeparatedSyntaxList {
        private elements: ISyntaxNodeOrToken[];
        private _data: number = -1;

        constructor(elements: ISyntaxNodeOrToken[]) {
            this.elements = elements;
        }

        public kind() { return SyntaxKind.SeparatedList; }

        public isToken(): bool { return false; }
        public isNode(): bool { return false; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return true; }
        public toJSON(key) { return this.elements; }

        public childCount() { return this.elements.length; }
        public nonSeparatorCount() { return IntegerUtilities.integerDivide(this.elements.length + 1, 2); }
        public separatorCount() { return IntegerUtilities.integerDivide(this.elements.length, 2); }

        public toArray(): ISyntaxNodeOrToken[] { return this.elements.slice(0); }

        public toNonSeparatorArray(): ISyntaxNodeOrToken[] {
            var result: ISyntaxNodeOrToken[] = [];
            for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                result.push(this.nonSeparatorAt(i));
            }

            return result;
        }
        
        public childAt(index: number): ISyntaxNodeOrToken {
            if (index < 0 || index >= this.elements.length) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.elements[index];
        }

        public nonSeparatorAt(index: number): ISyntaxNodeOrToken {
            var value = index * 2;
            if (value < 0 || value >= this.elements.length) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.elements[value];
        }

        public separatorAt(index: number): ISyntaxToken {
            var value = index * 2 + 1;
            if (value < 0 || value >= this.elements.length) {
                throw Errors.argumentOutOfRange("index");
            }

            return <ISyntaxToken>this.elements[value];
        }

        public firstToken(): ISyntaxToken {
            var token;
            for (var i = 0, n = this.elements.length; i < n; i++) {
                if (i % 2 === 0) {
                    var nodeOrToken = this.elements[i];
                    token = nodeOrToken.firstToken();
                    if (token !== null) {
                        return token;
                    }
                }
                else {
                    token = <ISyntaxToken>this.elements[i];
                    if (token.width() > 0) {
                        return token;
                    }
                }
            }

            return null;
        }

        public lastToken(): ISyntaxToken {
            var token;
            for (var i = this.elements.length - 1; i >= 0; i--) {
                if (i % 2 === 0) {
                    var nodeOrToken = this.elements[i];
                    token = nodeOrToken.lastToken();
                    if (token !== null) {
                        return token;
                    }
                }
                else {
                    token = <ISyntaxToken>this.elements[i];
                    if (token.width() > 0) {
                        return token;
                    }
                }
            }

            return null;
        }

        public fullText(): string {
            var elements: string[] = [];
            this.collectTextElements(elements);
            return elements.join("");
        }

        public isTypeScriptSpecific(): bool {
            for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                if (this.nonSeparatorAt(i).isTypeScriptSpecific()) {
                    return true;
                }
            }

            return false;
        }

        public hasSkippedText(): bool {
            return (this.data() & SyntaxConstants.NodeSkippedTextMask) !== 0;
        }

        public hasZeroWidthToken(): bool {
            return (this.data() & SyntaxConstants.NodeZeroWidthTokenMask) !== 0;
        }

        public hasRegularExpressionToken(): bool {
            return (this.data() & SyntaxConstants.NodeRegularExpressionTokenMask) !== 0;
        }

        public fullWidth(): number {
            return this.data() >>> SyntaxConstants.NodeFullWidthShift;
        }

        public width(): number {
            var fullWidth = this.fullWidth();
            return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        }

        public leadingTrivia(): ISyntaxTriviaList {
            return this.firstToken().leadingTrivia();
        }

        public trailingTrivia(): ISyntaxTriviaList {
            return this.lastToken().trailingTrivia();
        }

        public leadingTriviaWidth(): number {
            return this.firstToken().leadingTriviaWidth();
        }

        public trailingTriviaWidth(): number {
            return this.lastToken().trailingTriviaWidth();
        }

        private computeData(): number {
            var fullWidth = 0;
            var hasSkippedText = false;
            var hasZeroWidthToken = false;
            var hasRegularExpressionToken = false;

            for (var i = 0, n = this.elements.length; i < n; i++) {
                var element = this.elements[i];

                var childWidth = element.fullWidth();
                fullWidth += childWidth;

                if (i % 2 === 0) {
                    var nodeOrToken = element;

                    hasSkippedText = hasSkippedText || nodeOrToken.hasSkippedText();
                    hasZeroWidthToken = hasZeroWidthToken || nodeOrToken.hasZeroWidthToken();
                    hasRegularExpressionToken = hasRegularExpressionToken || nodeOrToken.hasRegularExpressionToken();
                }
                else {
                    var token = <ISyntaxToken>element;

                    hasSkippedText = hasSkippedText || token.hasSkippedText();
                    hasZeroWidthToken = hasZeroWidthToken || (childWidth === 0);

                    // A regex token never shows up as a separator token in a list.  If the language
                    // ever changes, add hte appropriate check here.
                }
            }

            return (fullWidth << SyntaxConstants.NodeFullWidthShift)
                 | (hasSkippedText ? SyntaxConstants.NodeSkippedTextMask : 0)
                 | (hasZeroWidthToken ? SyntaxConstants.NodeZeroWidthTokenMask : 0)
                 | (hasRegularExpressionToken ? SyntaxConstants.NodeRegularExpressionTokenMask : 0);
        }

        private data(): number {
            if (this._data === -1) {
                this._data = this.computeData();
            }

            return this._data;
        }

        public findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            parent = new PositionedSeparatedList(parent, this, fullStart);
            for (var i = 0, n = this.elements.length; i < n; i++) {
                var element = this.elements[i];

                var childWidth = element.fullWidth();
                if (position < childWidth) {
                    return (<any>element).findTokenInternal(parent, position, fullStart);
                }

                position -= childWidth;
                fullStart += childWidth;
            }

            throw Errors.invalidOperation();
        }

        private collectTextElements(elements: string[]): void {
            for (var i = 0, n = this.elements.length; i < n; i++) {
                var element = this.elements[i];
                element.collectTextElements(elements);
            }
        }

        public insertChildrenInto(array: ISyntaxElement[], index: number): void {
            if (index === 0) {
                array.unshift.apply(array, this.elements);
            }
            else {
                // TODO: this seems awfully innefficient.  Can we do better here?
                array.splice.apply(array, [index, <any>0].concat(this.elements));
            }
        }
    }

    export function separatedList(nodes: ISyntaxNodeOrToken[]): ISeparatedSyntaxList {
        return separatedListAndValidate(nodes, false);
    }

    function separatedListAndValidate(nodes: ISyntaxNodeOrToken[], validate: bool): ISeparatedSyntaxList {
        if (nodes === undefined || nodes === null || nodes.length === 0) {
            return emptySeparatedList;
        }

        if (validate) {
            for (var i = 0; i < nodes.length; i++) {
                var item = nodes[i];

                if (i % 2 === 1) {
                    // Debug.assert(SyntaxFacts.isTokenKind(item.kind()));
                }
            }
        }

        if (nodes.length === 1) {
            return new SingletonSeparatedSyntaxList(nodes[0]);
        }

        return new NormalSeparatedSyntaxList(nodes);
    }
}
///<reference path='References.ts' />

module TypeScript.Syntax {
    // TODO: stop exporting this once typecheck bug is fixed.
    export class EmptySyntaxList implements ISyntaxList {
        public kind(): SyntaxKind { return SyntaxKind.List; }

        public isNode(): bool { return false; }
        public isToken(): bool { return false; }
        public isList(): bool { return true; }
        public isSeparatedList(): bool { return false; }

        public toJSON(key) {
            return [];
        }

        public childCount(): number {
            return 0;
        }

        public childAt(index: number): ISyntaxNodeOrToken {
            throw Errors.argumentOutOfRange("index");
        }

        public toArray(): ISyntaxNodeOrToken[] {
            return [];
        }

        private collectTextElements(elements: string[]): void {
        }

        public firstToken(): ISyntaxToken {
            return null;
        }

        public lastToken(): ISyntaxToken {
            return null;
        }

        public fullWidth(): number {
            return 0;
        }

        public width(): number {
            return 0;
        }

        public leadingTrivia(): ISyntaxTriviaList {
            return Syntax.emptyTriviaList;
        }

        public trailingTrivia(): ISyntaxTriviaList {
            return Syntax.emptyTriviaList;
        }

        public leadingTriviaWidth(): number {
            return 0;
        }

        public trailingTriviaWidth(): number {
            return 0;
        }

        public fullText(): string {
            return "";
        }

        public isTypeScriptSpecific(): bool {
            return false;
        }

        public hasSkippedText(): bool {
            return false;
        }

        public hasZeroWidthToken(): bool {
            return false;
        }

        public hasRegularExpressionToken(): bool {
            return false;
        }

        public findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            // This should never have been called on this list.  It has a 0 width, so the client 
            // should have skipped over this.
            throw Errors.invalidOperation();
        }

        public insertChildrenInto(array: ISyntaxElement[], index: number): void {
        }
    }

    export var emptyList: ISyntaxList = new EmptySyntaxList();

    class SingletonSyntaxList implements ISyntaxList {
        private item: ISyntaxNodeOrToken;

        constructor(item: ISyntaxNodeOrToken) {
            this.item = item;
        }

        public kind(): SyntaxKind { return SyntaxKind.List; }

        public isToken(): bool { return false; }
        public isNode(): bool { return false; }
        public isList(): bool { return true; }
        public isSeparatedList(): bool { return false; }

        public toJSON(key) {
            return [this.item];
        }

        public childCount() {
            return 1;
        }

        public childAt(index: number): ISyntaxNodeOrToken {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.item;
        }

        public toArray(): ISyntaxNodeOrToken[] {
            return [this.item];
        }

        private collectTextElements(elements: string[]): void {
            this.item.collectTextElements(elements);
        }

        public firstToken(): ISyntaxToken {
            return this.item.firstToken();
        }

        public lastToken(): ISyntaxToken {
            return this.item.lastToken();
        }

        public fullWidth(): number {
            return this.item.fullWidth();
        }

        public width(): number {
            return this.item.width();
        }
        
        public leadingTrivia(): ISyntaxTriviaList {
            return this.item.leadingTrivia();
        }

        public trailingTrivia(): ISyntaxTriviaList {
            return this.item.trailingTrivia();
        }

        public leadingTriviaWidth(): number {
            return this.item.leadingTriviaWidth();
        }

        public trailingTriviaWidth(): number {
            return this.item.trailingTriviaWidth();
        }

        public fullText(): string {
            return this.item.fullText();
        }

        public isTypeScriptSpecific(): bool {
            return this.item.isTypeScriptSpecific();
        }

        public hasSkippedText(): bool {
            return this.item.hasSkippedText();
        }

        public hasZeroWidthToken(): bool {
            return this.item.hasZeroWidthToken();
        }

        public hasRegularExpressionToken(): bool {
            return this.item.hasRegularExpressionToken();
        }

        public findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            // Debug.assert(position >= 0 && position < this.item.fullWidth());
            return (<any>this.item).findTokenInternal(
                new PositionedList(parent, this, fullStart), position, fullStart);
        }

        public insertChildrenInto(array: ISyntaxElement[], index: number): void {
            array.splice(index, 0, this.item);
        }
    }

    class NormalSyntaxList implements ISyntaxList {
        private nodeOrTokens: ISyntaxNodeOrToken[];
        private _data: number = -1;

        constructor(nodeOrTokens: ISyntaxNodeOrToken[]) {
            this.nodeOrTokens = nodeOrTokens;
        }

        public kind(): SyntaxKind { return SyntaxKind.List; }

        public isNode(): bool { return false; }
        public isToken(): bool { return false; }
        public isList(): bool { return true; }
        public isSeparatedList(): bool { return false; }

        public toJSON(key) {
            return this.nodeOrTokens;
        }

        public childCount() {
            return this.nodeOrTokens.length;
        }

        public childAt(index: number): ISyntaxNodeOrToken {
            if (index < 0 || index >= this.nodeOrTokens.length) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.nodeOrTokens[index];
        }

        public toArray(): ISyntaxNodeOrToken[] {
            return this.nodeOrTokens.slice(0);
        }

        private collectTextElements(elements: string[]): void {
            for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var element = this.nodeOrTokens[i];
                element.collectTextElements(elements);
            }
        }

        public firstToken(): ISyntaxToken {
            for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var token = this.nodeOrTokens[i].firstToken();
                if (token !== null) {
                    return token;
                }
            }

            return null;
        }

        public lastToken(): ISyntaxToken {
            for (var i = this.nodeOrTokens.length - 1; i >= 0; i--) {
                var token = this.nodeOrTokens[i].lastToken();
                if (token !== null) {
                    return token;
                }
            }

            return null;
        }

        public fullText(): string {
            var elements: string[] = [];
            this.collectTextElements(elements);
            return elements.join("");
        }

        public isTypeScriptSpecific(): bool {
            for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                if (this.nodeOrTokens[i].isTypeScriptSpecific()) {
                    return true;
                }
            }

            return false;
        }

        public hasSkippedText(): bool {
            return (this.data() & SyntaxConstants.NodeSkippedTextMask) !== 0;
        }

        public hasZeroWidthToken(): bool {
            return (this.data() & SyntaxConstants.NodeZeroWidthTokenMask) !== 0;
        }

        public hasRegularExpressionToken(): bool {
            return (this.data() & SyntaxConstants.NodeRegularExpressionTokenMask) !== 0;
        }

        public fullWidth(): number {
            return this.data() >>> SyntaxConstants.NodeFullWidthShift;
        }

        public width(): number {
            var fullWidth = this.fullWidth();
            return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        }

        public leadingTrivia(): ISyntaxTriviaList {
            return this.firstToken().leadingTrivia();
        }

        public trailingTrivia(): ISyntaxTriviaList {
            return this.lastToken().trailingTrivia();
        }

        public leadingTriviaWidth(): number {
            return this.firstToken().leadingTriviaWidth();
        }

        public trailingTriviaWidth(): number {
            return this.lastToken().trailingTriviaWidth();
        }

        private computeData(): number {
            var fullWidth = 0;
            var hasSkippedText = false;
            var hasZeroWidthToken = false;
            var hasRegularExpressionToken = false;

            for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var node = this.nodeOrTokens[i];
                fullWidth += node.fullWidth();
                hasSkippedText = hasSkippedText || node.hasSkippedText();
                hasZeroWidthToken = hasZeroWidthToken || node.hasZeroWidthToken();
                hasRegularExpressionToken = hasRegularExpressionToken || node.hasRegularExpressionToken();
            }

            return (fullWidth << SyntaxConstants.NodeFullWidthShift)
                 | (hasSkippedText ? SyntaxConstants.NodeSkippedTextMask : 0)
                 | (hasZeroWidthToken ? SyntaxConstants.NodeZeroWidthTokenMask : 0)
                 | (hasRegularExpressionToken ? SyntaxConstants.NodeRegularExpressionTokenMask : 0);
        }

        private data(): number {
            if (this._data === -1) {
                this._data = this.computeData();
            }

            return this._data;
        }

        public findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            // Debug.assert(position >= 0 && position < this.fullWidth());
            
            parent = new PositionedList(parent, this, fullStart);
            for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                var nodeOrToken = this.nodeOrTokens[i];

                var childWidth = nodeOrToken.fullWidth();
                if (position < childWidth) {
                    return (<any>nodeOrToken).findTokenInternal(parent, position, fullStart);
                }

                position -= childWidth;
                fullStart += childWidth;
            }

            throw Errors.invalidOperation();
        }

        public insertChildrenInto(array: ISyntaxElement[], index: number): void {
            if (index === 0) {
                array.unshift.apply(array, this.nodeOrTokens);
            }
            else {
                // TODO: this seems awfully innefficient.  Can we do better here?
                array.splice.apply(array, [index, <any>0].concat(this.nodeOrTokens));
            }
        }
    }

    export function list(nodes: ISyntaxNodeOrToken[]): ISyntaxList {
        if (nodes === undefined || nodes === null || nodes.length === 0) {
            return emptyList;
        }

        if (nodes.length === 1) {
            var item = nodes[0];
            return new SingletonSyntaxList(item);
        }

        return new NormalSyntaxList(nodes);
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class Hash {
        // This table uses FNV1a as a string hash
        private static FNV_BASE = 2166136261;
        private static FNV_PRIME = 16777619;

        private static computeFnv1aCharArrayHashCode(text: number[], start: number, len: number): number {
            var hashCode = Hash.FNV_BASE;
            var end = start + len;

            for (var i = start; i < end; i++) {
                hashCode = (hashCode ^ text[i]) * Hash.FNV_PRIME;
            }

            return hashCode;
        }

        public static computeSimple31BitCharArrayHashCode(key: number[], start: number, len: number): number {
            // Start with an int.
            var hash = 0;

            for (var i = 0; i < len; i++) {
                var ch = key[start + i];

                // Left shift keeps things as a 32bit int.  And we're only doing two adds.  Chakra and
                // V8 recognize this as not needing to go past the 53 bits needed for the float 
                // mantissa.  Or'ing with 0 keeps this 32 bits.
                hash = (((hash << 5) + hash) + ch) | 0;
            }

            // Ensure we fit in 31 bits.  That way if/when this gets stored, it won't require any heap
            // allocation.
            return hash & 0x7FFFFFFF;
        }

        public static computeSimple31BitStringHashCode(key: string): number {
            // Start with an int.
            var hash = 0;

            var start = 0;
            var len = key.length;

            for (var i = 0; i < len; i++) {
                var ch = key.charCodeAt(start + i);

                // Left shift keeps things as a 32bit int.  And we're only doing two adds.  Chakra and
                // V8 recognize this as not needing to go past the 53 bits needed for the float 
                // mantissa.  Or'ing with 0 keeps this 32 bits.
                hash = (((hash << 5) + hash) + ch) | 0;
            }

            // Ensure we fit in 31 bits.  That way if/when this gets stored, it won't require any heap
            // allocation.
            return hash & 0x7FFFFFFF;
        }

        public static computeMurmur2CharArrayHashCode(key: number[], start: number, len: number): number {
            // 'm' and 'r' are mixing constants generated offline.
            // They're not really 'magic', they just happen to work well.
            var m = 0x5bd1e995;
            var r = 24;

            // Initialize the hash to a 'random' value
            var numberOfCharsLeft = len;
            var h = (0 ^ numberOfCharsLeft);

            // Mix 4 bytes at a time into the hash.  NOTE: 4 bytes is two chars, so we iterate
            // through the string two chars at a time.
            var index = start;
            while (numberOfCharsLeft >= 2) {
                var c1 = key[index];
                var c2 = key[index + 1];

                var k = c1 | (c2 << 16);

                k *= m;
                k ^= k >> r;
                k *= m;

                h *= m;
                h ^= k;

                index += 2;
                numberOfCharsLeft -= 2;
            }

            // Handle the last char (or 2 bytes) if they exist.  This happens if the original string had
            // odd length.
            if (numberOfCharsLeft === 1) {
                h ^= key[index];
                h *= m;
            }

            // Do a few final mixes of the hash to ensure the last few bytes are well-incorporated.

            h ^= h >> 13;
            h *= m;
            h ^= h >> 15;

            return h;
        }

        public static computeMurmur2StringHashCode(key: string): number {
            // 'm' and 'r' are mixing constants generated offline.
            // They're not really 'magic', they just happen to work well.
            var m = 0x5bd1e995;
            var r = 24;

            var start = 0;
            var len = key.length;
            var numberOfCharsLeft = len;

            // Initialize the hash to a 'random' value.
            var h = (0 ^ numberOfCharsLeft);

            // Mix 4 bytes at a time into the hash.  NOTE: 4 bytes is two chars, so we iterate
            // through the string two chars at a time.
            var index = start;
            while (numberOfCharsLeft >= 2) {
                var c1 = key.charCodeAt(index);
                var c2 = key.charCodeAt(index + 1);

                var k = c1 | (c2 << 16);

                k *= m;
                k ^= k >> r;
                k *= m;

                h *= m;
                h ^= k;

                index += 2;
                numberOfCharsLeft -= 2;
            }

            // Handle the last char (or 2 bytes) if they exist.  This happens if the original string had
            // odd length.
            if (numberOfCharsLeft === 1) {
                h ^= key.charCodeAt(index);
                h *= m;
            }

            // Do a few final mixes of the hash to ensure the last few bytes are well-incorporated.

            h ^= h >> 13;
            h *= m;
            h ^= h >> 15;

            return h;
        }

        private static primes =
            [3, 7, 11, 17, 23, 29, 37, 47, 59, 71, 89, 107, 131, 163, 197, 239, 293, 353, 431, 521,
              631, 761, 919, 1103, 1327, 1597, 1931, 2333, 2801, 3371, 4049, 4861, 5839, 7013, 8419,
              10103, 12143, 14591, 17519, 21023, 25229, 30293, 36353, 43627, 52361, 62851, 75431,
              90523, 108631, 130363, 156437, 187751, 225307, 270371, 324449, 389357, 467237, 560689,
              672827, 807403, 968897, 1162687, 1395263, 1674319, 2009191, 2411033, 2893249, 3471899,
              4166287, 4999559, 5999471, 7199369];

        public static getPrime(min: number): number {
            for (var i = 0; i < Hash.primes.length; i++) {
                var num = Hash.primes[i];
                if (num >= min) {
                    return num;
                }
            }

            throw Errors.notYetImplemented();
        }

        public static expandPrime(oldSize: number): number {
            var num = oldSize << 1;
            if (num > 2146435069 && 2146435069 > oldSize) {
                // NOTE: 2146435069 fits in 31 bits.
                return 2146435069;
            }
            return Hash.getPrime(num);
        }

        public static combine(value: number, currentHash: number): number {
            // Ensure we stay within 31 bits.
            return (((currentHash << 5) + currentHash) + value) & 0x7FFFFFFF;
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class ArrayUtilities {
        public static isArray(value: any): bool {
            return Object.prototype.toString.apply(value, []) === '[object Array]';
        }

        public static sequenceEquals(array1: any[], array2: any[], equals: (v1, v2) => bool) {
            if (array1 === array2) {
                return true;
            }

            if (array1 === null || array2 === null) {
                return false;
            }

            if (array1.length !== array2.length) {
                return false;
            }

            for (var i = 0, n = array1.length; i < n; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }

            return true;
        }

        public static contains(array: any[], value: any): bool {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === value) {
                    return true;
                }
            }

            return false;
        }

        public static groupBy(array: any[], func: (v: any) => string): any {
            var result = {};

            for (var i = 0, n = array.length; i < n; i++) {
                var v = array[i];
                var k = func(v);

                var list = result[k] || [];
                list.push(v);
                result[k] = list;
            }

            return result;
        }

        public static min(array: any[], func: (v: any) => number): number {
            // Debug.assert(array.length > 0);
            var min = func(array[0]);

            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next < min) {
                    min = next;
                }
            }

            return min;
        }

        public static max(array: any[], func: (v: any) => number): number {
            // Debug.assert(array.length > 0);
            var max = func(array[0]);

            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next > max) {
                    max = next;
                }
            }

            return max;
        }

        public static last(array: any[]) {
            if (array.length === 0) {
                throw Errors.argumentOutOfRange('array');
            }

            return array[array.length - 1];
        }

        public static firstOrDefault(array: any[], func: (v: any) => bool): any {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (func(value)) {
                    return value;
                }
            }

            return null;
        }

        public static sum(array: any[], func: (v: any) => number): number {
            var result = 0;

            for (var i = 0, n = array.length; i < n; i++) {
                result += func(array[i]);
            }

            return result;
        }

        public static whereNotNull(array: any[]): any[] {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                var value = array[i];
                if (value !== null) {
                    result.push(value);
                }
            }

            return result;
        }

        public static select(values: any[], func: (v: any) => any): any[] {
            var result = [];

            for (var i = 0; i < values.length; i++) {
                result.push(func(values[i]));
            }

            return result;
        }

        public static where(values: any[], func: (v: any) => bool): any[] {
            var result = [];

            for (var i = 0; i < values.length; i++) {
                if (func(values[i])) {
                    result.push(values[i]);
                }
            }

            return result;
        }

        public static any(array: any[], func: (v: any) => bool): bool {
            for (var i = 0, n = array.length; i < n; i++) {
                if (func(array[i])) {
                    return true;
                }
            }

            return false;
        }

        public static all(array: any[], func: (v: any) => bool): bool {
            for (var i = 0, n = array.length; i < n; i++) {
                if (!func(array[i])) {
                    return false;
                }
            }

            return true;
        }

        public static binarySearch(array: number[], value: number): number {
            var low = 0;
            var high = array.length - 1;

            while (low <= high) {
                var middle = low + ((high - low) >> 1);
                var midValue = array[middle];

                if (midValue === value) {
                    return middle;
                }
                else if (midValue > value) {
                    high = middle - 1;
                }
                else {
                    low = middle + 1;
                }
            }

            return ~low;
        }

        public static createArray(length: number, defaultvalue: any): any[] {
            var result = [];
            for (var i = 0; i < length; i++) {
                result.push(defaultvalue);
            }

            return result;
        }

        public static grow(array: any[], length: number, defaultValue: any): void {
            var count = length - array.length;
            for (var i = 0; i < count; i++) {
                array.push(defaultValue);
            }
        }

        public static copy(sourceArray: any[], sourceIndex: number, destinationArray: any[], destinationIndex: number, length: number): void {
            for (var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export interface ISlidingWindowSource {
        // Asks the source to copy items starting at sourceIndex into the window at 'destinationIndex'
        // with up to 'spaceAvailable' items.  The actual number of items fetched should be given as 
        // the return value.
        fetchMoreItems(argument: any, sourceIndex: number, window: any[], destinationIndex: number, spaceAvailable: number): number;
    }

    export class SlidingWindow {

        // The number of valid items in window.
        private windowCount: number = 0;

        // The *absolute* index in the *full* array of items the *window* array starts at.  i.e.
        // if there were 100 items, and window contains tokens [70, 80), then this value would be
        // 70.
        public windowAbsoluteStartIndex: number = 0;

        // The index in the window array that we're at. i.e. if there 100 items and 
        // window contains tokens [70, 80), and we're on item 75, then this value would be '5'.
        // Note: it is not absolute.  It is relative to the start of the window.
        private currentRelativeItemIndex: number = 0;

        // The number of pinned points there are.  As long as there is at least one  pinned point, we 
        // will not advance the start of the window array past the item marked by that pin point.
        private _pinCount: number = 0;

        // If there are any outstanding rewind points, this is index in the full array of items
        // that the first rewind point points to.  If this is not -1, then we will not shift the
        // start of the items array past this point.
        private firstPinnedAbsoluteIndex: number = -1;

        constructor(// Underlying source that we retrieve items from.
                    private source: ISlidingWindowSource,
                    // A window of items that has been read in from the underlying source.
                    public window: any[],
                    // The default value to return when there are no more items left in the window.
                    private defaultValue: any,
                    // The length of the source we're reading from if we know it up front.  -1 if we do not.
                    private sourceLength = -1) {
        }

        // The last legal index of the window (exclusive).
        private windowAbsoluteEndIndex(): number {
            return this.windowAbsoluteStartIndex + this.windowCount;
        }

        private addMoreItemsToWindow(argument: any): bool {
            if (this.sourceLength >= 0 && this.absoluteIndex() >= this.sourceLength) {
                return false;
            }

            // First, make room for the new items if we're out of room.
            if (this.windowCount >= this.window.length) {
                this.tryShiftOrGrowWindow();
            }

            var spaceAvailable = this.window.length - this.windowCount;
            var amountFetched = this.source.fetchMoreItems(argument, this.windowAbsoluteEndIndex(), this.window, this.windowCount, spaceAvailable);

            // Assert disabled because it is actually expensive enugh to affect perf.

            this.windowCount += amountFetched;
            return amountFetched > 0;
        }

        private tryShiftOrGrowWindow(): void {
            // We want to shift if our current item is past the halfway point of the current item window.
            var currentIndexIsPastWindowHalfwayPoint = this.currentRelativeItemIndex > (this.window.length >>> 1);

            // However, we can only shift if we have no outstanding rewind points.  Or, if we have an 
            // outstanding rewind point, that it points to some point after the start of the window.
            var isAllowedToShift =
                this.firstPinnedAbsoluteIndex === -1 ||
                this.firstPinnedAbsoluteIndex > this.windowAbsoluteStartIndex;

            if (currentIndexIsPastWindowHalfwayPoint && isAllowedToShift) {
                // Figure out where we're going to start shifting from. If we have no oustanding rewind 
                // points, then we'll start shifting over all the items starting from the current 
                // token we're point out.  Otherwise, we'll shift starting from the first item that 
                // the rewind point is pointing at.
                // 
                // We'll call that point 'N' from now on. 
                var shiftStartIndex = this.firstPinnedAbsoluteIndex === -1
                    ? this.currentRelativeItemIndex
                    : this.firstPinnedAbsoluteIndex - this.windowAbsoluteStartIndex;

                // We have to shift the number of elements between the start index and the number of 
                // items in the window.
                var shiftCount = this.windowCount - shiftStartIndex;

                // Debug.assert(shiftStartIndex > 0);
                if (shiftCount > 0) {
                    ArrayUtilities.copy(this.window, shiftStartIndex, this.window, 0, shiftCount);
                }

                // The window has now moved over to the right by N.
                this.windowAbsoluteStartIndex += shiftStartIndex;

                // The number of valid items in the window has now decreased by N.
                this.windowCount -= shiftStartIndex;

                // The current item now starts further to the left in the window.
                this.currentRelativeItemIndex -= shiftStartIndex;
            }
            else {
                // Grow the exisitng array.
                // this.window[this.window.length * 2 - 1] = this.defaultValue;
                ArrayUtilities.grow(this.window, this.window.length * 2, this.defaultValue);
            }
        }

        public absoluteIndex(): number {
            return this.windowAbsoluteStartIndex + this.currentRelativeItemIndex;
        }

        public isAtEndOfSource(): bool {
            return this.absoluteIndex() >= this.sourceLength;
        }

        public getAndPinAbsoluteIndex(): number {
            // Find the absolute index of this pin point.  i.e. it's the index as if we had an 
            // array containing *all* tokens.  
            var absoluteIndex = this.absoluteIndex();
            var pinCount = this._pinCount++;
            if (pinCount === 0) {
                // If this is the first pinned point, then store off this index.  We will ensure that
                // we never shift the window past this point.
                this.firstPinnedAbsoluteIndex = absoluteIndex;
            }

            return absoluteIndex;
        }

        public releaseAndUnpinAbsoluteIndex(absoluteIndex: number) {
            this._pinCount--;
            if (this._pinCount === 0) {
                // If we just released the last outstanding pin, then we no longer need to 'fix' the 
                // token window so it can't move forward.  Set the index to -1 so that we can shift 
                // things over the next time we read past the end of the array.
                this.firstPinnedAbsoluteIndex = -1;
            }
        }

        public rewindToPinnedIndex(absoluteIndex: number): void {
            // The rewind point shows which absolute item we want to rewind to.  Get the relative 
            // index in the actual array that we want to point to.
            var relativeIndex = absoluteIndex - this.windowAbsoluteStartIndex;

            // Make sure we haven't screwed anything up.
            // Debug.assert(relativeIndex >= 0 && relativeIndex < this.windowCount);

            // Set ourselves back to that point.
            this.currentRelativeItemIndex = relativeIndex;
        }

        public currentItem(argument: any): any {
            if (this.currentRelativeItemIndex >= this.windowCount) {
                if (!this.addMoreItemsToWindow(argument)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex];
        }

        public peekItemN(n: number): any {
            // Assert disabled because it is actually expensive enugh to affect perf.
            // Debug.assert(n >= 0);
            while (this.currentRelativeItemIndex + n >= this.windowCount) {
                if (!this.addMoreItemsToWindow(/*argument:*/ null)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex + n];
        }

        public moveToNextItem(): void {
            this.currentRelativeItemIndex++;
        }

        public disgardAllItemsFromCurrentIndexOnwards(): void {
            // By setting the window count to the current relative offset, we are effectively making
            // any items we added to the window from the current offset onwards unusable.  When we
            // try to get the next item, we'll be forced to refetch them from the underlying source.
            this.windowCount = this.currentRelativeItemIndex;
        }

        public setAbsoluteIndex(absoluteIndex: number): void {
            if (this.absoluteIndex() === absoluteIndex) {
                // Nothing to do if we're setting hte absolute index to where we current are.
                return;
            }

            if (this._pinCount > 0) {
                // If we have any active pins, then the caller better be setting the index somewhere
                // inside our active window.
                // Debug.assert(absoluteIndex >= this.windowAbsoluteStartIndex && absoluteIndex < this.windowAbsoluteEndIndex());
            }

            if (absoluteIndex >= this.windowAbsoluteStartIndex && absoluteIndex < this.windowAbsoluteEndIndex()) {
                // The caller is setting the index to some place inside our current window.  This is 
                // easy to handle (and should be the common case).
                this.currentRelativeItemIndex = (absoluteIndex - this.windowAbsoluteStartIndex);
            }
            else {
                // The caller is setting the index to a place not in the window.  Just throw away 
                // everything we've got.

                // First, set the window start to that index.
                this.windowAbsoluteStartIndex = absoluteIndex;

                // Now, set the count to 0.  So we'll be forced to fetch more items.
                this.windowCount = 0;

                // And set us back to the start of the window.
                this.currentRelativeItemIndex = 0;
            }
        }

        public pinCount(): number {
            return this._pinCount;
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export enum CharacterCodes {
        nullCharacter = 0,
        maxAsciiCharacter = 127,

        lineFeed = 10,       // \n
        carriageReturn = 13,       // \r
        lineSeparator = 0x2028,
        paragraphSeparator = 0x2029,

        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems 
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        nextLine = 0x0085,

        // Unicode 3.0 space characters
        space = 0x0020,   // " "
        nonBreakingSpace = 0x00A0,   //
        enQuad = 0x2000,
        emQuad = 0x2001,
        enSpace = 0x2002,
        emSpace = 0x2003,
        threePerEmSpace = 0x2004,
        fourPerEmSpace = 0x2005,
        sixPerEmSpace = 0x2006,
        figureSpace = 0x2007,
        punctuationSpace = 0x2008,
        thinSpace = 0x2009,
        hairSpace = 0x200A,
        zeroWidthSpace = 0x200B,
        narrowNoBreakSpace = 0x202F,
        ideographicSpace = 0x3000,

        _ = 95,
        $ = 36,

        _0 = 48,
        _9 = 57,

        a = 97,
        b = 98,
        c = 99,
        d = 100,
        e = 101,
        f = 102,
        g = 103,
        h = 104,
        i = 105,
        k = 107,
        l = 108,
        m = 109,
        n = 110,
        o = 111,
        p = 112,
        r = 114,
        s = 115,
        t = 116,
        u = 117,
        v = 118,
        w = 119,
        x = 120,
        y = 121,
        z = 122,

        A = 65,
        E = 69,
        F = 70,
        X = 88,
        Z = 90,

        ampersand = 38,          // &
        asterisk = 42,          // *
        backslash = 92,          // \
        bar = 124,         // |
        caret = 94,          // ^
        closeBrace = 125,         // }
        closeBracket = 93,          // ]
        closeParen = 41,          // )
        colon = 58,          // : 
        comma = 44,          // ,
        dot = 46,          // .
        doubleQuote = 34,          // "
        equals = 61,          // =
        exclamation = 33,          // !
        greaterThan = 62,          // >
        lessThan = 60,          // <
        minus = 45,          // -
        openBrace = 123,         // {
        openBracket = 91,          // [
        openParen = 40,          // (
        percent = 37,          // %
        plus = 43,          // +
        question = 63,          // ?
        semicolon = 59,          // ;
        singleQuote = 39,          // '
        slash = 47,          // /
        tilde = 126,         // ~

        backspace = 8,          // \b
        formFeed = 12,         // \f
        byteOrderMark = 0xFEFF,
        tab = 9,          // \t
        verticalTab = 11,         // \v
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class CharacterInfo {
        public static isDecimalDigit(c: number): bool {
            return c >= CharacterCodes._0 && c <= CharacterCodes._9;
        }

        public static isHexDigit(c: number): bool {
            return CharacterInfo.isDecimalDigit(c) ||
                   (c >= CharacterCodes.A && c <= CharacterCodes.F) ||
                   (c >= CharacterCodes.a && c <= CharacterCodes.f);
        }

        public static hexValue(c: number): number {
            // Debug.assert(isHexDigit(c));
            return CharacterInfo.isDecimalDigit(c)
                ? (c - CharacterCodes._0)
                : (c >= CharacterCodes.A && c <= CharacterCodes.F)
                    ? c - CharacterCodes.A + 10
                    : c - CharacterCodes.a + 10;
        }

        public static isWhitespace(ch: number): bool {
            switch (ch) {
                // Unicode 3.0 space characters.
                case CharacterCodes.space:
                case CharacterCodes.nonBreakingSpace:
                case CharacterCodes.enQuad:
                case CharacterCodes.emQuad:
                case CharacterCodes.enSpace:
                case CharacterCodes.emSpace:
                case CharacterCodes.threePerEmSpace:
                case CharacterCodes.fourPerEmSpace:
                case CharacterCodes.sixPerEmSpace:
                case CharacterCodes.figureSpace:
                case CharacterCodes.punctuationSpace:
                case CharacterCodes.thinSpace:
                case CharacterCodes.hairSpace:
                case CharacterCodes.zeroWidthSpace:
                case CharacterCodes.narrowNoBreakSpace:
                case CharacterCodes.ideographicSpace:

                case CharacterCodes.tab:
                case CharacterCodes.verticalTab:
                case CharacterCodes.formFeed:
                case CharacterCodes.byteOrderMark:
                    return true;
            }

            return false;
        }

        public static isLineTerminator(ch: number): bool {
            switch (ch) {
                case CharacterCodes.carriageReturn:
                case CharacterCodes.lineFeed:
                case CharacterCodes.paragraphSeparator:
                case CharacterCodes.lineSeparator:
                    return true;
            }

            return false;
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export enum SyntaxConstants {
        // Masks that we use to place information about trivia into a single int. The first two flags 
        // mark bools that tell us if the trivia contains a comment or a newline. The width of the 
        // trivia is then stored in the rest of the int.  This allows trivia of nearly any length.
        // However, nearly all of the time the trivia will be less than 511MB, and will fit into 31
        // bits (which will only be stored a a single 32bit int in chakra).
        TriviaNewLineMask = 0x00000001, //  0000 0000 0000 0000 0000 0000 0000 0001
        TriviaCommentMask = 0x00000002, //  0000 0100 0000 0000 0000 0000 0000 0010
        TriviaFullWidthShift = 2,          //  1111 1111 1111 1111 1111 1111 1111 1100

        // Masks that we use to place information about a node into a single int.  The first three tell
        // us if the node either contained any skipped tokens, or if it had any zero width tokens 
        // anywhere within it, or if it had a regex token in it ("/", "/=" or "/.../").  If it does, 
        // then we cannot be reused by the incremental parser.
        //
        // The next bit lets us know if the nodes was parsed in a strict context or node.  A node can
        // only be used by the incremental parser if it is parsed in the same strict context as before.
        // last masks off the part of the int
        //
        // The width of the node is stored in the remainder of the int.  This allows us up to 255 MB
        // for a node by using all 28 bits.  However, in the common case, we'll use less than 28 bits
        // for the width.  Thus, the info will be stored in a single int in chakra.
        //
        // If we need more space, we can always merge the first 3 bits into a single bit:
        // 'canBeIncrementallyReused'.  That will allow us up to 1023MB for a single node.
        NodeSkippedTextMask = 0x00000001, // 0000 0000 0000 0000 0000 0000 0000 0001
        NodeZeroWidthTokenMask = 0x00000002, // 0000 0000 0000 0000 0000 0000 0000 0010
        NodeRegularExpressionTokenMask = 0x00000004, // 0000 0000 0000 0000 0000 0000 0000 0100
        NodeParsedInStrictModeMask = 0x00000008, // 0000 0000 0000 0000 0000 0000 0000 1000
        NodeFullWidthShift = 4,          // 1111 1111 1111 1111 1111 1111 1111 0000
    }
}
module TypeScript {
    export enum LanguageVersion {
        EcmaScript3,
        EcmaScript5,
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class Contract {
        public static requires(expression: bool): void {
            if (!expression) {
                throw new Error("Contract violated. False expression.");
            }
        }

        public static throwIfFalse(expression: bool): void {
            if (!expression) {
                throw new Error("Contract violated. False expression.");
            }
        }

        public static throwIfNull(value: any): void {
            if (value === null) {
                throw new Error("Contract violated. Null value.");
            }
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class MathPrototype {
        public static max(a: number, b: number): number {
            return a >= b ? a : b;
        }

        public static min(a: number, b: number): number {
            return a <= b ? a : b;
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class TextSpan {
        private _start: number;
        private _length: number;

        /// <summary>
        /// Creates a TextSpan instance beginning with the position Start and having the Length
        /// specified with length.
        /// </summary>
        constructor(start: number, length: number) {
            if (start < 0) {
                Errors.argument("start");
            }

            if (start + length < start) {
                throw new Error("length");
            }

            this._start = start;
            this._length = length;
        }

        public start(): number {
            return this._start;
        }

        public length(): number {
            return this._length;
        }

        public end(): number {
            return this._start + this._length;
        }

        public isEmpty(): bool {
            return this._length === 0;
        }

        /// <summary>
        /// Determines whether the position lies within the span.
        /// </summary>
        /// <param name="position">
        /// The position to check.
        /// </param>
        /// <returns>
        /// <c>true</c> if the position is greater than or equal to Start and strictly less 
        /// than End, otherwise <c>false</c>.
        /// </returns>
        public containsPosition(position: number): bool {
            return position >= this._start && position < this.end();
        }

        /// <summary>
        /// Determines whether <paramref name="span"/> falls completely within this span.
        /// </summary>
        /// <param name="span">
        /// The span to check.
        /// </param>
        /// <returns>
        /// <c>true</c> if the specified span falls completely within this span, otherwise <c>false</c>.
        /// </returns>
        public containsTextSpan(span: TextSpan): bool {
            return span._start >= this._start && span.end() <= this.end();
        }

        /// <summary>
        /// Determines whether <paramref name="span"/> overlaps this span. Two spans are considered to overlap 
        /// if they have positions in common and neither is empty. Empty spans do not overlap with any 
        /// other span.
        /// </summary>
        /// <param name="span">
        /// The span to check.
        /// </param>
        /// <returns>
        /// <c>true</c> if the spans overlap, otherwise <c>false</c>.
        /// </returns>
        public overlapsWith(span: TextSpan): bool {
            var overlapStart = MathPrototype.max(this._start, span._start);
            var overlapEnd = MathPrototype.min(this.end(), span.end());

            return overlapStart < overlapEnd;
        }

        /// <summary>
        /// Returns the overlap with the given span, or null if there is no overlap.
        /// </summary>
        /// <param name="span">
        /// The span to check.
        /// </param>
        /// <returns>
        /// The overlap of the spans, or null if the overlap is empty.
        /// </returns>
        public overlap(span: TextSpan): TextSpan {
            var overlapStart = MathPrototype.max(this._start, span._start);
            var overlapEnd = MathPrototype.min(this.end(), span.end());

            if (overlapStart < overlapEnd) {
                return TextSpan.fromBounds(overlapStart, overlapEnd);
            }

            return null;
        }

        /// <summary>
        /// Determines whether <paramref name="span"/> intersects this span. Two spans are considered to 
        /// intersect if they have positions in common or the end of one span 
        /// coincides with the start of the other span.
        /// </summary>
        /// <param name="span">
        /// The span to check.
        /// </param>
        /// <returns>
        /// <c>true</c> if the spans intersect, otherwise <c>false</c>.
        /// </returns>
        public intersectsWithTextSpan(span: TextSpan): bool {
            return span._start <= this.end() && span.end() >= this._start;
        }

        public intersectsWith(start: number, length: number): bool {
            var end = start + length;
            return start <= this.end() && end >= this._start;
        }

        /// <summary>
        /// Determines whether <paramref name="position"/> intersects this span. 
        /// A position is considered to intersect if it is between the start and
        /// end positions (inclusive) of this span.
        /// </summary>
        /// <param name="position">
        /// The position to check.
        /// </param>
        /// <returns>
        /// <c>true</c> if the position intersects, otherwise <c>false</c>.
        /// </returns>
        public intersectsWithPosition(position: number): bool {
            return position <= this.end() && position >= this._start;
        }

        /// <summary>
        /// Returns the intersection with the given span, or null if there is no intersection.
        /// </summary>
        /// <param name="span">
        /// The span to check.
        /// </param>
        /// <returns>
        /// The intersection of the spans, or null if the intersection is empty.
        /// </returns>
        public intersection(span: TextSpan): TextSpan {
            var intersectStart = MathPrototype.max(this._start, span._start);
            var intersectEnd = MathPrototype.min(this.end(), span.end());

            if (intersectStart <= intersectEnd) {
                return TextSpan.fromBounds(intersectStart, intersectEnd);
            }

            return null;
        }

        /// <summary>
        /// Creates a new <see cref="T:TextSpan"/> from <param name="start" /> and <param
        /// name="end"/> positions as opposed to a position and length.
        /// </summary>
        public static fromBounds(start: number, end: number): TextSpan {
            Contract.requires(start >= 0);
            Contract.requires(end - start >= 0);
            return new TextSpan(start, end - start);
        }
    }
}
///<reference path='References.ts' />

/// <summary>
/// Immutable representation of a line in an IText instance.
/// </summary>
module TypeScript {
    export interface ITextLine {
        /// <summary>
        /// Start of the line.
        /// </summary>
        start(): number;

        /// <summary>
        /// End of the line not including the line break.
        /// </summary>
        end(): number;

        /// <summary>
        /// End of the line including the line break.
        /// </summary>
        endIncludingLineBreak(): number;

        /// <summary>
        /// Extent of the line not including the line break.
        /// </summary>
        extent(): TextSpan;

        /// <summary>
        /// Extent of the line including the line break.
        /// </summary>
        extentIncludingLineBreak(): TextSpan;

        /// <summary>
        /// Gets the text of the line excluding the line break.
        /// </summary>
        toString(): string;

        /// <summary>
        /// Gets the line number for this line.
        /// </summary>
        lineNumber(): number;
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class LineAndCharacter {
        private _line: number = 0;
        private _character: number = 0;

        /// <summary>
        /// Initializes a new instance of a <see cref="LinePosition"/> with the given line and character.
        /// </summary>
        /// <param name="line">
        /// The line of the line position. The first line in a file is defined as line 0 (zero based line numbering).
        /// </param>
        /// <param name="character">
        /// The character position in the line.
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="line"/> or <paramref name="character"/> is less than zero. </exception>
        constructor(line: number, character: number) {
            if (line < 0) {
                throw Errors.argumentOutOfRange("line");
            }

            if (character < 0) {
                throw Errors.argumentOutOfRange("character");
            }

            this._line = line;
            this._character = character;
        }

        public line(): number {
            return this._line;
        }

        public character(): number {
            return this._character;
        }
    }
}
///<reference path='References.ts' />

module TypeScript.TextUtilities {
    export function parseLineStarts(text: ISimpleText): number[]{
        var length = text.length();

        // Corner case check
        if (0 === length) {
            var result: number[] = [];
            result.push(0);
            return result;
        }

        var position = 0;
        var index = 0;
        var arrayBuilder: number[] = [];
        var lineNumber = 0;

        // The following loop goes through every character in the text. It is highly
        // performance critical, and thus inlines knowledge about common line breaks
        // and non-line breaks.
        while (index < length) {
            var c = text.charCodeAt(index);
            var lineBreakLength;

            // common case - ASCII & not a line break
            if (c > CharacterCodes.carriageReturn && c <= 127) {
                index++;
                continue;
            }
            else if (c === CharacterCodes.carriageReturn && index + 1 < length && text.charCodeAt(index + 1) === CharacterCodes.lineFeed) {
                lineBreakLength = 2;
            }
            else if (c === CharacterCodes.lineFeed) {
                lineBreakLength = 1;
            }
            else {
                lineBreakLength = TextUtilities.getLengthOfLineBreak(text, index);
            }

            if (0 === lineBreakLength) {
                index++;
            }
            else {
                arrayBuilder.push(position);
                index += lineBreakLength;
                position = index;
                lineNumber++;
            }
        }

        // Create a start for the final line.  
        arrayBuilder.push(position);

        return arrayBuilder;
    }

    export function getLengthOfLineBreakSlow(text: ISimpleText, index: number, c: number): number {
        if (c === CharacterCodes.carriageReturn) {
            var next = index + 1;
            return (next < text.length()) && CharacterCodes.lineFeed === text.charCodeAt(next) ? 2 : 1;
        }
        else if (isAnyLineBreakCharacter(c)) {
            return 1;
        }
        else {
            return 0;
        }
    }

    export function getLengthOfLineBreak(text: ISimpleText, index: number): number {
        var c = text.charCodeAt(index);

        // common case - ASCII & not a line break
        if (c > CharacterCodes.carriageReturn && c <= 127) {
            return 0;
        }

        return getLengthOfLineBreakSlow(text, index, c);
    }

    export function isAnyLineBreakCharacter(c: number): bool {
        return c === CharacterCodes.lineFeed ||
               c === CharacterCodes.carriageReturn ||
               c === CharacterCodes.nextLine ||
               c === CharacterCodes.lineSeparator ||
               c === CharacterCodes.paragraphSeparator;
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class LineMap {
        public static empty = new LineMap([0], 0);

        constructor(private _lineStarts: number[], private length: number) {
        }

        public toJSON(key) {
            return { lineStarts: this._lineStarts, length: this.length };
        }

        public equals(other: LineMap): bool {
            return this.length === other.length &&
                   ArrayUtilities.sequenceEquals(this.lineStarts(), other.lineStarts(), (v1, v2) => v1 === v2);
        }

        public lineStarts(): number[] {
            return this._lineStarts;
        }

        public lineCount(): number {
            return this.lineStarts().length;
        }

        public getPosition(line: number, character: number): number {
            return this.lineStarts()[line] + character;
        }

        public getLineNumberFromPosition(position: number): number {
            if (position < 0 || position > this.length) {
                throw Errors.argumentOutOfRange("position");
            }

            if (position === this.length) {
                // this can happen when the user tried to get the line of items
                // that are at the absolute end of this text (i.e. the EndOfLine
                // token, or missing tokens that are at the end of the text).
                // In this case, we want the last line in the text.
                return this.lineCount() - 1;
            }

            // Binary search to find the right line
            var lineNumber = ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }

            return lineNumber;
        }

        public getLineStartPosition(lineNumber: number): number {
            return this.lineStarts()[lineNumber];
        }

        public fillLineAndCharacterFromPosition(position: number, lineAndCharacter: ILineAndCharacter): void {
            if (position < 0 || position > this.length) {
                throw Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);
            lineAndCharacter.line = lineNumber;
            lineAndCharacter.character = position - this.lineStarts()[lineNumber];
        }

        public getLineAndCharacterFromPosition(position: number): LineAndCharacter {
            if (position < 0 || position > this.length) {
                throw Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            return new LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
        }

        public static fromSimpleText(text: ISimpleText): LineMap {
            var lineStarts = TextUtilities.parseLineStarts(text);

            return new LineMap(lineStarts, text.length());
        }

        public static fromScriptSnapshot(scriptSnapshot: IScriptSnapshot): LineMap {
            return new LineMap(scriptSnapshot.getLineStartPositions(), scriptSnapshot.getLength());
        }

        public static fromString(text: string): LineMap {
            return LineMap.fromSimpleText(SimpleText.fromString(text));
        }
    }
}
///<reference path='References.ts' />

/// <summary>
/// Represents an immutable snapshot of text.
/// </summary>
module TypeScript {
    export interface ISimpleText {
        /// <summary>
        /// Total number of characters in the text source.
        /// </summary>
        length(): number;

        /// <summary>
        /// Copy the count contents of IText starting from sourceIndex to destination starting at
        /// destinationIndex.
        /// </summary>
        copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void;

        substr(start: number, length: number, intern: bool): string;

        /// <summary>
        /// Gets the a new IText that corresponds to the contents of this IText for the given span.
        /// </summary>
        subText(span: TextSpan): ISimpleText;

        charCodeAt(index: number): number;
        lineMap(): LineMap;
    }

    /// <summary>
    /// Represents an immutable snapshot of text.
    /// </summary>
    export interface IText extends ISimpleText {
        /// <summary>
        /// Total number of lines in the text.
        /// </summary>
        lineCount(): number;

        /// <summary>
        /// Returns the collection of line information for the <see cref="T:IText"/> instance.
        /// </summary>
        lines(): ITextLine[];

        /// <summary>
        /// Return the char at position in the IText.
        /// </summary>
        charCodeAt(position: number): number;

        /// <summary>
        /// Gets the line corresponding to the provided line number.
        /// </summary>
        getLineFromLineNumber(lineNumber: number): ITextLine;

        /// <summary>
        /// Gets the line which encompasses the provided position.
        /// </summary>
        getLineFromPosition(position: number): ITextLine;

        /// <summary>
        /// Gets the number of the line that contains the character at the specified position.
        /// </summary>
        getLineNumberFromPosition(position: number): number;

        /// <summary>
        /// Gets a line number, and position within that line, for the character at the 
        /// specified position
        /// </summary>
        getLinePosition(position: number): LineAndCharacter;

        /// <summary>
        /// Returns a string representation of the contents of this IText within the given span.
        /// </summary>
        toString(span?: TextSpan): string;

        /// <summary>
        /// Gets the a new IText that corresponds to the contents of this IText for the given span.
        /// </summary>
        subText(span: TextSpan): IText;
    }
}
﻿///<reference path='References.ts' />

module TypeScript {
    export class ScannerUtilities {
        public static identifierKind(array: number[], startIndex: number, length: number): SyntaxKind {
            switch (length) {
            case 2:
                // do, if, in
            switch(array[startIndex]) {
            case CharacterCodes.d:
                // do
                return (array[startIndex + 1] === CharacterCodes.o) ? SyntaxKind.DoKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.i:
                // if, in
                switch(array[startIndex + 1]) {
                case CharacterCodes.f:
                    // if
                    return SyntaxKind.IfKeyword;
                case CharacterCodes.n:
                    // in
                    return SyntaxKind.InKeyword;
                default:
                    return SyntaxKind.IdentifierName;
                }

            default:
                return SyntaxKind.IdentifierName;
            }

            case 3:
                // for, new, try, var, let, any, get, set
            switch(array[startIndex]) {
            case CharacterCodes.f:
                // for
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.r) ? SyntaxKind.ForKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.n:
                // new
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.w) ? SyntaxKind.NewKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.t:
                // try
                return (array[startIndex + 1] === CharacterCodes.r && array[startIndex + 2] === CharacterCodes.y) ? SyntaxKind.TryKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.v:
                // var
                return (array[startIndex + 1] === CharacterCodes.a && array[startIndex + 2] === CharacterCodes.r) ? SyntaxKind.VarKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.l:
                // let
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.t) ? SyntaxKind.LetKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.a:
                // any
                return (array[startIndex + 1] === CharacterCodes.n && array[startIndex + 2] === CharacterCodes.y) ? SyntaxKind.AnyKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.g:
                // get
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.t) ? SyntaxKind.GetKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.s:
                // set
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.t) ? SyntaxKind.SetKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

            case 4:
                // case, else, null, this, true, void, with, enum, bool
            switch(array[startIndex]) {
            case CharacterCodes.c:
                // case
                return (array[startIndex + 1] === CharacterCodes.a && array[startIndex + 2] === CharacterCodes.s && array[startIndex + 3] === CharacterCodes.e) ? SyntaxKind.CaseKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.e:
                // else, enum
                switch(array[startIndex + 1]) {
                case CharacterCodes.l:
                    // else
                    return (array[startIndex + 2] === CharacterCodes.s && array[startIndex + 3] === CharacterCodes.e) ? SyntaxKind.ElseKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.n:
                    // enum
                    return (array[startIndex + 2] === CharacterCodes.u && array[startIndex + 3] === CharacterCodes.m) ? SyntaxKind.EnumKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.n:
                // null
                return (array[startIndex + 1] === CharacterCodes.u && array[startIndex + 2] === CharacterCodes.l && array[startIndex + 3] === CharacterCodes.l) ? SyntaxKind.NullKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.t:
                // this, true
                switch(array[startIndex + 1]) {
                case CharacterCodes.h:
                    // this
                    return (array[startIndex + 2] === CharacterCodes.i && array[startIndex + 3] === CharacterCodes.s) ? SyntaxKind.ThisKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.r:
                    // true
                    return (array[startIndex + 2] === CharacterCodes.u && array[startIndex + 3] === CharacterCodes.e) ? SyntaxKind.TrueKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.v:
                // void
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.i && array[startIndex + 3] === CharacterCodes.d) ? SyntaxKind.VoidKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.w:
                // with
                return (array[startIndex + 1] === CharacterCodes.i && array[startIndex + 2] === CharacterCodes.t && array[startIndex + 3] === CharacterCodes.h) ? SyntaxKind.WithKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.b:
                // bool
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.o && array[startIndex + 3] === CharacterCodes.l) ? SyntaxKind.BoolKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

            case 5:
                // break, catch, false, throw, while, class, const, super, yield
            switch(array[startIndex]) {
            case CharacterCodes.b:
                // break
                return (array[startIndex + 1] === CharacterCodes.r && array[startIndex + 2] === CharacterCodes.e && array[startIndex + 3] === CharacterCodes.a && array[startIndex + 4] === CharacterCodes.k) ? SyntaxKind.BreakKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.c:
                // catch, class, const
                switch(array[startIndex + 1]) {
                case CharacterCodes.a:
                    // catch
                    return (array[startIndex + 2] === CharacterCodes.t && array[startIndex + 3] === CharacterCodes.c && array[startIndex + 4] === CharacterCodes.h) ? SyntaxKind.CatchKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.l:
                    // class
                    return (array[startIndex + 2] === CharacterCodes.a && array[startIndex + 3] === CharacterCodes.s && array[startIndex + 4] === CharacterCodes.s) ? SyntaxKind.ClassKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.o:
                    // const
                    return (array[startIndex + 2] === CharacterCodes.n && array[startIndex + 3] === CharacterCodes.s && array[startIndex + 4] === CharacterCodes.t) ? SyntaxKind.ConstKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.f:
                // false
                return (array[startIndex + 1] === CharacterCodes.a && array[startIndex + 2] === CharacterCodes.l && array[startIndex + 3] === CharacterCodes.s && array[startIndex + 4] === CharacterCodes.e) ? SyntaxKind.FalseKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.t:
                // throw
                return (array[startIndex + 1] === CharacterCodes.h && array[startIndex + 2] === CharacterCodes.r && array[startIndex + 3] === CharacterCodes.o && array[startIndex + 4] === CharacterCodes.w) ? SyntaxKind.ThrowKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.w:
                // while
                return (array[startIndex + 1] === CharacterCodes.h && array[startIndex + 2] === CharacterCodes.i && array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.e) ? SyntaxKind.WhileKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.s:
                // super
                return (array[startIndex + 1] === CharacterCodes.u && array[startIndex + 2] === CharacterCodes.p && array[startIndex + 3] === CharacterCodes.e && array[startIndex + 4] === CharacterCodes.r) ? SyntaxKind.SuperKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.y:
                // yield
                return (array[startIndex + 1] === CharacterCodes.i && array[startIndex + 2] === CharacterCodes.e && array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.d) ? SyntaxKind.YieldKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

            case 6:
                // delete, return, switch, typeof, export, import, public, static, module, number, string
            switch(array[startIndex]) {
            case CharacterCodes.d:
                // delete
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.l && array[startIndex + 3] === CharacterCodes.e && array[startIndex + 4] === CharacterCodes.t && array[startIndex + 5] === CharacterCodes.e) ? SyntaxKind.DeleteKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.r:
                // return
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.t && array[startIndex + 3] === CharacterCodes.u && array[startIndex + 4] === CharacterCodes.r && array[startIndex + 5] === CharacterCodes.n) ? SyntaxKind.ReturnKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.s:
                // switch, static, string
                switch(array[startIndex + 1]) {
                case CharacterCodes.w:
                    // switch
                    return (array[startIndex + 2] === CharacterCodes.i && array[startIndex + 3] === CharacterCodes.t && array[startIndex + 4] === CharacterCodes.c && array[startIndex + 5] === CharacterCodes.h) ? SyntaxKind.SwitchKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.t:
                    // static, string
                    switch(array[startIndex + 2]) {
                    case CharacterCodes.a:
                        // static
                        return (array[startIndex + 3] === CharacterCodes.t && array[startIndex + 4] === CharacterCodes.i && array[startIndex + 5] === CharacterCodes.c) ? SyntaxKind.StaticKeyword : SyntaxKind.IdentifierName;
                    case CharacterCodes.r:
                        // string
                        return (array[startIndex + 3] === CharacterCodes.i && array[startIndex + 4] === CharacterCodes.n && array[startIndex + 5] === CharacterCodes.g) ? SyntaxKind.StringKeyword : SyntaxKind.IdentifierName;
                    default:
                        return SyntaxKind.IdentifierName;
                    }

                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.t:
                // typeof
                return (array[startIndex + 1] === CharacterCodes.y && array[startIndex + 2] === CharacterCodes.p && array[startIndex + 3] === CharacterCodes.e && array[startIndex + 4] === CharacterCodes.o && array[startIndex + 5] === CharacterCodes.f) ? SyntaxKind.TypeOfKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.e:
                // export
                return (array[startIndex + 1] === CharacterCodes.x && array[startIndex + 2] === CharacterCodes.p && array[startIndex + 3] === CharacterCodes.o && array[startIndex + 4] === CharacterCodes.r && array[startIndex + 5] === CharacterCodes.t) ? SyntaxKind.ExportKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.i:
                // import
                return (array[startIndex + 1] === CharacterCodes.m && array[startIndex + 2] === CharacterCodes.p && array[startIndex + 3] === CharacterCodes.o && array[startIndex + 4] === CharacterCodes.r && array[startIndex + 5] === CharacterCodes.t) ? SyntaxKind.ImportKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.p:
                // public
                return (array[startIndex + 1] === CharacterCodes.u && array[startIndex + 2] === CharacterCodes.b && array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.i && array[startIndex + 5] === CharacterCodes.c) ? SyntaxKind.PublicKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.m:
                // module
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.d && array[startIndex + 3] === CharacterCodes.u && array[startIndex + 4] === CharacterCodes.l && array[startIndex + 5] === CharacterCodes.e) ? SyntaxKind.ModuleKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.n:
                // number
                return (array[startIndex + 1] === CharacterCodes.u && array[startIndex + 2] === CharacterCodes.m && array[startIndex + 3] === CharacterCodes.b && array[startIndex + 4] === CharacterCodes.e && array[startIndex + 5] === CharacterCodes.r) ? SyntaxKind.NumberKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

            case 7:
                // default, finally, extends, package, private, boolean, declare
            switch(array[startIndex]) {
            case CharacterCodes.d:
                // default, declare
                switch(array[startIndex + 1]) {
                case CharacterCodes.e:
                    // default, declare
                    switch(array[startIndex + 2]) {
                    case CharacterCodes.f:
                        // default
                        return (array[startIndex + 3] === CharacterCodes.a && array[startIndex + 4] === CharacterCodes.u && array[startIndex + 5] === CharacterCodes.l && array[startIndex + 6] === CharacterCodes.t) ? SyntaxKind.DefaultKeyword : SyntaxKind.IdentifierName;
                    case CharacterCodes.c:
                        // declare
                        return (array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.a && array[startIndex + 5] === CharacterCodes.r && array[startIndex + 6] === CharacterCodes.e) ? SyntaxKind.DeclareKeyword : SyntaxKind.IdentifierName;
                    default:
                        return SyntaxKind.IdentifierName;
                    }

                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.f:
                // finally
                return (array[startIndex + 1] === CharacterCodes.i && array[startIndex + 2] === CharacterCodes.n && array[startIndex + 3] === CharacterCodes.a && array[startIndex + 4] === CharacterCodes.l && array[startIndex + 5] === CharacterCodes.l && array[startIndex + 6] === CharacterCodes.y) ? SyntaxKind.FinallyKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.e:
                // extends
                return (array[startIndex + 1] === CharacterCodes.x && array[startIndex + 2] === CharacterCodes.t && array[startIndex + 3] === CharacterCodes.e && array[startIndex + 4] === CharacterCodes.n && array[startIndex + 5] === CharacterCodes.d && array[startIndex + 6] === CharacterCodes.s) ? SyntaxKind.ExtendsKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.p:
                // package, private
                switch(array[startIndex + 1]) {
                case CharacterCodes.a:
                    // package
                    return (array[startIndex + 2] === CharacterCodes.c && array[startIndex + 3] === CharacterCodes.k && array[startIndex + 4] === CharacterCodes.a && array[startIndex + 5] === CharacterCodes.g && array[startIndex + 6] === CharacterCodes.e) ? SyntaxKind.PackageKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.r:
                    // private
                    return (array[startIndex + 2] === CharacterCodes.i && array[startIndex + 3] === CharacterCodes.v && array[startIndex + 4] === CharacterCodes.a && array[startIndex + 5] === CharacterCodes.t && array[startIndex + 6] === CharacterCodes.e) ? SyntaxKind.PrivateKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            case CharacterCodes.b:
                // boolean
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.o && array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.e && array[startIndex + 5] === CharacterCodes.a && array[startIndex + 6] === CharacterCodes.n) ? SyntaxKind.BooleanKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

            case 8:
                // continue, debugger, function
            switch(array[startIndex]) {
            case CharacterCodes.c:
                // continue
                return (array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.n && array[startIndex + 3] === CharacterCodes.t && array[startIndex + 4] === CharacterCodes.i && array[startIndex + 5] === CharacterCodes.n && array[startIndex + 6] === CharacterCodes.u && array[startIndex + 7] === CharacterCodes.e) ? SyntaxKind.ContinueKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.d:
                // debugger
                return (array[startIndex + 1] === CharacterCodes.e && array[startIndex + 2] === CharacterCodes.b && array[startIndex + 3] === CharacterCodes.u && array[startIndex + 4] === CharacterCodes.g && array[startIndex + 5] === CharacterCodes.g && array[startIndex + 6] === CharacterCodes.e && array[startIndex + 7] === CharacterCodes.r) ? SyntaxKind.DebuggerKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.f:
                // function
                return (array[startIndex + 1] === CharacterCodes.u && array[startIndex + 2] === CharacterCodes.n && array[startIndex + 3] === CharacterCodes.c && array[startIndex + 4] === CharacterCodes.t && array[startIndex + 5] === CharacterCodes.i && array[startIndex + 6] === CharacterCodes.o && array[startIndex + 7] === CharacterCodes.n) ? SyntaxKind.FunctionKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

            case 9:
                // interface, protected
            switch(array[startIndex]) {
            case CharacterCodes.i:
                // interface
                return (array[startIndex + 1] === CharacterCodes.n && array[startIndex + 2] === CharacterCodes.t && array[startIndex + 3] === CharacterCodes.e && array[startIndex + 4] === CharacterCodes.r && array[startIndex + 5] === CharacterCodes.f && array[startIndex + 6] === CharacterCodes.a && array[startIndex + 7] === CharacterCodes.c && array[startIndex + 8] === CharacterCodes.e) ? SyntaxKind.InterfaceKeyword : SyntaxKind.IdentifierName;
            case CharacterCodes.p:
                // protected
                return (array[startIndex + 1] === CharacterCodes.r && array[startIndex + 2] === CharacterCodes.o && array[startIndex + 3] === CharacterCodes.t && array[startIndex + 4] === CharacterCodes.e && array[startIndex + 5] === CharacterCodes.c && array[startIndex + 6] === CharacterCodes.t && array[startIndex + 7] === CharacterCodes.e && array[startIndex + 8] === CharacterCodes.d) ? SyntaxKind.ProtectedKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }

            case 10:
                // instanceof, implements
            switch(array[startIndex]) {
            case CharacterCodes.i:
                // instanceof, implements
                switch(array[startIndex + 1]) {
                case CharacterCodes.n:
                    // instanceof
                    return (array[startIndex + 2] === CharacterCodes.s && array[startIndex + 3] === CharacterCodes.t && array[startIndex + 4] === CharacterCodes.a && array[startIndex + 5] === CharacterCodes.n && array[startIndex + 6] === CharacterCodes.c && array[startIndex + 7] === CharacterCodes.e && array[startIndex + 8] === CharacterCodes.o && array[startIndex + 9] === CharacterCodes.f) ? SyntaxKind.InstanceOfKeyword : SyntaxKind.IdentifierName;
                case CharacterCodes.m:
                    // implements
                    return (array[startIndex + 2] === CharacterCodes.p && array[startIndex + 3] === CharacterCodes.l && array[startIndex + 4] === CharacterCodes.e && array[startIndex + 5] === CharacterCodes.m && array[startIndex + 6] === CharacterCodes.e && array[startIndex + 7] === CharacterCodes.n && array[startIndex + 8] === CharacterCodes.t && array[startIndex + 9] === CharacterCodes.s) ? SyntaxKind.ImplementsKeyword : SyntaxKind.IdentifierName;
                default:
                    return SyntaxKind.IdentifierName;
                }

            default:
                return SyntaxKind.IdentifierName;
            }

            case 11:
                // constructor
            return (array[startIndex] === CharacterCodes.c && array[startIndex + 1] === CharacterCodes.o && array[startIndex + 2] === CharacterCodes.n && array[startIndex + 3] === CharacterCodes.s && array[startIndex + 4] === CharacterCodes.t && array[startIndex + 5] === CharacterCodes.r && array[startIndex + 6] === CharacterCodes.u && array[startIndex + 7] === CharacterCodes.c && array[startIndex + 8] === CharacterCodes.t && array[startIndex + 9] === CharacterCodes.o && array[startIndex + 10] === CharacterCodes.r) ? SyntaxKind.ConstructorKeyword : SyntaxKind.IdentifierName;
            default:
                return SyntaxKind.IdentifierName;
            }
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class StringUtilities {
        public static fromCharCodeArray(array: number[]): string {
            return String.fromCharCode.apply(null, array);
        }

        public static endsWith(string: string, value: string): bool {
            return string.substring(string.length - value.length, string.length) === value;
        }

        public static startsWith(string: string, value: string): bool {
            return string.substr(0, value.length) === value;
        }

        public static copyTo(source: string, sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            for (var i = 0; i < count; i++) {
                destination[destinationIndex + i] = source.charCodeAt(sourceIndex + i);
            }
        }

        public static repeat(value: string, count: number) {
            return Array(count + 1).join(value);
        }
    }
}
///<reference path='References.ts' />

module TypeScript.Collections {
    export var DefaultStringTableCapacity = 256;

    class StringTableEntry {
        constructor(public Text: string,
                    public HashCode: number,
                    public Next: StringTableEntry) {
        }
    }

    // A table of interned strings.  Faster and better than an arbitrary hashtable for the needs of the
    // scanner. Specifically, the scanner operates over a sliding window of characters, with a start 
    // and end pointer for the current lexeme.  The scanner then wants to get the *interned* string
    // represented by that subsection.
    //
    // Importantly, if the string is already interned, then it wants ask "is the string represented by 
    // this section of a char array contained within the table" in a non-allocating fashion.  i.e. if 
    // you have "[' ', 'p', 'u', 'b', 'l', 'i', 'c', ' ']" and you ask to get the string represented by
    //  range [1, 7), then this table will return "public" without any allocations if that value was 
    // already in the table.
    //
    // Of course, if the value is not in the table then there will be an initial cost to allocate the 
    // string and the bucket for the table.  However, that is only incurred the first time each unique 
    // string is added.
    export class StringTable {
        // TODO: uncomment this once typecheck bug is fixed.
        private entries /*: StringTableEntry[]*/ = [];
        private count: number = 0;

        constructor(capacity) {
            var size = Hash.getPrime(capacity);
            this.entries = ArrayUtilities.createArray(size, null);
        }

        public addCharArray(key: number[], start: number, len: number): string {
            // Compute the hash for this key.  Also ensure that it fits within 31 bits  (so that it 
            // stays a non-heap integer, and so we can index into the array safely).
            var hashCode = Hash.computeSimple31BitCharArrayHashCode(key, start, len) & 0x7FFFFFFF;
            // Debug.assert(hashCode > 0);

            // First see if we already have the string represented by "key[start, start + len)" already
            // present in this table.  If we do, just return that string.  Do this without any 
            // allocations
            var entry = this.findCharArrayEntry(key, start, len, hashCode);
            if (entry !== null) {
                return entry.Text;
            }

            // We don't have an entry for that string in our table.  Convert that 
            var slice: number[] = key.slice(start, start + len);
            return this.addEntry(StringUtilities.fromCharCodeArray(slice), hashCode);
        }

        private findCharArrayEntry(key: number[], start: number, len: number, hashCode: number) {
            for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                if (e.HashCode === hashCode && StringTable.textCharArrayEquals(e.Text, key, start, len)) {
                    return e;
                }
            }

            return null;
        }

        private addEntry(text: string, hashCode: number): string {
            var index = hashCode % this.entries.length;

            var e = new StringTableEntry(text, hashCode, this.entries[index]);

            this.entries[index] = e;

            // We grow when our load factor equals 1.  I tried different load factors (like .75 and 
            // .5), however they seemed to have no effect on running time.  With a load factor of 1
            // we seem to get about 80% slot fill rate with an average of around 1.25 table entries 
            // per slot.
            if (this.count === this.entries.length) {
                this.grow();
            }

            this.count++;
            return e.Text;
        }

        //private dumpStats() {
        //    var standardOut = Environment.standardOut;

        //    standardOut.WriteLine("----------------------")
        //    standardOut.WriteLine("String table stats");
        //    standardOut.WriteLine("Count            : " + this.count);
        //    standardOut.WriteLine("Entries Length   : " + this.entries.length);

        //    var longestSlot = 0;
        //    var occupiedSlots = 0;
        //    for (var i = 0; i < this.entries.length; i++) {
        //        if (this.entries[i] !== null) {
        //            occupiedSlots++;

        //            var current = this.entries[i];
        //            var slotCount = 0;
        //            while (current !== null) {
        //                slotCount++;
        //                current = current.Next;
        //            }

        //            longestSlot = MathPrototype.max(longestSlot, slotCount);
        //        }
        //    }

        //    standardOut.WriteLine("Occupied slots   : " + occupiedSlots);
        //    standardOut.WriteLine("Longest  slot    : " + longestSlot);
        //    standardOut.WriteLine("Avg Length/Slot  : " + (this.count / occupiedSlots));
        //    standardOut.WriteLine("----------------------");
        //}

        private grow(): void {
            // this.dumpStats();

            var newSize = Hash.expandPrime(this.entries.length);

            var oldEntries = this.entries;
            var newEntries: StringTableEntry[] = ArrayUtilities.createArray(newSize, null);

            this.entries = newEntries;

            for (var i = 0; i < oldEntries.length; i++) {
                var e = oldEntries[i];
                while (e !== null) {
                    var newIndex = e.HashCode % newSize;
                    var tmp = e.Next;
                    e.Next = newEntries[newIndex];
                    newEntries[newIndex] = e;
                    e = tmp;
                }
            }

            // this.dumpStats();
        }

        private static textCharArrayEquals(text: string, array: number[], start: number, length: number): bool {
            if (text.length !== length) {
                return false;
            }

            var s = start;
            for (var i = 0; i < length; i++) {
                if (text.charCodeAt(i) !== array[s]) {
                    return false;
                }

                s++;
            }

            return true;
        }
    }

    export var DefaultStringTable = new StringTable(DefaultStringTableCapacity);
}
///<reference path='References.ts' />

module TypeScript {
    export enum DiagnosticCode {
        Unrecognized_escape_sequence,
        Unexpected_character_0,
        Missing_closing_quote_character,
        Identifier_expected,
        _0_keyword_expected,
        _0_expected,
        Identifier_expected__0_is_a_keyword,
        Automatic_semicolon_insertion_not_allowed,
        Unexpected_token__0_expected,
        Trailing_separator_not_allowed,
        _StarSlash__expected,
        _public_or_private_modifier_must_precede__static_,
        Unexpected_token_,
    }

    export class DiagnosticMessages1 {
        private static codeToFormatString: string[] = [];
        private static initializeStaticData(): void {
            if (DiagnosticMessages1.codeToFormatString.length === 0) {
                DiagnosticMessages1.codeToFormatString[DiagnosticCode.Unrecognized_escape_sequence] = "Unrecognized escape sequence.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode.Unexpected_character_0] = "Unexpected character {0}.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode.Missing_closing_quote_character] = "Missing close quote character.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode.Identifier_expected] = "Identifier expected.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode._0_keyword_expected] = "'{0}' keyword expected.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode._0_expected] = "'{0}' expected.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode.Identifier_expected__0_is_a_keyword] = "Identifier expected; '{0}' is a keyword.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode.Automatic_semicolon_insertion_not_allowed] = "Automatic semicolon insertion not allowed.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode.Unexpected_token__0_expected] = "Unexpected token; '{0}' expected.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode.Trailing_separator_not_allowed] = "Trailing separator not allowed.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode._StarSlash__expected] = "'*/' expected.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode._public_or_private_modifier_must_precede__static_] = "'public' or 'private' modifier must precede 'static'.";
                DiagnosticMessages1.codeToFormatString[DiagnosticCode.Unexpected_token_] = "Unexpected token.";
            }
        }

        private static getFormatString(code: DiagnosticCode): string {
            DiagnosticMessages1.initializeStaticData();
            return DiagnosticMessages1.codeToFormatString[code];
        }

        public static getDiagnosticMessage(code: DiagnosticCode, args: any[]): string {
            var formatString = DiagnosticMessages1.getFormatString(code);

            var result = formatString.replace(/{(\d+)}/g, function (match, num) {
                return typeof args[num] !== 'undefined'
                    ? args[num]
                    : match;
            });

            return result;
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class Diagnostic1 {
        private _diagnosticCode: DiagnosticCode;
        private _arguments: any[];

        constructor(diagnosticCode: DiagnosticCode, arguments: any[]) {
            this._diagnosticCode = diagnosticCode;
            this._arguments = (arguments && arguments.length > 0) ? arguments : null;
        }

        /// <summary>
        /// The error code, as an integer.
        /// </summary>
        public diagnosticCode(): DiagnosticCode {
            return this._diagnosticCode;
        }

        /// <summary>
        /// If a derived class has additional information about other referenced symbols, it can
        /// expose the locations of those symbols in a general way, so they can be reported along
        /// with the error.
        /// </summary>
        public additionalLocations(): Location[] {
            return [];
        }

        /// <summary>
        /// Get the text of the message in the given language.
        /// </summary>
        public message(): string {
            return DiagnosticMessages1.getDiagnosticMessage(this._diagnosticCode, this._arguments);
        }

        public static equals(diagnostic1: Diagnostic1, diagnostic2: Diagnostic1): bool {
            return diagnostic1._diagnosticCode === diagnostic2._diagnosticCode &&
                   ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, (v1, v2) => v1 === v2);
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export interface IDiagnostic {
        fileName(): string;
        start(): number;
        length(): number;
        message(): string;
    }

     export class Diagnostic implements IDiagnostic {
        private _fileName: string;
        private _start: number;
        private _length: number;
        private _message: string;

        constructor(start: number, length: number, fileName: string, message: string) {
            this._fileName = fileName;
            this._start = start;
            this._length = length;
            this._message = message;
        }

        public fileName(): string {
            return this._fileName;
        }

        public start(): number {
            return this._start;
        }

        public length(): number {
            return this._length;
        }

        public message(): string {
            return this._message;
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class SyntaxDiagnostic extends Diagnostic1 implements IDiagnostic {
        private _fileName: string;
        private _start: number;
        private _length: number;

        constructor(fileName: string, start: number, length: number, code: DiagnosticCode, args: any[]) {
            super(code, args);

            if (length < 0) {
                throw Errors.argumentOutOfRange("width");
            }

            this._fileName = fileName;
            this._start = start;
            this._length = length;
        }

        public toJSON(key) {
            var result: any = {};
            result._position = this._start;
            result._width = this._length;
            result._diagnosticCode = (<any>DiagnosticCode)._map[this.diagnosticCode()];

            var arguments = (<any>this)._arguments;
            if (arguments && arguments.length > 0) {
                result._arguments = arguments;
            }

            return result;
        }

        public fileName(): string {
            return this._fileName;
        }

        public start(): number {
            return this._start;
        }

        public length(): number {
            return this._length;
        }

        public static equals(diagnostic1: SyntaxDiagnostic, diagnostic2: SyntaxDiagnostic): bool {
            return diagnostic1._start === diagnostic2._start &&
                   diagnostic1._length === diagnostic2._length &&
                   Diagnostic1.equals(diagnostic1, diagnostic2);
        }
    }
}
﻿///<reference path='References.ts' />

module TypeScript.Syntax {
    export class VariableWidthTokenWithNoTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _textOrWidth: any;
        private _value: any = null;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, textOrWidth: any) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._textOrWidth = textOrWidth;
        }

        public clone(): ISyntaxToken {
            return new VariableWidthTokenWithNoTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._textOrWidth);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return this.width(); }
        private start(): number { return this._fullStart; }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; }

        public text(): string {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(
                    this.start(), this._textOrWidth, /*intern:*/ this.tokenKind === SyntaxKind.IdentifierName);
            }

            return this._textOrWidth;
        }

        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return this._value || (this._value = value(this)); }
        public hasLeadingTrivia(): bool { return false; }
        public hasLeadingComment(): bool { return false; }
        public hasLeadingNewLine(): bool { return false; }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return 0; }
        public leadingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasTrailingTrivia(): bool { return false; }
        public hasTrailingComment(): bool { return false; }
        public hasTrailingNewLine(): bool { return false; }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return 0; }
        public trailingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        public firstToken(): ISyntaxToken { return this; }
        public lastToken(): ISyntaxToken { return this; }
        public isTypeScriptSpecific(): bool { return false; }
        public hasZeroWidthToken(): bool { return this.fullWidth() === 0; }
        public accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        public hasRegularExpressionToken(): bool { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realizeToken(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class VariableWidthTokenWithLeadingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _leadingTriviaInfo: number;
        private _textOrWidth: any;
        private _value: any = null;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, leadingTriviaInfo: number, textOrWidth: any) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
            this._textOrWidth = textOrWidth;
        }

        public clone(): ISyntaxToken {
            return new VariableWidthTokenWithLeadingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._leadingTriviaInfo,
                this._textOrWidth);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return getTriviaWidth(this._leadingTriviaInfo) + this.width(); }
        private start(): number { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; }

        public text(): string {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(
                    this.start(), this._textOrWidth, /*intern:*/ this.tokenKind === SyntaxKind.IdentifierName);
            }

            return this._textOrWidth;
        }

        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return this._value || (this._value = value(this)); }
        public hasLeadingTrivia(): bool { return true; }
        public hasLeadingComment(): bool { return hasTriviaComment(this._leadingTriviaInfo); }
        public hasLeadingNewLine(): bool { return hasTriviaNewLine(this._leadingTriviaInfo); }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return getTriviaWidth(this._leadingTriviaInfo); }
        public leadingTrivia(): ISyntaxTriviaList { return Scanner1.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), /*isTrailing:*/ false); }

        public hasTrailingTrivia(): bool { return false; }
        public hasTrailingComment(): bool { return false; }
        public hasTrailingNewLine(): bool { return false; }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return 0; }
        public trailingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        public firstToken(): ISyntaxToken { return this; }
        public lastToken(): ISyntaxToken { return this; }
        public isTypeScriptSpecific(): bool { return false; }
        public hasZeroWidthToken(): bool { return this.fullWidth() === 0; }
        public accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        public hasRegularExpressionToken(): bool { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realizeToken(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class VariableWidthTokenWithTrailingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _textOrWidth: any;
        private _value: any = null;
        private _trailingTriviaInfo: number;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, textOrWidth: any, trailingTriviaInfo: number) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._textOrWidth = textOrWidth;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }

        public clone(): ISyntaxToken {
            return new VariableWidthTokenWithTrailingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._textOrWidth,
                this._trailingTriviaInfo);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return this.width() + getTriviaWidth(this._trailingTriviaInfo); }
        private start(): number { return this._fullStart; }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; }

        public text(): string {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(
                    this.start(), this._textOrWidth, /*intern:*/ this.tokenKind === SyntaxKind.IdentifierName);
            }

            return this._textOrWidth;
        }

        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return this._value || (this._value = value(this)); }
        public hasLeadingTrivia(): bool { return false; }
        public hasLeadingComment(): bool { return false; }
        public hasLeadingNewLine(): bool { return false; }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return 0; }
        public leadingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasTrailingTrivia(): bool { return true; }
        public hasTrailingComment(): bool { return hasTriviaComment(this._trailingTriviaInfo); }
        public hasTrailingNewLine(): bool { return hasTriviaNewLine(this._trailingTriviaInfo); }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return getTriviaWidth(this._trailingTriviaInfo); }
        public trailingTrivia(): ISyntaxTriviaList { return Scanner1.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), /*isTrailing:*/ true); }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        public firstToken(): ISyntaxToken { return this; }
        public lastToken(): ISyntaxToken { return this; }
        public isTypeScriptSpecific(): bool { return false; }
        public hasZeroWidthToken(): bool { return this.fullWidth() === 0; }
        public accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        public hasRegularExpressionToken(): bool { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realizeToken(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class VariableWidthTokenWithLeadingAndTrailingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _leadingTriviaInfo: number;
        private _textOrWidth: any;
        private _value: any = null;
        private _trailingTriviaInfo: number;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, leadingTriviaInfo: number, textOrWidth: any, trailingTriviaInfo: number) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
            this._textOrWidth = textOrWidth;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }

        public clone(): ISyntaxToken {
            return new VariableWidthTokenWithLeadingAndTrailingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._leadingTriviaInfo,
                this._textOrWidth,
                this._trailingTriviaInfo);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo); }
        private start(): number { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length; }

        public text(): string {
            if (typeof this._textOrWidth === 'number') {
                this._textOrWidth = this._sourceText.substr(
                    this.start(), this._textOrWidth, /*intern:*/ this.tokenKind === SyntaxKind.IdentifierName);
            }

            return this._textOrWidth;
        }

        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return this._value || (this._value = value(this)); }
        public hasLeadingTrivia(): bool { return true; }
        public hasLeadingComment(): bool { return hasTriviaComment(this._leadingTriviaInfo); }
        public hasLeadingNewLine(): bool { return hasTriviaNewLine(this._leadingTriviaInfo); }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return getTriviaWidth(this._leadingTriviaInfo); }
        public leadingTrivia(): ISyntaxTriviaList { return Scanner1.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), /*isTrailing:*/ false); }

        public hasTrailingTrivia(): bool { return true; }
        public hasTrailingComment(): bool { return hasTriviaComment(this._trailingTriviaInfo); }
        public hasTrailingNewLine(): bool { return hasTriviaNewLine(this._trailingTriviaInfo); }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return getTriviaWidth(this._trailingTriviaInfo); }
        public trailingTrivia(): ISyntaxTriviaList { return Scanner1.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), /*isTrailing:*/ true); }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        public firstToken(): ISyntaxToken { return this; }
        public lastToken(): ISyntaxToken { return this; }
        public isTypeScriptSpecific(): bool { return false; }
        public hasZeroWidthToken(): bool { return this.fullWidth() === 0; }
        public accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        public hasRegularExpressionToken(): bool { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realizeToken(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class FixedWidthTokenWithNoTrivia implements ISyntaxToken {
        public tokenKind: SyntaxKind;

        constructor(kind: SyntaxKind) {
            this.tokenKind = kind;
        }

        public clone(): ISyntaxToken {
            return new FixedWidthTokenWithNoTrivia(
                this.tokenKind);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return this.width(); }
        public width(): number { return this.text().length; }
        public text(): string { return SyntaxFacts.getText(this.tokenKind); }
        public fullText(): string { return this.text(); }

        public value(): any { return null; }
        public hasLeadingTrivia(): bool { return false; }
        public hasLeadingComment(): bool { return false; }
        public hasLeadingNewLine(): bool { return false; }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return 0; }
        public leadingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasTrailingTrivia(): bool { return false; }
        public hasTrailingComment(): bool { return false; }
        public hasTrailingNewLine(): bool { return false; }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return 0; }
        public trailingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        public firstToken(): ISyntaxToken { return this; }
        public lastToken(): ISyntaxToken { return this; }
        public isTypeScriptSpecific(): bool { return false; }
        public hasZeroWidthToken(): bool { return this.fullWidth() === 0; }
        public accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        public hasRegularExpressionToken(): bool { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realizeToken(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class FixedWidthTokenWithLeadingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _leadingTriviaInfo: number;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, leadingTriviaInfo: number) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
        }

        public clone(): ISyntaxToken {
            return new FixedWidthTokenWithLeadingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._leadingTriviaInfo);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return getTriviaWidth(this._leadingTriviaInfo) + this.width(); }
        private start(): number { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return this.text().length; }
        public text(): string { return SyntaxFacts.getText(this.tokenKind); }
        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return null; }
        public hasLeadingTrivia(): bool { return true; }
        public hasLeadingComment(): bool { return hasTriviaComment(this._leadingTriviaInfo); }
        public hasLeadingNewLine(): bool { return hasTriviaNewLine(this._leadingTriviaInfo); }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return getTriviaWidth(this._leadingTriviaInfo); }
        public leadingTrivia(): ISyntaxTriviaList { return Scanner1.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), /*isTrailing:*/ false); }

        public hasTrailingTrivia(): bool { return false; }
        public hasTrailingComment(): bool { return false; }
        public hasTrailingNewLine(): bool { return false; }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return 0; }
        public trailingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        public firstToken(): ISyntaxToken { return this; }
        public lastToken(): ISyntaxToken { return this; }
        public isTypeScriptSpecific(): bool { return false; }
        public hasZeroWidthToken(): bool { return this.fullWidth() === 0; }
        public accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        public hasRegularExpressionToken(): bool { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realizeToken(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class FixedWidthTokenWithTrailingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _trailingTriviaInfo: number;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, trailingTriviaInfo: number) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }

        public clone(): ISyntaxToken {
            return new FixedWidthTokenWithTrailingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._trailingTriviaInfo);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return this.width() + getTriviaWidth(this._trailingTriviaInfo); }
        private start(): number { return this._fullStart; }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return this.text().length; }
        public text(): string { return SyntaxFacts.getText(this.tokenKind); }
        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return null; }
        public hasLeadingTrivia(): bool { return false; }
        public hasLeadingComment(): bool { return false; }
        public hasLeadingNewLine(): bool { return false; }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return 0; }
        public leadingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }

        public hasTrailingTrivia(): bool { return true; }
        public hasTrailingComment(): bool { return hasTriviaComment(this._trailingTriviaInfo); }
        public hasTrailingNewLine(): bool { return hasTriviaNewLine(this._trailingTriviaInfo); }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return getTriviaWidth(this._trailingTriviaInfo); }
        public trailingTrivia(): ISyntaxTriviaList { return Scanner1.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), /*isTrailing:*/ true); }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        public firstToken(): ISyntaxToken { return this; }
        public lastToken(): ISyntaxToken { return this; }
        public isTypeScriptSpecific(): bool { return false; }
        public hasZeroWidthToken(): bool { return this.fullWidth() === 0; }
        public accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        public hasRegularExpressionToken(): bool { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realizeToken(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export class FixedWidthTokenWithLeadingAndTrailingTrivia implements ISyntaxToken {
        private _sourceText: ISimpleText;
        private _fullStart: number;
        public tokenKind: SyntaxKind;
        private _leadingTriviaInfo: number;
        private _trailingTriviaInfo: number;

        constructor(sourceText: ISimpleText, fullStart: number,kind: SyntaxKind, leadingTriviaInfo: number, trailingTriviaInfo: number) {
            this._sourceText = sourceText;
            this._fullStart = fullStart;
            this.tokenKind = kind;
            this._leadingTriviaInfo = leadingTriviaInfo;
            this._trailingTriviaInfo = trailingTriviaInfo;
        }

        public clone(): ISyntaxToken {
            return new FixedWidthTokenWithLeadingAndTrailingTrivia(
                this._sourceText,
                this._fullStart,
                this.tokenKind,
                this._leadingTriviaInfo,
                this._trailingTriviaInfo);
        }

        public isNode(): bool { return false; }
        public isToken(): bool { return true; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public kind(): SyntaxKind { return this.tokenKind; }

        public childCount(): number { return 0; }
        public childAt(index: number): ISyntaxElement { throw Errors.argumentOutOfRange('index'); }

        public fullWidth(): number { return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo); }
        private start(): number { return this._fullStart + getTriviaWidth(this._leadingTriviaInfo); }
        private end(): number { return this.start() + this.width(); }

        public width(): number { return this.text().length; }
        public text(): string { return SyntaxFacts.getText(this.tokenKind); }
        public fullText(): string { return this._sourceText.substr(this._fullStart, this.fullWidth(), /*intern:*/ false); }

        public value(): any { return null; }
        public hasLeadingTrivia(): bool { return true; }
        public hasLeadingComment(): bool { return hasTriviaComment(this._leadingTriviaInfo); }
        public hasLeadingNewLine(): bool { return hasTriviaNewLine(this._leadingTriviaInfo); }
        public hasLeadingSkippedText(): bool { return false; }
        public leadingTriviaWidth(): number { return getTriviaWidth(this._leadingTriviaInfo); }
        public leadingTrivia(): ISyntaxTriviaList { return Scanner1.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), /*isTrailing:*/ false); }

        public hasTrailingTrivia(): bool { return true; }
        public hasTrailingComment(): bool { return hasTriviaComment(this._trailingTriviaInfo); }
        public hasTrailingNewLine(): bool { return hasTriviaNewLine(this._trailingTriviaInfo); }
        public hasTrailingSkippedText(): bool { return false; }
        public trailingTriviaWidth(): number { return getTriviaWidth(this._trailingTriviaInfo); }
        public trailingTrivia(): ISyntaxTriviaList { return Scanner1.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), /*isTrailing:*/ true); }

        public hasSkippedText(): bool { return false; }
        public toJSON(key) { return tokenToJSON(this); }
        public firstToken(): ISyntaxToken { return this; }
        public lastToken(): ISyntaxToken { return this; }
        public isTypeScriptSpecific(): bool { return false; }
        public hasZeroWidthToken(): bool { return this.fullWidth() === 0; }
        public accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }
        public hasRegularExpressionToken(): bool { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }
        private realize(): ISyntaxToken { return realizeToken(this); }
        private collectTextElements(elements: string[]): void { collectTokenTextElements(this, elements); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    function collectTokenTextElements(token: ISyntaxToken, elements: string[]): void {
        token.leadingTrivia().collectTextElements(elements);
        elements.push(token.text());
        token.trailingTrivia().collectTextElements(elements);
    }

    export function fixedWidthToken(sourceText: ISimpleText, fullStart: number,
        kind: SyntaxKind,
        leadingTriviaInfo: number,
        trailingTriviaInfo: number): ISyntaxToken {

        if (leadingTriviaInfo === 0) {
            if (trailingTriviaInfo === 0) {
                return new FixedWidthTokenWithNoTrivia(kind);
            }
            else {
                return new FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo);
            }
        }
        else if (trailingTriviaInfo === 0) {
            return new FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo);
        }
        else {
            return new FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
        }
    }

    export function variableWidthToken(sourceText: ISimpleText, fullStart: number,
        kind: SyntaxKind,
        leadingTriviaInfo: number,
        width: number,
        trailingTriviaInfo: number): ISyntaxToken {

        if (leadingTriviaInfo === 0) {
            if (trailingTriviaInfo === 0) {
                return new VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, width);
            }
            else {
                return new VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, width, trailingTriviaInfo);
            }
        }
        else if (trailingTriviaInfo === 0) {
            return new VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width);
        }
        else {
            return new VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
        }
    }

    function getTriviaWidth(value: number): number {
        return value >>> SyntaxConstants.TriviaFullWidthShift;
    }

    function hasTriviaComment(value: number): bool {
        return (value & SyntaxConstants.TriviaCommentMask) !== 0;
    }

    function hasTriviaNewLine(value: number): bool {
        return (value & SyntaxConstants.TriviaNewLineMask) !== 0;
    }
}
///<reference path='References.ts' />

module TypeScript.Syntax {
    class SyntaxTrivia implements ISyntaxTrivia {
        private _kind: SyntaxKind;
        private _text: string;

        constructor(kind: SyntaxKind, text: string) {
            this._kind = kind;
            this._text = text;
        }

        public toJSON(key) {
            var result: any = {};
            result.kind = (<any>SyntaxKind)._map[this._kind];
            result.text = this._text;
            return result;
        }

        public kind(): SyntaxKind {
            return this._kind;
        }

        public fullWidth(): number {
            return this._text.length;
        }

        public fullText(): string {
            return this._text;
        }

        public isWhitespace(): bool {
            return this.kind() === SyntaxKind.WhitespaceTrivia;
        }

        public isComment(): bool {
            return this.kind() === SyntaxKind.SingleLineCommentTrivia || this.kind() === SyntaxKind.MultiLineCommentTrivia;
        }

        public isNewLine(): bool {
            return this.kind() === SyntaxKind.NewLineTrivia;
        }

        public isSkippedText(): bool {
            return this.kind() === SyntaxKind.SkippedTextTrivia;
        }

        public collectTextElements(elements: string[]): void {
            elements.push(this.fullText());
        }
    }

    export function trivia(kind: SyntaxKind, text: string): ISyntaxTrivia {
        // Debug.assert(kind === SyntaxKind.MultiLineCommentTrivia || kind === SyntaxKind.NewLineTrivia || kind === SyntaxKind.SingleLineCommentTrivia || kind === SyntaxKind.WhitespaceTrivia || kind === SyntaxKind.SkippedTextTrivia);
        // Debug.assert(text.length > 0);
        return new SyntaxTrivia(kind, text);
    }

    export function spaces(count: number): ISyntaxTrivia {
        return trivia(SyntaxKind.WhitespaceTrivia, StringUtilities.repeat(" ", count));
    }

    export function whitespace(text: string): ISyntaxTrivia {
        return trivia(SyntaxKind.WhitespaceTrivia, text);
    }

    export function multiLineComment(text: string): ISyntaxTrivia {
        return trivia(SyntaxKind.MultiLineCommentTrivia, text);
    }

    export function singleLineComment(text: string): ISyntaxTrivia {
        return trivia(SyntaxKind.SingleLineCommentTrivia, text);
    }

    export var spaceTrivia: ISyntaxTrivia = spaces(1);
    export var lineFeedTrivia: ISyntaxTrivia = trivia(SyntaxKind.NewLineTrivia, "\n");
    export var carriageReturnTrivia: ISyntaxTrivia = trivia(SyntaxKind.NewLineTrivia, "\r");
    export var carriageReturnLineFeedTrivia: ISyntaxTrivia = trivia(SyntaxKind.NewLineTrivia, "\r\n");

    // Breaks a multiline trivia up into individual line components.  If the trivia doesn't span
    // any lines, then the result will be a single string with the entire text of the trivia. 
    // Otherwise, there will be one entry in the array for each line spanned by the trivia.  Each
    // entry will contain the line separator at the end of the string.
    export function splitMultiLineCommentTriviaIntoMultipleLines(trivia: ISyntaxTrivia): string[] {
        // Debug.assert(trivia.kind() === SyntaxKind.MultiLineCommentTrivia);
        var result: string[] = [];

        var triviaText = trivia.fullText();
        var currentIndex = 0;

        for (var i = 0; i < triviaText.length; i++) {
            var ch = triviaText.charCodeAt(i);

            // When we run into a newline for the first time, create the string builder and copy
            // all the values up to this newline into it.
            var isCarriageReturnLineFeed = false;
            switch (ch) {
                case CharacterCodes.carriageReturn:
                    if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === CharacterCodes.lineFeed) {
                        // Consume the \r
                        i++;
                    }

                // Fall through.

                case CharacterCodes.lineFeed:
                case CharacterCodes.paragraphSeparator:
                case CharacterCodes.lineSeparator:
                    // Eat from the last stating position through to the end of the newline.
                    result.push(triviaText.substring(currentIndex, i + 1));

                    // Set the current index to *after* the newline.
                    currentIndex = i + 1;
                    continue;
            }
        }

        result.push(triviaText.substring(currentIndex));
        return result;
    }
}
///<reference path='References.ts' />

module TypeScript.Syntax {
    export var emptyTriviaList: ISyntaxTriviaList = {
        kind: (): SyntaxKind => SyntaxKind.TriviaList,

        count: (): number => 0,

        syntaxTriviaAt: (index: number): ISyntaxTrivia => {
            throw Errors.argumentOutOfRange("index");
        },

        last: (): ISyntaxTrivia => {
            throw Errors.argumentOutOfRange("index");
        },

        fullWidth: (): number => 0,
        fullText: (): string => "",

        hasComment: (): bool => false,
        hasNewLine: (): bool => false,
        hasSkippedText: (): bool => false,

        toJSON: (key) => [],

        collectTextElements: (elements: string[]): void => { },

        toArray: (): ISyntaxTrivia[] => [],

        concat: (trivia: ISyntaxTriviaList): ISyntaxTriviaList => trivia,
    };

    function concatTrivia(list1: ISyntaxTriviaList, list2: ISyntaxTriviaList): ISyntaxTriviaList {
        if (list1.count() === 0) {
            return list2;
        }

        if (list2.count() === 0) {
            return list1;
        }

        var trivia = list1.toArray();
        trivia.push.apply(trivia, list2.toArray());

        return triviaList(trivia);
    }

    function isComment(trivia: ISyntaxTrivia): bool {
        return trivia.kind() === SyntaxKind.MultiLineCommentTrivia || trivia.kind() === SyntaxKind.SingleLineCommentTrivia;
    }

    class SingletonSyntaxTriviaList implements ISyntaxTriviaList {
        private item: ISyntaxTrivia;

        constructor(item: ISyntaxTrivia) {
            this.item = item;
        }

        public kind(): SyntaxKind { return SyntaxKind.TriviaList; }

        public count(): number {
            return 1;
        }

        public syntaxTriviaAt(index: number): ISyntaxTrivia {
            if (index !== 0) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.item;
        }

        public last(): ISyntaxTrivia {
            return this.item;
        }

        public fullWidth(): number {
            return this.item.fullWidth();
        }

        public fullText(): string {
            return this.item.fullText();
        }

        public hasComment(): bool {
            return isComment(this.item);
        }

        public hasNewLine(): bool {
            return this.item.kind() === SyntaxKind.NewLineTrivia;
        }

        public hasSkippedText(): bool {
            return this.item.kind() === SyntaxKind.SkippedTextTrivia;
        }

        public toJSON(key) {
            return [this.item];
        }

        private collectTextElements(elements: string[]): void {
            (<any>this.item).collectTextElements(elements);
        }

        public toArray(): ISyntaxTrivia[] {
            return [this.item];
        }

        public concat(trivia: ISyntaxTriviaList): ISyntaxTriviaList {
            return concatTrivia(this, trivia);
        }
    }

    class NormalSyntaxTriviaList implements ISyntaxTriviaList {
        private trivia: ISyntaxTrivia[];

        constructor(trivia: ISyntaxTrivia[]) {
            this.trivia = trivia;
        }

        public kind(): SyntaxKind { return SyntaxKind.TriviaList; }

        public count() {
            return this.trivia.length;
        }

        public syntaxTriviaAt(index: number): ISyntaxTrivia {
            if (index < 0 || index >= this.trivia.length) {
                throw Errors.argumentOutOfRange("index");
            }

            return this.trivia[index];
        }
        
        public last(): ISyntaxTrivia {
            return this.trivia[this.trivia.length - 1];
        }

        public fullWidth(): number {
            return ArrayUtilities.sum(this.trivia, t => t.fullWidth());
        }

        public fullText(): string {
            var result = "";

            for (var i = 0, n = this.trivia.length; i < n; i++) {
                result += this.trivia[i].fullText();
            }

            return result;
        }

        public hasComment(): bool {
            for (var i = 0; i < this.trivia.length; i++) {
                if (isComment(this.trivia[i])) {
                    return true;
                }
            }

            return false;
        }

        public hasNewLine(): bool {
            for (var i = 0; i < this.trivia.length; i++) {
                if (this.trivia[i].kind() === SyntaxKind.NewLineTrivia) {
                    return true;
                }
            }

            return false;
        }

        public hasSkippedText(): bool {
            for (var i = 0; i < this.trivia.length; i++) {
                if (this.trivia[i].kind() === SyntaxKind.SkippedTextTrivia) {
                    return true;
                }
            }

            return false;
        }

        public toJSON(key) {
            return this.trivia;
        }

        private collectTextElements(elements: string[]): void {
            for (var i = 0; i < this.trivia.length; i++) {
                (<any>this.trivia[i]).collectTextElements(elements);
            }
        }

        public toArray(): ISyntaxTrivia[] {
            return this.trivia.slice(0);
        }

        public concat(trivia: ISyntaxTriviaList): ISyntaxTriviaList {
            return concatTrivia(this, trivia);
        }
    }

    export function triviaList(trivia: ISyntaxTrivia[]): ISyntaxTriviaList {
        if (trivia === undefined || trivia === null || trivia.length === 0) {
            return Syntax.emptyTriviaList;
        }

        if (trivia.length === 1) {
            return new SingletonSyntaxTriviaList(trivia[0]);
        }

        return new NormalSyntaxTriviaList(trivia);
    }

    export var spaceTriviaList: ISyntaxTriviaList = triviaList([Syntax.spaceTrivia]);
}
///<reference path='References.ts' />

module TypeScript {
    export class Unicode {
        // Unicode range maps
        // REVIEW: These range maps have been extracted from the Unicode specifications, they might be missing values, and/or include 
        //         incorrect ranges. but for the most they seem to be correct. A more accurate and thorough review is needed.

        /*
            As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
            IdentifierStart :: Can contain Unicode 3.0.0  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).
            IdentifierPart :: Can contain IdentifierStart + Unicode 3.0.0  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), or Connector punctuation (Pc).
                        
            Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
            http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
        */
        static unicodeES3IdentifierStart = [
            170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,
            1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611,
            2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970,
            2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517,
            3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138,
            4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885,
            4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147,
            8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588,
            12593, 12686, 12704, 12727, 13312, 13312, 19893, 19893, 19968, 19968, 40869, 40869, 40960, 42124, 44032, 44032, 55203, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967,
            65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500
        ];

        static unicodeES3IdentifierPart = [
            768, 846, 864, 866, 1155, 1158, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1611, 1621, 1632, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 2305, 2307, 2364, 2364, 2366, 2381, 2385, 2388, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492,
            2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2562, 2562, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2662, 2673, 2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2790, 2799, 2817, 2819, 2876, 2876, 2878, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2918, 2927, 2946, 2947, 3006, 3010, 3014, 3016,
            3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3174, 3183, 3202, 3203, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3302, 3311, 3330, 3331, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3633, 3633,
            3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903, 3953, 3972, 3974, 3975, 3984, 3991, 3993, 4028, 4038, 4038, 4140, 4146, 4150, 4153, 4160, 4169, 4182, 4185, 4969, 4977, 6068, 6099, 6112, 6121, 6160, 6169, 6313, 6313,
            8255, 8256, 8400, 8412, 8417, 8417, 12330, 12335, 12441, 12442, 12539, 12539, 64286, 64286, 65056, 65059, 65075, 65076, 65101, 65103, 65296, 65305, 65343, 65343, 65381, 65381
        ];


        /*
            As per ECMAScript Language Specification 5th Edition, Section 7.6: Identifier Names and Identifiers
            IdentifierStart :: Can contain Unicode 6.2  categories Uppercase letter (Lu), Lowercase letter (Ll), Titlecase letter (Lt), Modifier letter (Lm), Other letter (Lo), or Letter number (Nl).
            IdentifierPart :: Can contain IdentifierStart + Unicode 6.2  categories Non-spacing mark (Mn), Combining spacing mark (Mc), Decimal number (Nd), Connector punctuation (Pc), <ZWNJ>, or <ZWJ>.
                        
            Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
            http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
        */
        static unicodeES5IdentifierStart = [
            170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775,
            1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489,
            2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864,
            2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,
            3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743,
            3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680,
            4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000,
            6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957,
            7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486,
            8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726,
            11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 13312, 19893, 19893, 19968, 19968, 40908, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527,
            42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560,
            43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 44032, 55203, 55203, 55216, 55238, 55243, 55291,
            63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487,
            65490, 65495, 65498, 65500
        ];

        static unicodeES5IdentifierPart = [
            768, 879, 1155, 1159, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1552, 1562, 1611, 1641, 1648, 1648, 1750, 1756, 1759, 1764, 1767, 1768, 1770, 1773, 1776, 1785, 1809, 1809, 1840, 1866, 1958, 1968, 1984, 1993, 2027, 2035, 2070, 2073, 2075, 2083, 2085, 2087, 2089, 2093, 2137, 2139, 2276, 2302, 2304, 2307, 2362, 2364,
            2366, 2383, 2385, 2391, 2402, 2403, 2406, 2415, 2433, 2435, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2534, 2543, 2561, 2563, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2662, 2673, 2677, 2677, 2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2786, 2787, 2790, 2799, 2817, 2819,
            2876, 2876, 2878, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2914, 2915, 2918, 2927, 2946, 2946, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3046, 3055, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3170, 3171, 3174, 3183, 3202, 3203, 3260, 3260, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3298, 3299, 3302, 3311,
            3330, 3331, 3390, 3396, 3398, 3400, 3402, 3405, 3415, 3415, 3426, 3427, 3430, 3439, 3458, 3459, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3633, 3633, 3636, 3642, 3655, 3662, 3664, 3673, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3792, 3801, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3903,
            3953, 3972, 3974, 3975, 3981, 3991, 3993, 4028, 4038, 4038, 4139, 4158, 4160, 4169, 4182, 4185, 4190, 4192, 4194, 4196, 4199, 4205, 4209, 4212, 4226, 4237, 4239, 4253, 4957, 4959, 5906, 5908, 5938, 5940, 5970, 5971, 6002, 6003, 6068, 6099, 6109, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6313, 6313, 6432, 6443, 6448, 6459, 6470, 6479,
            6576, 6592, 6600, 6601, 6608, 6617, 6679, 6683, 6741, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6912, 6916, 6964, 6980, 6992, 7001, 7019, 7027, 7040, 7042, 7073, 7085, 7088, 7097, 7142, 7155, 7204, 7223, 7232, 7241, 7248, 7257, 7376, 7378, 7380, 7400, 7405, 7405, 7410, 7412, 7616, 7654, 7676, 7679, 8204, 8205, 8255, 8256, 8276, 8276,
            8400, 8412, 8417, 8417, 8421, 8432, 11503, 11505, 11647, 11647, 11744, 11775, 12330, 12335, 12441, 12442, 42528, 42537, 42607, 42607, 42612, 42621, 42655, 42655, 42736, 42737, 43010, 43010, 43014, 43014, 43019, 43019, 43043, 43047, 43136, 43137, 43188, 43204, 43216, 43225, 43232, 43249, 43264, 43273, 43302, 43309, 43335, 43347,
            43392, 43395, 43443, 43456, 43472, 43481, 43561, 43574, 43587, 43587, 43596, 43597, 43600, 43609, 43643, 43643, 43696, 43696, 43698, 43700, 43703, 43704, 43710, 43711, 43713, 43713, 43755, 43759, 43765, 43766, 44003, 44010, 44012, 44013, 44016, 44025, 64286, 64286, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103,
            65296, 65305, 65343, 65343
        ];

        static lookupInUnicodeMap(code: number, map: number[]): bool {
            // Bail out quickly if it couldn't possibly be in the map.
            if (code < map[0]) {
                return false;
            }

            // Perform binary search in one of the unicode range maps
            var lo: number = 0;
            var hi: number = map.length;
            var mid: number;

            while (lo + 1 < hi) {
                mid = lo + (hi - lo) / 2;
                // mid has to be even to catch a range's beginning
                mid -= mid % 2;
                if (map[mid] <= code && code <= map[mid + 1]) {
                    return true;
                }

                if (code < map[mid]) {
                    hi = mid;
                }
                else {
                    lo = mid + 2;
                }
            }

            return false;
        }

        public static isIdentifierStart(code: number, languageVersion: LanguageVersion) {
            if (languageVersion === LanguageVersion.EcmaScript3) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
            }
            else if (languageVersion === LanguageVersion.EcmaScript5) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
            }
            else {
                throw Errors.argumentOutOfRange("languageVersion");
            }
        }

        public static isIdentifierPart(code: number, languageVersion: LanguageVersion) {
            if (languageVersion === LanguageVersion.EcmaScript3) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
            }
            else if (languageVersion === LanguageVersion.EcmaScript5) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
            }
            else {
                throw Errors.argumentOutOfRange("languageVersion");
            }
        }
    }
}
﻿///<reference path='References.ts' />

module TypeScript {
    export class Scanner1 implements ISlidingWindowSource {
        private slidingWindow: SlidingWindow;

        private fileName: string;
        private text: ISimpleText;
        private _languageVersion: LanguageVersion;

        private static isKeywordStartCharacter: bool[] = [];
        private static isIdentifierStartCharacter: bool[] = [];
        public static isIdentifierPartCharacter: bool[] = [];
        private static isNumericLiteralStart: bool[] = [];

        private static initializeStaticData() {
            if (Scanner1.isKeywordStartCharacter.length === 0) {
                Scanner1.isKeywordStartCharacter = ArrayUtilities.createArray(CharacterCodes.maxAsciiCharacter, false);
                Scanner1.isIdentifierStartCharacter = ArrayUtilities.createArray(CharacterCodes.maxAsciiCharacter, false);
                Scanner1.isIdentifierPartCharacter = ArrayUtilities.createArray(CharacterCodes.maxAsciiCharacter, false);
                Scanner1.isNumericLiteralStart = ArrayUtilities.createArray(CharacterCodes.maxAsciiCharacter, false);

                for (var character = 0; character < CharacterCodes.maxAsciiCharacter; character++) {
                    if (character >= CharacterCodes.a && character <= CharacterCodes.z) {
                        Scanner1.isIdentifierStartCharacter[character] = true;
                        Scanner1.isIdentifierPartCharacter[character] = true;
                    }
                    else if ((character >= CharacterCodes.A && character <= CharacterCodes.Z) ||
                             character === CharacterCodes._ ||
                             character === CharacterCodes.$) {
                        Scanner1.isIdentifierStartCharacter[character] = true;
                        Scanner1.isIdentifierPartCharacter[character] = true;
                    }
                    else if (character >= CharacterCodes._0 && character <= CharacterCodes._9) {
                        Scanner1.isIdentifierPartCharacter[character] = true;
                        Scanner1.isNumericLiteralStart[character] = true;
                    }
                }

                Scanner1.isNumericLiteralStart[CharacterCodes.dot] = true;

                for (var keywordKind = SyntaxKind.FirstKeyword; keywordKind <= SyntaxKind.LastKeyword; keywordKind++) {
                    var keyword = SyntaxFacts.getText(keywordKind);
                    Scanner1.isKeywordStartCharacter[keyword.charCodeAt(0)] = true;
                }
            }
        }

        constructor(fileName: string,
                    text: ISimpleText,
                    languageVersion: LanguageVersion,
                    window: number[] = ArrayUtilities.createArray(2048, 0)) {
            Scanner1.initializeStaticData();

            this.slidingWindow = new SlidingWindow(this, window, 0, text.length());
            this.fileName = fileName;
            this.text = text;
            this._languageVersion = languageVersion;
        }

        public languageVersion(): LanguageVersion {
            return this._languageVersion;
        }

        public fetchMoreItems(argument: any, sourceIndex: number, window: number[], destinationIndex: number, spaceAvailable: number): number {
            var charactersRemaining = this.text.length() - sourceIndex;
            var amountToRead = MathPrototype.min(charactersRemaining, spaceAvailable);
            this.text.copyTo(sourceIndex, window, destinationIndex, amountToRead);
            return amountToRead;
        }

        private currentCharCode(): number {
            return this.slidingWindow.currentItem(/*argument:*/ null);
        }

        public absoluteIndex(): number {
            return this.slidingWindow.absoluteIndex();
        }

        // Set's the scanner to a specific position in the text.
        public setAbsoluteIndex(index: number): void {
            this.slidingWindow.setAbsoluteIndex(index);
        }

        // Scans a token starting at the current position.  Any errors encountered will be added to 
        // 'diagnostics'.
        public scan(diagnostics: SyntaxDiagnostic[], allowRegularExpression: bool): ISyntaxToken {
            var fullStart = this.slidingWindow.absoluteIndex();
            var leadingTriviaInfo = this.scanTriviaInfo(diagnostics, /*isTrailing: */ false);

            var start = this.slidingWindow.absoluteIndex();
            var kind = this.scanSyntaxToken(diagnostics, allowRegularExpression);
            var end = this.slidingWindow.absoluteIndex();

            var trailingTriviaInfo = this.scanTriviaInfo(diagnostics,/*isTrailing: */true);

            if (kind >= SyntaxKind.FirstFixedWidth) {
                if (leadingTriviaInfo === 0) {
                    if (trailingTriviaInfo === 0) {
                        return new Syntax.FixedWidthTokenWithNoTrivia(kind);
                    }
                    else {
                        return new Syntax.FixedWidthTokenWithTrailingTrivia(this.text, fullStart, kind, trailingTriviaInfo);
                    }
                }
                else if (trailingTriviaInfo === 0) {
                    return new Syntax.FixedWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo);
                }
                else {
                    return new Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
                }
            }
            else {
                var width = end - start;
                if (leadingTriviaInfo === 0) {
                    if (trailingTriviaInfo === 0) {
                        return new Syntax.VariableWidthTokenWithNoTrivia(this.text, fullStart, kind, width);
                    }
                    else {
                        return new Syntax.VariableWidthTokenWithTrailingTrivia(this.text, fullStart, kind, width, trailingTriviaInfo);
                    }
                }
                else if (trailingTriviaInfo === 0) {
                    return new Syntax.VariableWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width);
                }
                else {
                    return new Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
                }
            }
        }

        private static triviaWindow = ArrayUtilities.createArray(2048, 0);

        // Scans a subsection of 'text' as trivia.
        public static scanTrivia(text: ISimpleText, start: number, length: number, isTrailing: bool): ISyntaxTriviaList {
            // Debug.assert(length > 0);
            var scanner = new Scanner1(/*fileName:*/ null, text.subText(new TextSpan(start, length)), LanguageVersion.EcmaScript5, Scanner1.triviaWindow);
            return scanner.scanTrivia(isTrailing);
        }

        private scanTrivia(isTrailing: bool): ISyntaxTriviaList {
            // Keep this exactly in sync with scanTriviaInfo
            var trivia: ISyntaxTrivia[] = [];

            while (true) {
                if (!this.slidingWindow.isAtEndOfSource()) {
                    var ch = this.currentCharCode();

                    switch (ch) {
                        // Unicode 3.0 space characters
                        case CharacterCodes.space:
                        case CharacterCodes.nonBreakingSpace:
                        case CharacterCodes.enQuad:
                        case CharacterCodes.emQuad:
                        case CharacterCodes.enSpace:
                        case CharacterCodes.emSpace:
                        case CharacterCodes.threePerEmSpace:
                        case CharacterCodes.fourPerEmSpace:
                        case CharacterCodes.sixPerEmSpace:
                        case CharacterCodes.figureSpace:
                        case CharacterCodes.punctuationSpace:
                        case CharacterCodes.thinSpace:
                        case CharacterCodes.hairSpace:
                        case CharacterCodes.zeroWidthSpace:
                        case CharacterCodes.narrowNoBreakSpace:
                        case CharacterCodes.ideographicSpace:

                        case CharacterCodes.tab:
                        case CharacterCodes.verticalTab:
                        case CharacterCodes.formFeed:
                        case CharacterCodes.byteOrderMark:
                            // Normal whitespace.  Consume and continue.
                            trivia.push(this.scanWhitespaceTrivia());
                            continue;

                        case CharacterCodes.slash:
                            // Potential comment.  Consume if so.  Otherwise, break out and return.
                            var ch2 = this.slidingWindow.peekItemN(1);
                            if (ch2 === CharacterCodes.slash) {
                                trivia.push(this.scanSingleLineCommentTrivia());
                                continue;
                            }

                            if (ch2 === CharacterCodes.asterisk) {
                                trivia.push(this.scanMultiLineCommentTrivia());
                                continue;
                            }

                            // Not a comment.  Don't consume.
                            throw Errors.invalidOperation();

                        case CharacterCodes.carriageReturn:
                        case CharacterCodes.lineFeed:
                        case CharacterCodes.paragraphSeparator:
                        case CharacterCodes.lineSeparator:
                            trivia.push(this.scanLineTerminatorSequenceTrivia(ch));

                            // If we're consuming leading trivia, then we will continue consuming more 
                            // trivia (including newlines) up to the first token we see.  If we're 
                            // consuming trailing trivia, then we break after the first newline we see.
                            if (!isTrailing) {
                                continue;
                            }

                            break;

                        default:
                            throw Errors.invalidOperation();
                    }
                }

                // Debug.assert(trivia.length > 0);
                return Syntax.triviaList(trivia);
            }
        }

        private scanTriviaInfo(diagnostics: SyntaxDiagnostic[], isTrailing: bool): number {
            // Keep this exactly in sync with scanTrivia
            var width = 0;
            var hasCommentOrNewLine = 0;

            while (true) {
                var ch = this.currentCharCode();

                switch (ch) {
                    // Unicode 3.0 space characters
                    case CharacterCodes.space:
                    case CharacterCodes.nonBreakingSpace:
                    case CharacterCodes.enQuad:
                    case CharacterCodes.emQuad:
                    case CharacterCodes.enSpace:
                    case CharacterCodes.emSpace:
                    case CharacterCodes.threePerEmSpace:
                    case CharacterCodes.fourPerEmSpace:
                    case CharacterCodes.sixPerEmSpace:
                    case CharacterCodes.figureSpace:
                    case CharacterCodes.punctuationSpace:
                    case CharacterCodes.thinSpace:
                    case CharacterCodes.hairSpace:
                    case CharacterCodes.zeroWidthSpace:
                    case CharacterCodes.narrowNoBreakSpace:
                    case CharacterCodes.ideographicSpace:

                    case CharacterCodes.tab:
                    case CharacterCodes.verticalTab:
                    case CharacterCodes.formFeed:
                    case CharacterCodes.byteOrderMark:
                        // Normal whitespace.  Consume and continue.
                        this.slidingWindow.moveToNextItem();
                        width++;
                        continue;

                    case CharacterCodes.slash:
                        // Potential comment.  Consume if so.  Otherwise, break out and return.
                        var ch2 = this.slidingWindow.peekItemN(1);
                        if (ch2 === CharacterCodes.slash) {
                            hasCommentOrNewLine |= SyntaxConstants.TriviaCommentMask;
                            width += this.scanSingleLineCommentTriviaLength();
                            continue;
                        }

                        if (ch2 === CharacterCodes.asterisk) {
                            hasCommentOrNewLine |= SyntaxConstants.TriviaCommentMask;
                            width += this.scanMultiLineCommentTriviaLength(diagnostics);
                            continue;
                        }

                        // Not a comment.  Don't consume.
                        break;

                    case CharacterCodes.carriageReturn:
                    case CharacterCodes.lineFeed:
                    case CharacterCodes.paragraphSeparator:
                    case CharacterCodes.lineSeparator:
                        hasCommentOrNewLine |= SyntaxConstants.TriviaNewLineMask;
                        width += this.scanLineTerminatorSequenceLength(ch);

                        // If we're consuming leading trivia, then we will continue consuming more 
                        // trivia (including newlines) up to the first token we see.  If we're 
                        // consuming trailing trivia, then we break after the first newline we see.
                        if (!isTrailing) {
                            continue;
                        }

                        break;
                }

                return (width << SyntaxConstants.TriviaFullWidthShift) | hasCommentOrNewLine;
            }
        }

        private isNewLineCharacter(ch: number): bool {
            switch (ch) {
                case CharacterCodes.carriageReturn:
                case CharacterCodes.lineFeed:
                case CharacterCodes.paragraphSeparator:
                case CharacterCodes.lineSeparator:
                    return true;
                default:
                    return false;
            }
        }

        private scanWhitespaceTrivia(): ISyntaxTrivia {
            // We're going to be extracting text out of sliding window.  Make sure it can't move past
            // this point.
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            var width = 0;
            while (true) {
                var ch = this.currentCharCode();

                switch (ch) {
                    // Unicode 3.0 space characters
                    case CharacterCodes.space:
                    case CharacterCodes.nonBreakingSpace:
                    case CharacterCodes.enQuad:
                    case CharacterCodes.emQuad:
                    case CharacterCodes.enSpace:
                    case CharacterCodes.emSpace:
                    case CharacterCodes.threePerEmSpace:
                    case CharacterCodes.fourPerEmSpace:
                    case CharacterCodes.sixPerEmSpace:
                    case CharacterCodes.figureSpace:
                    case CharacterCodes.punctuationSpace:
                    case CharacterCodes.thinSpace:
                    case CharacterCodes.hairSpace:
                    case CharacterCodes.zeroWidthSpace:
                    case CharacterCodes.narrowNoBreakSpace:
                    case CharacterCodes.ideographicSpace:

                    case CharacterCodes.tab:
                    case CharacterCodes.verticalTab:
                    case CharacterCodes.formFeed:
                    case CharacterCodes.byteOrderMark:
                        // Normal whitespace.  Consume and continue.
                        this.slidingWindow.moveToNextItem();
                        width++;
                        continue;
                }

                break;
            }

            // TODO: we probably should intern whitespace.
            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, /*intern:*/ false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return Syntax.whitespace(text);
        }

        private scanSingleLineCommentTrivia(): ISyntaxTrivia {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanSingleLineCommentTriviaLength();

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, /*intern:*/ false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return Syntax.singleLineComment(text);
        }

        private scanSingleLineCommentTriviaLength(): number {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            // The '2' is for the "//" we consumed.
            var width = 2;
            while (true) {
                if (this.slidingWindow.isAtEndOfSource() || this.isNewLineCharacter(this.currentCharCode())) {
                    return width;
                }

                this.slidingWindow.moveToNextItem();
                width++;
            }
        }

        private scanMultiLineCommentTrivia(): ISyntaxTrivia {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanMultiLineCommentTriviaLength(null);

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, /*intern:*/ false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return Syntax.multiLineComment(text);
        }

        private scanMultiLineCommentTriviaLength(diagnostics: SyntaxDiagnostic[]): number {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            // The '2' is for the "/*" we consumed.
            var width = 2;
            while (true) {
                if (this.slidingWindow.isAtEndOfSource()) {
                    if (diagnostics !== null) {
                        diagnostics.push(new SyntaxDiagnostic(
                            this.fileName,
                            this.slidingWindow.absoluteIndex(), 0, DiagnosticCode._StarSlash__expected, null));
                    }

                    return width;
                }

                var ch = this.currentCharCode();
                if (ch === CharacterCodes.asterisk && this.slidingWindow.peekItemN(1) === CharacterCodes.slash) {
                    this.slidingWindow.moveToNextItem();
                    this.slidingWindow.moveToNextItem();
                    width += 2;
                    return width;
                }

                this.slidingWindow.moveToNextItem();
                width++;
            }
        }

        private scanLineTerminatorSequenceTrivia(ch: number): ISyntaxTrivia {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanLineTerminatorSequenceLength(ch);

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, /*intern:*/ false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return Syntax.trivia(SyntaxKind.NewLineTrivia, text);
        }

        private scanLineTerminatorSequenceLength(ch: number): number {
            // Consume the first of the line terminator we saw.
            this.slidingWindow.moveToNextItem();

            // If it happened to be a \r and there's a following \n, then consume both.
            if (ch === CharacterCodes.carriageReturn && this.currentCharCode() === CharacterCodes.lineFeed) {
                this.slidingWindow.moveToNextItem();
                return 2;
            }
            else {
                return 1;
            }
        }

        private scanSyntaxToken(diagnostics: SyntaxDiagnostic[], allowRegularExpression: bool): SyntaxKind {
            if (this.slidingWindow.isAtEndOfSource()) {
                return SyntaxKind.EndOfFileToken;
            }

            var character = this.currentCharCode();

            switch (character) {
                case CharacterCodes.doubleQuote:
                case CharacterCodes.singleQuote:
                    return this.scanStringLiteral(diagnostics);

                // These are the set of variable width punctuation tokens.
                case CharacterCodes.slash:
                    return this.scanSlashToken(allowRegularExpression);

                case CharacterCodes.dot:
                    return this.scanDotToken();

                case CharacterCodes.minus:
                    return this.scanMinusToken();

                case CharacterCodes.exclamation:
                    return this.scanExclamationToken();

                case CharacterCodes.equals:
                    return this.scanEqualsToken();

                case CharacterCodes.bar:
                    return this.scanBarToken();

                case CharacterCodes.asterisk:
                    return this.scanAsteriskToken();

                case CharacterCodes.plus:
                    return this.scanPlusToken();

                case CharacterCodes.percent:
                    return this.scanPercentToken();

                case CharacterCodes.ampersand:
                    return this.scanAmpersandToken();

                case CharacterCodes.caret:
                    return this.scanCaretToken();

                case CharacterCodes.lessThan:
                    return this.scanLessThanToken();

                // These are the set of fixed, single character length punctuation tokens.
                // The token kind does not depend on what follows.
                case CharacterCodes.greaterThan:
                    return this.advanceAndSetTokenKind(SyntaxKind.GreaterThanToken);

                case CharacterCodes.comma:
                    return this.advanceAndSetTokenKind(SyntaxKind.CommaToken);

                case CharacterCodes.colon:
                    return this.advanceAndSetTokenKind(SyntaxKind.ColonToken);

                case CharacterCodes.semicolon:
                    return this.advanceAndSetTokenKind(SyntaxKind.SemicolonToken);

                case CharacterCodes.tilde:
                    return this.advanceAndSetTokenKind(SyntaxKind.TildeToken);

                case CharacterCodes.openParen:
                    return this.advanceAndSetTokenKind(SyntaxKind.OpenParenToken);

                case CharacterCodes.closeParen:
                    return this.advanceAndSetTokenKind(SyntaxKind.CloseParenToken);

                case CharacterCodes.openBrace:
                    return this.advanceAndSetTokenKind(SyntaxKind.OpenBraceToken);

                case CharacterCodes.closeBrace:
                    return this.advanceAndSetTokenKind(SyntaxKind.CloseBraceToken);

                case CharacterCodes.openBracket:
                    return this.advanceAndSetTokenKind(SyntaxKind.OpenBracketToken);

                case CharacterCodes.closeBracket:
                    return this.advanceAndSetTokenKind(SyntaxKind.CloseBracketToken);

                case CharacterCodes.question:
                    return this.advanceAndSetTokenKind(SyntaxKind.QuestionToken);
            }

            if (Scanner1.isNumericLiteralStart[character]) {
                return this.scanNumericLiteral();
            }

            // We run into so many identifiers (and keywords) when scanning, that we want the code to
            // be as fast as possible.  To that end, we have an extremely fast path for scanning that
            // handles the 99.9% case of no-unicode characters and no unicode escapes.
            if (Scanner1.isIdentifierStartCharacter[character]) {
                var result = this.tryFastScanIdentifierOrKeyword(character);
                if (result !== SyntaxKind.None) {
                    return result;
                }
            }

            if (this.isIdentifierStart(this.peekCharOrUnicodeEscape())) {
                return this.slowScanIdentifier(diagnostics);
            }

            return this.scanDefaultCharacter(character, diagnostics);
        }

        private isIdentifierStart(interpretedChar: number): bool {
            if (Scanner1.isIdentifierStartCharacter[interpretedChar]) {
                return true;
            }

            return interpretedChar > CharacterCodes.maxAsciiCharacter && Unicode.isIdentifierStart(interpretedChar, this._languageVersion);
        }

        private isIdentifierPart(interpretedChar: number): bool {
            if (Scanner1.isIdentifierPartCharacter[interpretedChar]) {
                return true;
            }

            return interpretedChar > CharacterCodes.maxAsciiCharacter && Unicode.isIdentifierPart(interpretedChar, this._languageVersion);
        }

        private tryFastScanIdentifierOrKeyword(firstCharacter: number): SyntaxKind {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            while (true) {
                var character = this.currentCharCode();
                if (Scanner1.isIdentifierPartCharacter[character]) {
                    // Still part of an identifier.  Move to the next caracter.
                    this.slidingWindow.moveToNextItem();
                }
                else if (character === CharacterCodes.backslash || character > CharacterCodes.maxAsciiCharacter) {
                    // We saw a \ (which could start a unicode escape), or we saw a unicode character.
                    // This can't be scanned quickly.  Reset to the beginning and bail out.  We'll 
                    // go and try the slow path instead.
                    this.slidingWindow.rewindToPinnedIndex(startIndex);
                    this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                    return SyntaxKind.None;
                }
                else {
                    // Saw an ascii character that wasn't a backslash and wasn't an identifier 
                    // character.  This identifier is done.
                    var endIndex = this.slidingWindow.absoluteIndex();

                    // Also check if it a keyword if it started with a lowercase letter.
                    var kind;
                    if (Scanner1.isKeywordStartCharacter[firstCharacter]) {
                        var offset = startIndex - this.slidingWindow.windowAbsoluteStartIndex;
                        kind = ScannerUtilities.identifierKind(this.slidingWindow.window, offset, endIndex - startIndex);
                    }
                    else {
                        kind = SyntaxKind.IdentifierName;
                    }

                    this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                    return kind;
                }
            }
        }

        // A slow path for scanning identifiers.  Called when we run into a unicode character or 
        // escape sequence while processing the fast path.
        private slowScanIdentifier(diagnostics: SyntaxDiagnostic[]): SyntaxKind {
            var startIndex = this.slidingWindow.absoluteIndex();

            do {
                this.scanCharOrUnicodeEscape(diagnostics);
            }
            while (this.isIdentifierPart(this.peekCharOrUnicodeEscape()));

            return SyntaxKind.IdentifierName;
        }

        private scanNumericLiteral(): SyntaxKind {
            if (this.isHexNumericLiteral()) {
                return this.scanHexNumericLiteral();
            }
            else {
                return this.scanDecimalNumericLiteral();
            }
        }

        private scanDecimalNumericLiteral(): SyntaxKind {
            while (CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            if (this.currentCharCode() === CharacterCodes.dot) {
                this.slidingWindow.moveToNextItem();
            }

            while (CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            var ch = this.currentCharCode();
            if (ch === CharacterCodes.e || ch === CharacterCodes.E) {
                this.slidingWindow.moveToNextItem();

                ch = this.currentCharCode();
                if (ch === CharacterCodes.minus || ch === CharacterCodes.plus) {
                    if (CharacterInfo.isDecimalDigit(this.slidingWindow.peekItemN(1))) {
                        this.slidingWindow.moveToNextItem();
                    }
                }
            }

            while (CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            return SyntaxKind.NumericLiteral;
        }

        private scanHexNumericLiteral(): SyntaxKind {
            // Debug.assert(this.isHexNumericLiteral());

            // Move past the 0x.
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            while (CharacterInfo.isHexDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            return SyntaxKind.NumericLiteral;
        }

        private isHexNumericLiteral(): bool {
            if (this.currentCharCode() === CharacterCodes._0) {
                var ch = this.slidingWindow.peekItemN(1);

                if (ch === CharacterCodes.x || ch === CharacterCodes.X) {
                    ch = this.slidingWindow.peekItemN(2);

                    return CharacterInfo.isHexDigit(ch);
                }
            }

            return false;
        }

        private advanceAndSetTokenKind(kind: SyntaxKind): SyntaxKind {
            this.slidingWindow.moveToNextItem();
            return kind;
        }

        private scanLessThanToken(): SyntaxKind {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.LessThanEqualsToken;
            }
            else if (this.currentCharCode() === CharacterCodes.lessThan) {
                this.slidingWindow.moveToNextItem();
                if (this.currentCharCode() === CharacterCodes.equals) {
                    this.slidingWindow.moveToNextItem();
                    return SyntaxKind.LessThanLessThanEqualsToken;
                }
                else {
                    return SyntaxKind.LessThanLessThanToken;
                }
            }
            else {
                return SyntaxKind.LessThanToken;
            }
        }

        private scanBarToken(): SyntaxKind {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.BarEqualsToken;
            }
            else if (this.currentCharCode() === CharacterCodes.bar) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.BarBarToken;
            }
            else {
                return SyntaxKind.BarToken;
            }
        }

        private scanCaretToken(): SyntaxKind {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.CaretEqualsToken;
            }
            else {
                return SyntaxKind.CaretToken;
            }
        }

        private scanAmpersandToken(): SyntaxKind {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.AmpersandEqualsToken;
            }
            else if (this.currentCharCode() === CharacterCodes.ampersand) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.AmpersandAmpersandToken;
            }
            else {
                return SyntaxKind.AmpersandToken;
            }
        }

        private scanPercentToken(): SyntaxKind {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.PercentEqualsToken;
            }
            else {
                return SyntaxKind.PercentToken;
            }
        }

        private scanMinusToken(): SyntaxKind {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();

            if (character === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.MinusEqualsToken;
            }
            else if (character === CharacterCodes.minus) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.MinusMinusToken;
            }
            else {
                return SyntaxKind.MinusToken;
            }
        }

        private scanPlusToken(): SyntaxKind {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.PlusEqualsToken;
            }
            else if (character === CharacterCodes.plus) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.PlusPlusToken;
            }
            else {
                return SyntaxKind.PlusToken;
            }
        }

        private scanAsteriskToken(): SyntaxKind {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.AsteriskEqualsToken;
            }
            else {
                return SyntaxKind.AsteriskToken;
            }
        }

        private scanEqualsToken(): SyntaxKind {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode()
            if (character === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();

                if (this.currentCharCode() === CharacterCodes.equals) {
                    this.slidingWindow.moveToNextItem();

                    return SyntaxKind.EqualsEqualsEqualsToken;
                }
                else {
                    return SyntaxKind.EqualsEqualsToken;
                }
            }
            else if (character === CharacterCodes.greaterThan) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.EqualsGreaterThanToken;
            }
            else {
                return SyntaxKind.EqualsToken;
            }
        }

        private isDotPrefixedNumericLiteral(): bool {
            if (this.currentCharCode() === CharacterCodes.dot) {
                var ch = this.slidingWindow.peekItemN(1);
                return CharacterInfo.isDecimalDigit(ch);
            }

            return false;
        }

        private scanDotToken(): SyntaxKind {
            if (this.isDotPrefixedNumericLiteral()) {
                return this.scanNumericLiteral();
            }

            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === CharacterCodes.dot &&
                this.slidingWindow.peekItemN(1) === CharacterCodes.dot) {

                this.slidingWindow.moveToNextItem();
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.DotDotDotToken;
            }
            else {
                return SyntaxKind.DotToken;
            }
        }

        private scanSlashToken(allowRegularExpression: bool): SyntaxKind {
            // NOTE: By default, we do not try scanning a / as a regexp here.  We instead consider it a
            // div or div-assign.  Later on, if the parser runs into a situation where it would like a 
            // term, and it sees one of these then it may restart us asking specifically if we could 
            // scan out a regex.
            if (allowRegularExpression) {
                var result = this.tryScanRegularExpressionToken();
                if (result !== SyntaxKind.None) {
                    return result;
                }
            }

            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();
                return SyntaxKind.SlashEqualsToken;
            }
            else {
                return SyntaxKind.SlashToken;
            }
        }

        private tryScanRegularExpressionToken(): SyntaxKind {
            // Debug.assert(this.currentCharCode() === CharacterCodes.slash);

            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            try {
                this.slidingWindow.moveToNextItem();

                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    var ch = this.currentCharCode();
                    if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                        this.slidingWindow.rewindToPinnedIndex(startIndex);
                        return SyntaxKind.None;
                    }

                    this.slidingWindow.moveToNextItem();
                    if (inEscape) {
                        inEscape = false;
                        continue;
                    }

                    switch (ch) {
                        case CharacterCodes.backslash:
                            // We're now in an escape.  Consume the next character we see (unless it's
                            // a newline or null.
                            inEscape = true;
                            continue;

                        case CharacterCodes.openBracket:
                            // If we see a [ then we're starting an character class.  Note: it's ok if 
                            // we then hit another [ inside a character class.  We'll just set the value
                            // to true again and that's ok.
                            inCharacterClass = true;
                            continue;

                        case CharacterCodes.closeBracket:
                            // If we ever hit a cloe bracket then we're now no longer in a character 
                            // class.  If we weren't in a character class to begin with, then this has 
                            // no effect.
                            inCharacterClass = false;
                            continue;

                        case CharacterCodes.slash:
                            // If we see a slash, and we're in a character class, then ignore it.
                            if (inCharacterClass) {
                                continue;
                            }

                            // We're done with the regex.  Break out of the switch (which will break 
                            // out of hte loop.
                            break;

                        default:
                            // Just consume any other characters.
                            continue;
                    }

                    break;
                }

                // TODO: The grammar says any identifier part is allowed here.  Do we need to support
                // \u identifiers here?  The existing typescript parser does not.  
                while (Scanner1.isIdentifierPartCharacter[this.currentCharCode()]) {
                    this.slidingWindow.moveToNextItem();
                }

                return SyntaxKind.RegularExpressionLiteral;
            }
            finally {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
            }
        }

        private scanExclamationToken(): SyntaxKind {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === CharacterCodes.equals) {
                this.slidingWindow.moveToNextItem();

                if (this.currentCharCode() === CharacterCodes.equals) {
                    this.slidingWindow.moveToNextItem();

                    return SyntaxKind.ExclamationEqualsEqualsToken;
                }
                else {
                    return SyntaxKind.ExclamationEqualsToken;
                }
            }
            else {
                return SyntaxKind.ExclamationToken;
            }
        }

        private scanDefaultCharacter(character: number, diagnostics: SyntaxDiagnostic[]): SyntaxKind {
            var position = this.slidingWindow.absoluteIndex();
            this.slidingWindow.moveToNextItem();

            var text = String.fromCharCode(character);
            var messageText = this.getErrorMessageText(text);
            diagnostics.push(new SyntaxDiagnostic(this.fileName,
                position, 1, DiagnosticCode.Unexpected_character_0, [messageText]));

            return SyntaxKind.ErrorToken;
        }

        // Convert text into a printable form usable for an error message.  This will both quote the 
        // string, and ensure all characters printable (i.e. by using unicode escapes when they're not).
        private getErrorMessageText(text: string): string {
            // For just a simple backslash, we return it as is.  The default behavior of JSON2.stringify
            // is not what we want here.
            if (text === "\\") {
                return '"\\"';
            }

            return JSON2.stringify(text);
        }

        // Code for if we ever want the value of a string literal:
        //    private skipEscapeSequence(diagnostics: SyntaxDiagnostic[]): void {
        //    // Debug.assert(this.currentCharCode() === CharacterCodes.backslash);

        //    var rewindPoint = this.slidingWindow.getAndPinAbsoluteIndex();
        //    try {
        //    // Consume the backslash.
        //        this.slidingWindow.moveToNextItem();

        //    // Get the char after the backslash
        //        var ch = this.currentCharCode();
        //        this.slidingWindow.moveToNextItem();
        //        switch (ch) {
        //            case CharacterCodes.singleQuote:
        //            case CharacterCodes.doubleQuote:
        //            case CharacterCodes.backslash:
        //                // value is ch itself;
        //                return;

        //            case CharacterCodes._0:
        //                // TODO: Deal with this part of the spec rule: 0 [lookahead ∉DecimalDigit]
        //                // value is CharacterCodes.nullCharacter;
        //                return;

        //            case CharacterCodes.b:
        //                // value is CharacterCodes.backspace;
        //                return;

        //            case CharacterCodes.f:
        //                // value is CharacterCodes.formFeed;
        //                return;

        //            case CharacterCodes.n:
        //                // value is CharacterCodes.newLine;
        //                return;

        //            case CharacterCodes.r:
        //                // value is CharacterCodes.carriageReturn;
        //                return;

        //            case CharacterCodes.t:
        //                // value is CharacterCodes.tab;
        //                return;

        //            case CharacterCodes.v:
        //                // value is CharacterCodes.verticalTab;
        //                return;

        //            case CharacterCodes.x:
        //            case CharacterCodes.u:
        //                this.rewind(rewindPoint);
        //                var value = this.scanUnicodeOrHexEscape(diagnostics);
        //                return;

        //            case CharacterCodes.carriageReturn:
        //                // If it's \r\n then consume both characters.
        //                if (this.currentCharCode() === CharacterCodes.lineFeed) {
        //                    this.slidingWindow.moveToNextItem();
        //                }
        //                return;
        //            case CharacterCodes.lineFeed:
        //            case CharacterCodes.paragraphSeparator:
        //            case CharacterCodes.lineSeparator:
        //                return;

        //            default:
        //                // Any other character is ok as well.  As per rule:
        //                // EscapeSequence :: CharacterEscapeSequence
        //                // CharacterEscapeSequence :: NonEscapeCharacter
        //                // NonEscapeCharacter :: SourceCharacter but notEscapeCharacter or LineTerminator
        //                return;
        //        }
        //    }
        //    finally {
        //        this.releaseAndUnpinAbsoluteIndex(rewindPoint);
        //    }
        //}

        private skipEscapeSequence(diagnostics: SyntaxDiagnostic[]): void {
            // Debug.assert(this.currentCharCode() === CharacterCodes.backslash);

            var rewindPoint = this.slidingWindow.getAndPinAbsoluteIndex();
            try {
                // Consume the backslash.
                this.slidingWindow.moveToNextItem();

                // Get the char after the backslash
                var ch = this.currentCharCode();
                this.slidingWindow.moveToNextItem();
                switch (ch) {
                    case CharacterCodes.x:
                    case CharacterCodes.u:
                        this.slidingWindow.rewindToPinnedIndex(rewindPoint);
                        var value = this.scanUnicodeOrHexEscape(diagnostics);
                        return;

                    case CharacterCodes.carriageReturn:
                        // If it's \r\n then consume both characters.
                        if (this.currentCharCode() === CharacterCodes.lineFeed) {
                            this.slidingWindow.moveToNextItem();
                        }
                        return;

                    // We don't have to do anything special about these characters.  I'm including them
                    // Just so it's clear that we intentially process them in the exact same way:
                    //case CharacterCodes.singleQuote:
                    //case CharacterCodes.doubleQuote:
                    //case CharacterCodes.backslash:
                    //case CharacterCodes._0:
                    //case CharacterCodes.b:
                    //case CharacterCodes.f:
                    //case CharacterCodes.n:
                    //case CharacterCodes.r:
                    //case CharacterCodes.t:
                    //case CharacterCodes.v:
                    //case CharacterCodes.lineFeed:
                    //case CharacterCodes.paragraphSeparator:
                    //case CharacterCodes.lineSeparator:
                    default:
                        // Any other character is ok as well.  As per rule:
                        // EscapeSequence :: CharacterEscapeSequence
                        // CharacterEscapeSequence :: NonEscapeCharacter
                        // NonEscapeCharacter :: SourceCharacter but notEscapeCharacter or LineTerminator
                        return;
                }
            }
            finally {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(rewindPoint);
            }
        }

        private scanStringLiteral(diagnostics: SyntaxDiagnostic[]): SyntaxKind {
            var quoteCharacter = this.currentCharCode();

            // Debug.assert(quoteCharacter === CharacterCodes.singleQuote || quoteCharacter === CharacterCodes.doubleQuote);

            this.slidingWindow.moveToNextItem();

            while (true) {
                var ch = this.currentCharCode();
                if (ch === CharacterCodes.backslash) {
                    this.skipEscapeSequence(diagnostics);
                }
                else if (ch === quoteCharacter) {
                    this.slidingWindow.moveToNextItem();
                    break;
                }
                else if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                    diagnostics.push(new SyntaxDiagnostic(this.fileName,
                        this.slidingWindow.absoluteIndex(), 1, DiagnosticCode.Missing_closing_quote_character, null));
                    break;
                }
                else {
                    this.slidingWindow.moveToNextItem();
                }
            }

            return SyntaxKind.StringLiteral;
        }

        private isUnicodeOrHexEscape(character: number): bool {
            return this.isUnicodeEscape(character) || this.isHexEscape(character);
        }

        private isUnicodeEscape(character: number): bool {
            if (character === CharacterCodes.backslash) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === CharacterCodes.u) {
                    return true;
                }
            }

            return false;
        }

        private isHexEscape(character: number): bool {
            if (character === CharacterCodes.backslash) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === CharacterCodes.x) {
                    return true;
                }
            }

            return false;
        }

        private peekCharOrUnicodeOrHexEscape(): number {
            var character = this.currentCharCode();
            if (this.isUnicodeOrHexEscape(character)) {
                return this.peekUnicodeOrHexEscape();
            }
            else {
                return character;
            }
        }

        private peekCharOrUnicodeEscape(): number {
            var character = this.currentCharCode();
            if (this.isUnicodeEscape(character)) {
                return this.peekUnicodeOrHexEscape();
            }
            else {
                return character;
            }
        }

        private peekUnicodeOrHexEscape(): number {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            // if we're peeking, then we don't want to change the position
            var ch = this.scanUnicodeOrHexEscape(/*errors:*/ null);

            this.slidingWindow.rewindToPinnedIndex(startIndex);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);

            return ch;
        }

        private scanCharOrUnicodeEscape(errors: SyntaxDiagnostic[]): number {
            var ch = this.currentCharCode();
            if (ch === CharacterCodes.backslash) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === CharacterCodes.u) {
                    return this.scanUnicodeOrHexEscape(errors);
                }
            }

            this.slidingWindow.moveToNextItem();
            return ch;
        }

        private scanCharOrUnicodeOrHexEscape(errors: SyntaxDiagnostic[]): number {
            var ch = this.currentCharCode();
            if (ch === CharacterCodes.backslash) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === CharacterCodes.u || ch2 === CharacterCodes.x) {
                    return this.scanUnicodeOrHexEscape(errors);
                }
            }

            this.slidingWindow.moveToNextItem();
            return ch;
        }

        private scanUnicodeOrHexEscape(errors: SyntaxDiagnostic[]): number {
            var start = this.slidingWindow.absoluteIndex();
            var character = this.currentCharCode();
            // Debug.assert(character === CharacterCodes.backslash);
            this.slidingWindow.moveToNextItem();

            character = this.currentCharCode();
            // Debug.assert(character === CharacterCodes.u || character === CharacterCodes.x);

            var intChar = 0;
            this.slidingWindow.moveToNextItem();

            var count = character === CharacterCodes.u ? 4 : 2;

            for (var i = 0; i < count; i++) {
                var ch2 = this.currentCharCode();
                if (!CharacterInfo.isHexDigit(ch2)) {
                    if (errors !== null) {
                        var end = this.slidingWindow.absoluteIndex();
                        var info = this.createIllegalEscapeDiagnostic(start, end);
                        errors.push(info);
                    }

                    break;
                }

                intChar = (intChar << 4) + CharacterInfo.hexValue(ch2);
                this.slidingWindow.moveToNextItem();
            }

            return intChar;
        }

        public substring(start: number, end: number, intern: bool): string {
            var length = end - start;
            var offset = start - this.slidingWindow.windowAbsoluteStartIndex;

            // Debug.assert(offset >= 0);
            if (intern) {
                return Collections.DefaultStringTable.addCharArray(this.slidingWindow.window, offset, length);
            }
            else {
                return StringUtilities.fromCharCodeArray(this.slidingWindow.window.slice(offset, offset + length));
            }
        }

        private createIllegalEscapeDiagnostic(start: number, end: number): SyntaxDiagnostic {
            return new SyntaxDiagnostic(this.fileName, start, end - start,
                DiagnosticCode.Unrecognized_escape_sequence, null);
        }
    }
}
///<reference path='References.ts' />

module TypeScript.Syntax {
    export function realizeToken(token: ISyntaxToken): ISyntaxToken {
        return new RealizedToken(token.tokenKind,
            token.leadingTrivia(), token.text(), token.value(), token.trailingTrivia());
    }

    export function convertToIdentifierName(token: ISyntaxToken): ISyntaxToken {
        Debug.assert(SyntaxFacts.isAnyKeyword(token.tokenKind));
        return new RealizedToken(SyntaxKind.IdentifierName,
            token.leadingTrivia(), token.text(), token.value(), token.trailingTrivia());
    }

    export function tokenToJSON(token: ISyntaxToken) {
        var result: any = {};

        result.kind = (<any>SyntaxKind)._map[token.kind()];

        result.width = token.width();
        if (token.fullWidth() !== token.width()) {
            result.fullWidth = token.fullWidth();
        }

        result.text = token.text();

        if (token.value() !== null) {
            result.valueText = token.value();
        }

        if (token.hasLeadingTrivia()) {
            result.hasLeadingTrivia = true;
        }

        if (token.hasLeadingComment()) {
            result.hasLeadingComment = true;
        }

        if (token.hasLeadingNewLine()) {
            result.hasLeadingNewLine = true;
        }

        if (token.hasLeadingSkippedText()) {
            result.hasLeadingSkippedText = true;
        }

        if (token.hasTrailingTrivia()) {
            result.hasTrailingTrivia = true;
        }

        if (token.hasTrailingComment()) {
            result.hasTrailingComment = true;
        }

        if (token.hasTrailingNewLine()) {
            result.hasTrailingNewLine = true;
        }

        if (token.hasTrailingSkippedText()) {
            result.hasTrailingSkippedText = true;
        }

        var trivia = token.leadingTrivia();
        if (trivia.count() > 0) {
            result.leadingTrivia = trivia;
        }

        trivia = token.trailingTrivia();
        if (trivia.count() > 0) {
            result.trailingTrivia = trivia;
        }

        return result;
    }

    export function value(token: ISyntaxToken): any {
        if (token.tokenKind === SyntaxKind.IdentifierName) {
            var text = token.text();
            for (var i = 0; i < text.length; i++) {
                // TODO: handle unicode and escapes.
                if (!Scanner1.isIdentifierPartCharacter[text.charCodeAt(i)]) {
                    return null;
                }
            }

            return text;
        }
        else if (token.tokenKind === SyntaxKind.NumericLiteral) {
            // TODO: implement this.
            return null;
        }
        else if (token.tokenKind === SyntaxKind.StringLiteral) {
            // TODO: implement this.
            return null;
        }
        else if (token.tokenKind === SyntaxKind.RegularExpressionLiteral) {
            // TODO: implement this.
            return null;
        }
        else if (token.tokenKind === SyntaxKind.EndOfFileToken || token.tokenKind === SyntaxKind.ErrorToken) {
            return null;
        }
        else {
            throw Errors.invalidOperation();
        }
    }

    class EmptyToken implements ISyntaxToken {
        public tokenKind: SyntaxKind;

        constructor(kind: SyntaxKind) {
            this.tokenKind = kind;
        }

        public clone(): ISyntaxToken {
            return new EmptyToken(this.tokenKind);
        }

        public kind() { return this.tokenKind; }

        public isToken(): bool { return true; }
        public isNode(): bool { return false; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }

        public childCount(): number {
            return 0;
        }

        public childAt(index: number): ISyntaxElement {
            throw Errors.argumentOutOfRange("index");
        }

        public toJSON(key) { return tokenToJSON(this); }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind); }

        public fullWidth() { return 0; }
        public width() { return 0; }
        public text() { return ""; }
        public fullText(): string { return ""; }
        public value() { return null; }

        public hasLeadingTrivia() { return false; }
        public hasLeadingComment() { return false; }
        public hasLeadingNewLine() { return false; }
        public hasLeadingSkippedText() { return false; }
        public leadingTriviaWidth() { return 0; }
        public hasTrailingTrivia() { return false; }
        public hasTrailingComment() { return false; }
        public hasTrailingNewLine() { return false; }
        public hasTrailingSkippedText() { return false; }
        public hasSkippedText() { return false; }

        public trailingTriviaWidth() { return 0; }
        public leadingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }
        public trailingTrivia(): ISyntaxTriviaList { return Syntax.emptyTriviaList; }
        public realize(): ISyntaxToken { return realizeToken(this); }
        private collectTextElements(elements: string[]): void { }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withLeadingTrivia(leadingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return this.realize().withTrailingTrivia(trailingTrivia);
        }
    }

    export function emptyToken(kind: SyntaxKind): ISyntaxToken {
        return new EmptyToken(kind);
    }

    class RealizedToken implements ISyntaxToken {
        public tokenKind: SyntaxKind;
        // public tokenKeywordKind: SyntaxKind;
        private _leadingTrivia: ISyntaxTriviaList;
        private _text: string;
        private _value: any;
        private _trailingTrivia: ISyntaxTriviaList;

        constructor(tokenKind: SyntaxKind,
                    leadingTrivia: ISyntaxTriviaList,
                    text: string,
                    value: any,
                    trailingTrivia: ISyntaxTriviaList) {
            this.tokenKind = tokenKind;
            this._leadingTrivia = leadingTrivia;
            this._text = text;
            this._value = value;
            this._trailingTrivia = trailingTrivia;
        }

        public clone(): ISyntaxToken {
            return new RealizedToken(this.tokenKind, /*this.tokenKeywordKind,*/ this._leadingTrivia,
                this._text, this._value, this._trailingTrivia);
        }

        public kind(): SyntaxKind { return this.tokenKind; }
        public toJSON(key) { return tokenToJSON(this); }
        private firstToken() { return this; }
        private lastToken() { return this; }
        private isTypeScriptSpecific() { return false; }
        private hasZeroWidthToken() { return this.fullWidth() === 0; }
        private hasRegularExpressionToken() { return SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.kind()); }
        private accept(visitor: ISyntaxVisitor): any { return visitor.visitToken(this); }

        public childCount(): number {
            return 0;
        }

        public childAt(index: number): ISyntaxElement {
            throw Errors.argumentOutOfRange("index");
        }

        public isToken(): bool { return true; }
        public isNode(): bool { return false; }
        public isList(): bool { return false; }
        public isSeparatedList(): bool { return false; }
        public isTrivia(): bool { return false; }
        public isTriviaList(): bool { return false; }

        public fullWidth(): number { return this._leadingTrivia.fullWidth() + this.width() + this._trailingTrivia.fullWidth(); }
        public width(): number { return this.text().length; }

        public text(): string { return this._text; }
        public fullText(): string { return this._leadingTrivia.fullText() + this.text() + this._trailingTrivia.fullText(); }

        public value(): any { return this._value; }

        public hasLeadingTrivia(): bool { return this._leadingTrivia.count() > 0; }
        public hasLeadingComment(): bool { return this._leadingTrivia.hasComment(); }
        public hasLeadingNewLine(): bool { return this._leadingTrivia.hasNewLine(); }
        public hasLeadingSkippedText(): bool { return this._leadingTrivia.hasSkippedText(); }
        public leadingTriviaWidth(): number { return this._leadingTrivia.fullWidth(); }

        public hasTrailingTrivia(): bool { return this._trailingTrivia.count() > 0; }
        public hasTrailingComment(): bool { return this._trailingTrivia.hasComment(); }
        public hasTrailingNewLine(): bool { return this._trailingTrivia.hasNewLine(); }
        public hasTrailingSkippedText(): bool { return this._trailingTrivia.hasSkippedText(); }
        public trailingTriviaWidth(): number { return this._trailingTrivia.fullWidth(); }

        public hasSkippedText(): bool { return this.hasLeadingSkippedText() || this.hasTrailingSkippedText(); }

        public leadingTrivia(): ISyntaxTriviaList { return this._leadingTrivia; }
        public trailingTrivia(): ISyntaxTriviaList { return this._trailingTrivia; }

        private findTokenInternal(parent: PositionedElement, position: number, fullStart: number): PositionedToken {
            return new PositionedToken(parent, this, fullStart);
        }

        private collectTextElements(elements: string[]): void {
            this.leadingTrivia().collectTextElements(elements);
            elements.push(this.text());
            this.trailingTrivia().collectTextElements(elements);
        }

        public withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return new RealizedToken(
                this.tokenKind, /*this.tokenKeywordKind,*/
                leadingTrivia, this._text, this._value,
                this._trailingTrivia);
        }

        public withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken {
            return new RealizedToken(
                this.tokenKind, /*this.tokenKeywordKind,*/
                this._leadingTrivia, this._text, this._value,
                trailingTrivia);
        }
    }

    export function token(kind: SyntaxKind, info: ITokenInfo = null): ISyntaxToken {
        var text = (info !== null && info.text !== undefined) ? info.text : SyntaxFacts.getText(kind);
        var value = (info !== null && info.value !== undefined) ? info.value : null;

        return new RealizedToken(
            kind,
            Syntax.triviaList(info === null ? null : info.leadingTrivia),
            text,
            value,
            Syntax.triviaList(info === null ? null : info.trailingTrivia));
    }
    
    export function identifier(text: string, info: ITokenInfo = null): ISyntaxToken {
        info = info || {};
        info.text = text;
        return token(SyntaxKind.IdentifierName, info);
    }
}
﻿///<reference path='References.ts' />

module TypeScript.Syntax {
    export interface IFactory {
        sourceUnit(moduleElements: ISyntaxList, endOfFileToken: ISyntaxToken): SourceUnitSyntax;
        externalModuleReference(moduleKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax;
        moduleNameModuleReference(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax;
        importDeclaration(importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: ModuleReferenceSyntax, semicolonToken: ISyntaxToken): ImportDeclarationSyntax;
        exportAssignment(exportKeyword: ISyntaxToken, equalsToken: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ExportAssignmentSyntax;
        classDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, implementsClause: ImplementsClauseSyntax, openBraceToken: ISyntaxToken, classElements: ISyntaxList, closeBraceToken: ISyntaxToken): ClassDeclarationSyntax;
        interfaceDeclaration(exportKeyword: ISyntaxToken, interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, body: ObjectTypeSyntax): InterfaceDeclarationSyntax;
        extendsClause(extendsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax;
        implementsClause(implementsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax;
        moduleDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, moduleKeyword: ISyntaxToken, moduleName: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: ISyntaxList, closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax;
        functionDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): FunctionDeclarationSyntax;
        variableStatement(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken): VariableStatementSyntax;
        variableDeclaration(varKeyword: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax;
        variableDeclarator(identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax;
        equalsValueClause(equalsToken: ISyntaxToken, value: IExpressionSyntax): EqualsValueClauseSyntax;
        prefixUnaryExpression(kind: SyntaxKind, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax;
        arrayLiteralExpression(openBracketToken: ISyntaxToken, expressions: ISeparatedSyntaxList, closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax;
        omittedExpression(): OmittedExpressionSyntax;
        parenthesizedExpression(openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax;
        simpleArrowFunctionExpression(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax;
        parenthesizedArrowFunctionExpression(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax;
        qualifiedName(left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken): QualifiedNameSyntax;
        typeArgumentList(lessThanToken: ISyntaxToken, typeArguments: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeArgumentListSyntax;
        constructorType(newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): ConstructorTypeSyntax;
        functionType(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): FunctionTypeSyntax;
        objectType(openBraceToken: ISyntaxToken, typeMembers: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectTypeSyntax;
        arrayType(type: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken): ArrayTypeSyntax;
        genericType(name: INameSyntax, typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax;
        typeAnnotation(colonToken: ISyntaxToken, type: ITypeSyntax): TypeAnnotationSyntax;
        block(openBraceToken: ISyntaxToken, statements: ISyntaxList, closeBraceToken: ISyntaxToken): BlockSyntax;
        parameter(dotDotDotToken: ISyntaxToken, publicOrPrivateKeyword: ISyntaxToken, identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax;
        memberAccessExpression(expression: IExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken): MemberAccessExpressionSyntax;
        postfixUnaryExpression(kind: SyntaxKind, operand: IExpressionSyntax, operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax;
        elementAccessExpression(expression: IExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax;
        invocationExpression(expression: IExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax;
        argumentList(typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, arguments: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ArgumentListSyntax;
        binaryExpression(kind: SyntaxKind, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax;
        conditionalExpression(condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax): ConditionalExpressionSyntax;
        constructSignature(newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax): ConstructSignatureSyntax;
        methodSignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax): MethodSignatureSyntax;
        indexSignature(openBracketToken: ISyntaxToken, identifier: ISyntaxToken, parameterTypeAnnotation: TypeAnnotationSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax;
        propertySignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax;
        callSignature(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax;
        parameterList(openParenToken: ISyntaxToken, parameters: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ParameterListSyntax;
        typeParameterList(lessThanToken: ISyntaxToken, typeParameters: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeParameterListSyntax;
        typeParameter(identifier: ISyntaxToken, constraint: ConstraintSyntax): TypeParameterSyntax;
        constraint(extendsKeyword: ISyntaxToken, type: ITypeSyntax): ConstraintSyntax;
        elseClause(elseKeyword: ISyntaxToken, statement: IStatementSyntax): ElseClauseSyntax;
        ifStatement(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax): IfStatementSyntax;
        expressionStatement(expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ExpressionStatementSyntax;
        constructorDeclaration(constructorKeyword: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax;
        memberFunctionDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax;
        getMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, getKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetMemberAccessorDeclarationSyntax;
        setMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, setKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetMemberAccessorDeclarationSyntax;
        memberVariableDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax;
        throwStatement(throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ThrowStatementSyntax;
        returnStatement(returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ReturnStatementSyntax;
        objectCreationExpression(newKeyword: ISyntaxToken, expression: IExpressionSyntax, argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax;
        switchStatement(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISyntaxList, closeBraceToken: ISyntaxToken): SwitchStatementSyntax;
        caseSwitchClause(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: ISyntaxList): CaseSwitchClauseSyntax;
        defaultSwitchClause(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: ISyntaxList): DefaultSwitchClauseSyntax;
        breakStatement(breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): BreakStatementSyntax;
        continueStatement(continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ContinueStatementSyntax;
        forStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForStatementSyntax;
        forInStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForInStatementSyntax;
        whileStatement(whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WhileStatementSyntax;
        withStatement(withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WithStatementSyntax;
        enumDeclaration(exportKeyword: ISyntaxToken, enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, enumElements: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): EnumDeclarationSyntax;
        enumElement(identifier: ISyntaxToken, stringLiteral: ISyntaxToken, equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax;
        castExpression(lessThanToken: ISyntaxToken, type: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax): CastExpressionSyntax;
        objectLiteralExpression(openBraceToken: ISyntaxToken, propertyAssignments: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax;
        simplePropertyAssignment(propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax): SimplePropertyAssignmentSyntax;
        getAccessorPropertyAssignment(getKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, closeParenToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetAccessorPropertyAssignmentSyntax;
        setAccessorPropertyAssignment(setKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, parameter: ParameterSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax): SetAccessorPropertyAssignmentSyntax;
        functionExpression(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax;
        emptyStatement(semicolonToken: ISyntaxToken): EmptyStatementSyntax;
        tryStatement(tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax): TryStatementSyntax;
        catchClause(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax): CatchClauseSyntax;
        finallyClause(finallyKeyword: ISyntaxToken, block: BlockSyntax): FinallyClauseSyntax;
        labeledStatement(identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax): LabeledStatementSyntax;
        doStatement(doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken): DoStatementSyntax;
        typeOfExpression(typeOfKeyword: ISyntaxToken, expression: IExpressionSyntax): TypeOfExpressionSyntax;
        deleteExpression(deleteKeyword: ISyntaxToken, expression: IExpressionSyntax): DeleteExpressionSyntax;
        voidExpression(voidKeyword: ISyntaxToken, expression: IExpressionSyntax): VoidExpressionSyntax;
        debuggerStatement(debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): DebuggerStatementSyntax;
    }

    export class NormalModeFactory implements IFactory {
        sourceUnit(moduleElements: ISyntaxList, endOfFileToken: ISyntaxToken): SourceUnitSyntax {
            return new SourceUnitSyntax(moduleElements, endOfFileToken, /*parsedInStrictMode:*/ false);
        }
        externalModuleReference(moduleKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax {
            return new ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, /*parsedInStrictMode:*/ false);
        }
        moduleNameModuleReference(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax {
            return new ModuleNameModuleReferenceSyntax(moduleName, /*parsedInStrictMode:*/ false);
        }
        importDeclaration(importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: ModuleReferenceSyntax, semicolonToken: ISyntaxToken): ImportDeclarationSyntax {
            return new ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        exportAssignment(exportKeyword: ISyntaxToken, equalsToken: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ExportAssignmentSyntax {
            return new ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        classDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, implementsClause: ImplementsClauseSyntax, openBraceToken: ISyntaxToken, classElements: ISyntaxList, closeBraceToken: ISyntaxToken): ClassDeclarationSyntax {
            return new ClassDeclarationSyntax(exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        interfaceDeclaration(exportKeyword: ISyntaxToken, interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, body: ObjectTypeSyntax): InterfaceDeclarationSyntax {
            return new InterfaceDeclarationSyntax(exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body, /*parsedInStrictMode:*/ false);
        }
        extendsClause(extendsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax {
            return new ExtendsClauseSyntax(extendsKeyword, typeNames, /*parsedInStrictMode:*/ false);
        }
        implementsClause(implementsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax {
            return new ImplementsClauseSyntax(implementsKeyword, typeNames, /*parsedInStrictMode:*/ false);
        }
        moduleDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, moduleKeyword: ISyntaxToken, moduleName: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: ISyntaxList, closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
            return new ModuleDeclarationSyntax(exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        functionDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): FunctionDeclarationSyntax {
            return new FunctionDeclarationSyntax(exportKeyword, declareKeyword, functionKeyword, identifier, callSignature, block, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        variableStatement(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken): VariableStatementSyntax {
            return new VariableStatementSyntax(exportKeyword, declareKeyword, variableDeclaration, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        variableDeclaration(varKeyword: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax {
            return new VariableDeclarationSyntax(varKeyword, variableDeclarators, /*parsedInStrictMode:*/ false);
        }
        variableDeclarator(identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax {
            return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ false);
        }
        equalsValueClause(equalsToken: ISyntaxToken, value: IExpressionSyntax): EqualsValueClauseSyntax {
            return new EqualsValueClauseSyntax(equalsToken, value, /*parsedInStrictMode:*/ false);
        }
        prefixUnaryExpression(kind: SyntaxKind, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax {
            return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, /*parsedInStrictMode:*/ false);
        }
        arrayLiteralExpression(openBracketToken: ISyntaxToken, expressions: ISeparatedSyntaxList, closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
            return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, /*parsedInStrictMode:*/ false);
        }
        omittedExpression(): OmittedExpressionSyntax {
            return new OmittedExpressionSyntax(/*parsedInStrictMode:*/ false);
        }
        parenthesizedExpression(openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax {
            return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, /*parsedInStrictMode:*/ false);
        }
        simpleArrowFunctionExpression(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax {
            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ false);
        }
        parenthesizedArrowFunctionExpression(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax {
            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ false);
        }
        qualifiedName(left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken): QualifiedNameSyntax {
            return new QualifiedNameSyntax(left, dotToken, right, /*parsedInStrictMode:*/ false);
        }
        typeArgumentList(lessThanToken: ISyntaxToken, typeArguments: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeArgumentListSyntax {
            return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, /*parsedInStrictMode:*/ false);
        }
        constructorType(newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): ConstructorTypeSyntax {
            return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ false);
        }
        functionType(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): FunctionTypeSyntax {
            return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ false);
        }
        objectType(openBraceToken: ISyntaxToken, typeMembers: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectTypeSyntax {
            return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        arrayType(type: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken): ArrayTypeSyntax {
            return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, /*parsedInStrictMode:*/ false);
        }
        genericType(name: INameSyntax, typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax {
            return new GenericTypeSyntax(name, typeArgumentList, /*parsedInStrictMode:*/ false);
        }
        typeAnnotation(colonToken: ISyntaxToken, type: ITypeSyntax): TypeAnnotationSyntax {
            return new TypeAnnotationSyntax(colonToken, type, /*parsedInStrictMode:*/ false);
        }
        block(openBraceToken: ISyntaxToken, statements: ISyntaxList, closeBraceToken: ISyntaxToken): BlockSyntax {
            return new BlockSyntax(openBraceToken, statements, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        parameter(dotDotDotToken: ISyntaxToken, publicOrPrivateKeyword: ISyntaxToken, identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax {
            return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ false);
        }
        memberAccessExpression(expression: IExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken): MemberAccessExpressionSyntax {
            return new MemberAccessExpressionSyntax(expression, dotToken, name, /*parsedInStrictMode:*/ false);
        }
        postfixUnaryExpression(kind: SyntaxKind, operand: IExpressionSyntax, operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax {
            return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, /*parsedInStrictMode:*/ false);
        }
        elementAccessExpression(expression: IExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax {
            return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, /*parsedInStrictMode:*/ false);
        }
        invocationExpression(expression: IExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax {
            return new InvocationExpressionSyntax(expression, argumentList, /*parsedInStrictMode:*/ false);
        }
        argumentList(typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, _arguments: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ArgumentListSyntax {
            return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, /*parsedInStrictMode:*/ false);
        }
        binaryExpression(kind: SyntaxKind, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax {
            return new BinaryExpressionSyntax(kind, left, operatorToken, right, /*parsedInStrictMode:*/ false);
        }
        conditionalExpression(condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax): ConditionalExpressionSyntax {
            return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, /*parsedInStrictMode:*/ false);
        }
        constructSignature(newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax): ConstructSignatureSyntax {
            return new ConstructSignatureSyntax(newKeyword, callSignature, /*parsedInStrictMode:*/ false);
        }
        methodSignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax): MethodSignatureSyntax {
            return new MethodSignatureSyntax(propertyName, questionToken, callSignature, /*parsedInStrictMode:*/ false);
        }
        indexSignature(openBracketToken: ISyntaxToken, identifier: ISyntaxToken, parameterTypeAnnotation: TypeAnnotationSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax {
            return new IndexSignatureSyntax(openBracketToken, identifier, parameterTypeAnnotation, closeBracketToken, typeAnnotation, /*parsedInStrictMode:*/ false);
        }
        propertySignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax {
            return new PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, /*parsedInStrictMode:*/ false);
        }
        callSignature(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax {
            return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, /*parsedInStrictMode:*/ false);
        }
        parameterList(openParenToken: ISyntaxToken, parameters: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ParameterListSyntax {
            return new ParameterListSyntax(openParenToken, parameters, closeParenToken, /*parsedInStrictMode:*/ false);
        }
        typeParameterList(lessThanToken: ISyntaxToken, typeParameters: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeParameterListSyntax {
            return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, /*parsedInStrictMode:*/ false);
        }
        typeParameter(identifier: ISyntaxToken, constraint: ConstraintSyntax): TypeParameterSyntax {
            return new TypeParameterSyntax(identifier, constraint, /*parsedInStrictMode:*/ false);
        }
        constraint(extendsKeyword: ISyntaxToken, type: ITypeSyntax): ConstraintSyntax {
            return new ConstraintSyntax(extendsKeyword, type, /*parsedInStrictMode:*/ false);
        }
        elseClause(elseKeyword: ISyntaxToken, statement: IStatementSyntax): ElseClauseSyntax {
            return new ElseClauseSyntax(elseKeyword, statement, /*parsedInStrictMode:*/ false);
        }
        ifStatement(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax): IfStatementSyntax {
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, /*parsedInStrictMode:*/ false);
        }
        expressionStatement(expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ExpressionStatementSyntax {
            return new ExpressionStatementSyntax(expression, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        constructorDeclaration(constructorKeyword: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax {
            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        memberFunctionDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax {
            return new MemberFunctionDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, propertyName, callSignature, block, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        getMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, getKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetMemberAccessorDeclarationSyntax {
            return new GetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block, /*parsedInStrictMode:*/ false);
        }
        setMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, setKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetMemberAccessorDeclarationSyntax {
            return new SetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block, /*parsedInStrictMode:*/ false);
        }
        memberVariableDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax {
            return new MemberVariableDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        throwStatement(throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ThrowStatementSyntax {
            return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        returnStatement(returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ReturnStatementSyntax {
            return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        objectCreationExpression(newKeyword: ISyntaxToken, expression: IExpressionSyntax, argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax {
            return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, /*parsedInStrictMode:*/ false);
        }
        switchStatement(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISyntaxList, closeBraceToken: ISyntaxToken): SwitchStatementSyntax {
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        caseSwitchClause(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: ISyntaxList): CaseSwitchClauseSyntax {
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, /*parsedInStrictMode:*/ false);
        }
        defaultSwitchClause(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: ISyntaxList): DefaultSwitchClauseSyntax {
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, /*parsedInStrictMode:*/ false);
        }
        breakStatement(breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): BreakStatementSyntax {
            return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        continueStatement(continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ContinueStatementSyntax {
            return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        forStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForStatementSyntax {
            return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, /*parsedInStrictMode:*/ false);
        }
        forInStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForInStatementSyntax {
            return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, /*parsedInStrictMode:*/ false);
        }
        whileStatement(whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WhileStatementSyntax {
            return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ false);
        }
        withStatement(withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WithStatementSyntax {
            return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ false);
        }
        enumDeclaration(exportKeyword: ISyntaxToken, enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, enumElements: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): EnumDeclarationSyntax {
            return new EnumDeclarationSyntax(exportKeyword, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        enumElement(identifier: ISyntaxToken, stringLiteral: ISyntaxToken, equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax {
            return new EnumElementSyntax(identifier, stringLiteral, equalsValueClause, /*parsedInStrictMode:*/ false);
        }
        castExpression(lessThanToken: ISyntaxToken, type: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax): CastExpressionSyntax {
            return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, /*parsedInStrictMode:*/ false);
        }
        objectLiteralExpression(openBraceToken: ISyntaxToken, propertyAssignments: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
            return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, /*parsedInStrictMode:*/ false);
        }
        simplePropertyAssignment(propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax): SimplePropertyAssignmentSyntax {
            return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, /*parsedInStrictMode:*/ false);
        }
        getAccessorPropertyAssignment(getKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, closeParenToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetAccessorPropertyAssignmentSyntax {
            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, /*parsedInStrictMode:*/ false);
        }
        setAccessorPropertyAssignment(setKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, parameter: ParameterSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax): SetAccessorPropertyAssignmentSyntax {
            return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, /*parsedInStrictMode:*/ false);
        }
        functionExpression(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax {
            return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, /*parsedInStrictMode:*/ false);
        }
        emptyStatement(semicolonToken: ISyntaxToken): EmptyStatementSyntax {
            return new EmptyStatementSyntax(semicolonToken, /*parsedInStrictMode:*/ false);
        }
        tryStatement(tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax): TryStatementSyntax {
            return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, /*parsedInStrictMode:*/ false);
        }
        catchClause(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax): CatchClauseSyntax {
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, /*parsedInStrictMode:*/ false);
        }
        finallyClause(finallyKeyword: ISyntaxToken, block: BlockSyntax): FinallyClauseSyntax {
            return new FinallyClauseSyntax(finallyKeyword, block, /*parsedInStrictMode:*/ false);
        }
        labeledStatement(identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax): LabeledStatementSyntax {
            return new LabeledStatementSyntax(identifier, colonToken, statement, /*parsedInStrictMode:*/ false);
        }
        doStatement(doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken): DoStatementSyntax {
            return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, /*parsedInStrictMode:*/ false);
        }
        typeOfExpression(typeOfKeyword: ISyntaxToken, expression: IExpressionSyntax): TypeOfExpressionSyntax {
            return new TypeOfExpressionSyntax(typeOfKeyword, expression, /*parsedInStrictMode:*/ false);
        }
        deleteExpression(deleteKeyword: ISyntaxToken, expression: IExpressionSyntax): DeleteExpressionSyntax {
            return new DeleteExpressionSyntax(deleteKeyword, expression, /*parsedInStrictMode:*/ false);
        }
        voidExpression(voidKeyword: ISyntaxToken, expression: IExpressionSyntax): VoidExpressionSyntax {
            return new VoidExpressionSyntax(voidKeyword, expression, /*parsedInStrictMode:*/ false);
        }
        debuggerStatement(debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): DebuggerStatementSyntax {
            return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, /*parsedInStrictMode:*/ false);
        }
    }

    export class StrictModeFactory implements IFactory {
        sourceUnit(moduleElements: ISyntaxList, endOfFileToken: ISyntaxToken): SourceUnitSyntax {
            return new SourceUnitSyntax(moduleElements, endOfFileToken, /*parsedInStrictMode:*/ true);
        }
        externalModuleReference(moduleKeyword: ISyntaxToken, openParenToken: ISyntaxToken, stringLiteral: ISyntaxToken, closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax {
            return new ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, /*parsedInStrictMode:*/ true);
        }
        moduleNameModuleReference(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax {
            return new ModuleNameModuleReferenceSyntax(moduleName, /*parsedInStrictMode:*/ true);
        }
        importDeclaration(importKeyword: ISyntaxToken, identifier: ISyntaxToken, equalsToken: ISyntaxToken, moduleReference: ModuleReferenceSyntax, semicolonToken: ISyntaxToken): ImportDeclarationSyntax {
            return new ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        exportAssignment(exportKeyword: ISyntaxToken, equalsToken: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ExportAssignmentSyntax {
            return new ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        classDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, classKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, implementsClause: ImplementsClauseSyntax, openBraceToken: ISyntaxToken, classElements: ISyntaxList, closeBraceToken: ISyntaxToken): ClassDeclarationSyntax {
            return new ClassDeclarationSyntax(exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        interfaceDeclaration(exportKeyword: ISyntaxToken, interfaceKeyword: ISyntaxToken, identifier: ISyntaxToken, typeParameterList: TypeParameterListSyntax, extendsClause: ExtendsClauseSyntax, body: ObjectTypeSyntax): InterfaceDeclarationSyntax {
            return new InterfaceDeclarationSyntax(exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body, /*parsedInStrictMode:*/ true);
        }
        extendsClause(extendsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax {
            return new ExtendsClauseSyntax(extendsKeyword, typeNames, /*parsedInStrictMode:*/ true);
        }
        implementsClause(implementsKeyword: ISyntaxToken, typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax {
            return new ImplementsClauseSyntax(implementsKeyword, typeNames, /*parsedInStrictMode:*/ true);
        }
        moduleDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, moduleKeyword: ISyntaxToken, moduleName: INameSyntax, stringLiteral: ISyntaxToken, openBraceToken: ISyntaxToken, moduleElements: ISyntaxList, closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
            return new ModuleDeclarationSyntax(exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        functionDeclaration(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): FunctionDeclarationSyntax {
            return new FunctionDeclarationSyntax(exportKeyword, declareKeyword, functionKeyword, identifier, callSignature, block, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        variableStatement(exportKeyword: ISyntaxToken, declareKeyword: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, semicolonToken: ISyntaxToken): VariableStatementSyntax {
            return new VariableStatementSyntax(exportKeyword, declareKeyword, variableDeclaration, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        variableDeclaration(varKeyword: ISyntaxToken, variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax {
            return new VariableDeclarationSyntax(varKeyword, variableDeclarators, /*parsedInStrictMode:*/ true);
        }
        variableDeclarator(identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax {
            return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ true);
        }
        equalsValueClause(equalsToken: ISyntaxToken, value: IExpressionSyntax): EqualsValueClauseSyntax {
            return new EqualsValueClauseSyntax(equalsToken, value, /*parsedInStrictMode:*/ true);
        }
        prefixUnaryExpression(kind: SyntaxKind, operatorToken: ISyntaxToken, operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax {
            return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, /*parsedInStrictMode:*/ true);
        }
        arrayLiteralExpression(openBracketToken: ISyntaxToken, expressions: ISeparatedSyntaxList, closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
            return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, /*parsedInStrictMode:*/ true);
        }
        omittedExpression(): OmittedExpressionSyntax {
            return new OmittedExpressionSyntax(/*parsedInStrictMode:*/ true);
        }
        parenthesizedExpression(openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax {
            return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, /*parsedInStrictMode:*/ true);
        }
        simpleArrowFunctionExpression(identifier: ISyntaxToken, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax {
            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ true);
        }
        parenthesizedArrowFunctionExpression(callSignature: CallSignatureSyntax, equalsGreaterThanToken: ISyntaxToken, body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax {
            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ true);
        }
        qualifiedName(left: INameSyntax, dotToken: ISyntaxToken, right: ISyntaxToken): QualifiedNameSyntax {
            return new QualifiedNameSyntax(left, dotToken, right, /*parsedInStrictMode:*/ true);
        }
        typeArgumentList(lessThanToken: ISyntaxToken, typeArguments: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeArgumentListSyntax {
            return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, /*parsedInStrictMode:*/ true);
        }
        constructorType(newKeyword: ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): ConstructorTypeSyntax {
            return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ true);
        }
        functionType(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: ISyntaxToken, type: ITypeSyntax): FunctionTypeSyntax {
            return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ true);
        }
        objectType(openBraceToken: ISyntaxToken, typeMembers: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectTypeSyntax {
            return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        arrayType(type: ITypeSyntax, openBracketToken: ISyntaxToken, closeBracketToken: ISyntaxToken): ArrayTypeSyntax {
            return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, /*parsedInStrictMode:*/ true);
        }
        genericType(name: INameSyntax, typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax {
            return new GenericTypeSyntax(name, typeArgumentList, /*parsedInStrictMode:*/ true);
        }
        typeAnnotation(colonToken: ISyntaxToken, type: ITypeSyntax): TypeAnnotationSyntax {
            return new TypeAnnotationSyntax(colonToken, type, /*parsedInStrictMode:*/ true);
        }
        block(openBraceToken: ISyntaxToken, statements: ISyntaxList, closeBraceToken: ISyntaxToken): BlockSyntax {
            return new BlockSyntax(openBraceToken, statements, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        parameter(dotDotDotToken: ISyntaxToken, publicOrPrivateKeyword: ISyntaxToken, identifier: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax {
            return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ true);
        }
        memberAccessExpression(expression: IExpressionSyntax, dotToken: ISyntaxToken, name: ISyntaxToken): MemberAccessExpressionSyntax {
            return new MemberAccessExpressionSyntax(expression, dotToken, name, /*parsedInStrictMode:*/ true);
        }
        postfixUnaryExpression(kind: SyntaxKind, operand: IExpressionSyntax, operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax {
            return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, /*parsedInStrictMode:*/ true);
        }
        elementAccessExpression(expression: IExpressionSyntax, openBracketToken: ISyntaxToken, argumentExpression: IExpressionSyntax, closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax {
            return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, /*parsedInStrictMode:*/ true);
        }
        invocationExpression(expression: IExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax {
            return new InvocationExpressionSyntax(expression, argumentList, /*parsedInStrictMode:*/ true);
        }
        argumentList(typeArgumentList: TypeArgumentListSyntax, openParenToken: ISyntaxToken, _arguments: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ArgumentListSyntax {
            return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, /*parsedInStrictMode:*/ true);
        }
        binaryExpression(kind: SyntaxKind, left: IExpressionSyntax, operatorToken: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax {
            return new BinaryExpressionSyntax(kind, left, operatorToken, right, /*parsedInStrictMode:*/ true);
        }
        conditionalExpression(condition: IExpressionSyntax, questionToken: ISyntaxToken, whenTrue: IExpressionSyntax, colonToken: ISyntaxToken, whenFalse: IExpressionSyntax): ConditionalExpressionSyntax {
            return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, /*parsedInStrictMode:*/ true);
        }
        constructSignature(newKeyword: ISyntaxToken, callSignature: CallSignatureSyntax): ConstructSignatureSyntax {
            return new ConstructSignatureSyntax(newKeyword, callSignature, /*parsedInStrictMode:*/ true);
        }
        methodSignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, callSignature: CallSignatureSyntax): MethodSignatureSyntax {
            return new MethodSignatureSyntax(propertyName, questionToken, callSignature, /*parsedInStrictMode:*/ true);
        }
        indexSignature(openBracketToken: ISyntaxToken, identifier: ISyntaxToken, parameterTypeAnnotation: TypeAnnotationSyntax, closeBracketToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax {
            return new IndexSignatureSyntax(openBracketToken, identifier, parameterTypeAnnotation, closeBracketToken, typeAnnotation, /*parsedInStrictMode:*/ true);
        }
        propertySignature(propertyName: ISyntaxToken, questionToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax {
            return new PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, /*parsedInStrictMode:*/ true);
        }
        callSignature(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax {
            return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, /*parsedInStrictMode:*/ true);
        }
        parameterList(openParenToken: ISyntaxToken, parameters: ISeparatedSyntaxList, closeParenToken: ISyntaxToken): ParameterListSyntax {
            return new ParameterListSyntax(openParenToken, parameters, closeParenToken, /*parsedInStrictMode:*/ true);
        }
        typeParameterList(lessThanToken: ISyntaxToken, typeParameters: ISeparatedSyntaxList, greaterThanToken: ISyntaxToken): TypeParameterListSyntax {
            return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, /*parsedInStrictMode:*/ true);
        }
        typeParameter(identifier: ISyntaxToken, constraint: ConstraintSyntax): TypeParameterSyntax {
            return new TypeParameterSyntax(identifier, constraint, /*parsedInStrictMode:*/ true);
        }
        constraint(extendsKeyword: ISyntaxToken, type: ITypeSyntax): ConstraintSyntax {
            return new ConstraintSyntax(extendsKeyword, type, /*parsedInStrictMode:*/ true);
        }
        elseClause(elseKeyword: ISyntaxToken, statement: IStatementSyntax): ElseClauseSyntax {
            return new ElseClauseSyntax(elseKeyword, statement, /*parsedInStrictMode:*/ true);
        }
        ifStatement(ifKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax, elseClause: ElseClauseSyntax): IfStatementSyntax {
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, /*parsedInStrictMode:*/ true);
        }
        expressionStatement(expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ExpressionStatementSyntax {
            return new ExpressionStatementSyntax(expression, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        constructorDeclaration(constructorKeyword: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax {
            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        memberFunctionDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, propertyName: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax {
            return new MemberFunctionDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, propertyName, callSignature, block, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        getMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, getKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetMemberAccessorDeclarationSyntax {
            return new GetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block, /*parsedInStrictMode:*/ true);
        }
        setMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, setKeyword: ISyntaxToken, identifier: ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetMemberAccessorDeclarationSyntax {
            return new SetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block, /*parsedInStrictMode:*/ true);
        }
        memberVariableDeclaration(publicOrPrivateKeyword: ISyntaxToken, staticKeyword: ISyntaxToken, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax {
            return new MemberVariableDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        throwStatement(throwKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ThrowStatementSyntax {
            return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        returnStatement(returnKeyword: ISyntaxToken, expression: IExpressionSyntax, semicolonToken: ISyntaxToken): ReturnStatementSyntax {
            return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        objectCreationExpression(newKeyword: ISyntaxToken, expression: IExpressionSyntax, argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax {
            return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, /*parsedInStrictMode:*/ true);
        }
        switchStatement(switchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, openBraceToken: ISyntaxToken, switchClauses: ISyntaxList, closeBraceToken: ISyntaxToken): SwitchStatementSyntax {
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        caseSwitchClause(caseKeyword: ISyntaxToken, expression: IExpressionSyntax, colonToken: ISyntaxToken, statements: ISyntaxList): CaseSwitchClauseSyntax {
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, /*parsedInStrictMode:*/ true);
        }
        defaultSwitchClause(defaultKeyword: ISyntaxToken, colonToken: ISyntaxToken, statements: ISyntaxList): DefaultSwitchClauseSyntax {
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, /*parsedInStrictMode:*/ true);
        }
        breakStatement(breakKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): BreakStatementSyntax {
            return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        continueStatement(continueKeyword: ISyntaxToken, identifier: ISyntaxToken, semicolonToken: ISyntaxToken): ContinueStatementSyntax {
            return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        forStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: IExpressionSyntax, firstSemicolonToken: ISyntaxToken, condition: IExpressionSyntax, secondSemicolonToken: ISyntaxToken, incrementor: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForStatementSyntax {
            return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, /*parsedInStrictMode:*/ true);
        }
        forInStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: IExpressionSyntax, inKeyword: ISyntaxToken, expression: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): ForInStatementSyntax {
            return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, /*parsedInStrictMode:*/ true);
        }
        whileStatement(whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WhileStatementSyntax {
            return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ true);
        }
        withStatement(withKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, statement: IStatementSyntax): WithStatementSyntax {
            return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ true);
        }
        enumDeclaration(exportKeyword: ISyntaxToken, enumKeyword: ISyntaxToken, identifier: ISyntaxToken, openBraceToken: ISyntaxToken, enumElements: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): EnumDeclarationSyntax {
            return new EnumDeclarationSyntax(exportKeyword, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        enumElement(identifier: ISyntaxToken, stringLiteral: ISyntaxToken, equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax {
            return new EnumElementSyntax(identifier, stringLiteral, equalsValueClause, /*parsedInStrictMode:*/ true);
        }
        castExpression(lessThanToken: ISyntaxToken, type: ITypeSyntax, greaterThanToken: ISyntaxToken, expression: IUnaryExpressionSyntax): CastExpressionSyntax {
            return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, /*parsedInStrictMode:*/ true);
        }
        objectLiteralExpression(openBraceToken: ISyntaxToken, propertyAssignments: ISeparatedSyntaxList, closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
            return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, /*parsedInStrictMode:*/ true);
        }
        simplePropertyAssignment(propertyName: ISyntaxToken, colonToken: ISyntaxToken, expression: IExpressionSyntax): SimplePropertyAssignmentSyntax {
            return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, /*parsedInStrictMode:*/ true);
        }
        getAccessorPropertyAssignment(getKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, closeParenToken: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetAccessorPropertyAssignmentSyntax {
            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, /*parsedInStrictMode:*/ true);
        }
        setAccessorPropertyAssignment(setKeyword: ISyntaxToken, propertyName: ISyntaxToken, openParenToken: ISyntaxToken, parameter: ParameterSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax): SetAccessorPropertyAssignmentSyntax {
            return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, /*parsedInStrictMode:*/ true);
        }
        functionExpression(functionKeyword: ISyntaxToken, identifier: ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax {
            return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, /*parsedInStrictMode:*/ true);
        }
        emptyStatement(semicolonToken: ISyntaxToken): EmptyStatementSyntax {
            return new EmptyStatementSyntax(semicolonToken, /*parsedInStrictMode:*/ true);
        }
        tryStatement(tryKeyword: ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax): TryStatementSyntax {
            return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, /*parsedInStrictMode:*/ true);
        }
        catchClause(catchKeyword: ISyntaxToken, openParenToken: ISyntaxToken, identifier: ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, closeParenToken: ISyntaxToken, block: BlockSyntax): CatchClauseSyntax {
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, /*parsedInStrictMode:*/ true);
        }
        finallyClause(finallyKeyword: ISyntaxToken, block: BlockSyntax): FinallyClauseSyntax {
            return new FinallyClauseSyntax(finallyKeyword, block, /*parsedInStrictMode:*/ true);
        }
        labeledStatement(identifier: ISyntaxToken, colonToken: ISyntaxToken, statement: IStatementSyntax): LabeledStatementSyntax {
            return new LabeledStatementSyntax(identifier, colonToken, statement, /*parsedInStrictMode:*/ true);
        }
        doStatement(doKeyword: ISyntaxToken, statement: IStatementSyntax, whileKeyword: ISyntaxToken, openParenToken: ISyntaxToken, condition: IExpressionSyntax, closeParenToken: ISyntaxToken, semicolonToken: ISyntaxToken): DoStatementSyntax {
            return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, /*parsedInStrictMode:*/ true);
        }
        typeOfExpression(typeOfKeyword: ISyntaxToken, expression: IExpressionSyntax): TypeOfExpressionSyntax {
            return new TypeOfExpressionSyntax(typeOfKeyword, expression, /*parsedInStrictMode:*/ true);
        }
        deleteExpression(deleteKeyword: ISyntaxToken, expression: IExpressionSyntax): DeleteExpressionSyntax {
            return new DeleteExpressionSyntax(deleteKeyword, expression, /*parsedInStrictMode:*/ true);
        }
        voidExpression(voidKeyword: ISyntaxToken, expression: IExpressionSyntax): VoidExpressionSyntax {
            return new VoidExpressionSyntax(voidKeyword, expression, /*parsedInStrictMode:*/ true);
        }
        debuggerStatement(debuggerKeyword: ISyntaxToken, semicolonToken: ISyntaxToken): DebuggerStatementSyntax {
            return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, /*parsedInStrictMode:*/ true);
        }
    }

    export var normalModeFactory: IFactory = new NormalModeFactory();
    export var strictModeFactory: IFactory = new StrictModeFactory();
}
///<reference path='References.ts' />

module TypeScript.Syntax {
    export function emptySourceUnit() {
        return Syntax.normalModeFactory.sourceUnit(Syntax.emptyList, Syntax.token(SyntaxKind.EndOfFileToken, { text: "" }));
    }

    export function getStandaloneExpression(positionedToken: PositionedToken): PositionedNodeOrToken
    {
        var token = positionedToken.token();
        if (positionedToken !== null && positionedToken.kind() === SyntaxKind.IdentifierName) {
            var parentPositionedNode = positionedToken.containingNode();
            var parentNode = parentPositionedNode.node();

            if (parentNode.kind() === SyntaxKind.QualifiedName && (<QualifiedNameSyntax>parentNode).right === token) {
                return parentPositionedNode;
            }
            else if (parentNode.kind() === SyntaxKind.MemberAccessExpression && (<MemberAccessExpressionSyntax>parentNode).name === token) {
                return parentPositionedNode;
            }
        }

        return positionedToken;
    }

    export function isInModuleOrTypeContext(positionedToken: PositionedToken): bool {
        if (positionedToken !== null) {
            var positionedNodeOrToken = Syntax.getStandaloneExpression(positionedToken);
            var parent = positionedNodeOrToken.containingNode();

            if (parent !== null) {
                switch (parent.kind()) {
                    case SyntaxKind.ModuleNameModuleReference:
                        return true;
                    case SyntaxKind.QualifiedName:
                        // left of QN is namespace or type.  Note: when you have "a.b.c()", then
                        // "a.b" is not a qualified name, it is a member access expression.
                        // Qualified names are only parsed when the parser knows it's a type only
                        // context.
                        return true;
                    default:
                        return isInTypeOnlyContext(positionedToken);
                }
            }
        }

        return false;
    }

    export function isInTypeOnlyContext(positionedToken: PositionedToken): bool {
        var positionedNodeOrToken = Syntax.getStandaloneExpression(positionedToken);
        var positionedParent = positionedNodeOrToken.containingNode();

        var parent = positionedParent.node();
        var nodeOrToken = positionedNodeOrToken.nodeOrToken();

        if (parent !== null) {
            switch (parent.kind()) {
                case SyntaxKind.ArrayType:
                    return (<ArrayTypeSyntax>parent).type === nodeOrToken;
                case SyntaxKind.CastExpression:
                    return (<CastExpressionSyntax>parent).type === nodeOrToken;
                case SyntaxKind.TypeAnnotation:
                case SyntaxKind.ExtendsClause:
                case SyntaxKind.ImplementsClause:
                case SyntaxKind.TypeArgumentList:
                    return true;
                // TODO: add more cases if necessary.  This list may not be complete.
            }
        }

        return false;
    }

    export function childOffset(parent: ISyntaxElement, child: ISyntaxElement): number {
        var offset = 0;
        for (var i = 0, n = parent.childCount(); i < n; i++) {
            var current = parent.childAt(i);
            if (current === child) {
                return offset;
            }

            if (current !== null) {
                offset += current.fullWidth();
            }
        }

        throw Errors.invalidOperation();
    }

    export function nodeStructuralEquals(node1: SyntaxNode, node2: SyntaxNode): bool {
        if (node1 === null) {
            return node2 === null;
        }

        return node1.structuralEquals(node2);
    }

    export function nodeOrTokenStructuralEquals(node1: ISyntaxNodeOrToken, node2: ISyntaxNodeOrToken): bool {
        if (node1 === node2) {
            return true;
        }

        if (node1 === null || node2 === null) {
            return false;
        }

        if (node1.isToken()) {
            return node2.isToken() ? tokenStructuralEquals(<ISyntaxToken>node1, <ISyntaxToken>node2) : false;
        }

        return node2.isNode() ? nodeStructuralEquals(<SyntaxNode>node1, <SyntaxNode>node2) : false;
    }

    export function tokenStructuralEquals(token1: ISyntaxToken, token2: ISyntaxToken): bool {
        if (token1 === token2) {
            return true;
        }

        if (token1 === null || token2 === null) {
            return false;
        }

        return token1.kind() === token2.kind() &&
               token1.width() === token2.width() &&
               token1.fullWidth() === token2.fullWidth() &&
               token1.text() === token2.text() &&
               Syntax.triviaListStructuralEquals(token1.leadingTrivia(), token2.leadingTrivia()) &&
               Syntax.triviaListStructuralEquals(token1.trailingTrivia(), token2.trailingTrivia());
    }

    export function triviaListStructuralEquals(triviaList1: ISyntaxTriviaList, triviaList2: ISyntaxTriviaList): bool {
        if (triviaList1.count() !== triviaList2.count()) {
            return false;
        }

        for (var i = 0, n = triviaList1.count(); i < n; i++) {
            if (!Syntax.triviaStructuralEquals(triviaList1.syntaxTriviaAt(i), triviaList2.syntaxTriviaAt(i))) {
                return false;
            }
        }

        return true;
    }

    export function triviaStructuralEquals(trivia1: ISyntaxTrivia, trivia2: ISyntaxTrivia): bool {
        return trivia1.kind() === trivia2.kind() &&
               trivia1.fullWidth() === trivia2.fullWidth() &&
               trivia1.fullText() === trivia2.fullText();
    }

    export function listStructuralEquals(list1: ISyntaxList, list2: ISyntaxList): bool {
        if (list1.childCount() !== list2.childCount()) {
            return false;
        }

        for (var i = 0, n = list1.childCount(); i < n; i++) {
            if (!Syntax.nodeOrTokenStructuralEquals(list1.childAt(i), list2.childAt(i))) {
                return false;
            }
        }

        return true;
    }

    export function separatedListStructuralEquals(list1: ISeparatedSyntaxList, list2: ISeparatedSyntaxList): bool {
        if (list1.childCount() !== list2.childCount()) {
            return false;
        }

        for (var i = 0, n = list1.childCount(); i < n; i++) {
            var element1 = list1.childAt(i);
            var element2 = list2.childAt(i);
            if (!Syntax.nodeOrTokenStructuralEquals(element1, element2)) {
                return false;
            }
        }

        return true;
    }
    
    export function elementStructuralEquals(element1: ISyntaxElement, element2: ISyntaxElement) {
        if (element1 === element2) {
            return true;
        }

        if (element1 === null || element2 === null) {
            return false;
        }

        if (element2.kind() !== element2.kind()) {
            return false;
        }

        if (element1.isToken()) {
            return tokenStructuralEquals(<ISyntaxToken>element1, <ISyntaxToken>element2);
        }
        else if (element1.isNode()) {
            return nodeStructuralEquals(<SyntaxNode>element1, <SyntaxNode>element2) ;
        }
        else if (element1.isList()) {
            return listStructuralEquals(<ISyntaxList>element1, <ISyntaxList>element2);
        }
        else if (element1.isSeparatedList()) {
            return separatedListStructuralEquals(<ISeparatedSyntaxList>element1, <ISeparatedSyntaxList>element2);
        }

        throw Errors.invalidOperation();
    }

    export function identifierName(text: string, info: ITokenInfo = null): ISyntaxToken {
        return identifier(text);
    }

    export function trueExpression(): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.TrueKeyword);
    }

    export function falseExpression(): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.FalseKeyword);
    }

    export function numericLiteralExpression(text: string): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.NumericLiteral, { text: text });
    }

    export function stringLiteralExpression(text: string): IUnaryExpressionSyntax {
        return Syntax.token(SyntaxKind.StringLiteral, { text: text });
    }

    export function isSuperInvocationExpression(node: IExpressionSyntax): bool {
        return node.kind() === SyntaxKind.InvocationExpression &&
            (<InvocationExpressionSyntax>node).expression.kind() === SyntaxKind.SuperKeyword;
    }

    export function isSuperInvocationExpressionStatement(node: SyntaxNode): bool {
        return node.kind() === SyntaxKind.ExpressionStatement &&
            isSuperInvocationExpression((<ExpressionStatementSyntax>node).expression);
    }

    export function isSuperMemberAccessExpression(node: IExpressionSyntax): bool {
        return node.kind() === SyntaxKind.MemberAccessExpression &&
            (<MemberAccessExpressionSyntax>node).expression.kind() === SyntaxKind.SuperKeyword;
    }

    export function isSuperMemberAccessInvocationExpression(node: SyntaxNode): bool {
        return node.kind() === SyntaxKind.InvocationExpression &&
            isSuperMemberAccessExpression((<InvocationExpressionSyntax>node).expression);
    }

    export function assignmentExpression(left: IExpressionSyntax, token: ISyntaxToken, right: IExpressionSyntax): BinaryExpressionSyntax {
        return Syntax.normalModeFactory.binaryExpression(SyntaxKind.AssignmentExpression, left, token, right);
    }
}
﻿///<reference path='References.ts' />

module TypeScript {
    export class SourceUnitSyntax extends SyntaxNode {

    constructor(public moduleElements: ISyntaxList,
                public endOfFileToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSourceUnit(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SourceUnit;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.moduleElements;
            case 1: return this.endOfFileToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(moduleElements: ISyntaxList,
                  endOfFileToken: ISyntaxToken): SourceUnitSyntax {
        if (this.moduleElements === moduleElements && this.endOfFileToken === endOfFileToken) {
            return this;
        }

        return new SourceUnitSyntax(moduleElements, endOfFileToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(endOfFileToken: ISyntaxToken): SourceUnitSyntax {
        return new SourceUnitSyntax(Syntax.emptyList, endOfFileToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(endOfFileToken: ISyntaxToken): SourceUnitSyntax {
        return new SourceUnitSyntax(Syntax.emptyList, endOfFileToken, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SourceUnitSyntax {
        return <SourceUnitSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SourceUnitSyntax {
        return <SourceUnitSyntax>super.withTrailingTrivia(trivia);
    }

    public withModuleElements(moduleElements: ISyntaxList): SourceUnitSyntax {
        return this.update(moduleElements, this.endOfFileToken);
    }

    public withModuleElement(moduleElement: IModuleElementSyntax): SourceUnitSyntax {
        return this.withModuleElements(Syntax.list([moduleElement]));
    }

    public withEndOfFileToken(endOfFileToken: ISyntaxToken): SourceUnitSyntax {
        return this.update(this.moduleElements, endOfFileToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.moduleElements.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ModuleReferenceSyntax extends SyntaxNode implements IModuleReferenceSyntax {
    constructor(parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    private isModuleReference(): bool {
        return true;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ModuleReferenceSyntax {
        return <ModuleReferenceSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ModuleReferenceSyntax {
        return <ModuleReferenceSyntax>super.withTrailingTrivia(trivia);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ExternalModuleReferenceSyntax extends ModuleReferenceSyntax {

    constructor(public moduleKeyword: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public stringLiteral: ISyntaxToken,
                public closeParenToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitExternalModuleReference(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ExternalModuleReference;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.moduleKeyword;
            case 1: return this.openParenToken;
            case 2: return this.stringLiteral;
            case 3: return this.closeParenToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(moduleKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  stringLiteral: ISyntaxToken,
                  closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax {
        if (this.moduleKeyword === moduleKeyword && this.openParenToken === openParenToken && this.stringLiteral === stringLiteral && this.closeParenToken === closeParenToken) {
            return this;
        }

        return new ExternalModuleReferenceSyntax(moduleKeyword, openParenToken, stringLiteral, closeParenToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(stringLiteral: ISyntaxToken): ExternalModuleReferenceSyntax {
        return new ExternalModuleReferenceSyntax(Syntax.token(SyntaxKind.ModuleKeyword), Syntax.token(SyntaxKind.OpenParenToken), stringLiteral, Syntax.token(SyntaxKind.CloseParenToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ExternalModuleReferenceSyntax {
        return <ExternalModuleReferenceSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ExternalModuleReferenceSyntax {
        return <ExternalModuleReferenceSyntax>super.withTrailingTrivia(trivia);
    }

    public withModuleKeyword(moduleKeyword: ISyntaxToken): ExternalModuleReferenceSyntax {
        return this.update(moduleKeyword, this.openParenToken, this.stringLiteral, this.closeParenToken);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ExternalModuleReferenceSyntax {
        return this.update(this.moduleKeyword, openParenToken, this.stringLiteral, this.closeParenToken);
    }

    public withStringLiteral(stringLiteral: ISyntaxToken): ExternalModuleReferenceSyntax {
        return this.update(this.moduleKeyword, this.openParenToken, stringLiteral, this.closeParenToken);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ExternalModuleReferenceSyntax {
        return this.update(this.moduleKeyword, this.openParenToken, this.stringLiteral, closeParenToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ModuleNameModuleReferenceSyntax extends ModuleReferenceSyntax {

    constructor(public moduleName: INameSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitModuleNameModuleReference(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ModuleNameModuleReference;
    }

    public childCount(): number {
        return 1;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.moduleName;
            default: throw Errors.invalidOperation();
        }
    }

    public update(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax {
        if (this.moduleName === moduleName) {
            return this;
        }

        return new ModuleNameModuleReferenceSyntax(moduleName, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ModuleNameModuleReferenceSyntax {
        return <ModuleNameModuleReferenceSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ModuleNameModuleReferenceSyntax {
        return <ModuleNameModuleReferenceSyntax>super.withTrailingTrivia(trivia);
    }

    public withModuleName(moduleName: INameSyntax): ModuleNameModuleReferenceSyntax {
        return this.update(moduleName);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ImportDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {

    constructor(public importKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public equalsToken: ISyntaxToken,
                public moduleReference: ModuleReferenceSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitImportDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ImportDeclaration;
    }

    public childCount(): number {
        return 5;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.importKeyword;
            case 1: return this.identifier;
            case 2: return this.equalsToken;
            case 3: return this.moduleReference;
            case 4: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(importKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  equalsToken: ISyntaxToken,
                  moduleReference: ModuleReferenceSyntax,
                  semicolonToken: ISyntaxToken): ImportDeclarationSyntax {
        if (this.importKeyword === importKeyword && this.identifier === identifier && this.equalsToken === equalsToken && this.moduleReference === moduleReference && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(identifier: ISyntaxToken,
                          moduleReference: ModuleReferenceSyntax): ImportDeclarationSyntax {
        return new ImportDeclarationSyntax(Syntax.token(SyntaxKind.ImportKeyword), identifier, Syntax.token(SyntaxKind.EqualsToken), moduleReference, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ImportDeclarationSyntax {
        return <ImportDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ImportDeclarationSyntax {
        return <ImportDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withImportKeyword(importKeyword: ISyntaxToken): ImportDeclarationSyntax {
        return this.update(importKeyword, this.identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
    }

    public withIdentifier(identifier: ISyntaxToken): ImportDeclarationSyntax {
        return this.update(this.importKeyword, identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
    }

    public withEqualsToken(equalsToken: ISyntaxToken): ImportDeclarationSyntax {
        return this.update(this.importKeyword, this.identifier, equalsToken, this.moduleReference, this.semicolonToken);
    }

    public withModuleReference(moduleReference: ModuleReferenceSyntax): ImportDeclarationSyntax {
        return this.update(this.importKeyword, this.identifier, this.equalsToken, moduleReference, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ImportDeclarationSyntax {
        return this.update(this.importKeyword, this.identifier, this.equalsToken, this.moduleReference, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ExportAssignmentSyntax extends SyntaxNode implements IModuleElementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public equalsToken: ISyntaxToken,
                public identifier: ISyntaxToken,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitExportAssignment(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ExportAssignment;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.equalsToken;
            case 2: return this.identifier;
            case 3: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  equalsToken: ISyntaxToken,
                  identifier: ISyntaxToken,
                  semicolonToken: ISyntaxToken): ExportAssignmentSyntax {
        if (this.exportKeyword === exportKeyword && this.equalsToken === equalsToken && this.identifier === identifier && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(identifier: ISyntaxToken): ExportAssignmentSyntax {
        return new ExportAssignmentSyntax(Syntax.token(SyntaxKind.ExportKeyword), Syntax.token(SyntaxKind.EqualsToken), identifier, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ExportAssignmentSyntax {
        return <ExportAssignmentSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ExportAssignmentSyntax {
        return <ExportAssignmentSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): ExportAssignmentSyntax {
        return this.update(exportKeyword, this.equalsToken, this.identifier, this.semicolonToken);
    }

    public withEqualsToken(equalsToken: ISyntaxToken): ExportAssignmentSyntax {
        return this.update(this.exportKeyword, equalsToken, this.identifier, this.semicolonToken);
    }

    public withIdentifier(identifier: ISyntaxToken): ExportAssignmentSyntax {
        return this.update(this.exportKeyword, this.equalsToken, identifier, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ExportAssignmentSyntax {
        return this.update(this.exportKeyword, this.equalsToken, this.identifier, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ClassDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public declareKeyword: ISyntaxToken,
                public classKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public typeParameterList: TypeParameterListSyntax,
                public extendsClause: ExtendsClauseSyntax,
                public implementsClause: ImplementsClauseSyntax,
                public openBraceToken: ISyntaxToken,
                public classElements: ISyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitClassDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ClassDeclaration;
    }

    public childCount(): number {
        return 10;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.declareKeyword;
            case 2: return this.classKeyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.extendsClause;
            case 6: return this.implementsClause;
            case 7: return this.openBraceToken;
            case 8: return this.classElements;
            case 9: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  declareKeyword: ISyntaxToken,
                  classKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  typeParameterList: TypeParameterListSyntax,
                  extendsClause: ExtendsClauseSyntax,
                  implementsClause: ImplementsClauseSyntax,
                  openBraceToken: ISyntaxToken,
                  classElements: ISyntaxList,
                  closeBraceToken: ISyntaxToken): ClassDeclarationSyntax {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.classKeyword === classKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.extendsClause === extendsClause && this.implementsClause === implementsClause && this.openBraceToken === openBraceToken && this.classElements === classElements && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new ClassDeclarationSyntax(exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause, implementsClause, openBraceToken, classElements, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(classKeyword: ISyntaxToken,
                         identifier: ISyntaxToken,
                         openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): ClassDeclarationSyntax {
        return new ClassDeclarationSyntax(null, null, classKeyword, identifier, null, null, null, openBraceToken, Syntax.emptyList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): ClassDeclarationSyntax {
        return new ClassDeclarationSyntax(null, null, Syntax.token(SyntaxKind.ClassKeyword), identifier, null, null, null, Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptyList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ClassDeclarationSyntax {
        return <ClassDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ClassDeclarationSyntax {
        return <ClassDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withDeclareKeyword(declareKeyword: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withClassKeyword(classKeyword: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withIdentifier(identifier: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withTypeParameterList(typeParameterList: TypeParameterListSyntax): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withExtendsClause(extendsClause: ExtendsClauseSyntax): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, extendsClause, this.implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withImplementsClause(implementsClause: ImplementsClauseSyntax): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, implementsClause, this.openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, openBraceToken, this.classElements, this.closeBraceToken);
    }

    public withClassElements(classElements: ISyntaxList): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, classElements, this.closeBraceToken);
    }

    public withClassElement(classElement: IClassElementSyntax): ClassDeclarationSyntax {
        return this.withClassElements(Syntax.list([classElement]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): ClassDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.classKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.implementsClause, this.openBraceToken, this.classElements, closeBraceToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class InterfaceDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public interfaceKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public typeParameterList: TypeParameterListSyntax,
                public extendsClause: ExtendsClauseSyntax,
                public body: ObjectTypeSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitInterfaceDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.InterfaceDeclaration;
    }

    public childCount(): number {
        return 6;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.interfaceKeyword;
            case 2: return this.identifier;
            case 3: return this.typeParameterList;
            case 4: return this.extendsClause;
            case 5: return this.body;
            default: throw Errors.invalidOperation();
        }
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  interfaceKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  typeParameterList: TypeParameterListSyntax,
                  extendsClause: ExtendsClauseSyntax,
                  body: ObjectTypeSyntax): InterfaceDeclarationSyntax {
        if (this.exportKeyword === exportKeyword && this.interfaceKeyword === interfaceKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.extendsClause === extendsClause && this.body === body) {
            return this;
        }

        return new InterfaceDeclarationSyntax(exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, body, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(interfaceKeyword: ISyntaxToken,
                         identifier: ISyntaxToken,
                         body: ObjectTypeSyntax): InterfaceDeclarationSyntax {
        return new InterfaceDeclarationSyntax(null, interfaceKeyword, identifier, null, null, body, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): InterfaceDeclarationSyntax {
        return new InterfaceDeclarationSyntax(null, Syntax.token(SyntaxKind.InterfaceKeyword), identifier, null, null, ObjectTypeSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): InterfaceDeclarationSyntax {
        return <InterfaceDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): InterfaceDeclarationSyntax {
        return <InterfaceDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): InterfaceDeclarationSyntax {
        return this.update(exportKeyword, this.interfaceKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.body);
    }

    public withInterfaceKeyword(interfaceKeyword: ISyntaxToken): InterfaceDeclarationSyntax {
        return this.update(this.exportKeyword, interfaceKeyword, this.identifier, this.typeParameterList, this.extendsClause, this.body);
    }

    public withIdentifier(identifier: ISyntaxToken): InterfaceDeclarationSyntax {
        return this.update(this.exportKeyword, this.interfaceKeyword, identifier, this.typeParameterList, this.extendsClause, this.body);
    }

    public withTypeParameterList(typeParameterList: TypeParameterListSyntax): InterfaceDeclarationSyntax {
        return this.update(this.exportKeyword, this.interfaceKeyword, this.identifier, typeParameterList, this.extendsClause, this.body);
    }

    public withExtendsClause(extendsClause: ExtendsClauseSyntax): InterfaceDeclarationSyntax {
        return this.update(this.exportKeyword, this.interfaceKeyword, this.identifier, this.typeParameterList, extendsClause, this.body);
    }

    public withBody(body: ObjectTypeSyntax): InterfaceDeclarationSyntax {
        return this.update(this.exportKeyword, this.interfaceKeyword, this.identifier, this.typeParameterList, this.extendsClause, body);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ExtendsClauseSyntax extends SyntaxNode {

    constructor(public extendsKeyword: ISyntaxToken,
                public typeNames: ISeparatedSyntaxList,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitExtendsClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ExtendsClause;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.extendsKeyword;
            case 1: return this.typeNames;
            default: throw Errors.invalidOperation();
        }
    }

    public update(extendsKeyword: ISyntaxToken,
                  typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax {
        if (this.extendsKeyword === extendsKeyword && this.typeNames === typeNames) {
            return this;
        }

        return new ExtendsClauseSyntax(extendsKeyword, typeNames, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax {
        return new ExtendsClauseSyntax(Syntax.token(SyntaxKind.ExtendsKeyword), typeNames, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ExtendsClauseSyntax {
        return <ExtendsClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ExtendsClauseSyntax {
        return <ExtendsClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withExtendsKeyword(extendsKeyword: ISyntaxToken): ExtendsClauseSyntax {
        return this.update(extendsKeyword, this.typeNames);
    }

    public withTypeNames(typeNames: ISeparatedSyntaxList): ExtendsClauseSyntax {
        return this.update(this.extendsKeyword, typeNames);
    }

    public withTypeName(typeName: INameSyntax): ExtendsClauseSyntax {
        return this.withTypeNames(Syntax.separatedList([typeName]));
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ImplementsClauseSyntax extends SyntaxNode {

    constructor(public implementsKeyword: ISyntaxToken,
                public typeNames: ISeparatedSyntaxList,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitImplementsClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ImplementsClause;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.implementsKeyword;
            case 1: return this.typeNames;
            default: throw Errors.invalidOperation();
        }
    }

    public update(implementsKeyword: ISyntaxToken,
                  typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax {
        if (this.implementsKeyword === implementsKeyword && this.typeNames === typeNames) {
            return this;
        }

        return new ImplementsClauseSyntax(implementsKeyword, typeNames, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax {
        return new ImplementsClauseSyntax(Syntax.token(SyntaxKind.ImplementsKeyword), typeNames, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ImplementsClauseSyntax {
        return <ImplementsClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ImplementsClauseSyntax {
        return <ImplementsClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withImplementsKeyword(implementsKeyword: ISyntaxToken): ImplementsClauseSyntax {
        return this.update(implementsKeyword, this.typeNames);
    }

    public withTypeNames(typeNames: ISeparatedSyntaxList): ImplementsClauseSyntax {
        return this.update(this.implementsKeyword, typeNames);
    }

    public withTypeName(typeName: INameSyntax): ImplementsClauseSyntax {
        return this.withTypeNames(Syntax.separatedList([typeName]));
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ModuleDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public declareKeyword: ISyntaxToken,
                public moduleKeyword: ISyntaxToken,
                public moduleName: INameSyntax,
                public stringLiteral: ISyntaxToken,
                public openBraceToken: ISyntaxToken,
                public moduleElements: ISyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitModuleDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ModuleDeclaration;
    }

    public childCount(): number {
        return 8;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.declareKeyword;
            case 2: return this.moduleKeyword;
            case 3: return this.moduleName;
            case 4: return this.stringLiteral;
            case 5: return this.openBraceToken;
            case 6: return this.moduleElements;
            case 7: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  declareKeyword: ISyntaxToken,
                  moduleKeyword: ISyntaxToken,
                  moduleName: INameSyntax,
                  stringLiteral: ISyntaxToken,
                  openBraceToken: ISyntaxToken,
                  moduleElements: ISyntaxList,
                  closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.moduleKeyword === moduleKeyword && this.moduleName === moduleName && this.stringLiteral === stringLiteral && this.openBraceToken === openBraceToken && this.moduleElements === moduleElements && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new ModuleDeclarationSyntax(exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(moduleKeyword: ISyntaxToken,
                         openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
        return new ModuleDeclarationSyntax(null, null, moduleKeyword, null, null, openBraceToken, Syntax.emptyList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ModuleDeclarationSyntax {
        return new ModuleDeclarationSyntax(null, null, Syntax.token(SyntaxKind.ModuleKeyword), null, null, Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptyList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ModuleDeclarationSyntax {
        return <ModuleDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ModuleDeclarationSyntax {
        return <ModuleDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withDeclareKeyword(declareKeyword: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withModuleKeyword(moduleKeyword: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withModuleName(moduleName: INameSyntax): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withStringLiteral(stringLiteral: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, openBraceToken, this.moduleElements, this.closeBraceToken);
    }

    public withModuleElements(moduleElements: ISyntaxList): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, moduleElements, this.closeBraceToken);
    }

    public withModuleElement(moduleElement: IModuleElementSyntax): ModuleDeclarationSyntax {
        return this.withModuleElements(Syntax.list([moduleElement]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): ModuleDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, closeBraceToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class FunctionDeclarationSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public declareKeyword: ISyntaxToken,
                public functionKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public callSignature: CallSignatureSyntax,
                public block: BlockSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitFunctionDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.FunctionDeclaration;
    }

    public childCount(): number {
        return 7;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.declareKeyword;
            case 2: return this.functionKeyword;
            case 3: return this.identifier;
            case 4: return this.callSignature;
            case 5: return this.block;
            case 6: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  declareKeyword: ISyntaxToken,
                  functionKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  callSignature: CallSignatureSyntax,
                  block: BlockSyntax,
                  semicolonToken: ISyntaxToken): FunctionDeclarationSyntax {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new FunctionDeclarationSyntax(exportKeyword, declareKeyword, functionKeyword, identifier, callSignature, block, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(functionKeyword: ISyntaxToken,
                         identifier: ISyntaxToken,
                         callSignature: CallSignatureSyntax): FunctionDeclarationSyntax {
        return new FunctionDeclarationSyntax(null, null, functionKeyword, identifier, callSignature, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): FunctionDeclarationSyntax {
        return new FunctionDeclarationSyntax(null, null, Syntax.token(SyntaxKind.FunctionKeyword), identifier, CallSignatureSyntax.create1(), null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): FunctionDeclarationSyntax {
        return <FunctionDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): FunctionDeclarationSyntax {
        return <FunctionDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): FunctionDeclarationSyntax {
        return this.update(exportKeyword, this.declareKeyword, this.functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
    }

    public withDeclareKeyword(declareKeyword: ISyntaxToken): FunctionDeclarationSyntax {
        return this.update(this.exportKeyword, declareKeyword, this.functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
    }

    public withFunctionKeyword(functionKeyword: ISyntaxToken): FunctionDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
    }

    public withIdentifier(identifier: ISyntaxToken): FunctionDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.functionKeyword, identifier, this.callSignature, this.block, this.semicolonToken);
    }

    public withCallSignature(callSignature: CallSignatureSyntax): FunctionDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.functionKeyword, this.identifier, callSignature, this.block, this.semicolonToken);
    }

    public withBlock(block: BlockSyntax): FunctionDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.functionKeyword, this.identifier, this.callSignature, block, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): FunctionDeclarationSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.functionKeyword, this.identifier, this.callSignature, this.block, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.exportKeyword !== null) { return true; }
        if (this.declareKeyword !== null) { return true; }
        if (this.callSignature.isTypeScriptSpecific()) { return true; }
        if (this.block !== null && this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class VariableStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public declareKeyword: ISyntaxToken,
                public variableDeclaration: VariableDeclarationSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitVariableStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.VariableStatement;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.declareKeyword;
            case 2: return this.variableDeclaration;
            case 3: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  declareKeyword: ISyntaxToken,
                  variableDeclaration: VariableDeclarationSyntax,
                  semicolonToken: ISyntaxToken): VariableStatementSyntax {
        if (this.exportKeyword === exportKeyword && this.declareKeyword === declareKeyword && this.variableDeclaration === variableDeclaration && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new VariableStatementSyntax(exportKeyword, declareKeyword, variableDeclaration, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(variableDeclaration: VariableDeclarationSyntax,
                         semicolonToken: ISyntaxToken): VariableStatementSyntax {
        return new VariableStatementSyntax(null, null, variableDeclaration, semicolonToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(variableDeclaration: VariableDeclarationSyntax): VariableStatementSyntax {
        return new VariableStatementSyntax(null, null, variableDeclaration, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): VariableStatementSyntax {
        return <VariableStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): VariableStatementSyntax {
        return <VariableStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): VariableStatementSyntax {
        return this.update(exportKeyword, this.declareKeyword, this.variableDeclaration, this.semicolonToken);
    }

    public withDeclareKeyword(declareKeyword: ISyntaxToken): VariableStatementSyntax {
        return this.update(this.exportKeyword, declareKeyword, this.variableDeclaration, this.semicolonToken);
    }

    public withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): VariableStatementSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, variableDeclaration, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): VariableStatementSyntax {
        return this.update(this.exportKeyword, this.declareKeyword, this.variableDeclaration, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.exportKeyword !== null) { return true; }
        if (this.declareKeyword !== null) { return true; }
        if (this.variableDeclaration.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class VariableDeclarationSyntax extends SyntaxNode {

    constructor(public varKeyword: ISyntaxToken,
                public variableDeclarators: ISeparatedSyntaxList,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitVariableDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.VariableDeclaration;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.varKeyword;
            case 1: return this.variableDeclarators;
            default: throw Errors.invalidOperation();
        }
    }

    public update(varKeyword: ISyntaxToken,
                  variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax {
        if (this.varKeyword === varKeyword && this.variableDeclarators === variableDeclarators) {
            return this;
        }

        return new VariableDeclarationSyntax(varKeyword, variableDeclarators, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax {
        return new VariableDeclarationSyntax(Syntax.token(SyntaxKind.VarKeyword), variableDeclarators, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): VariableDeclarationSyntax {
        return <VariableDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): VariableDeclarationSyntax {
        return <VariableDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withVarKeyword(varKeyword: ISyntaxToken): VariableDeclarationSyntax {
        return this.update(varKeyword, this.variableDeclarators);
    }

    public withVariableDeclarators(variableDeclarators: ISeparatedSyntaxList): VariableDeclarationSyntax {
        return this.update(this.varKeyword, variableDeclarators);
    }

    public withVariableDeclarator(variableDeclarator: VariableDeclaratorSyntax): VariableDeclarationSyntax {
        return this.withVariableDeclarators(Syntax.separatedList([variableDeclarator]));
    }

    public isTypeScriptSpecific(): bool {
        if (this.variableDeclarators.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class VariableDeclaratorSyntax extends SyntaxNode {

    constructor(public identifier: ISyntaxToken,
                public typeAnnotation: TypeAnnotationSyntax,
                public equalsValueClause: EqualsValueClauseSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitVariableDeclarator(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.VariableDeclarator;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.identifier;
            case 1: return this.typeAnnotation;
            case 2: return this.equalsValueClause;
            default: throw Errors.invalidOperation();
        }
    }

    public update(identifier: ISyntaxToken,
                  typeAnnotation: TypeAnnotationSyntax,
                  equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax {
        if (this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
            return this;
        }

        return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(identifier: ISyntaxToken): VariableDeclaratorSyntax {
        return new VariableDeclaratorSyntax(identifier, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): VariableDeclaratorSyntax {
        return new VariableDeclaratorSyntax(identifier, null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): VariableDeclaratorSyntax {
        return <VariableDeclaratorSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): VariableDeclaratorSyntax {
        return <VariableDeclaratorSyntax>super.withTrailingTrivia(trivia);
    }

    public withIdentifier(identifier: ISyntaxToken): VariableDeclaratorSyntax {
        return this.update(identifier, this.typeAnnotation, this.equalsValueClause);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): VariableDeclaratorSyntax {
        return this.update(this.identifier, typeAnnotation, this.equalsValueClause);
    }

    public withEqualsValueClause(equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax {
        return this.update(this.identifier, this.typeAnnotation, equalsValueClause);
    }

    public isTypeScriptSpecific(): bool {
        if (this.typeAnnotation !== null) { return true; }
        if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class EqualsValueClauseSyntax extends SyntaxNode {

    constructor(public equalsToken: ISyntaxToken,
                public value: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitEqualsValueClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.EqualsValueClause;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.equalsToken;
            case 1: return this.value;
            default: throw Errors.invalidOperation();
        }
    }

    public update(equalsToken: ISyntaxToken,
                  value: IExpressionSyntax): EqualsValueClauseSyntax {
        if (this.equalsToken === equalsToken && this.value === value) {
            return this;
        }

        return new EqualsValueClauseSyntax(equalsToken, value, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(value: IExpressionSyntax): EqualsValueClauseSyntax {
        return new EqualsValueClauseSyntax(Syntax.token(SyntaxKind.EqualsToken), value, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): EqualsValueClauseSyntax {
        return <EqualsValueClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): EqualsValueClauseSyntax {
        return <EqualsValueClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withEqualsToken(equalsToken: ISyntaxToken): EqualsValueClauseSyntax {
        return this.update(equalsToken, this.value);
    }

    public withValue(value: IExpressionSyntax): EqualsValueClauseSyntax {
        return this.update(this.equalsToken, value);
    }

    public isTypeScriptSpecific(): bool {
        if (this.value.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class PrefixUnaryExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
    private _kind: SyntaxKind;

    constructor(kind: SyntaxKind,
                public operatorToken: ISyntaxToken,
                public operand: IUnaryExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

        this._kind = kind;
    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitPrefixUnaryExpression(this);
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.operatorToken;
            case 1: return this.operand;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public kind(): SyntaxKind {
        return this._kind;
    }

    public update(kind: SyntaxKind,
                  operatorToken: ISyntaxToken,
                  operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax {
        if (this._kind === kind && this.operatorToken === operatorToken && this.operand === operand) {
            return this;
        }

        return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): PrefixUnaryExpressionSyntax {
        return <PrefixUnaryExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): PrefixUnaryExpressionSyntax {
        return <PrefixUnaryExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withKind(kind: SyntaxKind): PrefixUnaryExpressionSyntax {
        return this.update(kind, this.operatorToken, this.operand);
    }

    public withOperatorToken(operatorToken: ISyntaxToken): PrefixUnaryExpressionSyntax {
        return this.update(this._kind, operatorToken, this.operand);
    }

    public withOperand(operand: IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax {
        return this.update(this._kind, this.operatorToken, operand);
    }

    public isTypeScriptSpecific(): bool {
        if (this.operand.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ArrayLiteralExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public openBracketToken: ISyntaxToken,
                public expressions: ISeparatedSyntaxList,
                public closeBracketToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitArrayLiteralExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ArrayLiteralExpression;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openBracketToken;
            case 1: return this.expressions;
            case 2: return this.closeBracketToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(openBracketToken: ISyntaxToken,
                  expressions: ISeparatedSyntaxList,
                  closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
        if (this.openBracketToken === openBracketToken && this.expressions === expressions && this.closeBracketToken === closeBracketToken) {
            return this;
        }

        return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openBracketToken: ISyntaxToken,
                         closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
        return new ArrayLiteralExpressionSyntax(openBracketToken, Syntax.emptySeparatedList, closeBracketToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ArrayLiteralExpressionSyntax {
        return new ArrayLiteralExpressionSyntax(Syntax.token(SyntaxKind.OpenBracketToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseBracketToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ArrayLiteralExpressionSyntax {
        return <ArrayLiteralExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ArrayLiteralExpressionSyntax {
        return <ArrayLiteralExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenBracketToken(openBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
        return this.update(openBracketToken, this.expressions, this.closeBracketToken);
    }

    public withExpressions(expressions: ISeparatedSyntaxList): ArrayLiteralExpressionSyntax {
        return this.update(this.openBracketToken, expressions, this.closeBracketToken);
    }

    public withExpression(expression: IExpressionSyntax): ArrayLiteralExpressionSyntax {
        return this.withExpressions(Syntax.separatedList([expression]));
    }

    public withCloseBracketToken(closeBracketToken: ISyntaxToken): ArrayLiteralExpressionSyntax {
        return this.update(this.openBracketToken, this.expressions, closeBracketToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expressions.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class OmittedExpressionSyntax extends SyntaxNode implements IExpressionSyntax {
    constructor(parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitOmittedExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.OmittedExpression;
    }

    public childCount(): number {
        return 0;
    }

    public childAt(slot: number): ISyntaxElement {
        throw Errors.invalidOperation();
    }

    private isExpression(): bool {
        return true;
    }

    public update(): OmittedExpressionSyntax {
        return this;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): OmittedExpressionSyntax {
        return <OmittedExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): OmittedExpressionSyntax {
        return <OmittedExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public isTypeScriptSpecific(): bool {
        return false;
    }
    }

    export class ParenthesizedExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public openParenToken: ISyntaxToken,
                public expression: IExpressionSyntax,
                public closeParenToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitParenthesizedExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ParenthesizedExpression;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openParenToken;
            case 1: return this.expression;
            case 2: return this.closeParenToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(openParenToken: ISyntaxToken,
                  expression: IExpressionSyntax,
                  closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax {
        if (this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken) {
            return this;
        }

        return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): ParenthesizedExpressionSyntax {
        return new ParenthesizedExpressionSyntax(Syntax.token(SyntaxKind.OpenParenToken), expression, Syntax.token(SyntaxKind.CloseParenToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ParenthesizedExpressionSyntax {
        return <ParenthesizedExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ParenthesizedExpressionSyntax {
        return <ParenthesizedExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ParenthesizedExpressionSyntax {
        return this.update(openParenToken, this.expression, this.closeParenToken);
    }

    public withExpression(expression: IExpressionSyntax): ParenthesizedExpressionSyntax {
        return this.update(this.openParenToken, expression, this.closeParenToken);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ParenthesizedExpressionSyntax {
        return this.update(this.openParenToken, this.expression, closeParenToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ArrowFunctionExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
    constructor(public equalsGreaterThanToken: ISyntaxToken,
                public body: ISyntaxNodeOrToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ArrowFunctionExpressionSyntax {
        return <ArrowFunctionExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ArrowFunctionExpressionSyntax {
        return <ArrowFunctionExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class SimpleArrowFunctionExpressionSyntax extends ArrowFunctionExpressionSyntax {

    constructor(public identifier: ISyntaxToken,
                equalsGreaterThanToken: ISyntaxToken,
                body: ISyntaxNodeOrToken,
                parsedInStrictMode: bool) {
        super(equalsGreaterThanToken, body, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSimpleArrowFunctionExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SimpleArrowFunctionExpression;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.identifier;
            case 1: return this.equalsGreaterThanToken;
            case 2: return this.body;
            default: throw Errors.invalidOperation();
        }
    }

    public update(identifier: ISyntaxToken,
                  equalsGreaterThanToken: ISyntaxToken,
                  body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax {
        if (this.identifier === identifier && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
            return this;
        }

        return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(identifier: ISyntaxToken,
                          body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax {
        return new SimpleArrowFunctionExpressionSyntax(identifier, Syntax.token(SyntaxKind.EqualsGreaterThanToken), body, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SimpleArrowFunctionExpressionSyntax {
        return <SimpleArrowFunctionExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SimpleArrowFunctionExpressionSyntax {
        return <SimpleArrowFunctionExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withIdentifier(identifier: ISyntaxToken): SimpleArrowFunctionExpressionSyntax {
        return this.update(identifier, this.equalsGreaterThanToken, this.body);
    }

    public withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): SimpleArrowFunctionExpressionSyntax {
        return this.update(this.identifier, equalsGreaterThanToken, this.body);
    }

    public withBody(body: ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax {
        return this.update(this.identifier, this.equalsGreaterThanToken, body);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ParenthesizedArrowFunctionExpressionSyntax extends ArrowFunctionExpressionSyntax {

    constructor(public callSignature: CallSignatureSyntax,
                equalsGreaterThanToken: ISyntaxToken,
                body: ISyntaxNodeOrToken,
                parsedInStrictMode: bool) {
        super(equalsGreaterThanToken, body, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitParenthesizedArrowFunctionExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ParenthesizedArrowFunctionExpression;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.callSignature;
            case 1: return this.equalsGreaterThanToken;
            case 2: return this.body;
            default: throw Errors.invalidOperation();
        }
    }

    public update(callSignature: CallSignatureSyntax,
                  equalsGreaterThanToken: ISyntaxToken,
                  body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax {
        if (this.callSignature === callSignature && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
            return this;
        }

        return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax {
        return new ParenthesizedArrowFunctionExpressionSyntax(CallSignatureSyntax.create1(), Syntax.token(SyntaxKind.EqualsGreaterThanToken), body, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ParenthesizedArrowFunctionExpressionSyntax {
        return <ParenthesizedArrowFunctionExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ParenthesizedArrowFunctionExpressionSyntax {
        return <ParenthesizedArrowFunctionExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withCallSignature(callSignature: CallSignatureSyntax): ParenthesizedArrowFunctionExpressionSyntax {
        return this.update(callSignature, this.equalsGreaterThanToken, this.body);
    }

    public withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): ParenthesizedArrowFunctionExpressionSyntax {
        return this.update(this.callSignature, equalsGreaterThanToken, this.body);
    }

    public withBody(body: ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax {
        return this.update(this.callSignature, this.equalsGreaterThanToken, body);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class QualifiedNameSyntax extends SyntaxNode implements INameSyntax {

    constructor(public left: INameSyntax,
                public dotToken: ISyntaxToken,
                public right: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitQualifiedName(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.QualifiedName;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.left;
            case 1: return this.dotToken;
            case 2: return this.right;
            default: throw Errors.invalidOperation();
        }
    }

    private isName(): bool {
        return true;
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(left: INameSyntax,
                  dotToken: ISyntaxToken,
                  right: ISyntaxToken): QualifiedNameSyntax {
        if (this.left === left && this.dotToken === dotToken && this.right === right) {
            return this;
        }

        return new QualifiedNameSyntax(left, dotToken, right, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(left: INameSyntax,
                          right: ISyntaxToken): QualifiedNameSyntax {
        return new QualifiedNameSyntax(left, Syntax.token(SyntaxKind.DotToken), right, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): QualifiedNameSyntax {
        return <QualifiedNameSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): QualifiedNameSyntax {
        return <QualifiedNameSyntax>super.withTrailingTrivia(trivia);
    }

    public withLeft(left: INameSyntax): QualifiedNameSyntax {
        return this.update(left, this.dotToken, this.right);
    }

    public withDotToken(dotToken: ISyntaxToken): QualifiedNameSyntax {
        return this.update(this.left, dotToken, this.right);
    }

    public withRight(right: ISyntaxToken): QualifiedNameSyntax {
        return this.update(this.left, this.dotToken, right);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class TypeArgumentListSyntax extends SyntaxNode {

    constructor(public lessThanToken: ISyntaxToken,
                public typeArguments: ISeparatedSyntaxList,
                public greaterThanToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTypeArgumentList(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TypeArgumentList;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.lessThanToken;
            case 1: return this.typeArguments;
            case 2: return this.greaterThanToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(lessThanToken: ISyntaxToken,
                  typeArguments: ISeparatedSyntaxList,
                  greaterThanToken: ISyntaxToken): TypeArgumentListSyntax {
        if (this.lessThanToken === lessThanToken && this.typeArguments === typeArguments && this.greaterThanToken === greaterThanToken) {
            return this;
        }

        return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(lessThanToken: ISyntaxToken,
                         greaterThanToken: ISyntaxToken): TypeArgumentListSyntax {
        return new TypeArgumentListSyntax(lessThanToken, Syntax.emptySeparatedList, greaterThanToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): TypeArgumentListSyntax {
        return new TypeArgumentListSyntax(Syntax.token(SyntaxKind.LessThanToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.GreaterThanToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TypeArgumentListSyntax {
        return <TypeArgumentListSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TypeArgumentListSyntax {
        return <TypeArgumentListSyntax>super.withTrailingTrivia(trivia);
    }

    public withLessThanToken(lessThanToken: ISyntaxToken): TypeArgumentListSyntax {
        return this.update(lessThanToken, this.typeArguments, this.greaterThanToken);
    }

    public withTypeArguments(typeArguments: ISeparatedSyntaxList): TypeArgumentListSyntax {
        return this.update(this.lessThanToken, typeArguments, this.greaterThanToken);
    }

    public withTypeArgument(typeArgument: ITypeSyntax): TypeArgumentListSyntax {
        return this.withTypeArguments(Syntax.separatedList([typeArgument]));
    }

    public withGreaterThanToken(greaterThanToken: ISyntaxToken): TypeArgumentListSyntax {
        return this.update(this.lessThanToken, this.typeArguments, greaterThanToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ConstructorTypeSyntax extends SyntaxNode implements ITypeSyntax {

    constructor(public newKeyword: ISyntaxToken,
                public typeParameterList: TypeParameterListSyntax,
                public parameterList: ParameterListSyntax,
                public equalsGreaterThanToken: ISyntaxToken,
                public type: ITypeSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitConstructorType(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ConstructorType;
    }

    public childCount(): number {
        return 5;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.newKeyword;
            case 1: return this.typeParameterList;
            case 2: return this.parameterList;
            case 3: return this.equalsGreaterThanToken;
            case 4: return this.type;
            default: throw Errors.invalidOperation();
        }
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(newKeyword: ISyntaxToken,
                  typeParameterList: TypeParameterListSyntax,
                  parameterList: ParameterListSyntax,
                  equalsGreaterThanToken: ISyntaxToken,
                  type: ITypeSyntax): ConstructorTypeSyntax {
        if (this.newKeyword === newKeyword && this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
            return this;
        }

        return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(newKeyword: ISyntaxToken,
                         parameterList: ParameterListSyntax,
                         equalsGreaterThanToken: ISyntaxToken,
                         type: ITypeSyntax): ConstructorTypeSyntax {
        return new ConstructorTypeSyntax(newKeyword, null, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ false);
    }

    public static create1(type: ITypeSyntax): ConstructorTypeSyntax {
        return new ConstructorTypeSyntax(Syntax.token(SyntaxKind.NewKeyword), null, ParameterListSyntax.create1(), Syntax.token(SyntaxKind.EqualsGreaterThanToken), type, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ConstructorTypeSyntax {
        return <ConstructorTypeSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ConstructorTypeSyntax {
        return <ConstructorTypeSyntax>super.withTrailingTrivia(trivia);
    }

    public withNewKeyword(newKeyword: ISyntaxToken): ConstructorTypeSyntax {
        return this.update(newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
    }

    public withTypeParameterList(typeParameterList: TypeParameterListSyntax): ConstructorTypeSyntax {
        return this.update(this.newKeyword, typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
    }

    public withParameterList(parameterList: ParameterListSyntax): ConstructorTypeSyntax {
        return this.update(this.newKeyword, this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
    }

    public withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): ConstructorTypeSyntax {
        return this.update(this.newKeyword, this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
    }

    public withType(type: ITypeSyntax): ConstructorTypeSyntax {
        return this.update(this.newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class FunctionTypeSyntax extends SyntaxNode implements ITypeSyntax {

    constructor(public typeParameterList: TypeParameterListSyntax,
                public parameterList: ParameterListSyntax,
                public equalsGreaterThanToken: ISyntaxToken,
                public type: ITypeSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitFunctionType(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.FunctionType;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.typeParameterList;
            case 1: return this.parameterList;
            case 2: return this.equalsGreaterThanToken;
            case 3: return this.type;
            default: throw Errors.invalidOperation();
        }
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(typeParameterList: TypeParameterListSyntax,
                  parameterList: ParameterListSyntax,
                  equalsGreaterThanToken: ISyntaxToken,
                  type: ITypeSyntax): FunctionTypeSyntax {
        if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
            return this;
        }

        return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(parameterList: ParameterListSyntax,
                         equalsGreaterThanToken: ISyntaxToken,
                         type: ITypeSyntax): FunctionTypeSyntax {
        return new FunctionTypeSyntax(null, parameterList, equalsGreaterThanToken, type, /*parsedInStrictMode:*/ false);
    }

    public static create1(type: ITypeSyntax): FunctionTypeSyntax {
        return new FunctionTypeSyntax(null, ParameterListSyntax.create1(), Syntax.token(SyntaxKind.EqualsGreaterThanToken), type, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): FunctionTypeSyntax {
        return <FunctionTypeSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): FunctionTypeSyntax {
        return <FunctionTypeSyntax>super.withTrailingTrivia(trivia);
    }

    public withTypeParameterList(typeParameterList: TypeParameterListSyntax): FunctionTypeSyntax {
        return this.update(typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
    }

    public withParameterList(parameterList: ParameterListSyntax): FunctionTypeSyntax {
        return this.update(this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
    }

    public withEqualsGreaterThanToken(equalsGreaterThanToken: ISyntaxToken): FunctionTypeSyntax {
        return this.update(this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
    }

    public withType(type: ITypeSyntax): FunctionTypeSyntax {
        return this.update(this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ObjectTypeSyntax extends SyntaxNode implements ITypeSyntax {

    constructor(public openBraceToken: ISyntaxToken,
                public typeMembers: ISeparatedSyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitObjectType(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ObjectType;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openBraceToken;
            case 1: return this.typeMembers;
            case 2: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(openBraceToken: ISyntaxToken,
                  typeMembers: ISeparatedSyntaxList,
                  closeBraceToken: ISyntaxToken): ObjectTypeSyntax {
        if (this.openBraceToken === openBraceToken && this.typeMembers === typeMembers && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): ObjectTypeSyntax {
        return new ObjectTypeSyntax(openBraceToken, Syntax.emptySeparatedList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ObjectTypeSyntax {
        return new ObjectTypeSyntax(Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ObjectTypeSyntax {
        return <ObjectTypeSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ObjectTypeSyntax {
        return <ObjectTypeSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): ObjectTypeSyntax {
        return this.update(openBraceToken, this.typeMembers, this.closeBraceToken);
    }

    public withTypeMembers(typeMembers: ISeparatedSyntaxList): ObjectTypeSyntax {
        return this.update(this.openBraceToken, typeMembers, this.closeBraceToken);
    }

    public withTypeMember(typeMember: ITypeMemberSyntax): ObjectTypeSyntax {
        return this.withTypeMembers(Syntax.separatedList([typeMember]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): ObjectTypeSyntax {
        return this.update(this.openBraceToken, this.typeMembers, closeBraceToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ArrayTypeSyntax extends SyntaxNode implements ITypeSyntax {

    constructor(public type: ITypeSyntax,
                public openBracketToken: ISyntaxToken,
                public closeBracketToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitArrayType(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ArrayType;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.type;
            case 1: return this.openBracketToken;
            case 2: return this.closeBracketToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(type: ITypeSyntax,
                  openBracketToken: ISyntaxToken,
                  closeBracketToken: ISyntaxToken): ArrayTypeSyntax {
        if (this.type === type && this.openBracketToken === openBracketToken && this.closeBracketToken === closeBracketToken) {
            return this;
        }

        return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(type: ITypeSyntax): ArrayTypeSyntax {
        return new ArrayTypeSyntax(type, Syntax.token(SyntaxKind.OpenBracketToken), Syntax.token(SyntaxKind.CloseBracketToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ArrayTypeSyntax {
        return <ArrayTypeSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ArrayTypeSyntax {
        return <ArrayTypeSyntax>super.withTrailingTrivia(trivia);
    }

    public withType(type: ITypeSyntax): ArrayTypeSyntax {
        return this.update(type, this.openBracketToken, this.closeBracketToken);
    }

    public withOpenBracketToken(openBracketToken: ISyntaxToken): ArrayTypeSyntax {
        return this.update(this.type, openBracketToken, this.closeBracketToken);
    }

    public withCloseBracketToken(closeBracketToken: ISyntaxToken): ArrayTypeSyntax {
        return this.update(this.type, this.openBracketToken, closeBracketToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class GenericTypeSyntax extends SyntaxNode implements ITypeSyntax {

    constructor(public name: INameSyntax,
                public typeArgumentList: TypeArgumentListSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitGenericType(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.GenericType;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.name;
            case 1: return this.typeArgumentList;
            default: throw Errors.invalidOperation();
        }
    }

    private isType(): bool {
        return true;
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(name: INameSyntax,
                  typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax {
        if (this.name === name && this.typeArgumentList === typeArgumentList) {
            return this;
        }

        return new GenericTypeSyntax(name, typeArgumentList, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(name: INameSyntax): GenericTypeSyntax {
        return new GenericTypeSyntax(name, TypeArgumentListSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): GenericTypeSyntax {
        return <GenericTypeSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): GenericTypeSyntax {
        return <GenericTypeSyntax>super.withTrailingTrivia(trivia);
    }

    public withName(name: INameSyntax): GenericTypeSyntax {
        return this.update(name, this.typeArgumentList);
    }

    public withTypeArgumentList(typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax {
        return this.update(this.name, typeArgumentList);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class TypeAnnotationSyntax extends SyntaxNode {

    constructor(public colonToken: ISyntaxToken,
                public type: ITypeSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTypeAnnotation(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TypeAnnotation;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.colonToken;
            case 1: return this.type;
            default: throw Errors.invalidOperation();
        }
    }

    public update(colonToken: ISyntaxToken,
                  type: ITypeSyntax): TypeAnnotationSyntax {
        if (this.colonToken === colonToken && this.type === type) {
            return this;
        }

        return new TypeAnnotationSyntax(colonToken, type, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(type: ITypeSyntax): TypeAnnotationSyntax {
        return new TypeAnnotationSyntax(Syntax.token(SyntaxKind.ColonToken), type, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TypeAnnotationSyntax {
        return <TypeAnnotationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TypeAnnotationSyntax {
        return <TypeAnnotationSyntax>super.withTrailingTrivia(trivia);
    }

    public withColonToken(colonToken: ISyntaxToken): TypeAnnotationSyntax {
        return this.update(colonToken, this.type);
    }

    public withType(type: ITypeSyntax): TypeAnnotationSyntax {
        return this.update(this.colonToken, type);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class BlockSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public openBraceToken: ISyntaxToken,
                public statements: ISyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitBlock(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.Block;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openBraceToken;
            case 1: return this.statements;
            case 2: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(openBraceToken: ISyntaxToken,
                  statements: ISyntaxList,
                  closeBraceToken: ISyntaxToken): BlockSyntax {
        if (this.openBraceToken === openBraceToken && this.statements === statements && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new BlockSyntax(openBraceToken, statements, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): BlockSyntax {
        return new BlockSyntax(openBraceToken, Syntax.emptyList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): BlockSyntax {
        return new BlockSyntax(Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptyList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): BlockSyntax {
        return <BlockSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): BlockSyntax {
        return <BlockSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): BlockSyntax {
        return this.update(openBraceToken, this.statements, this.closeBraceToken);
    }

    public withStatements(statements: ISyntaxList): BlockSyntax {
        return this.update(this.openBraceToken, statements, this.closeBraceToken);
    }

    public withStatement(statement: IStatementSyntax): BlockSyntax {
        return this.withStatements(Syntax.list([statement]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): BlockSyntax {
        return this.update(this.openBraceToken, this.statements, closeBraceToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.statements.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ParameterSyntax extends SyntaxNode {

    constructor(public dotDotDotToken: ISyntaxToken,
                public publicOrPrivateKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public questionToken: ISyntaxToken,
                public typeAnnotation: TypeAnnotationSyntax,
                public equalsValueClause: EqualsValueClauseSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitParameter(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.Parameter;
    }

    public childCount(): number {
        return 6;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.dotDotDotToken;
            case 1: return this.publicOrPrivateKeyword;
            case 2: return this.identifier;
            case 3: return this.questionToken;
            case 4: return this.typeAnnotation;
            case 5: return this.equalsValueClause;
            default: throw Errors.invalidOperation();
        }
    }

    public update(dotDotDotToken: ISyntaxToken,
                  publicOrPrivateKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  questionToken: ISyntaxToken,
                  typeAnnotation: TypeAnnotationSyntax,
                  equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax {
        if (this.dotDotDotToken === dotDotDotToken && this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.identifier === identifier && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
            return this;
        }

        return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(identifier: ISyntaxToken): ParameterSyntax {
        return new ParameterSyntax(null, null, identifier, null, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): ParameterSyntax {
        return new ParameterSyntax(null, null, identifier, null, null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ParameterSyntax {
        return <ParameterSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ParameterSyntax {
        return <ParameterSyntax>super.withTrailingTrivia(trivia);
    }

    public withDotDotDotToken(dotDotDotToken: ISyntaxToken): ParameterSyntax {
        return this.update(dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
    }

    public withPublicOrPrivateKeyword(publicOrPrivateKeyword: ISyntaxToken): ParameterSyntax {
        return this.update(this.dotDotDotToken, publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
    }

    public withIdentifier(identifier: ISyntaxToken): ParameterSyntax {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
    }

    public withQuestionToken(questionToken: ISyntaxToken): ParameterSyntax {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, questionToken, this.typeAnnotation, this.equalsValueClause);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): ParameterSyntax {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, typeAnnotation, this.equalsValueClause);
    }

    public withEqualsValueClause(equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax {
        return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, equalsValueClause);
    }

    public isTypeScriptSpecific(): bool {
        if (this.dotDotDotToken !== null) { return true; }
        if (this.publicOrPrivateKeyword !== null) { return true; }
        if (this.questionToken !== null) { return true; }
        if (this.typeAnnotation !== null) { return true; }
        if (this.equalsValueClause !== null) { return true; }
        return false;
    }
    }

    export class MemberAccessExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public expression: IExpressionSyntax,
                public dotToken: ISyntaxToken,
                public name: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitMemberAccessExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.MemberAccessExpression;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.expression;
            case 1: return this.dotToken;
            case 2: return this.name;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(expression: IExpressionSyntax,
                  dotToken: ISyntaxToken,
                  name: ISyntaxToken): MemberAccessExpressionSyntax {
        if (this.expression === expression && this.dotToken === dotToken && this.name === name) {
            return this;
        }

        return new MemberAccessExpressionSyntax(expression, dotToken, name, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax,
                          name: ISyntaxToken): MemberAccessExpressionSyntax {
        return new MemberAccessExpressionSyntax(expression, Syntax.token(SyntaxKind.DotToken), name, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): MemberAccessExpressionSyntax {
        return <MemberAccessExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): MemberAccessExpressionSyntax {
        return <MemberAccessExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withExpression(expression: IExpressionSyntax): MemberAccessExpressionSyntax {
        return this.update(expression, this.dotToken, this.name);
    }

    public withDotToken(dotToken: ISyntaxToken): MemberAccessExpressionSyntax {
        return this.update(this.expression, dotToken, this.name);
    }

    public withName(name: ISyntaxToken): MemberAccessExpressionSyntax {
        return this.update(this.expression, this.dotToken, name);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class PostfixUnaryExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {
    private _kind: SyntaxKind;

    constructor(kind: SyntaxKind,
                public operand: IExpressionSyntax,
                public operatorToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

        this._kind = kind;
    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitPostfixUnaryExpression(this);
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.operand;
            case 1: return this.operatorToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public kind(): SyntaxKind {
        return this._kind;
    }

    public update(kind: SyntaxKind,
                  operand: IExpressionSyntax,
                  operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax {
        if (this._kind === kind && this.operand === operand && this.operatorToken === operatorToken) {
            return this;
        }

        return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): PostfixUnaryExpressionSyntax {
        return <PostfixUnaryExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): PostfixUnaryExpressionSyntax {
        return <PostfixUnaryExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withKind(kind: SyntaxKind): PostfixUnaryExpressionSyntax {
        return this.update(kind, this.operand, this.operatorToken);
    }

    public withOperand(operand: IExpressionSyntax): PostfixUnaryExpressionSyntax {
        return this.update(this._kind, operand, this.operatorToken);
    }

    public withOperatorToken(operatorToken: ISyntaxToken): PostfixUnaryExpressionSyntax {
        return this.update(this._kind, this.operand, operatorToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.operand.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ElementAccessExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public expression: IExpressionSyntax,
                public openBracketToken: ISyntaxToken,
                public argumentExpression: IExpressionSyntax,
                public closeBracketToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitElementAccessExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ElementAccessExpression;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.expression;
            case 1: return this.openBracketToken;
            case 2: return this.argumentExpression;
            case 3: return this.closeBracketToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(expression: IExpressionSyntax,
                  openBracketToken: ISyntaxToken,
                  argumentExpression: IExpressionSyntax,
                  closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax {
        if (this.expression === expression && this.openBracketToken === openBracketToken && this.argumentExpression === argumentExpression && this.closeBracketToken === closeBracketToken) {
            return this;
        }

        return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax,
                          argumentExpression: IExpressionSyntax): ElementAccessExpressionSyntax {
        return new ElementAccessExpressionSyntax(expression, Syntax.token(SyntaxKind.OpenBracketToken), argumentExpression, Syntax.token(SyntaxKind.CloseBracketToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ElementAccessExpressionSyntax {
        return <ElementAccessExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ElementAccessExpressionSyntax {
        return <ElementAccessExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withExpression(expression: IExpressionSyntax): ElementAccessExpressionSyntax {
        return this.update(expression, this.openBracketToken, this.argumentExpression, this.closeBracketToken);
    }

    public withOpenBracketToken(openBracketToken: ISyntaxToken): ElementAccessExpressionSyntax {
        return this.update(this.expression, openBracketToken, this.argumentExpression, this.closeBracketToken);
    }

    public withArgumentExpression(argumentExpression: IExpressionSyntax): ElementAccessExpressionSyntax {
        return this.update(this.expression, this.openBracketToken, argumentExpression, this.closeBracketToken);
    }

    public withCloseBracketToken(closeBracketToken: ISyntaxToken): ElementAccessExpressionSyntax {
        return this.update(this.expression, this.openBracketToken, this.argumentExpression, closeBracketToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.argumentExpression.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class InvocationExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public expression: IExpressionSyntax,
                public argumentList: ArgumentListSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitInvocationExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.InvocationExpression;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(expression: IExpressionSyntax,
                  argumentList: ArgumentListSyntax): InvocationExpressionSyntax {
        if (this.expression === expression && this.argumentList === argumentList) {
            return this;
        }

        return new InvocationExpressionSyntax(expression, argumentList, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): InvocationExpressionSyntax {
        return new InvocationExpressionSyntax(expression, ArgumentListSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): InvocationExpressionSyntax {
        return <InvocationExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): InvocationExpressionSyntax {
        return <InvocationExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withExpression(expression: IExpressionSyntax): InvocationExpressionSyntax {
        return this.update(expression, this.argumentList);
    }

    public withArgumentList(argumentList: ArgumentListSyntax): InvocationExpressionSyntax {
        return this.update(this.expression, argumentList);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.argumentList.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ArgumentListSyntax extends SyntaxNode {

    constructor(public typeArgumentList: TypeArgumentListSyntax,
                public openParenToken: ISyntaxToken,
                public arguments: ISeparatedSyntaxList,
                public closeParenToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitArgumentList(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ArgumentList;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.typeArgumentList;
            case 1: return this.openParenToken;
            case 2: return this.arguments;
            case 3: return this.closeParenToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(typeArgumentList: TypeArgumentListSyntax,
                  openParenToken: ISyntaxToken,
                  _arguments: ISeparatedSyntaxList,
                  closeParenToken: ISyntaxToken): ArgumentListSyntax {
        if (this.typeArgumentList === typeArgumentList && this.openParenToken === openParenToken && this.arguments === _arguments && this.closeParenToken === closeParenToken) {
            return this;
        }

        return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openParenToken: ISyntaxToken,
                         closeParenToken: ISyntaxToken): ArgumentListSyntax {
        return new ArgumentListSyntax(null, openParenToken, Syntax.emptySeparatedList, closeParenToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ArgumentListSyntax {
        return new ArgumentListSyntax(null, Syntax.token(SyntaxKind.OpenParenToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseParenToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ArgumentListSyntax {
        return <ArgumentListSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ArgumentListSyntax {
        return <ArgumentListSyntax>super.withTrailingTrivia(trivia);
    }

    public withTypeArgumentList(typeArgumentList: TypeArgumentListSyntax): ArgumentListSyntax {
        return this.update(typeArgumentList, this.openParenToken, this.arguments, this.closeParenToken);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ArgumentListSyntax {
        return this.update(this.typeArgumentList, openParenToken, this.arguments, this.closeParenToken);
    }

    public withArguments(_arguments: ISeparatedSyntaxList): ArgumentListSyntax {
        return this.update(this.typeArgumentList, this.openParenToken, _arguments, this.closeParenToken);
    }

    public withArgument(_argument: IExpressionSyntax): ArgumentListSyntax {
        return this.withArguments(Syntax.separatedList([_argument]));
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ArgumentListSyntax {
        return this.update(this.typeArgumentList, this.openParenToken, this.arguments, closeParenToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.typeArgumentList !== null && this.typeArgumentList.isTypeScriptSpecific()) { return true; }
        if (this.arguments.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class BinaryExpressionSyntax extends SyntaxNode implements IExpressionSyntax {
    private _kind: SyntaxKind;

    constructor(kind: SyntaxKind,
                public left: IExpressionSyntax,
                public operatorToken: ISyntaxToken,
                public right: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

        this._kind = kind;
    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitBinaryExpression(this);
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.left;
            case 1: return this.operatorToken;
            case 2: return this.right;
            default: throw Errors.invalidOperation();
        }
    }

    private isExpression(): bool {
        return true;
    }

    public kind(): SyntaxKind {
        return this._kind;
    }

    public update(kind: SyntaxKind,
                  left: IExpressionSyntax,
                  operatorToken: ISyntaxToken,
                  right: IExpressionSyntax): BinaryExpressionSyntax {
        if (this._kind === kind && this.left === left && this.operatorToken === operatorToken && this.right === right) {
            return this;
        }

        return new BinaryExpressionSyntax(kind, left, operatorToken, right, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): BinaryExpressionSyntax {
        return <BinaryExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): BinaryExpressionSyntax {
        return <BinaryExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withKind(kind: SyntaxKind): BinaryExpressionSyntax {
        return this.update(kind, this.left, this.operatorToken, this.right);
    }

    public withLeft(left: IExpressionSyntax): BinaryExpressionSyntax {
        return this.update(this._kind, left, this.operatorToken, this.right);
    }

    public withOperatorToken(operatorToken: ISyntaxToken): BinaryExpressionSyntax {
        return this.update(this._kind, this.left, operatorToken, this.right);
    }

    public withRight(right: IExpressionSyntax): BinaryExpressionSyntax {
        return this.update(this._kind, this.left, this.operatorToken, right);
    }

    public isTypeScriptSpecific(): bool {
        if (this.left.isTypeScriptSpecific()) { return true; }
        if (this.right.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ConditionalExpressionSyntax extends SyntaxNode implements IExpressionSyntax {

    constructor(public condition: IExpressionSyntax,
                public questionToken: ISyntaxToken,
                public whenTrue: IExpressionSyntax,
                public colonToken: ISyntaxToken,
                public whenFalse: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitConditionalExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ConditionalExpression;
    }

    public childCount(): number {
        return 5;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.condition;
            case 1: return this.questionToken;
            case 2: return this.whenTrue;
            case 3: return this.colonToken;
            case 4: return this.whenFalse;
            default: throw Errors.invalidOperation();
        }
    }

    private isExpression(): bool {
        return true;
    }

    public update(condition: IExpressionSyntax,
                  questionToken: ISyntaxToken,
                  whenTrue: IExpressionSyntax,
                  colonToken: ISyntaxToken,
                  whenFalse: IExpressionSyntax): ConditionalExpressionSyntax {
        if (this.condition === condition && this.questionToken === questionToken && this.whenTrue === whenTrue && this.colonToken === colonToken && this.whenFalse === whenFalse) {
            return this;
        }

        return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(condition: IExpressionSyntax,
                          whenTrue: IExpressionSyntax,
                          whenFalse: IExpressionSyntax): ConditionalExpressionSyntax {
        return new ConditionalExpressionSyntax(condition, Syntax.token(SyntaxKind.QuestionToken), whenTrue, Syntax.token(SyntaxKind.ColonToken), whenFalse, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ConditionalExpressionSyntax {
        return <ConditionalExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ConditionalExpressionSyntax {
        return <ConditionalExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withCondition(condition: IExpressionSyntax): ConditionalExpressionSyntax {
        return this.update(condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse);
    }

    public withQuestionToken(questionToken: ISyntaxToken): ConditionalExpressionSyntax {
        return this.update(this.condition, questionToken, this.whenTrue, this.colonToken, this.whenFalse);
    }

    public withWhenTrue(whenTrue: IExpressionSyntax): ConditionalExpressionSyntax {
        return this.update(this.condition, this.questionToken, whenTrue, this.colonToken, this.whenFalse);
    }

    public withColonToken(colonToken: ISyntaxToken): ConditionalExpressionSyntax {
        return this.update(this.condition, this.questionToken, this.whenTrue, colonToken, this.whenFalse);
    }

    public withWhenFalse(whenFalse: IExpressionSyntax): ConditionalExpressionSyntax {
        return this.update(this.condition, this.questionToken, this.whenTrue, this.colonToken, whenFalse);
    }

    public isTypeScriptSpecific(): bool {
        if (this.condition.isTypeScriptSpecific()) { return true; }
        if (this.whenTrue.isTypeScriptSpecific()) { return true; }
        if (this.whenFalse.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ConstructSignatureSyntax extends SyntaxNode implements ITypeMemberSyntax {

    constructor(public newKeyword: ISyntaxToken,
                public callSignature: CallSignatureSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitConstructSignature(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ConstructSignature;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.newKeyword;
            case 1: return this.callSignature;
            default: throw Errors.invalidOperation();
        }
    }

    private isTypeMember(): bool {
        return true;
    }

    public update(newKeyword: ISyntaxToken,
                  callSignature: CallSignatureSyntax): ConstructSignatureSyntax {
        if (this.newKeyword === newKeyword && this.callSignature === callSignature) {
            return this;
        }

        return new ConstructSignatureSyntax(newKeyword, callSignature, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(): ConstructSignatureSyntax {
        return new ConstructSignatureSyntax(Syntax.token(SyntaxKind.NewKeyword), CallSignatureSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ConstructSignatureSyntax {
        return <ConstructSignatureSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ConstructSignatureSyntax {
        return <ConstructSignatureSyntax>super.withTrailingTrivia(trivia);
    }

    public withNewKeyword(newKeyword: ISyntaxToken): ConstructSignatureSyntax {
        return this.update(newKeyword, this.callSignature);
    }

    public withCallSignature(callSignature: CallSignatureSyntax): ConstructSignatureSyntax {
        return this.update(this.newKeyword, callSignature);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class MethodSignatureSyntax extends SyntaxNode implements ITypeMemberSyntax {

    constructor(public propertyName: ISyntaxToken,
                public questionToken: ISyntaxToken,
                public callSignature: CallSignatureSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitMethodSignature(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.MethodSignature;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.propertyName;
            case 1: return this.questionToken;
            case 2: return this.callSignature;
            default: throw Errors.invalidOperation();
        }
    }

    private isTypeMember(): bool {
        return true;
    }

    public update(propertyName: ISyntaxToken,
                  questionToken: ISyntaxToken,
                  callSignature: CallSignatureSyntax): MethodSignatureSyntax {
        if (this.propertyName === propertyName && this.questionToken === questionToken && this.callSignature === callSignature) {
            return this;
        }

        return new MethodSignatureSyntax(propertyName, questionToken, callSignature, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(propertyName: ISyntaxToken,
                         callSignature: CallSignatureSyntax): MethodSignatureSyntax {
        return new MethodSignatureSyntax(propertyName, null, callSignature, /*parsedInStrictMode:*/ false);
    }

    public static create1(propertyName: ISyntaxToken): MethodSignatureSyntax {
        return new MethodSignatureSyntax(propertyName, null, CallSignatureSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): MethodSignatureSyntax {
        return <MethodSignatureSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): MethodSignatureSyntax {
        return <MethodSignatureSyntax>super.withTrailingTrivia(trivia);
    }

    public withPropertyName(propertyName: ISyntaxToken): MethodSignatureSyntax {
        return this.update(propertyName, this.questionToken, this.callSignature);
    }

    public withQuestionToken(questionToken: ISyntaxToken): MethodSignatureSyntax {
        return this.update(this.propertyName, questionToken, this.callSignature);
    }

    public withCallSignature(callSignature: CallSignatureSyntax): MethodSignatureSyntax {
        return this.update(this.propertyName, this.questionToken, callSignature);
    }

    public isTypeScriptSpecific(): bool {
        if (this.callSignature.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class IndexSignatureSyntax extends SyntaxNode implements ITypeMemberSyntax {

    constructor(public openBracketToken: ISyntaxToken,
                public identifier: ISyntaxToken,
                public parameterTypeAnnotation: TypeAnnotationSyntax,
                public closeBracketToken: ISyntaxToken,
                public typeAnnotation: TypeAnnotationSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitIndexSignature(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.IndexSignature;
    }

    public childCount(): number {
        return 5;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openBracketToken;
            case 1: return this.identifier;
            case 2: return this.parameterTypeAnnotation;
            case 3: return this.closeBracketToken;
            case 4: return this.typeAnnotation;
            default: throw Errors.invalidOperation();
        }
    }

    private isTypeMember(): bool {
        return true;
    }

    public update(openBracketToken: ISyntaxToken,
                  identifier: ISyntaxToken,
                  parameterTypeAnnotation: TypeAnnotationSyntax,
                  closeBracketToken: ISyntaxToken,
                  typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax {
        if (this.openBracketToken === openBracketToken && this.identifier === identifier && this.parameterTypeAnnotation === parameterTypeAnnotation && this.closeBracketToken === closeBracketToken && this.typeAnnotation === typeAnnotation) {
            return this;
        }

        return new IndexSignatureSyntax(openBracketToken, identifier, parameterTypeAnnotation, closeBracketToken, typeAnnotation, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openBracketToken: ISyntaxToken,
                         identifier: ISyntaxToken,
                         parameterTypeAnnotation: TypeAnnotationSyntax,
                         closeBracketToken: ISyntaxToken): IndexSignatureSyntax {
        return new IndexSignatureSyntax(openBracketToken, identifier, parameterTypeAnnotation, closeBracketToken, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken,
                          parameterTypeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax {
        return new IndexSignatureSyntax(Syntax.token(SyntaxKind.OpenBracketToken), identifier, parameterTypeAnnotation, Syntax.token(SyntaxKind.CloseBracketToken), null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): IndexSignatureSyntax {
        return <IndexSignatureSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): IndexSignatureSyntax {
        return <IndexSignatureSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenBracketToken(openBracketToken: ISyntaxToken): IndexSignatureSyntax {
        return this.update(openBracketToken, this.identifier, this.parameterTypeAnnotation, this.closeBracketToken, this.typeAnnotation);
    }

    public withIdentifier(identifier: ISyntaxToken): IndexSignatureSyntax {
        return this.update(this.openBracketToken, identifier, this.parameterTypeAnnotation, this.closeBracketToken, this.typeAnnotation);
    }

    public withParameterTypeAnnotation(parameterTypeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax {
        return this.update(this.openBracketToken, this.identifier, parameterTypeAnnotation, this.closeBracketToken, this.typeAnnotation);
    }

    public withCloseBracketToken(closeBracketToken: ISyntaxToken): IndexSignatureSyntax {
        return this.update(this.openBracketToken, this.identifier, this.parameterTypeAnnotation, closeBracketToken, this.typeAnnotation);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax {
        return this.update(this.openBracketToken, this.identifier, this.parameterTypeAnnotation, this.closeBracketToken, typeAnnotation);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class PropertySignatureSyntax extends SyntaxNode implements ITypeMemberSyntax {

    constructor(public propertyName: ISyntaxToken,
                public questionToken: ISyntaxToken,
                public typeAnnotation: TypeAnnotationSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitPropertySignature(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.PropertySignature;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.propertyName;
            case 1: return this.questionToken;
            case 2: return this.typeAnnotation;
            default: throw Errors.invalidOperation();
        }
    }

    private isTypeMember(): bool {
        return true;
    }

    public update(propertyName: ISyntaxToken,
                  questionToken: ISyntaxToken,
                  typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax {
        if (this.propertyName === propertyName && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation) {
            return this;
        }

        return new PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(propertyName: ISyntaxToken): PropertySignatureSyntax {
        return new PropertySignatureSyntax(propertyName, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(propertyName: ISyntaxToken): PropertySignatureSyntax {
        return new PropertySignatureSyntax(propertyName, null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): PropertySignatureSyntax {
        return <PropertySignatureSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): PropertySignatureSyntax {
        return <PropertySignatureSyntax>super.withTrailingTrivia(trivia);
    }

    public withPropertyName(propertyName: ISyntaxToken): PropertySignatureSyntax {
        return this.update(propertyName, this.questionToken, this.typeAnnotation);
    }

    public withQuestionToken(questionToken: ISyntaxToken): PropertySignatureSyntax {
        return this.update(this.propertyName, questionToken, this.typeAnnotation);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax {
        return this.update(this.propertyName, this.questionToken, typeAnnotation);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class CallSignatureSyntax extends SyntaxNode implements ITypeMemberSyntax {

    constructor(public typeParameterList: TypeParameterListSyntax,
                public parameterList: ParameterListSyntax,
                public typeAnnotation: TypeAnnotationSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitCallSignature(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.CallSignature;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.typeParameterList;
            case 1: return this.parameterList;
            case 2: return this.typeAnnotation;
            default: throw Errors.invalidOperation();
        }
    }

    private isTypeMember(): bool {
        return true;
    }

    public update(typeParameterList: TypeParameterListSyntax,
                  parameterList: ParameterListSyntax,
                  typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax {
        if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation) {
            return this;
        }

        return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(parameterList: ParameterListSyntax): CallSignatureSyntax {
        return new CallSignatureSyntax(null, parameterList, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(): CallSignatureSyntax {
        return new CallSignatureSyntax(null, ParameterListSyntax.create1(), null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): CallSignatureSyntax {
        return <CallSignatureSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): CallSignatureSyntax {
        return <CallSignatureSyntax>super.withTrailingTrivia(trivia);
    }

    public withTypeParameterList(typeParameterList: TypeParameterListSyntax): CallSignatureSyntax {
        return this.update(typeParameterList, this.parameterList, this.typeAnnotation);
    }

    public withParameterList(parameterList: ParameterListSyntax): CallSignatureSyntax {
        return this.update(this.typeParameterList, parameterList, this.typeAnnotation);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax {
        return this.update(this.typeParameterList, this.parameterList, typeAnnotation);
    }

    public isTypeScriptSpecific(): bool {
        if (this.typeParameterList !== null) { return true; }
        if (this.parameterList.isTypeScriptSpecific()) { return true; }
        if (this.typeAnnotation !== null) { return true; }
        return false;
    }
    }

    export class ParameterListSyntax extends SyntaxNode {

    constructor(public openParenToken: ISyntaxToken,
                public parameters: ISeparatedSyntaxList,
                public closeParenToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitParameterList(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ParameterList;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openParenToken;
            case 1: return this.parameters;
            case 2: return this.closeParenToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(openParenToken: ISyntaxToken,
                  parameters: ISeparatedSyntaxList,
                  closeParenToken: ISyntaxToken): ParameterListSyntax {
        if (this.openParenToken === openParenToken && this.parameters === parameters && this.closeParenToken === closeParenToken) {
            return this;
        }

        return new ParameterListSyntax(openParenToken, parameters, closeParenToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openParenToken: ISyntaxToken,
                         closeParenToken: ISyntaxToken): ParameterListSyntax {
        return new ParameterListSyntax(openParenToken, Syntax.emptySeparatedList, closeParenToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ParameterListSyntax {
        return new ParameterListSyntax(Syntax.token(SyntaxKind.OpenParenToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseParenToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ParameterListSyntax {
        return <ParameterListSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ParameterListSyntax {
        return <ParameterListSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ParameterListSyntax {
        return this.update(openParenToken, this.parameters, this.closeParenToken);
    }

    public withParameters(parameters: ISeparatedSyntaxList): ParameterListSyntax {
        return this.update(this.openParenToken, parameters, this.closeParenToken);
    }

    public withParameter(parameter: ParameterSyntax): ParameterListSyntax {
        return this.withParameters(Syntax.separatedList([parameter]));
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ParameterListSyntax {
        return this.update(this.openParenToken, this.parameters, closeParenToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.parameters.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class TypeParameterListSyntax extends SyntaxNode {

    constructor(public lessThanToken: ISyntaxToken,
                public typeParameters: ISeparatedSyntaxList,
                public greaterThanToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTypeParameterList(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TypeParameterList;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.lessThanToken;
            case 1: return this.typeParameters;
            case 2: return this.greaterThanToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(lessThanToken: ISyntaxToken,
                  typeParameters: ISeparatedSyntaxList,
                  greaterThanToken: ISyntaxToken): TypeParameterListSyntax {
        if (this.lessThanToken === lessThanToken && this.typeParameters === typeParameters && this.greaterThanToken === greaterThanToken) {
            return this;
        }

        return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(lessThanToken: ISyntaxToken,
                         greaterThanToken: ISyntaxToken): TypeParameterListSyntax {
        return new TypeParameterListSyntax(lessThanToken, Syntax.emptySeparatedList, greaterThanToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): TypeParameterListSyntax {
        return new TypeParameterListSyntax(Syntax.token(SyntaxKind.LessThanToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.GreaterThanToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TypeParameterListSyntax {
        return <TypeParameterListSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TypeParameterListSyntax {
        return <TypeParameterListSyntax>super.withTrailingTrivia(trivia);
    }

    public withLessThanToken(lessThanToken: ISyntaxToken): TypeParameterListSyntax {
        return this.update(lessThanToken, this.typeParameters, this.greaterThanToken);
    }

    public withTypeParameters(typeParameters: ISeparatedSyntaxList): TypeParameterListSyntax {
        return this.update(this.lessThanToken, typeParameters, this.greaterThanToken);
    }

    public withTypeParameter(typeParameter: TypeParameterSyntax): TypeParameterListSyntax {
        return this.withTypeParameters(Syntax.separatedList([typeParameter]));
    }

    public withGreaterThanToken(greaterThanToken: ISyntaxToken): TypeParameterListSyntax {
        return this.update(this.lessThanToken, this.typeParameters, greaterThanToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class TypeParameterSyntax extends SyntaxNode {

    constructor(public identifier: ISyntaxToken,
                public constraint: ConstraintSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTypeParameter(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TypeParameter;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.identifier;
            case 1: return this.constraint;
            default: throw Errors.invalidOperation();
        }
    }

    public update(identifier: ISyntaxToken,
                  constraint: ConstraintSyntax): TypeParameterSyntax {
        if (this.identifier === identifier && this.constraint === constraint) {
            return this;
        }

        return new TypeParameterSyntax(identifier, constraint, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(identifier: ISyntaxToken): TypeParameterSyntax {
        return new TypeParameterSyntax(identifier, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): TypeParameterSyntax {
        return new TypeParameterSyntax(identifier, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TypeParameterSyntax {
        return <TypeParameterSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TypeParameterSyntax {
        return <TypeParameterSyntax>super.withTrailingTrivia(trivia);
    }

    public withIdentifier(identifier: ISyntaxToken): TypeParameterSyntax {
        return this.update(identifier, this.constraint);
    }

    public withConstraint(constraint: ConstraintSyntax): TypeParameterSyntax {
        return this.update(this.identifier, constraint);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ConstraintSyntax extends SyntaxNode {

    constructor(public extendsKeyword: ISyntaxToken,
                public type: ITypeSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitConstraint(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.Constraint;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.extendsKeyword;
            case 1: return this.type;
            default: throw Errors.invalidOperation();
        }
    }

    public update(extendsKeyword: ISyntaxToken,
                  type: ITypeSyntax): ConstraintSyntax {
        if (this.extendsKeyword === extendsKeyword && this.type === type) {
            return this;
        }

        return new ConstraintSyntax(extendsKeyword, type, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(type: ITypeSyntax): ConstraintSyntax {
        return new ConstraintSyntax(Syntax.token(SyntaxKind.ExtendsKeyword), type, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ConstraintSyntax {
        return <ConstraintSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ConstraintSyntax {
        return <ConstraintSyntax>super.withTrailingTrivia(trivia);
    }

    public withExtendsKeyword(extendsKeyword: ISyntaxToken): ConstraintSyntax {
        return this.update(extendsKeyword, this.type);
    }

    public withType(type: ITypeSyntax): ConstraintSyntax {
        return this.update(this.extendsKeyword, type);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ElseClauseSyntax extends SyntaxNode {

    constructor(public elseKeyword: ISyntaxToken,
                public statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitElseClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ElseClause;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.elseKeyword;
            case 1: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    public update(elseKeyword: ISyntaxToken,
                  statement: IStatementSyntax): ElseClauseSyntax {
        if (this.elseKeyword === elseKeyword && this.statement === statement) {
            return this;
        }

        return new ElseClauseSyntax(elseKeyword, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(statement: IStatementSyntax): ElseClauseSyntax {
        return new ElseClauseSyntax(Syntax.token(SyntaxKind.ElseKeyword), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ElseClauseSyntax {
        return <ElseClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ElseClauseSyntax {
        return <ElseClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withElseKeyword(elseKeyword: ISyntaxToken): ElseClauseSyntax {
        return this.update(elseKeyword, this.statement);
    }

    public withStatement(statement: IStatementSyntax): ElseClauseSyntax {
        return this.update(this.elseKeyword, statement);
    }

    public isTypeScriptSpecific(): bool {
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class IfStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public ifKeyword: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public condition: IExpressionSyntax,
                public closeParenToken: ISyntaxToken,
                public statement: IStatementSyntax,
                public elseClause: ElseClauseSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitIfStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.IfStatement;
    }

    public childCount(): number {
        return 6;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.ifKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            case 5: return this.elseClause;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(ifKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  condition: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  statement: IStatementSyntax,
                  elseClause: ElseClauseSyntax): IfStatementSyntax {
        if (this.ifKeyword === ifKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement && this.elseClause === elseClause) {
            return this;
        }

        return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(ifKeyword: ISyntaxToken,
                         openParenToken: ISyntaxToken,
                         condition: IExpressionSyntax,
                         closeParenToken: ISyntaxToken,
                         statement: IStatementSyntax): IfStatementSyntax {
        return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(condition: IExpressionSyntax,
                          statement: IStatementSyntax): IfStatementSyntax {
        return new IfStatementSyntax(Syntax.token(SyntaxKind.IfKeyword), Syntax.token(SyntaxKind.OpenParenToken), condition, Syntax.token(SyntaxKind.CloseParenToken), statement, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): IfStatementSyntax {
        return <IfStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): IfStatementSyntax {
        return <IfStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withIfKeyword(ifKeyword: ISyntaxToken): IfStatementSyntax {
        return this.update(ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): IfStatementSyntax {
        return this.update(this.ifKeyword, openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
    }

    public withCondition(condition: IExpressionSyntax): IfStatementSyntax {
        return this.update(this.ifKeyword, this.openParenToken, condition, this.closeParenToken, this.statement, this.elseClause);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): IfStatementSyntax {
        return this.update(this.ifKeyword, this.openParenToken, this.condition, closeParenToken, this.statement, this.elseClause);
    }

    public withStatement(statement: IStatementSyntax): IfStatementSyntax {
        return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, statement, this.elseClause);
    }

    public withElseClause(elseClause: ElseClauseSyntax): IfStatementSyntax {
        return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, elseClause);
    }

    public isTypeScriptSpecific(): bool {
        if (this.condition.isTypeScriptSpecific()) { return true; }
        if (this.statement.isTypeScriptSpecific()) { return true; }
        if (this.elseClause !== null && this.elseClause.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ExpressionStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public expression: IExpressionSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitExpressionStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ExpressionStatement;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.expression;
            case 1: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(expression: IExpressionSyntax,
                  semicolonToken: ISyntaxToken): ExpressionStatementSyntax {
        if (this.expression === expression && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ExpressionStatementSyntax(expression, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): ExpressionStatementSyntax {
        return new ExpressionStatementSyntax(expression, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ExpressionStatementSyntax {
        return <ExpressionStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ExpressionStatementSyntax {
        return <ExpressionStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withExpression(expression: IExpressionSyntax): ExpressionStatementSyntax {
        return this.update(expression, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ExpressionStatementSyntax {
        return this.update(this.expression, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ConstructorDeclarationSyntax extends SyntaxNode implements IClassElementSyntax {

    constructor(public constructorKeyword: ISyntaxToken,
                public parameterList: ParameterListSyntax,
                public block: BlockSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitConstructorDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ConstructorDeclaration;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.constructorKeyword;
            case 1: return this.parameterList;
            case 2: return this.block;
            case 3: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isClassElement(): bool {
        return true;
    }

    public update(constructorKeyword: ISyntaxToken,
                  parameterList: ParameterListSyntax,
                  block: BlockSyntax,
                  semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax {
        if (this.constructorKeyword === constructorKeyword && this.parameterList === parameterList && this.block === block && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(constructorKeyword: ISyntaxToken,
                         parameterList: ParameterListSyntax): ConstructorDeclarationSyntax {
        return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ConstructorDeclarationSyntax {
        return new ConstructorDeclarationSyntax(Syntax.token(SyntaxKind.ConstructorKeyword), ParameterListSyntax.create1(), null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ConstructorDeclarationSyntax {
        return <ConstructorDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ConstructorDeclarationSyntax {
        return <ConstructorDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withConstructorKeyword(constructorKeyword: ISyntaxToken): ConstructorDeclarationSyntax {
        return this.update(constructorKeyword, this.parameterList, this.block, this.semicolonToken);
    }

    public withParameterList(parameterList: ParameterListSyntax): ConstructorDeclarationSyntax {
        return this.update(this.constructorKeyword, parameterList, this.block, this.semicolonToken);
    }

    public withBlock(block: BlockSyntax): ConstructorDeclarationSyntax {
        return this.update(this.constructorKeyword, this.parameterList, block, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ConstructorDeclarationSyntax {
        return this.update(this.constructorKeyword, this.parameterList, this.block, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class MemberFunctionDeclarationSyntax extends SyntaxNode implements IMemberDeclarationSyntax {

    constructor(public publicOrPrivateKeyword: ISyntaxToken,
                public staticKeyword: ISyntaxToken,
                public propertyName: ISyntaxToken,
                public callSignature: CallSignatureSyntax,
                public block: BlockSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitMemberFunctionDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.MemberFunctionDeclaration;
    }

    public childCount(): number {
        return 6;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.publicOrPrivateKeyword;
            case 1: return this.staticKeyword;
            case 2: return this.propertyName;
            case 3: return this.callSignature;
            case 4: return this.block;
            case 5: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isMemberDeclaration(): bool {
        return true;
    }

    private isClassElement(): bool {
        return true;
    }

    public update(publicOrPrivateKeyword: ISyntaxToken,
                  staticKeyword: ISyntaxToken,
                  propertyName: ISyntaxToken,
                  callSignature: CallSignatureSyntax,
                  block: BlockSyntax,
                  semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.propertyName === propertyName && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new MemberFunctionDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, propertyName, callSignature, block, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(propertyName: ISyntaxToken,
                         callSignature: CallSignatureSyntax): MemberFunctionDeclarationSyntax {
        return new MemberFunctionDeclarationSyntax(null, null, propertyName, callSignature, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(propertyName: ISyntaxToken): MemberFunctionDeclarationSyntax {
        return new MemberFunctionDeclarationSyntax(null, null, propertyName, CallSignatureSyntax.create1(), null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): MemberFunctionDeclarationSyntax {
        return <MemberFunctionDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): MemberFunctionDeclarationSyntax {
        return <MemberFunctionDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withPublicOrPrivateKeyword(publicOrPrivateKeyword: ISyntaxToken): MemberFunctionDeclarationSyntax {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.propertyName, this.callSignature, this.block, this.semicolonToken);
    }

    public withStaticKeyword(staticKeyword: ISyntaxToken): MemberFunctionDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.propertyName, this.callSignature, this.block, this.semicolonToken);
    }

    public withPropertyName(propertyName: ISyntaxToken): MemberFunctionDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, propertyName, this.callSignature, this.block, this.semicolonToken);
    }

    public withCallSignature(callSignature: CallSignatureSyntax): MemberFunctionDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.propertyName, callSignature, this.block, this.semicolonToken);
    }

    public withBlock(block: BlockSyntax): MemberFunctionDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.propertyName, this.callSignature, block, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): MemberFunctionDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.propertyName, this.callSignature, this.block, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class MemberAccessorDeclarationSyntax extends SyntaxNode implements IMemberDeclarationSyntax {
    constructor(public publicOrPrivateKeyword: ISyntaxToken,
                public staticKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public parameterList: ParameterListSyntax,
                public block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    private isMemberDeclaration(): bool {
        return true;
    }

    private isClassElement(): bool {
        return true;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): MemberAccessorDeclarationSyntax {
        return <MemberAccessorDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): MemberAccessorDeclarationSyntax {
        return <MemberAccessorDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class GetMemberAccessorDeclarationSyntax extends MemberAccessorDeclarationSyntax {

    constructor(publicOrPrivateKeyword: ISyntaxToken,
                staticKeyword: ISyntaxToken,
                public getKeyword: ISyntaxToken,
                identifier: ISyntaxToken,
                parameterList: ParameterListSyntax,
                public typeAnnotation: TypeAnnotationSyntax,
                block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(publicOrPrivateKeyword, staticKeyword, identifier, parameterList, block, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitGetMemberAccessorDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.GetMemberAccessorDeclaration;
    }

    public childCount(): number {
        return 7;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.publicOrPrivateKeyword;
            case 1: return this.staticKeyword;
            case 2: return this.getKeyword;
            case 3: return this.identifier;
            case 4: return this.parameterList;
            case 5: return this.typeAnnotation;
            case 6: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(publicOrPrivateKeyword: ISyntaxToken,
                  staticKeyword: ISyntaxToken,
                  getKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  parameterList: ParameterListSyntax,
                  typeAnnotation: TypeAnnotationSyntax,
                  block: BlockSyntax): GetMemberAccessorDeclarationSyntax {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.getKeyword === getKeyword && this.identifier === identifier && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation && this.block === block) {
            return this;
        }

        return new GetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(getKeyword: ISyntaxToken,
                         identifier: ISyntaxToken,
                         parameterList: ParameterListSyntax,
                         block: BlockSyntax): GetMemberAccessorDeclarationSyntax {
        return new GetMemberAccessorDeclarationSyntax(null, null, getKeyword, identifier, parameterList, null, block, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
        return new GetMemberAccessorDeclarationSyntax(null, null, Syntax.token(SyntaxKind.GetKeyword), identifier, ParameterListSyntax.create1(), null, BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): GetMemberAccessorDeclarationSyntax {
        return <GetMemberAccessorDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): GetMemberAccessorDeclarationSyntax {
        return <GetMemberAccessorDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withPublicOrPrivateKeyword(publicOrPrivateKeyword: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, this.parameterList, this.typeAnnotation, this.block);
    }

    public withStaticKeyword(staticKeyword: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.getKeyword, this.identifier, this.parameterList, this.typeAnnotation, this.block);
    }

    public withGetKeyword(getKeyword: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, getKeyword, this.identifier, this.parameterList, this.typeAnnotation, this.block);
    }

    public withIdentifier(identifier: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, identifier, this.parameterList, this.typeAnnotation, this.block);
    }

    public withParameterList(parameterList: ParameterListSyntax): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, parameterList, this.typeAnnotation, this.block);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, this.parameterList, typeAnnotation, this.block);
    }

    public withBlock(block: BlockSyntax): GetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.getKeyword, this.identifier, this.parameterList, this.typeAnnotation, block);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class SetMemberAccessorDeclarationSyntax extends MemberAccessorDeclarationSyntax {

    constructor(publicOrPrivateKeyword: ISyntaxToken,
                staticKeyword: ISyntaxToken,
                public setKeyword: ISyntaxToken,
                identifier: ISyntaxToken,
                parameterList: ParameterListSyntax,
                block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(publicOrPrivateKeyword, staticKeyword, identifier, parameterList, block, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSetMemberAccessorDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SetMemberAccessorDeclaration;
    }

    public childCount(): number {
        return 6;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.publicOrPrivateKeyword;
            case 1: return this.staticKeyword;
            case 2: return this.setKeyword;
            case 3: return this.identifier;
            case 4: return this.parameterList;
            case 5: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(publicOrPrivateKeyword: ISyntaxToken,
                  staticKeyword: ISyntaxToken,
                  setKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  parameterList: ParameterListSyntax,
                  block: BlockSyntax): SetMemberAccessorDeclarationSyntax {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.setKeyword === setKeyword && this.identifier === identifier && this.parameterList === parameterList && this.block === block) {
            return this;
        }

        return new SetMemberAccessorDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(setKeyword: ISyntaxToken,
                         identifier: ISyntaxToken,
                         parameterList: ParameterListSyntax,
                         block: BlockSyntax): SetMemberAccessorDeclarationSyntax {
        return new SetMemberAccessorDeclarationSyntax(null, null, setKeyword, identifier, parameterList, block, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
        return new SetMemberAccessorDeclarationSyntax(null, null, Syntax.token(SyntaxKind.SetKeyword), identifier, ParameterListSyntax.create1(), BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SetMemberAccessorDeclarationSyntax {
        return <SetMemberAccessorDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SetMemberAccessorDeclarationSyntax {
        return <SetMemberAccessorDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withPublicOrPrivateKeyword(publicOrPrivateKeyword: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, this.identifier, this.parameterList, this.block);
    }

    public withStaticKeyword(staticKeyword: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.setKeyword, this.identifier, this.parameterList, this.block);
    }

    public withSetKeyword(setKeyword: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, setKeyword, this.identifier, this.parameterList, this.block);
    }

    public withIdentifier(identifier: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, identifier, this.parameterList, this.block);
    }

    public withParameterList(parameterList: ParameterListSyntax): SetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, this.identifier, parameterList, this.block);
    }

    public withBlock(block: BlockSyntax): SetMemberAccessorDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.setKeyword, this.identifier, this.parameterList, block);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class MemberVariableDeclarationSyntax extends SyntaxNode implements IMemberDeclarationSyntax {

    constructor(public publicOrPrivateKeyword: ISyntaxToken,
                public staticKeyword: ISyntaxToken,
                public variableDeclarator: VariableDeclaratorSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitMemberVariableDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.MemberVariableDeclaration;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.publicOrPrivateKeyword;
            case 1: return this.staticKeyword;
            case 2: return this.variableDeclarator;
            case 3: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isMemberDeclaration(): bool {
        return true;
    }

    private isClassElement(): bool {
        return true;
    }

    public update(publicOrPrivateKeyword: ISyntaxToken,
                  staticKeyword: ISyntaxToken,
                  variableDeclarator: VariableDeclaratorSyntax,
                  semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax {
        if (this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.staticKeyword === staticKeyword && this.variableDeclarator === variableDeclarator && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new MemberVariableDeclarationSyntax(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(variableDeclarator: VariableDeclaratorSyntax,
                         semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax {
        return new MemberVariableDeclarationSyntax(null, null, variableDeclarator, semicolonToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(variableDeclarator: VariableDeclaratorSyntax): MemberVariableDeclarationSyntax {
        return new MemberVariableDeclarationSyntax(null, null, variableDeclarator, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): MemberVariableDeclarationSyntax {
        return <MemberVariableDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): MemberVariableDeclarationSyntax {
        return <MemberVariableDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withPublicOrPrivateKeyword(publicOrPrivateKeyword: ISyntaxToken): MemberVariableDeclarationSyntax {
        return this.update(publicOrPrivateKeyword, this.staticKeyword, this.variableDeclarator, this.semicolonToken);
    }

    public withStaticKeyword(staticKeyword: ISyntaxToken): MemberVariableDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, staticKeyword, this.variableDeclarator, this.semicolonToken);
    }

    public withVariableDeclarator(variableDeclarator: VariableDeclaratorSyntax): MemberVariableDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, variableDeclarator, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): MemberVariableDeclarationSyntax {
        return this.update(this.publicOrPrivateKeyword, this.staticKeyword, this.variableDeclarator, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ThrowStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public throwKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitThrowStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ThrowStatement;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.throwKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(throwKeyword: ISyntaxToken,
                  expression: IExpressionSyntax,
                  semicolonToken: ISyntaxToken): ThrowStatementSyntax {
        if (this.throwKeyword === throwKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): ThrowStatementSyntax {
        return new ThrowStatementSyntax(Syntax.token(SyntaxKind.ThrowKeyword), expression, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ThrowStatementSyntax {
        return <ThrowStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ThrowStatementSyntax {
        return <ThrowStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withThrowKeyword(throwKeyword: ISyntaxToken): ThrowStatementSyntax {
        return this.update(throwKeyword, this.expression, this.semicolonToken);
    }

    public withExpression(expression: IExpressionSyntax): ThrowStatementSyntax {
        return this.update(this.throwKeyword, expression, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ThrowStatementSyntax {
        return this.update(this.throwKeyword, this.expression, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ReturnStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public returnKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitReturnStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ReturnStatement;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.returnKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(returnKeyword: ISyntaxToken,
                  expression: IExpressionSyntax,
                  semicolonToken: ISyntaxToken): ReturnStatementSyntax {
        if (this.returnKeyword === returnKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(returnKeyword: ISyntaxToken,
                         semicolonToken: ISyntaxToken): ReturnStatementSyntax {
        return new ReturnStatementSyntax(returnKeyword, null, semicolonToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ReturnStatementSyntax {
        return new ReturnStatementSyntax(Syntax.token(SyntaxKind.ReturnKeyword), null, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ReturnStatementSyntax {
        return <ReturnStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ReturnStatementSyntax {
        return <ReturnStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withReturnKeyword(returnKeyword: ISyntaxToken): ReturnStatementSyntax {
        return this.update(returnKeyword, this.expression, this.semicolonToken);
    }

    public withExpression(expression: IExpressionSyntax): ReturnStatementSyntax {
        return this.update(this.returnKeyword, expression, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ReturnStatementSyntax {
        return this.update(this.returnKeyword, this.expression, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression !== null && this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ObjectCreationExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public newKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                public argumentList: ArgumentListSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitObjectCreationExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ObjectCreationExpression;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.newKeyword;
            case 1: return this.expression;
            case 2: return this.argumentList;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(newKeyword: ISyntaxToken,
                  expression: IExpressionSyntax,
                  argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax {
        if (this.newKeyword === newKeyword && this.expression === expression && this.argumentList === argumentList) {
            return this;
        }

        return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(newKeyword: ISyntaxToken,
                         expression: IExpressionSyntax): ObjectCreationExpressionSyntax {
        return new ObjectCreationExpressionSyntax(newKeyword, expression, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(expression: IExpressionSyntax): ObjectCreationExpressionSyntax {
        return new ObjectCreationExpressionSyntax(Syntax.token(SyntaxKind.NewKeyword), expression, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ObjectCreationExpressionSyntax {
        return <ObjectCreationExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ObjectCreationExpressionSyntax {
        return <ObjectCreationExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withNewKeyword(newKeyword: ISyntaxToken): ObjectCreationExpressionSyntax {
        return this.update(newKeyword, this.expression, this.argumentList);
    }

    public withExpression(expression: IExpressionSyntax): ObjectCreationExpressionSyntax {
        return this.update(this.newKeyword, expression, this.argumentList);
    }

    public withArgumentList(argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax {
        return this.update(this.newKeyword, this.expression, argumentList);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.argumentList !== null && this.argumentList.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class SwitchStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public switchKeyword: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public expression: IExpressionSyntax,
                public closeParenToken: ISyntaxToken,
                public openBraceToken: ISyntaxToken,
                public switchClauses: ISyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSwitchStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SwitchStatement;
    }

    public childCount(): number {
        return 7;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.switchKeyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            case 4: return this.openBraceToken;
            case 5: return this.switchClauses;
            case 6: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(switchKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  expression: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  openBraceToken: ISyntaxToken,
                  switchClauses: ISyntaxList,
                  closeBraceToken: ISyntaxToken): SwitchStatementSyntax {
        if (this.switchKeyword === switchKeyword && this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken && this.openBraceToken === openBraceToken && this.switchClauses === switchClauses && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(switchKeyword: ISyntaxToken,
                         openParenToken: ISyntaxToken,
                         expression: IExpressionSyntax,
                         closeParenToken: ISyntaxToken,
                         openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): SwitchStatementSyntax {
        return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, Syntax.emptyList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(expression: IExpressionSyntax): SwitchStatementSyntax {
        return new SwitchStatementSyntax(Syntax.token(SyntaxKind.SwitchKeyword), Syntax.token(SyntaxKind.OpenParenToken), expression, Syntax.token(SyntaxKind.CloseParenToken), Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptyList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SwitchStatementSyntax {
        return <SwitchStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SwitchStatementSyntax {
        return <SwitchStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withSwitchKeyword(switchKeyword: ISyntaxToken): SwitchStatementSyntax {
        return this.update(switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): SwitchStatementSyntax {
        return this.update(this.switchKeyword, openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    }

    public withExpression(expression: IExpressionSyntax): SwitchStatementSyntax {
        return this.update(this.switchKeyword, this.openParenToken, expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): SwitchStatementSyntax {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): SwitchStatementSyntax {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, openBraceToken, this.switchClauses, this.closeBraceToken);
    }

    public withSwitchClauses(switchClauses: ISyntaxList): SwitchStatementSyntax {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, switchClauses, this.closeBraceToken);
    }

    public withSwitchClause(switchClause: SwitchClauseSyntax): SwitchStatementSyntax {
        return this.withSwitchClauses(Syntax.list([switchClause]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): SwitchStatementSyntax {
        return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, closeBraceToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.switchClauses.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class SwitchClauseSyntax extends SyntaxNode implements ISwitchClauseSyntax {
    constructor(public colonToken: ISyntaxToken,
                public statements: ISyntaxList,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    private isSwitchClause(): bool {
        return true;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SwitchClauseSyntax {
        return <SwitchClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SwitchClauseSyntax {
        return <SwitchClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public isTypeScriptSpecific(): bool {
        return false;
    }
    }

    export class CaseSwitchClauseSyntax extends SwitchClauseSyntax {

    constructor(public caseKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                colonToken: ISyntaxToken,
                statements: ISyntaxList,
                parsedInStrictMode: bool) {
        super(colonToken, statements, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitCaseSwitchClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.CaseSwitchClause;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.caseKeyword;
            case 1: return this.expression;
            case 2: return this.colonToken;
            case 3: return this.statements;
            default: throw Errors.invalidOperation();
        }
    }

    public update(caseKeyword: ISyntaxToken,
                  expression: IExpressionSyntax,
                  colonToken: ISyntaxToken,
                  statements: ISyntaxList): CaseSwitchClauseSyntax {
        if (this.caseKeyword === caseKeyword && this.expression === expression && this.colonToken === colonToken && this.statements === statements) {
            return this;
        }

        return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(caseKeyword: ISyntaxToken,
                         expression: IExpressionSyntax,
                         colonToken: ISyntaxToken): CaseSwitchClauseSyntax {
        return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, Syntax.emptyList, /*parsedInStrictMode:*/ false);
    }

    public static create1(expression: IExpressionSyntax): CaseSwitchClauseSyntax {
        return new CaseSwitchClauseSyntax(Syntax.token(SyntaxKind.CaseKeyword), expression, Syntax.token(SyntaxKind.ColonToken), Syntax.emptyList, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): CaseSwitchClauseSyntax {
        return <CaseSwitchClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): CaseSwitchClauseSyntax {
        return <CaseSwitchClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withCaseKeyword(caseKeyword: ISyntaxToken): CaseSwitchClauseSyntax {
        return this.update(caseKeyword, this.expression, this.colonToken, this.statements);
    }

    public withExpression(expression: IExpressionSyntax): CaseSwitchClauseSyntax {
        return this.update(this.caseKeyword, expression, this.colonToken, this.statements);
    }

    public withColonToken(colonToken: ISyntaxToken): CaseSwitchClauseSyntax {
        return this.update(this.caseKeyword, this.expression, colonToken, this.statements);
    }

    public withStatements(statements: ISyntaxList): CaseSwitchClauseSyntax {
        return this.update(this.caseKeyword, this.expression, this.colonToken, statements);
    }

    public withStatement(statement: IStatementSyntax): CaseSwitchClauseSyntax {
        return this.withStatements(Syntax.list([statement]));
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.statements.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class DefaultSwitchClauseSyntax extends SwitchClauseSyntax {

    constructor(public defaultKeyword: ISyntaxToken,
                colonToken: ISyntaxToken,
                statements: ISyntaxList,
                parsedInStrictMode: bool) {
        super(colonToken, statements, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitDefaultSwitchClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.DefaultSwitchClause;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.defaultKeyword;
            case 1: return this.colonToken;
            case 2: return this.statements;
            default: throw Errors.invalidOperation();
        }
    }

    public update(defaultKeyword: ISyntaxToken,
                  colonToken: ISyntaxToken,
                  statements: ISyntaxList): DefaultSwitchClauseSyntax {
        if (this.defaultKeyword === defaultKeyword && this.colonToken === colonToken && this.statements === statements) {
            return this;
        }

        return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(defaultKeyword: ISyntaxToken,
                         colonToken: ISyntaxToken): DefaultSwitchClauseSyntax {
        return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, Syntax.emptyList, /*parsedInStrictMode:*/ false);
    }

    public static create1(): DefaultSwitchClauseSyntax {
        return new DefaultSwitchClauseSyntax(Syntax.token(SyntaxKind.DefaultKeyword), Syntax.token(SyntaxKind.ColonToken), Syntax.emptyList, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): DefaultSwitchClauseSyntax {
        return <DefaultSwitchClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): DefaultSwitchClauseSyntax {
        return <DefaultSwitchClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withDefaultKeyword(defaultKeyword: ISyntaxToken): DefaultSwitchClauseSyntax {
        return this.update(defaultKeyword, this.colonToken, this.statements);
    }

    public withColonToken(colonToken: ISyntaxToken): DefaultSwitchClauseSyntax {
        return this.update(this.defaultKeyword, colonToken, this.statements);
    }

    public withStatements(statements: ISyntaxList): DefaultSwitchClauseSyntax {
        return this.update(this.defaultKeyword, this.colonToken, statements);
    }

    public withStatement(statement: IStatementSyntax): DefaultSwitchClauseSyntax {
        return this.withStatements(Syntax.list([statement]));
    }

    public isTypeScriptSpecific(): bool {
        if (this.statements.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class BreakStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public breakKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitBreakStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.BreakStatement;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.breakKeyword;
            case 1: return this.identifier;
            case 2: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(breakKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  semicolonToken: ISyntaxToken): BreakStatementSyntax {
        if (this.breakKeyword === breakKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(breakKeyword: ISyntaxToken,
                         semicolonToken: ISyntaxToken): BreakStatementSyntax {
        return new BreakStatementSyntax(breakKeyword, null, semicolonToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): BreakStatementSyntax {
        return new BreakStatementSyntax(Syntax.token(SyntaxKind.BreakKeyword), null, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): BreakStatementSyntax {
        return <BreakStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): BreakStatementSyntax {
        return <BreakStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withBreakKeyword(breakKeyword: ISyntaxToken): BreakStatementSyntax {
        return this.update(breakKeyword, this.identifier, this.semicolonToken);
    }

    public withIdentifier(identifier: ISyntaxToken): BreakStatementSyntax {
        return this.update(this.breakKeyword, identifier, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): BreakStatementSyntax {
        return this.update(this.breakKeyword, this.identifier, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        return false;
    }
    }

    export class ContinueStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public continueKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitContinueStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ContinueStatement;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.continueKeyword;
            case 1: return this.identifier;
            case 2: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(continueKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  semicolonToken: ISyntaxToken): ContinueStatementSyntax {
        if (this.continueKeyword === continueKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(continueKeyword: ISyntaxToken,
                         semicolonToken: ISyntaxToken): ContinueStatementSyntax {
        return new ContinueStatementSyntax(continueKeyword, null, semicolonToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ContinueStatementSyntax {
        return new ContinueStatementSyntax(Syntax.token(SyntaxKind.ContinueKeyword), null, Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ContinueStatementSyntax {
        return <ContinueStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ContinueStatementSyntax {
        return <ContinueStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withContinueKeyword(continueKeyword: ISyntaxToken): ContinueStatementSyntax {
        return this.update(continueKeyword, this.identifier, this.semicolonToken);
    }

    public withIdentifier(identifier: ISyntaxToken): ContinueStatementSyntax {
        return this.update(this.continueKeyword, identifier, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): ContinueStatementSyntax {
        return this.update(this.continueKeyword, this.identifier, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        return false;
    }
    }

    export class IterationStatementSyntax extends SyntaxNode implements IStatementSyntax {
    constructor(public openParenToken: ISyntaxToken,
                public closeParenToken: ISyntaxToken,
                public statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): IterationStatementSyntax {
        return <IterationStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): IterationStatementSyntax {
        return <IterationStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public isTypeScriptSpecific(): bool {
        return false;
    }
    }

    export class BaseForStatementSyntax extends IterationStatementSyntax {
    constructor(public forKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                public variableDeclaration: VariableDeclarationSyntax,
                closeParenToken: ISyntaxToken,
                statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(openParenToken, closeParenToken, statement, parsedInStrictMode); 
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): BaseForStatementSyntax {
        return <BaseForStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): BaseForStatementSyntax {
        return <BaseForStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public isTypeScriptSpecific(): bool {
        return false;
    }
    }

    export class ForStatementSyntax extends BaseForStatementSyntax {

    constructor(forKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                variableDeclaration: VariableDeclarationSyntax,
                public initializer: IExpressionSyntax,
                public firstSemicolonToken: ISyntaxToken,
                public condition: IExpressionSyntax,
                public secondSemicolonToken: ISyntaxToken,
                public incrementor: IExpressionSyntax,
                closeParenToken: ISyntaxToken,
                statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitForStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ForStatement;
    }

    public childCount(): number {
        return 10;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.forKeyword;
            case 1: return this.openParenToken;
            case 2: return this.variableDeclaration;
            case 3: return this.initializer;
            case 4: return this.firstSemicolonToken;
            case 5: return this.condition;
            case 6: return this.secondSemicolonToken;
            case 7: return this.incrementor;
            case 8: return this.closeParenToken;
            case 9: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    public update(forKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  variableDeclaration: VariableDeclarationSyntax,
                  initializer: IExpressionSyntax,
                  firstSemicolonToken: ISyntaxToken,
                  condition: IExpressionSyntax,
                  secondSemicolonToken: ISyntaxToken,
                  incrementor: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  statement: IStatementSyntax): ForStatementSyntax {
        if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.initializer === initializer && this.firstSemicolonToken === firstSemicolonToken && this.condition === condition && this.secondSemicolonToken === secondSemicolonToken && this.incrementor === incrementor && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }

        return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(forKeyword: ISyntaxToken,
                         openParenToken: ISyntaxToken,
                         firstSemicolonToken: ISyntaxToken,
                         secondSemicolonToken: ISyntaxToken,
                         closeParenToken: ISyntaxToken,
                         statement: IStatementSyntax): ForStatementSyntax {
        return new ForStatementSyntax(forKeyword, openParenToken, null, null, firstSemicolonToken, null, secondSemicolonToken, null, closeParenToken, statement, /*parsedInStrictMode:*/ false);
    }

    public static create1(statement: IStatementSyntax): ForStatementSyntax {
        return new ForStatementSyntax(Syntax.token(SyntaxKind.ForKeyword), Syntax.token(SyntaxKind.OpenParenToken), null, null, Syntax.token(SyntaxKind.SemicolonToken), null, Syntax.token(SyntaxKind.SemicolonToken), null, Syntax.token(SyntaxKind.CloseParenToken), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ForStatementSyntax {
        return <ForStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ForStatementSyntax {
        return <ForStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withForKeyword(forKeyword: ISyntaxToken): ForStatementSyntax {
        return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ForStatementSyntax {
        return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withInitializer(initializer: IExpressionSyntax): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withFirstSemicolonToken(firstSemicolonToken: ISyntaxToken): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withCondition(condition: IExpressionSyntax): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withSecondSemicolonToken(secondSemicolonToken: ISyntaxToken): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
    }

    public withIncrementor(incrementor: IExpressionSyntax): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, incrementor, this.closeParenToken, this.statement);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, closeParenToken, this.statement);
    }

    public withStatement(statement: IStatementSyntax): ForStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, statement);
    }

    public isTypeScriptSpecific(): bool {
        if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) { return true; }
        if (this.initializer !== null && this.initializer.isTypeScriptSpecific()) { return true; }
        if (this.condition !== null && this.condition.isTypeScriptSpecific()) { return true; }
        if (this.incrementor !== null && this.incrementor.isTypeScriptSpecific()) { return true; }
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class ForInStatementSyntax extends BaseForStatementSyntax {

    constructor(forKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                variableDeclaration: VariableDeclarationSyntax,
                public left: IExpressionSyntax,
                public inKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                closeParenToken: ISyntaxToken,
                statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitForInStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ForInStatement;
    }

    public childCount(): number {
        return 8;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.forKeyword;
            case 1: return this.openParenToken;
            case 2: return this.variableDeclaration;
            case 3: return this.left;
            case 4: return this.inKeyword;
            case 5: return this.expression;
            case 6: return this.closeParenToken;
            case 7: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    public update(forKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  variableDeclaration: VariableDeclarationSyntax,
                  left: IExpressionSyntax,
                  inKeyword: ISyntaxToken,
                  expression: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  statement: IStatementSyntax): ForInStatementSyntax {
        if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.left === left && this.inKeyword === inKeyword && this.expression === expression && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }

        return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(forKeyword: ISyntaxToken,
                         openParenToken: ISyntaxToken,
                         inKeyword: ISyntaxToken,
                         expression: IExpressionSyntax,
                         closeParenToken: ISyntaxToken,
                         statement: IStatementSyntax): ForInStatementSyntax {
        return new ForInStatementSyntax(forKeyword, openParenToken, null, null, inKeyword, expression, closeParenToken, statement, /*parsedInStrictMode:*/ false);
    }

    public static create1(expression: IExpressionSyntax,
                          statement: IStatementSyntax): ForInStatementSyntax {
        return new ForInStatementSyntax(Syntax.token(SyntaxKind.ForKeyword), Syntax.token(SyntaxKind.OpenParenToken), null, null, Syntax.token(SyntaxKind.InKeyword), expression, Syntax.token(SyntaxKind.CloseParenToken), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ForInStatementSyntax {
        return <ForInStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ForInStatementSyntax {
        return <ForInStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withForKeyword(forKeyword: ISyntaxToken): ForInStatementSyntax {
        return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): ForInStatementSyntax {
        return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    }

    public withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    }

    public withLeft(left: IExpressionSyntax): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
    }

    public withInKeyword(inKeyword: ISyntaxToken): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, inKeyword, this.expression, this.closeParenToken, this.statement);
    }

    public withExpression(expression: IExpressionSyntax): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, expression, this.closeParenToken, this.statement);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, closeParenToken, this.statement);
    }

    public withStatement(statement: IStatementSyntax): ForInStatementSyntax {
        return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, statement);
    }

    public isTypeScriptSpecific(): bool {
        if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) { return true; }
        if (this.left !== null && this.left.isTypeScriptSpecific()) { return true; }
        if (this.expression.isTypeScriptSpecific()) { return true; }
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class WhileStatementSyntax extends IterationStatementSyntax {

    constructor(public whileKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                public condition: IExpressionSyntax,
                closeParenToken: ISyntaxToken,
                statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(openParenToken, closeParenToken, statement, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitWhileStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.WhileStatement;
    }

    public childCount(): number {
        return 5;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.whileKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    public update(whileKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  condition: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  statement: IStatementSyntax): WhileStatementSyntax {
        if (this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }

        return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(condition: IExpressionSyntax,
                          statement: IStatementSyntax): WhileStatementSyntax {
        return new WhileStatementSyntax(Syntax.token(SyntaxKind.WhileKeyword), Syntax.token(SyntaxKind.OpenParenToken), condition, Syntax.token(SyntaxKind.CloseParenToken), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): WhileStatementSyntax {
        return <WhileStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): WhileStatementSyntax {
        return <WhileStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withWhileKeyword(whileKeyword: ISyntaxToken): WhileStatementSyntax {
        return this.update(whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): WhileStatementSyntax {
        return this.update(this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
    }

    public withCondition(condition: IExpressionSyntax): WhileStatementSyntax {
        return this.update(this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): WhileStatementSyntax {
        return this.update(this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
    }

    public withStatement(statement: IStatementSyntax): WhileStatementSyntax {
        return this.update(this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
    }

    public isTypeScriptSpecific(): bool {
        if (this.condition.isTypeScriptSpecific()) { return true; }
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class WithStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public withKeyword: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public condition: IExpressionSyntax,
                public closeParenToken: ISyntaxToken,
                public statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitWithStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.WithStatement;
    }

    public childCount(): number {
        return 5;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.withKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(withKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  condition: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  statement: IStatementSyntax): WithStatementSyntax {
        if (this.withKeyword === withKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
            return this;
        }

        return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(condition: IExpressionSyntax,
                          statement: IStatementSyntax): WithStatementSyntax {
        return new WithStatementSyntax(Syntax.token(SyntaxKind.WithKeyword), Syntax.token(SyntaxKind.OpenParenToken), condition, Syntax.token(SyntaxKind.CloseParenToken), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): WithStatementSyntax {
        return <WithStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): WithStatementSyntax {
        return <WithStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withWithKeyword(withKeyword: ISyntaxToken): WithStatementSyntax {
        return this.update(withKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): WithStatementSyntax {
        return this.update(this.withKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
    }

    public withCondition(condition: IExpressionSyntax): WithStatementSyntax {
        return this.update(this.withKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): WithStatementSyntax {
        return this.update(this.withKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
    }

    public withStatement(statement: IStatementSyntax): WithStatementSyntax {
        return this.update(this.withKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
    }

    public isTypeScriptSpecific(): bool {
        if (this.condition.isTypeScriptSpecific()) { return true; }
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class EnumDeclarationSyntax extends SyntaxNode implements IModuleElementSyntax {

    constructor(public exportKeyword: ISyntaxToken,
                public enumKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public openBraceToken: ISyntaxToken,
                public enumElements: ISeparatedSyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitEnumDeclaration(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.EnumDeclaration;
    }

    public childCount(): number {
        return 6;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.exportKeyword;
            case 1: return this.enumKeyword;
            case 2: return this.identifier;
            case 3: return this.openBraceToken;
            case 4: return this.enumElements;
            case 5: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(exportKeyword: ISyntaxToken,
                  enumKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  openBraceToken: ISyntaxToken,
                  enumElements: ISeparatedSyntaxList,
                  closeBraceToken: ISyntaxToken): EnumDeclarationSyntax {
        if (this.exportKeyword === exportKeyword && this.enumKeyword === enumKeyword && this.identifier === identifier && this.openBraceToken === openBraceToken && this.enumElements === enumElements && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new EnumDeclarationSyntax(exportKeyword, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(enumKeyword: ISyntaxToken,
                         identifier: ISyntaxToken,
                         openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): EnumDeclarationSyntax {
        return new EnumDeclarationSyntax(null, enumKeyword, identifier, openBraceToken, Syntax.emptySeparatedList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): EnumDeclarationSyntax {
        return new EnumDeclarationSyntax(null, Syntax.token(SyntaxKind.EnumKeyword), identifier, Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): EnumDeclarationSyntax {
        return <EnumDeclarationSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): EnumDeclarationSyntax {
        return <EnumDeclarationSyntax>super.withTrailingTrivia(trivia);
    }

    public withExportKeyword(exportKeyword: ISyntaxToken): EnumDeclarationSyntax {
        return this.update(exportKeyword, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
    }

    public withEnumKeyword(enumKeyword: ISyntaxToken): EnumDeclarationSyntax {
        return this.update(this.exportKeyword, enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
    }

    public withIdentifier(identifier: ISyntaxToken): EnumDeclarationSyntax {
        return this.update(this.exportKeyword, this.enumKeyword, identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): EnumDeclarationSyntax {
        return this.update(this.exportKeyword, this.enumKeyword, this.identifier, openBraceToken, this.enumElements, this.closeBraceToken);
    }

    public withEnumElements(enumElements: ISeparatedSyntaxList): EnumDeclarationSyntax {
        return this.update(this.exportKeyword, this.enumKeyword, this.identifier, this.openBraceToken, enumElements, this.closeBraceToken);
    }

    public withEnumElement(enumElement: EnumElementSyntax): EnumDeclarationSyntax {
        return this.withEnumElements(Syntax.separatedList([enumElement]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): EnumDeclarationSyntax {
        return this.update(this.exportKeyword, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, closeBraceToken);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class EnumElementSyntax extends SyntaxNode {

    constructor(public identifier: ISyntaxToken,
                public stringLiteral: ISyntaxToken,
                public equalsValueClause: EqualsValueClauseSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitEnumElement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.EnumElement;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.identifier;
            case 1: return this.stringLiteral;
            case 2: return this.equalsValueClause;
            default: throw Errors.invalidOperation();
        }
    }

    public update(identifier: ISyntaxToken,
                  stringLiteral: ISyntaxToken,
                  equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax {
        if (this.identifier === identifier && this.stringLiteral === stringLiteral && this.equalsValueClause === equalsValueClause) {
            return this;
        }

        return new EnumElementSyntax(identifier, stringLiteral, equalsValueClause, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(): EnumElementSyntax {
        return new EnumElementSyntax(null, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(): EnumElementSyntax {
        return new EnumElementSyntax(null, null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): EnumElementSyntax {
        return <EnumElementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): EnumElementSyntax {
        return <EnumElementSyntax>super.withTrailingTrivia(trivia);
    }

    public withIdentifier(identifier: ISyntaxToken): EnumElementSyntax {
        return this.update(identifier, this.stringLiteral, this.equalsValueClause);
    }

    public withStringLiteral(stringLiteral: ISyntaxToken): EnumElementSyntax {
        return this.update(this.identifier, stringLiteral, this.equalsValueClause);
    }

    public withEqualsValueClause(equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax {
        return this.update(this.identifier, this.stringLiteral, equalsValueClause);
    }

    public isTypeScriptSpecific(): bool {
        if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class CastExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public lessThanToken: ISyntaxToken,
                public type: ITypeSyntax,
                public greaterThanToken: ISyntaxToken,
                public expression: IUnaryExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitCastExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.CastExpression;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.lessThanToken;
            case 1: return this.type;
            case 2: return this.greaterThanToken;
            case 3: return this.expression;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(lessThanToken: ISyntaxToken,
                  type: ITypeSyntax,
                  greaterThanToken: ISyntaxToken,
                  expression: IUnaryExpressionSyntax): CastExpressionSyntax {
        if (this.lessThanToken === lessThanToken && this.type === type && this.greaterThanToken === greaterThanToken && this.expression === expression) {
            return this;
        }

        return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(type: ITypeSyntax,
                          expression: IUnaryExpressionSyntax): CastExpressionSyntax {
        return new CastExpressionSyntax(Syntax.token(SyntaxKind.LessThanToken), type, Syntax.token(SyntaxKind.GreaterThanToken), expression, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): CastExpressionSyntax {
        return <CastExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): CastExpressionSyntax {
        return <CastExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withLessThanToken(lessThanToken: ISyntaxToken): CastExpressionSyntax {
        return this.update(lessThanToken, this.type, this.greaterThanToken, this.expression);
    }

    public withType(type: ITypeSyntax): CastExpressionSyntax {
        return this.update(this.lessThanToken, type, this.greaterThanToken, this.expression);
    }

    public withGreaterThanToken(greaterThanToken: ISyntaxToken): CastExpressionSyntax {
        return this.update(this.lessThanToken, this.type, greaterThanToken, this.expression);
    }

    public withExpression(expression: IUnaryExpressionSyntax): CastExpressionSyntax {
        return this.update(this.lessThanToken, this.type, this.greaterThanToken, expression);
    }

    public isTypeScriptSpecific(): bool {
        return true;
    }
    }

    export class ObjectLiteralExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public openBraceToken: ISyntaxToken,
                public propertyAssignments: ISeparatedSyntaxList,
                public closeBraceToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitObjectLiteralExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.ObjectLiteralExpression;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.openBraceToken;
            case 1: return this.propertyAssignments;
            case 2: return this.closeBraceToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(openBraceToken: ISyntaxToken,
                  propertyAssignments: ISeparatedSyntaxList,
                  closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
        if (this.openBraceToken === openBraceToken && this.propertyAssignments === propertyAssignments && this.closeBraceToken === closeBraceToken) {
            return this;
        }

        return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(openBraceToken: ISyntaxToken,
                         closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
        return new ObjectLiteralExpressionSyntax(openBraceToken, Syntax.emptySeparatedList, closeBraceToken, /*parsedInStrictMode:*/ false);
    }

    public static create1(): ObjectLiteralExpressionSyntax {
        return new ObjectLiteralExpressionSyntax(Syntax.token(SyntaxKind.OpenBraceToken), Syntax.emptySeparatedList, Syntax.token(SyntaxKind.CloseBraceToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): ObjectLiteralExpressionSyntax {
        return <ObjectLiteralExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): ObjectLiteralExpressionSyntax {
        return <ObjectLiteralExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withOpenBraceToken(openBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
        return this.update(openBraceToken, this.propertyAssignments, this.closeBraceToken);
    }

    public withPropertyAssignments(propertyAssignments: ISeparatedSyntaxList): ObjectLiteralExpressionSyntax {
        return this.update(this.openBraceToken, propertyAssignments, this.closeBraceToken);
    }

    public withPropertyAssignment(propertyAssignment: PropertyAssignmentSyntax): ObjectLiteralExpressionSyntax {
        return this.withPropertyAssignments(Syntax.separatedList([propertyAssignment]));
    }

    public withCloseBraceToken(closeBraceToken: ISyntaxToken): ObjectLiteralExpressionSyntax {
        return this.update(this.openBraceToken, this.propertyAssignments, closeBraceToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.propertyAssignments.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class PropertyAssignmentSyntax extends SyntaxNode {
    constructor(public propertyName: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): PropertyAssignmentSyntax {
        return <PropertyAssignmentSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): PropertyAssignmentSyntax {
        return <PropertyAssignmentSyntax>super.withTrailingTrivia(trivia);
    }

    public isTypeScriptSpecific(): bool {
        return false;
    }
    }

    export class SimplePropertyAssignmentSyntax extends PropertyAssignmentSyntax {

    constructor(propertyName: ISyntaxToken,
                public colonToken: ISyntaxToken,
                public expression: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(propertyName, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSimplePropertyAssignment(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SimplePropertyAssignment;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.propertyName;
            case 1: return this.colonToken;
            case 2: return this.expression;
            default: throw Errors.invalidOperation();
        }
    }

    public update(propertyName: ISyntaxToken,
                  colonToken: ISyntaxToken,
                  expression: IExpressionSyntax): SimplePropertyAssignmentSyntax {
        if (this.propertyName === propertyName && this.colonToken === colonToken && this.expression === expression) {
            return this;
        }

        return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(propertyName: ISyntaxToken,
                          expression: IExpressionSyntax): SimplePropertyAssignmentSyntax {
        return new SimplePropertyAssignmentSyntax(propertyName, Syntax.token(SyntaxKind.ColonToken), expression, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SimplePropertyAssignmentSyntax {
        return <SimplePropertyAssignmentSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SimplePropertyAssignmentSyntax {
        return <SimplePropertyAssignmentSyntax>super.withTrailingTrivia(trivia);
    }

    public withPropertyName(propertyName: ISyntaxToken): SimplePropertyAssignmentSyntax {
        return this.update(propertyName, this.colonToken, this.expression);
    }

    public withColonToken(colonToken: ISyntaxToken): SimplePropertyAssignmentSyntax {
        return this.update(this.propertyName, colonToken, this.expression);
    }

    public withExpression(expression: IExpressionSyntax): SimplePropertyAssignmentSyntax {
        return this.update(this.propertyName, this.colonToken, expression);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class AccessorPropertyAssignmentSyntax extends PropertyAssignmentSyntax {
    constructor(propertyName: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public closeParenToken: ISyntaxToken,
                public block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(propertyName, parsedInStrictMode); 
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): AccessorPropertyAssignmentSyntax {
        return <AccessorPropertyAssignmentSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): AccessorPropertyAssignmentSyntax {
        return <AccessorPropertyAssignmentSyntax>super.withTrailingTrivia(trivia);
    }

    public isTypeScriptSpecific(): bool {
        return false;
    }
    }

    export class GetAccessorPropertyAssignmentSyntax extends AccessorPropertyAssignmentSyntax {

    constructor(public getKeyword: ISyntaxToken,
                propertyName: ISyntaxToken,
                openParenToken: ISyntaxToken,
                closeParenToken: ISyntaxToken,
                public typeAnnotation: TypeAnnotationSyntax,
                block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(propertyName, openParenToken, closeParenToken, block, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitGetAccessorPropertyAssignment(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.GetAccessorPropertyAssignment;
    }

    public childCount(): number {
        return 6;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.getKeyword;
            case 1: return this.propertyName;
            case 2: return this.openParenToken;
            case 3: return this.closeParenToken;
            case 4: return this.typeAnnotation;
            case 5: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(getKeyword: ISyntaxToken,
                  propertyName: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  closeParenToken: ISyntaxToken,
                  typeAnnotation: TypeAnnotationSyntax,
                  block: BlockSyntax): GetAccessorPropertyAssignmentSyntax {
        if (this.getKeyword === getKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.closeParenToken === closeParenToken && this.typeAnnotation === typeAnnotation && this.block === block) {
            return this;
        }

        return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(getKeyword: ISyntaxToken,
                         propertyName: ISyntaxToken,
                         openParenToken: ISyntaxToken,
                         closeParenToken: ISyntaxToken,
                         block: BlockSyntax): GetAccessorPropertyAssignmentSyntax {
        return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, null, block, /*parsedInStrictMode:*/ false);
    }

    public static create1(propertyName: ISyntaxToken): GetAccessorPropertyAssignmentSyntax {
        return new GetAccessorPropertyAssignmentSyntax(Syntax.token(SyntaxKind.GetKeyword), propertyName, Syntax.token(SyntaxKind.OpenParenToken), Syntax.token(SyntaxKind.CloseParenToken), null, BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): GetAccessorPropertyAssignmentSyntax {
        return <GetAccessorPropertyAssignmentSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): GetAccessorPropertyAssignmentSyntax {
        return <GetAccessorPropertyAssignmentSyntax>super.withTrailingTrivia(trivia);
    }

    public withGetKeyword(getKeyword: ISyntaxToken): GetAccessorPropertyAssignmentSyntax {
        return this.update(getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
    }

    public withPropertyName(propertyName: ISyntaxToken): GetAccessorPropertyAssignmentSyntax {
        return this.update(this.getKeyword, propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): GetAccessorPropertyAssignmentSyntax {
        return this.update(this.getKeyword, this.propertyName, openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): GetAccessorPropertyAssignmentSyntax {
        return this.update(this.getKeyword, this.propertyName, this.openParenToken, closeParenToken, this.typeAnnotation, this.block);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): GetAccessorPropertyAssignmentSyntax {
        return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, typeAnnotation, this.block);
    }

    public withBlock(block: BlockSyntax): GetAccessorPropertyAssignmentSyntax {
        return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, block);
    }

    public isTypeScriptSpecific(): bool {
        if (this.typeAnnotation !== null && this.typeAnnotation.isTypeScriptSpecific()) { return true; }
        if (this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class SetAccessorPropertyAssignmentSyntax extends AccessorPropertyAssignmentSyntax {

    constructor(public setKeyword: ISyntaxToken,
                propertyName: ISyntaxToken,
                openParenToken: ISyntaxToken,
                public parameter: ParameterSyntax,
                closeParenToken: ISyntaxToken,
                block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(propertyName, openParenToken, closeParenToken, block, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitSetAccessorPropertyAssignment(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.SetAccessorPropertyAssignment;
    }

    public childCount(): number {
        return 6;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.setKeyword;
            case 1: return this.propertyName;
            case 2: return this.openParenToken;
            case 3: return this.parameter;
            case 4: return this.closeParenToken;
            case 5: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(setKeyword: ISyntaxToken,
                  propertyName: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  parameter: ParameterSyntax,
                  closeParenToken: ISyntaxToken,
                  block: BlockSyntax): SetAccessorPropertyAssignmentSyntax {
        if (this.setKeyword === setKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.parameter === parameter && this.closeParenToken === closeParenToken && this.block === block) {
            return this;
        }

        return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(propertyName: ISyntaxToken,
                          parameter: ParameterSyntax): SetAccessorPropertyAssignmentSyntax {
        return new SetAccessorPropertyAssignmentSyntax(Syntax.token(SyntaxKind.SetKeyword), propertyName, Syntax.token(SyntaxKind.OpenParenToken), parameter, Syntax.token(SyntaxKind.CloseParenToken), BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): SetAccessorPropertyAssignmentSyntax {
        return <SetAccessorPropertyAssignmentSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): SetAccessorPropertyAssignmentSyntax {
        return <SetAccessorPropertyAssignmentSyntax>super.withTrailingTrivia(trivia);
    }

    public withSetKeyword(setKeyword: ISyntaxToken): SetAccessorPropertyAssignmentSyntax {
        return this.update(setKeyword, this.propertyName, this.openParenToken, this.parameter, this.closeParenToken, this.block);
    }

    public withPropertyName(propertyName: ISyntaxToken): SetAccessorPropertyAssignmentSyntax {
        return this.update(this.setKeyword, propertyName, this.openParenToken, this.parameter, this.closeParenToken, this.block);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): SetAccessorPropertyAssignmentSyntax {
        return this.update(this.setKeyword, this.propertyName, openParenToken, this.parameter, this.closeParenToken, this.block);
    }

    public withParameter(parameter: ParameterSyntax): SetAccessorPropertyAssignmentSyntax {
        return this.update(this.setKeyword, this.propertyName, this.openParenToken, parameter, this.closeParenToken, this.block);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): SetAccessorPropertyAssignmentSyntax {
        return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameter, closeParenToken, this.block);
    }

    public withBlock(block: BlockSyntax): SetAccessorPropertyAssignmentSyntax {
        return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameter, this.closeParenToken, block);
    }

    public isTypeScriptSpecific(): bool {
        if (this.parameter.isTypeScriptSpecific()) { return true; }
        if (this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class FunctionExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public functionKeyword: ISyntaxToken,
                public identifier: ISyntaxToken,
                public callSignature: CallSignatureSyntax,
                public block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitFunctionExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.FunctionExpression;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.functionKeyword;
            case 1: return this.identifier;
            case 2: return this.callSignature;
            case 3: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(functionKeyword: ISyntaxToken,
                  identifier: ISyntaxToken,
                  callSignature: CallSignatureSyntax,
                  block: BlockSyntax): FunctionExpressionSyntax {
        if (this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block) {
            return this;
        }

        return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(functionKeyword: ISyntaxToken,
                         callSignature: CallSignatureSyntax,
                         block: BlockSyntax): FunctionExpressionSyntax {
        return new FunctionExpressionSyntax(functionKeyword, null, callSignature, block, /*parsedInStrictMode:*/ false);
    }

    public static create1(): FunctionExpressionSyntax {
        return new FunctionExpressionSyntax(Syntax.token(SyntaxKind.FunctionKeyword), null, CallSignatureSyntax.create1(), BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): FunctionExpressionSyntax {
        return <FunctionExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): FunctionExpressionSyntax {
        return <FunctionExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withFunctionKeyword(functionKeyword: ISyntaxToken): FunctionExpressionSyntax {
        return this.update(functionKeyword, this.identifier, this.callSignature, this.block);
    }

    public withIdentifier(identifier: ISyntaxToken): FunctionExpressionSyntax {
        return this.update(this.functionKeyword, identifier, this.callSignature, this.block);
    }

    public withCallSignature(callSignature: CallSignatureSyntax): FunctionExpressionSyntax {
        return this.update(this.functionKeyword, this.identifier, callSignature, this.block);
    }

    public withBlock(block: BlockSyntax): FunctionExpressionSyntax {
        return this.update(this.functionKeyword, this.identifier, this.callSignature, block);
    }

    public isTypeScriptSpecific(): bool {
        if (this.callSignature.isTypeScriptSpecific()) { return true; }
        if (this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class EmptyStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitEmptyStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.EmptyStatement;
    }

    public childCount(): number {
        return 1;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(semicolonToken: ISyntaxToken): EmptyStatementSyntax {
        if (this.semicolonToken === semicolonToken) {
            return this;
        }

        return new EmptyStatementSyntax(semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(): EmptyStatementSyntax {
        return new EmptyStatementSyntax(Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): EmptyStatementSyntax {
        return <EmptyStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): EmptyStatementSyntax {
        return <EmptyStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): EmptyStatementSyntax {
        return this.update(semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        return false;
    }
    }

    export class TryStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public tryKeyword: ISyntaxToken,
                public block: BlockSyntax,
                public catchClause: CatchClauseSyntax,
                public finallyClause: FinallyClauseSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTryStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TryStatement;
    }

    public childCount(): number {
        return 4;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.tryKeyword;
            case 1: return this.block;
            case 2: return this.catchClause;
            case 3: return this.finallyClause;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(tryKeyword: ISyntaxToken,
                  block: BlockSyntax,
                  catchClause: CatchClauseSyntax,
                  finallyClause: FinallyClauseSyntax): TryStatementSyntax {
        if (this.tryKeyword === tryKeyword && this.block === block && this.catchClause === catchClause && this.finallyClause === finallyClause) {
            return this;
        }

        return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(tryKeyword: ISyntaxToken,
                         block: BlockSyntax): TryStatementSyntax {
        return new TryStatementSyntax(tryKeyword, block, null, null, /*parsedInStrictMode:*/ false);
    }

    public static create1(): TryStatementSyntax {
        return new TryStatementSyntax(Syntax.token(SyntaxKind.TryKeyword), BlockSyntax.create1(), null, null, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TryStatementSyntax {
        return <TryStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TryStatementSyntax {
        return <TryStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withTryKeyword(tryKeyword: ISyntaxToken): TryStatementSyntax {
        return this.update(tryKeyword, this.block, this.catchClause, this.finallyClause);
    }

    public withBlock(block: BlockSyntax): TryStatementSyntax {
        return this.update(this.tryKeyword, block, this.catchClause, this.finallyClause);
    }

    public withCatchClause(catchClause: CatchClauseSyntax): TryStatementSyntax {
        return this.update(this.tryKeyword, this.block, catchClause, this.finallyClause);
    }

    public withFinallyClause(finallyClause: FinallyClauseSyntax): TryStatementSyntax {
        return this.update(this.tryKeyword, this.block, this.catchClause, finallyClause);
    }

    public isTypeScriptSpecific(): bool {
        if (this.block.isTypeScriptSpecific()) { return true; }
        if (this.catchClause !== null && this.catchClause.isTypeScriptSpecific()) { return true; }
        if (this.finallyClause !== null && this.finallyClause.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class CatchClauseSyntax extends SyntaxNode {

    constructor(public catchKeyword: ISyntaxToken,
                public openParenToken: ISyntaxToken,
                public identifier: ISyntaxToken,
                public typeAnnotation: TypeAnnotationSyntax,
                public closeParenToken: ISyntaxToken,
                public block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitCatchClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.CatchClause;
    }

    public childCount(): number {
        return 6;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.catchKeyword;
            case 1: return this.openParenToken;
            case 2: return this.identifier;
            case 3: return this.typeAnnotation;
            case 4: return this.closeParenToken;
            case 5: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(catchKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  identifier: ISyntaxToken,
                  typeAnnotation: TypeAnnotationSyntax,
                  closeParenToken: ISyntaxToken,
                  block: BlockSyntax): CatchClauseSyntax {
        if (this.catchKeyword === catchKeyword && this.openParenToken === openParenToken && this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.closeParenToken === closeParenToken && this.block === block) {
            return this;
        }

        return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create(catchKeyword: ISyntaxToken,
                         openParenToken: ISyntaxToken,
                         identifier: ISyntaxToken,
                         closeParenToken: ISyntaxToken,
                         block: BlockSyntax): CatchClauseSyntax {
        return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, null, closeParenToken, block, /*parsedInStrictMode:*/ false);
    }

    public static create1(identifier: ISyntaxToken): CatchClauseSyntax {
        return new CatchClauseSyntax(Syntax.token(SyntaxKind.CatchKeyword), Syntax.token(SyntaxKind.OpenParenToken), identifier, null, Syntax.token(SyntaxKind.CloseParenToken), BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): CatchClauseSyntax {
        return <CatchClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): CatchClauseSyntax {
        return <CatchClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withCatchKeyword(catchKeyword: ISyntaxToken): CatchClauseSyntax {
        return this.update(catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): CatchClauseSyntax {
        return this.update(this.catchKeyword, openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
    }

    public withIdentifier(identifier: ISyntaxToken): CatchClauseSyntax {
        return this.update(this.catchKeyword, this.openParenToken, identifier, this.typeAnnotation, this.closeParenToken, this.block);
    }

    public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): CatchClauseSyntax {
        return this.update(this.catchKeyword, this.openParenToken, this.identifier, typeAnnotation, this.closeParenToken, this.block);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): CatchClauseSyntax {
        return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, closeParenToken, this.block);
    }

    public withBlock(block: BlockSyntax): CatchClauseSyntax {
        return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, block);
    }

    public isTypeScriptSpecific(): bool {
        if (this.typeAnnotation !== null && this.typeAnnotation.isTypeScriptSpecific()) { return true; }
        if (this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class FinallyClauseSyntax extends SyntaxNode {

    constructor(public finallyKeyword: ISyntaxToken,
                public block: BlockSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitFinallyClause(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.FinallyClause;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.finallyKeyword;
            case 1: return this.block;
            default: throw Errors.invalidOperation();
        }
    }

    public update(finallyKeyword: ISyntaxToken,
                  block: BlockSyntax): FinallyClauseSyntax {
        if (this.finallyKeyword === finallyKeyword && this.block === block) {
            return this;
        }

        return new FinallyClauseSyntax(finallyKeyword, block, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(): FinallyClauseSyntax {
        return new FinallyClauseSyntax(Syntax.token(SyntaxKind.FinallyKeyword), BlockSyntax.create1(), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): FinallyClauseSyntax {
        return <FinallyClauseSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): FinallyClauseSyntax {
        return <FinallyClauseSyntax>super.withTrailingTrivia(trivia);
    }

    public withFinallyKeyword(finallyKeyword: ISyntaxToken): FinallyClauseSyntax {
        return this.update(finallyKeyword, this.block);
    }

    public withBlock(block: BlockSyntax): FinallyClauseSyntax {
        return this.update(this.finallyKeyword, block);
    }

    public isTypeScriptSpecific(): bool {
        if (this.block.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class LabeledStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public identifier: ISyntaxToken,
                public colonToken: ISyntaxToken,
                public statement: IStatementSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitLabeledStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.LabeledStatement;
    }

    public childCount(): number {
        return 3;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            case 2: return this.statement;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(identifier: ISyntaxToken,
                  colonToken: ISyntaxToken,
                  statement: IStatementSyntax): LabeledStatementSyntax {
        if (this.identifier === identifier && this.colonToken === colonToken && this.statement === statement) {
            return this;
        }

        return new LabeledStatementSyntax(identifier, colonToken, statement, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(identifier: ISyntaxToken,
                          statement: IStatementSyntax): LabeledStatementSyntax {
        return new LabeledStatementSyntax(identifier, Syntax.token(SyntaxKind.ColonToken), statement, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): LabeledStatementSyntax {
        return <LabeledStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): LabeledStatementSyntax {
        return <LabeledStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withIdentifier(identifier: ISyntaxToken): LabeledStatementSyntax {
        return this.update(identifier, this.colonToken, this.statement);
    }

    public withColonToken(colonToken: ISyntaxToken): LabeledStatementSyntax {
        return this.update(this.identifier, colonToken, this.statement);
    }

    public withStatement(statement: IStatementSyntax): LabeledStatementSyntax {
        return this.update(this.identifier, this.colonToken, statement);
    }

    public isTypeScriptSpecific(): bool {
        if (this.statement.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class DoStatementSyntax extends IterationStatementSyntax {

    constructor(public doKeyword: ISyntaxToken,
                statement: IStatementSyntax,
                public whileKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                public condition: IExpressionSyntax,
                closeParenToken: ISyntaxToken,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(openParenToken, closeParenToken, statement, parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitDoStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.DoStatement;
    }

    public childCount(): number {
        return 7;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.doKeyword;
            case 1: return this.statement;
            case 2: return this.whileKeyword;
            case 3: return this.openParenToken;
            case 4: return this.condition;
            case 5: return this.closeParenToken;
            case 6: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    public update(doKeyword: ISyntaxToken,
                  statement: IStatementSyntax,
                  whileKeyword: ISyntaxToken,
                  openParenToken: ISyntaxToken,
                  condition: IExpressionSyntax,
                  closeParenToken: ISyntaxToken,
                  semicolonToken: ISyntaxToken): DoStatementSyntax {
        if (this.doKeyword === doKeyword && this.statement === statement && this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(statement: IStatementSyntax,
                          condition: IExpressionSyntax): DoStatementSyntax {
        return new DoStatementSyntax(Syntax.token(SyntaxKind.DoKeyword), statement, Syntax.token(SyntaxKind.WhileKeyword), Syntax.token(SyntaxKind.OpenParenToken), condition, Syntax.token(SyntaxKind.CloseParenToken), Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): DoStatementSyntax {
        return <DoStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): DoStatementSyntax {
        return <DoStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withDoKeyword(doKeyword: ISyntaxToken): DoStatementSyntax {
        return this.update(doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    }

    public withStatement(statement: IStatementSyntax): DoStatementSyntax {
        return this.update(this.doKeyword, statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    }

    public withWhileKeyword(whileKeyword: ISyntaxToken): DoStatementSyntax {
        return this.update(this.doKeyword, this.statement, whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    }

    public withOpenParenToken(openParenToken: ISyntaxToken): DoStatementSyntax {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
    }

    public withCondition(condition: IExpressionSyntax): DoStatementSyntax {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.semicolonToken);
    }

    public withCloseParenToken(closeParenToken: ISyntaxToken): DoStatementSyntax {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): DoStatementSyntax {
        return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        if (this.statement.isTypeScriptSpecific()) { return true; }
        if (this.condition.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class TypeOfExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public typeOfKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitTypeOfExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.TypeOfExpression;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.typeOfKeyword;
            case 1: return this.expression;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(typeOfKeyword: ISyntaxToken,
                  expression: IExpressionSyntax): TypeOfExpressionSyntax {
        if (this.typeOfKeyword === typeOfKeyword && this.expression === expression) {
            return this;
        }

        return new TypeOfExpressionSyntax(typeOfKeyword, expression, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): TypeOfExpressionSyntax {
        return new TypeOfExpressionSyntax(Syntax.token(SyntaxKind.TypeOfKeyword), expression, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): TypeOfExpressionSyntax {
        return <TypeOfExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): TypeOfExpressionSyntax {
        return <TypeOfExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withTypeOfKeyword(typeOfKeyword: ISyntaxToken): TypeOfExpressionSyntax {
        return this.update(typeOfKeyword, this.expression);
    }

    public withExpression(expression: IExpressionSyntax): TypeOfExpressionSyntax {
        return this.update(this.typeOfKeyword, expression);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class DeleteExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public deleteKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitDeleteExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.DeleteExpression;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.deleteKeyword;
            case 1: return this.expression;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(deleteKeyword: ISyntaxToken,
                  expression: IExpressionSyntax): DeleteExpressionSyntax {
        if (this.deleteKeyword === deleteKeyword && this.expression === expression) {
            return this;
        }

        return new DeleteExpressionSyntax(deleteKeyword, expression, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): DeleteExpressionSyntax {
        return new DeleteExpressionSyntax(Syntax.token(SyntaxKind.DeleteKeyword), expression, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): DeleteExpressionSyntax {
        return <DeleteExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): DeleteExpressionSyntax {
        return <DeleteExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withDeleteKeyword(deleteKeyword: ISyntaxToken): DeleteExpressionSyntax {
        return this.update(deleteKeyword, this.expression);
    }

    public withExpression(expression: IExpressionSyntax): DeleteExpressionSyntax {
        return this.update(this.deleteKeyword, expression);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class VoidExpressionSyntax extends SyntaxNode implements IUnaryExpressionSyntax {

    constructor(public voidKeyword: ISyntaxToken,
                public expression: IExpressionSyntax,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitVoidExpression(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.VoidExpression;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.voidKeyword;
            case 1: return this.expression;
            default: throw Errors.invalidOperation();
        }
    }

    private isUnaryExpression(): bool {
        return true;
    }

    private isExpression(): bool {
        return true;
    }

    public update(voidKeyword: ISyntaxToken,
                  expression: IExpressionSyntax): VoidExpressionSyntax {
        if (this.voidKeyword === voidKeyword && this.expression === expression) {
            return this;
        }

        return new VoidExpressionSyntax(voidKeyword, expression, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(expression: IExpressionSyntax): VoidExpressionSyntax {
        return new VoidExpressionSyntax(Syntax.token(SyntaxKind.VoidKeyword), expression, /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): VoidExpressionSyntax {
        return <VoidExpressionSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): VoidExpressionSyntax {
        return <VoidExpressionSyntax>super.withTrailingTrivia(trivia);
    }

    public withVoidKeyword(voidKeyword: ISyntaxToken): VoidExpressionSyntax {
        return this.update(voidKeyword, this.expression);
    }

    public withExpression(expression: IExpressionSyntax): VoidExpressionSyntax {
        return this.update(this.voidKeyword, expression);
    }

    public isTypeScriptSpecific(): bool {
        if (this.expression.isTypeScriptSpecific()) { return true; }
        return false;
    }
    }

    export class DebuggerStatementSyntax extends SyntaxNode implements IStatementSyntax {

    constructor(public debuggerKeyword: ISyntaxToken,
                public semicolonToken: ISyntaxToken,
                parsedInStrictMode: bool) {
        super(parsedInStrictMode); 

    }

    public accept(visitor: ISyntaxVisitor): any {
        return visitor.visitDebuggerStatement(this);
    }

    public kind(): SyntaxKind {
        return SyntaxKind.DebuggerStatement;
    }

    public childCount(): number {
        return 2;
    }

    public childAt(slot: number): ISyntaxElement {
        switch (slot) {
            case 0: return this.debuggerKeyword;
            case 1: return this.semicolonToken;
            default: throw Errors.invalidOperation();
        }
    }

    private isStatement(): bool {
        return true;
    }

    private isModuleElement(): bool {
        return true;
    }

    public update(debuggerKeyword: ISyntaxToken,
                  semicolonToken: ISyntaxToken): DebuggerStatementSyntax {
        if (this.debuggerKeyword === debuggerKeyword && this.semicolonToken === semicolonToken) {
            return this;
        }

        return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, /*parsedInStrictMode:*/ this.parsedInStrictMode());
    }

    public static create1(): DebuggerStatementSyntax {
        return new DebuggerStatementSyntax(Syntax.token(SyntaxKind.DebuggerKeyword), Syntax.token(SyntaxKind.SemicolonToken), /*parsedInStrictMode:*/ false);
    }

    public withLeadingTrivia(trivia: ISyntaxTriviaList): DebuggerStatementSyntax {
        return <DebuggerStatementSyntax>super.withLeadingTrivia(trivia);
    }

    public withTrailingTrivia(trivia: ISyntaxTriviaList): DebuggerStatementSyntax {
        return <DebuggerStatementSyntax>super.withTrailingTrivia(trivia);
    }

    public withDebuggerKeyword(debuggerKeyword: ISyntaxToken): DebuggerStatementSyntax {
        return this.update(debuggerKeyword, this.semicolonToken);
    }

    public withSemicolonToken(semicolonToken: ISyntaxToken): DebuggerStatementSyntax {
        return this.update(this.debuggerKeyword, semicolonToken);
    }

    public isTypeScriptSpecific(): bool {
        return false;
    }
    }
}
﻿///<reference path='References.ts' />

module TypeScript {
    export interface ISyntaxVisitor {
        visitToken(token: ISyntaxToken): any;
        visitSourceUnit(node: SourceUnitSyntax): any;
        visitExternalModuleReference(node: ExternalModuleReferenceSyntax): any;
        visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): any;
        visitImportDeclaration(node: ImportDeclarationSyntax): any;
        visitExportAssignment(node: ExportAssignmentSyntax): any;
        visitClassDeclaration(node: ClassDeclarationSyntax): any;
        visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): any;
        visitExtendsClause(node: ExtendsClauseSyntax): any;
        visitImplementsClause(node: ImplementsClauseSyntax): any;
        visitModuleDeclaration(node: ModuleDeclarationSyntax): any;
        visitFunctionDeclaration(node: FunctionDeclarationSyntax): any;
        visitVariableStatement(node: VariableStatementSyntax): any;
        visitVariableDeclaration(node: VariableDeclarationSyntax): any;
        visitVariableDeclarator(node: VariableDeclaratorSyntax): any;
        visitEqualsValueClause(node: EqualsValueClauseSyntax): any;
        visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): any;
        visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): any;
        visitOmittedExpression(node: OmittedExpressionSyntax): any;
        visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): any;
        visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): any;
        visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): any;
        visitQualifiedName(node: QualifiedNameSyntax): any;
        visitTypeArgumentList(node: TypeArgumentListSyntax): any;
        visitConstructorType(node: ConstructorTypeSyntax): any;
        visitFunctionType(node: FunctionTypeSyntax): any;
        visitObjectType(node: ObjectTypeSyntax): any;
        visitArrayType(node: ArrayTypeSyntax): any;
        visitGenericType(node: GenericTypeSyntax): any;
        visitTypeAnnotation(node: TypeAnnotationSyntax): any;
        visitBlock(node: BlockSyntax): any;
        visitParameter(node: ParameterSyntax): any;
        visitMemberAccessExpression(node: MemberAccessExpressionSyntax): any;
        visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): any;
        visitElementAccessExpression(node: ElementAccessExpressionSyntax): any;
        visitInvocationExpression(node: InvocationExpressionSyntax): any;
        visitArgumentList(node: ArgumentListSyntax): any;
        visitBinaryExpression(node: BinaryExpressionSyntax): any;
        visitConditionalExpression(node: ConditionalExpressionSyntax): any;
        visitConstructSignature(node: ConstructSignatureSyntax): any;
        visitMethodSignature(node: MethodSignatureSyntax): any;
        visitIndexSignature(node: IndexSignatureSyntax): any;
        visitPropertySignature(node: PropertySignatureSyntax): any;
        visitCallSignature(node: CallSignatureSyntax): any;
        visitParameterList(node: ParameterListSyntax): any;
        visitTypeParameterList(node: TypeParameterListSyntax): any;
        visitTypeParameter(node: TypeParameterSyntax): any;
        visitConstraint(node: ConstraintSyntax): any;
        visitElseClause(node: ElseClauseSyntax): any;
        visitIfStatement(node: IfStatementSyntax): any;
        visitExpressionStatement(node: ExpressionStatementSyntax): any;
        visitConstructorDeclaration(node: ConstructorDeclarationSyntax): any;
        visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): any;
        visitGetMemberAccessorDeclaration(node: GetMemberAccessorDeclarationSyntax): any;
        visitSetMemberAccessorDeclaration(node: SetMemberAccessorDeclarationSyntax): any;
        visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): any;
        visitThrowStatement(node: ThrowStatementSyntax): any;
        visitReturnStatement(node: ReturnStatementSyntax): any;
        visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): any;
        visitSwitchStatement(node: SwitchStatementSyntax): any;
        visitCaseSwitchClause(node: CaseSwitchClauseSyntax): any;
        visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): any;
        visitBreakStatement(node: BreakStatementSyntax): any;
        visitContinueStatement(node: ContinueStatementSyntax): any;
        visitForStatement(node: ForStatementSyntax): any;
        visitForInStatement(node: ForInStatementSyntax): any;
        visitWhileStatement(node: WhileStatementSyntax): any;
        visitWithStatement(node: WithStatementSyntax): any;
        visitEnumDeclaration(node: EnumDeclarationSyntax): any;
        visitEnumElement(node: EnumElementSyntax): any;
        visitCastExpression(node: CastExpressionSyntax): any;
        visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): any;
        visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): any;
        visitGetAccessorPropertyAssignment(node: GetAccessorPropertyAssignmentSyntax): any;
        visitSetAccessorPropertyAssignment(node: SetAccessorPropertyAssignmentSyntax): any;
        visitFunctionExpression(node: FunctionExpressionSyntax): any;
        visitEmptyStatement(node: EmptyStatementSyntax): any;
        visitTryStatement(node: TryStatementSyntax): any;
        visitCatchClause(node: CatchClauseSyntax): any;
        visitFinallyClause(node: FinallyClauseSyntax): any;
        visitLabeledStatement(node: LabeledStatementSyntax): any;
        visitDoStatement(node: DoStatementSyntax): any;
        visitTypeOfExpression(node: TypeOfExpressionSyntax): any;
        visitDeleteExpression(node: DeleteExpressionSyntax): any;
        visitVoidExpression(node: VoidExpressionSyntax): any;
        visitDebuggerStatement(node: DebuggerStatementSyntax): any;
    }

    export class SyntaxVisitor implements ISyntaxVisitor {
        public defaultVisit(node: ISyntaxNodeOrToken): any {
            return null;
        }

        private visitToken(token: ISyntaxToken): any {
            return this.defaultVisit(token);
        }

        private visitSourceUnit(node: SourceUnitSyntax): any {
            return this.defaultVisit(node);
        }

        private visitExternalModuleReference(node: ExternalModuleReferenceSyntax): any {
            return this.defaultVisit(node);
        }

        private visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): any {
            return this.defaultVisit(node);
        }

        private visitImportDeclaration(node: ImportDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitExportAssignment(node: ExportAssignmentSyntax): any {
            return this.defaultVisit(node);
        }

        private visitClassDeclaration(node: ClassDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitExtendsClause(node: ExtendsClauseSyntax): any {
            return this.defaultVisit(node);
        }

        private visitImplementsClause(node: ImplementsClauseSyntax): any {
            return this.defaultVisit(node);
        }

        private visitModuleDeclaration(node: ModuleDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitFunctionDeclaration(node: FunctionDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitVariableStatement(node: VariableStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitVariableDeclaration(node: VariableDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitVariableDeclarator(node: VariableDeclaratorSyntax): any {
            return this.defaultVisit(node);
        }

        private visitEqualsValueClause(node: EqualsValueClauseSyntax): any {
            return this.defaultVisit(node);
        }

        private visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitOmittedExpression(node: OmittedExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitQualifiedName(node: QualifiedNameSyntax): any {
            return this.defaultVisit(node);
        }

        private visitTypeArgumentList(node: TypeArgumentListSyntax): any {
            return this.defaultVisit(node);
        }

        private visitConstructorType(node: ConstructorTypeSyntax): any {
            return this.defaultVisit(node);
        }

        private visitFunctionType(node: FunctionTypeSyntax): any {
            return this.defaultVisit(node);
        }

        private visitObjectType(node: ObjectTypeSyntax): any {
            return this.defaultVisit(node);
        }

        private visitArrayType(node: ArrayTypeSyntax): any {
            return this.defaultVisit(node);
        }

        private visitGenericType(node: GenericTypeSyntax): any {
            return this.defaultVisit(node);
        }

        private visitTypeAnnotation(node: TypeAnnotationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitBlock(node: BlockSyntax): any {
            return this.defaultVisit(node);
        }

        private visitParameter(node: ParameterSyntax): any {
            return this.defaultVisit(node);
        }

        private visitMemberAccessExpression(node: MemberAccessExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitElementAccessExpression(node: ElementAccessExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitInvocationExpression(node: InvocationExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitArgumentList(node: ArgumentListSyntax): any {
            return this.defaultVisit(node);
        }

        private visitBinaryExpression(node: BinaryExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitConditionalExpression(node: ConditionalExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitConstructSignature(node: ConstructSignatureSyntax): any {
            return this.defaultVisit(node);
        }

        private visitMethodSignature(node: MethodSignatureSyntax): any {
            return this.defaultVisit(node);
        }

        private visitIndexSignature(node: IndexSignatureSyntax): any {
            return this.defaultVisit(node);
        }

        private visitPropertySignature(node: PropertySignatureSyntax): any {
            return this.defaultVisit(node);
        }

        private visitCallSignature(node: CallSignatureSyntax): any {
            return this.defaultVisit(node);
        }

        private visitParameterList(node: ParameterListSyntax): any {
            return this.defaultVisit(node);
        }

        private visitTypeParameterList(node: TypeParameterListSyntax): any {
            return this.defaultVisit(node);
        }

        private visitTypeParameter(node: TypeParameterSyntax): any {
            return this.defaultVisit(node);
        }

        private visitConstraint(node: ConstraintSyntax): any {
            return this.defaultVisit(node);
        }

        private visitElseClause(node: ElseClauseSyntax): any {
            return this.defaultVisit(node);
        }

        private visitIfStatement(node: IfStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitExpressionStatement(node: ExpressionStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitConstructorDeclaration(node: ConstructorDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitGetMemberAccessorDeclaration(node: GetMemberAccessorDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitSetMemberAccessorDeclaration(node: SetMemberAccessorDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitThrowStatement(node: ThrowStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitReturnStatement(node: ReturnStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitSwitchStatement(node: SwitchStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitCaseSwitchClause(node: CaseSwitchClauseSyntax): any {
            return this.defaultVisit(node);
        }

        private visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): any {
            return this.defaultVisit(node);
        }

        private visitBreakStatement(node: BreakStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitContinueStatement(node: ContinueStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitForStatement(node: ForStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitForInStatement(node: ForInStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitWhileStatement(node: WhileStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitWithStatement(node: WithStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitEnumDeclaration(node: EnumDeclarationSyntax): any {
            return this.defaultVisit(node);
        }

        private visitEnumElement(node: EnumElementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitCastExpression(node: CastExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): any {
            return this.defaultVisit(node);
        }

        private visitGetAccessorPropertyAssignment(node: GetAccessorPropertyAssignmentSyntax): any {
            return this.defaultVisit(node);
        }

        private visitSetAccessorPropertyAssignment(node: SetAccessorPropertyAssignmentSyntax): any {
            return this.defaultVisit(node);
        }

        private visitFunctionExpression(node: FunctionExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitEmptyStatement(node: EmptyStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitTryStatement(node: TryStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitCatchClause(node: CatchClauseSyntax): any {
            return this.defaultVisit(node);
        }

        private visitFinallyClause(node: FinallyClauseSyntax): any {
            return this.defaultVisit(node);
        }

        private visitLabeledStatement(node: LabeledStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitDoStatement(node: DoStatementSyntax): any {
            return this.defaultVisit(node);
        }

        private visitTypeOfExpression(node: TypeOfExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitDeleteExpression(node: DeleteExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitVoidExpression(node: VoidExpressionSyntax): any {
            return this.defaultVisit(node);
        }

        private visitDebuggerStatement(node: DebuggerStatementSyntax): any {
            return this.defaultVisit(node);
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export interface ISyntaxToken extends ISyntaxNodeOrToken, INameSyntax {
        // Same as kind(), just exposed through a property for perf.
        tokenKind: SyntaxKind;

        // Text for this token, not including leading or trailing trivia.
        text(): string;

        value(): any;

        hasLeadingTrivia(): bool;
        hasLeadingComment(): bool;
        hasLeadingNewLine(): bool;
        hasLeadingSkippedText(): bool;

        hasTrailingTrivia(): bool;
        hasTrailingComment(): bool;
        hasTrailingNewLine(): bool;
        hasTrailingSkippedText(): bool;

        hasSkippedText(): bool;

        leadingTrivia(): ISyntaxTriviaList;
        trailingTrivia(): ISyntaxTriviaList;

        withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxToken;
        withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxToken;

        clone(): ISyntaxToken;
    }

    export interface ITokenInfo {
        leadingTrivia?: ISyntaxTrivia[];
        text?: string;
        value?: any;
        trailingTrivia?: ISyntaxTrivia[];
    }
}
///<reference path='References.ts' />

module TypeScript {
    export interface ISyntaxElement {
        kind(): SyntaxKind;

        isNode(): bool;
        isToken(): bool;
        isList(): bool;
        isSeparatedList(): bool;

        childCount(): number;
        childAt(index: number): ISyntaxElement;

        // True if this element is typescript specific and would not be legal in pure javascript.
        isTypeScriptSpecific(): bool;

        // True if this element (or any child element) contains any skipped text trivia.
        hasSkippedText(): bool;

        // True if this element (or any child element) contains any zero width tokens.
        hasZeroWidthToken(): bool;

        // True if this element (or any child element) contains any regular expression token.
        hasRegularExpressionToken(): bool;

        // With of this element, including leading and trailing trivia.
        fullWidth(): number;

        // Width of this element, not including leading and trailing trivia.
        width(): number;

        // Text for this element, including leading and trailing trivia.
        fullText(): string;

        leadingTrivia(): ISyntaxTriviaList;
        trailingTrivia(): ISyntaxTriviaList;

        leadingTriviaWidth(): number;
        trailingTriviaWidth(): number;

        firstToken(): ISyntaxToken;
        lastToken(): ISyntaxToken;

        collectTextElements(elements: string[]): void;
    }

    export interface ISyntaxNode extends ISyntaxNodeOrToken {
    }

    export interface IModuleReferenceSyntax extends ISyntaxNode {
    }

    export interface IModuleElementSyntax extends ISyntaxNode {
    }

    export interface IStatementSyntax extends IModuleElementSyntax {
    }

    export interface ITypeMemberSyntax extends ISyntaxNode {
    }

    export interface IClassElementSyntax extends ISyntaxNode {
    }

    export interface IMemberDeclarationSyntax extends IClassElementSyntax {
    }

    export interface ISwitchClauseSyntax extends ISyntaxNode {
    }

    export interface IExpressionSyntax extends ISyntaxNodeOrToken {
    }

    export interface IUnaryExpressionSyntax extends IExpressionSyntax {
    }

    export interface ITypeSyntax extends IUnaryExpressionSyntax {
    }

    export interface INameSyntax extends ITypeSyntax {
    }
}
///<reference path='References.ts' />

module TypeScript {
    export interface ISyntaxNodeOrToken extends ISyntaxElement {
        withLeadingTrivia(leadingTrivia: ISyntaxTriviaList): ISyntaxNodeOrToken;
        withTrailingTrivia(trailingTrivia: ISyntaxTriviaList): ISyntaxNodeOrToken;

        accept(visitor: ISyntaxVisitor): any;
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class ParseOptions {
        private _allowAutomaticSemicolonInsertion: bool;

        constructor(allowAutomaticSemicolonInsertion?: bool = true) {
            this._allowAutomaticSemicolonInsertion = allowAutomaticSemicolonInsertion;
        }

        public toJSON(key) {
            return { allowAutomaticSemicolonInsertion: this._allowAutomaticSemicolonInsertion };
        }

        public allowAutomaticSemicolonInsertion(): bool {
            return this._allowAutomaticSemicolonInsertion;
        }
    }
}
// Localizable string constants.  TODO: Figure out a way to actually localize things.

module TypeScript {
    export class Strings {
        public static module__class__interface__enum__import_or_statement: string = "module, class, interface, enum, import or statement";
        public static constructor__function__accessor_or_variable: string = "constructor, function, accessor or variable";
        public static statement: string = "statement";
        public static case_or_default_clause: string = "case or default clause";
        public static identifier: string = "identifier";
        public static call__construct__index__property_or_function_signature: string = "call, construct, index, property or function signature";
        public static expression: string = "expression";
        public static type_name: string = "type name";
        public static property_or_accessor: string = "property or accessor";
        public static parameter: string = "parameter";
        public static type: string = "type";
        public static type_parameter: string = "type parameter";
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class SyntaxTree {
        private _sourceUnit: SourceUnitSyntax;
        private _isDeclaration: bool;
        private _diagnostics: SyntaxDiagnostic[];
        private _fileName: string;
        private _lineMap: LineMap;
        private _languageVersion: LanguageVersion;
        private _parseOptions: ParseOptions;

        constructor(sourceUnit: SourceUnitSyntax,
                    isDeclaration: bool,
                    diagnostics: SyntaxDiagnostic[],
                    fileName: string,
                    lineMap: LineMap,
                    languageVersion: LanguageVersion,
                    parseOtions: ParseOptions) {
            this._sourceUnit = sourceUnit;
            this._isDeclaration = isDeclaration;
            this._diagnostics = diagnostics;
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._languageVersion = languageVersion;
            this._parseOptions = parseOtions;
        }

        public toJSON(key) {
            var result: any = {};

            result.isDeclaration = this._isDeclaration;
            result.languageVersion = (<any>LanguageVersion)._map[this._languageVersion];
            result.parseOptions = this._parseOptions;

            if (this._diagnostics.length > 0) {
                result.diagnostics = this._diagnostics;
            }

            result.sourceUnit = this._sourceUnit;
            result.lineMap = this._lineMap;

            return result;
        }

        public sourceUnit(): SourceUnitSyntax {
            return this._sourceUnit;
        }

        public isDeclaration(): bool {
            return this._isDeclaration;
        }

        public diagnostics(): SyntaxDiagnostic[] {
            return this._diagnostics;
        }

        public fileName(): string {
            return this._fileName;
        }

        public lineMap(): LineMap {
            return this._lineMap;
        }

        public languageVersion(): LanguageVersion {
            return this._languageVersion;
        }

        public parseOptions(): ParseOptions {
            return this._parseOptions;
        }

        public structuralEquals(tree: SyntaxTree): bool {
            return ArrayUtilities.sequenceEquals(this.diagnostics(), tree.diagnostics(), SyntaxDiagnostic.equals) &&
                this.sourceUnit().structuralEquals(tree.sourceUnit());
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export enum Constants {
        // 2^30-1
        Max31BitInteger = 1073741823,
        Min31BitInteger = -1073741824,
    }
}
///<reference path='References.ts' />

module TypeScript {
    export class TextChangeRange {
        public static unchanged = new TextChangeRange(new TextSpan(0, 0), 0);

        private _span: TextSpan;
        private _newLength: number;

        /// <summary>
        /// Initializes a new instance of <see cref="T:TextChangeRange"/>.
        /// </summary>
        /// <param name="span"></param>
        /// <param name="newLength"></param>
        constructor(span: TextSpan, newLength: number) {
            if (newLength < 0) {
                throw Errors.argumentOutOfRange("newLength");
            }

            this._span = span;
            this._newLength = newLength;
        }

        /// <summary>
        /// The span of text before the edit which is being changed
        /// </summary>
        public span(): TextSpan {
            return this._span;
        }

        /// <summary>
        /// Width of the span after the edit.  A 0 here would represent a delete
        /// </summary>
        public newLength(): number {
            return this._newLength;
        }

        public newSpan(): TextSpan {
            return new TextSpan(this.span().start(), this.newLength());
        }

        public isUnchanged(): bool {
            return this.span().isEmpty() && this.newLength() === 0;
        }

        /// <summary>
        /// Called to merge all the changes that occurred between one version of a script snapshot to 
        /// the next into a single change.  i.e. say a user did a box selection and made an edit.  That
        /// will show up as N text change ranges between version V of a script and version V+1.  This
        /// function collapses those N changes into a single change range valid between V and V+1.
        /// </summary>
        public static collapseChangesFromSingleVersion(changes: TextChangeRange[]): TextChangeRange {
            var diff = 0;
            var start = Constants.Max31BitInteger;
            var end = 0;

            // TODO: we are assuming that changes are normalized. That is currently not guaranteed,
            // but changes that we get from IDE are normalized. Idealy changes should come in a kind
            // of normalized change collection instead of IEnumerable to really guarantee that they
            // are normalized.
            for (var i = 0; i < changes.length; i++) {
                var change = changes[i];
                diff += change.newLength() - change.span().length();

                if (change.span().start() < start) {
                    start = change.span().start();
                }

                if (change.span().end() > end) {
                    end = change.span().end();
                }
            }

            if (start > end) {
                return null;
            }

            var combined = TextSpan.fromBounds(start, end);
            var newLen = combined.length() + diff;

            return new TextChangeRange(combined, newLen);
        }

        /// <summary>
        /// Called to merge all the changes that occurred across several versions of a script snapshot 
        /// into a single change.  i.e. if a user keeps making successive edits to a script we will
        /// have a text change from V1 to V2, V2 to V3, ..., Vn.  
        /// 
        /// This function will then merge those changes into a single change range valid between V1 and
        /// Vn.
        /// </summary>
        public static collapseChangesAcrossMultipleVersions(changes: TextChangeRange[]): TextChangeRange {
            if (changes.length == 0) {
                return TextChangeRange.unchanged;
            }

            if (changes.length == 1) {
                return changes[0];
            }

            // We change from talking about { { oldStart, oldLength }, newLength } to { oldStart, oldEnd, newEnd }
            // as it makes things much easier to reason about.
            var change0 = changes[0];

            var oldStartN = change0.span().start();
            var oldEndN = change0.span().end();
            var newEndN = oldStartN + change0.newLength();

            for (var i = 1; i < changes.length; i++) {
                var nextChange = changes[i];

                // Consider the following case:
                // i.e. two edits.  The first represents the text change range { { 10, 50 }, 30 }.  i.e. The span starting
                // at 10, with length 50 is reduced to length 30.  The second represents the text change range { { 30, 30 }, 40 }.
                // i.e. the span starting at 30 with length 30 is increased to length 40.
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      -------------------------------------------------------------------------------------------------------
                //                |                                                 /                                          
                //                |                                            /----                                           
                //  T1            |                                       /----                                                
                //                |                                  /----                                                     
                //                |                             /----                                                          
                //      -------------------------------------------------------------------------------------------------------
                //                                     |                            \                                          
                //                                     |                               \                                       
                //   T2                                |                                 \                                     
                //                                     |                                   \                                   
                //                                     |                                      \                                
                //      -------------------------------------------------------------------------------------------------------
                //
                // Merging these turns out to not be too difficult.  First, determining the new start of the change is trivial
                // it's just the min of the old and new starts.  i.e.:
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      ------------------------------------------------------------*------------------------------------------
                //                |                                                 /                                          
                //                |                                            /----                                           
                //  T1            |                                       /----                                                
                //                |                                  /----                                                     
                //                |                             /----                                                          
                //      ----------------------------------------$-------------------$------------------------------------------
                //                .                    |                            \                                          
                //                .                    |                               \                                       
                //   T2           .                    |                                 \                                     
                //                .                    |                                   \                                   
                //                .                    |                                      \                                
                //      ----------------------------------------------------------------------*--------------------------------
                //
                // (Note the dots represent the newly inferrred start.
                // Determining the new and old end is also pretty simple.  Basically it boils down to paying attention to the
                // absolute positions at the asterixes, and the relative change between the dollar signs. Basically, we see
                // which if the two $'s precedes the other, and we move that one forward until they line up.  in this case that
                // means:
                //
                //      0         10        20        30        40        50        60        70        80        90        100
                //      --------------------------------------------------------------------------------*----------------------
                //                |                                                                     /                      
                //                |                                                                /----                       
                //  T1            |                                                           /----                            
                //                |                                                      /----                                 
                //                |                                                 /----                                      
                //      ------------------------------------------------------------$------------------------------------------
                //                .                    |                            \                                          
                //                .                    |                               \                                       
                //   T2           .                    |                                 \                                     
                //                .                    |                                   \                                   
                //                .                    |                                      \                                
                //      ----------------------------------------------------------------------*--------------------------------
                //
                // In other words (in this case), we're recognizing that the second edit happened after where the first edit
                // ended with a delta of 20 characters (60 - 40).  Thus, if we go back in time to where the first edit started
                // that's the same as if we started at char 80 instead of 60.  
                //
                // As it so happens, the same logic applies if the second edit precedes the first edit.  In that case rahter
                // than pusing the first edit forward to match the second, we'll push the second edit forward to match the
                // first.
                //
                // In this case that means we have { oldStart: 10, oldEnd: 80, newEnd: 70 } or, in TextChangeRange
                // semantics: { { start: 10, length: 70 }, newLength: 60 }
                //
                // The math then works out as follows.
                // If we have { oldStart1, oldEnd1, newEnd1 } and { oldStart2, oldEnd2, newEnd2 } then we can compute the 
                // final result like so:
                //
                // {
                //      oldStart3: Min(oldStart1, oldStart2),
                //      oldEnd3  : Max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1)),
                //      newEnd3  : Max(newEnd2, newEnd2 + (newEnd1 - oldEnd2))
                // }

                var oldStart1 = oldStartN;
                var oldEnd1 = oldEndN;
                var newEnd1 = newEndN;

                var oldStart2 = nextChange.span().start();
                var oldEnd2 = nextChange.span().end();
                var newEnd2 = oldStart2 + nextChange.newLength();

                oldStartN = MathPrototype.min(oldStart1, oldStart2);
                oldEndN = MathPrototype.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
                newEndN = MathPrototype.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
            }

            return new TextChangeRange(TextSpan.fromBounds(oldStartN, oldEndN), /*newLength: */newEndN - oldStartN);
        }
    }
}
///<reference path='References.ts' />

module TypeScript.Parser {
    // Information the parser needs to effectively rewind.
    interface IParserRewindPoint {
        // Information used by normal parser source.
        previousToken: ISyntaxToken;
        absolutePosition: number;
        slidingWindowIndex: number;

        // Information used by the incremental parser source.
        oldSourceUnitCursorIndex: number;
        changeDelta: number;
        changeRange: TextChangeRange;

        // Information used by the parser itself.

        // As we speculatively parser, we may build up diagnostics.  When we rewind we want to 
        // 'forget' that information.In order to do that we store the count of diagnostics and 
        // when we start speculating, and we reset to that count when we're done.  That way the
        // speculative parse does not affect any further results.
        diagnosticsCount: number;

        // For debug purposes only, we also track the following information. They help us assert 
        // that we're not doing anything unexpected.

        // Rewind points should work like a stack.  The first rewind point given out should be the
        // last one released.  By keeping track of the count of points out when this was created, 
        // we can ensure that invariant was preserved.
        pinCount: number;

        // isInStrictMode and listParsingState should not have to be tracked by a rewind point.
        // Because they are naturally mutated and restored based on the normal stack movement of 
        // the parser, they should automatically return to whatever value they had to begin with
        // if the parser decides to rewind or not.  However, to ensure that this is true, we track
        // these variables and check if they have the same value when we're rewinding/releasing.
        isInStrictMode: bool;
        listParsingState: ListParsingState;
    }

    // The precedence of expressions in typescript.  While we're parsing an expression, we will 
    // continue to consume and form new trees if the precedence is greater than our current
    // precedence.  For example, if we have: a + b * c, we will first parse 'a' with precedence 0. 
    // We will then see the + with precedence 13.  13 is greater than 0 so we will decide to create
    // a binary expression with the result of parsing the sub expression "b * c".  We'll then parse
    // the term 'b' (passing in precedence 13).  We will then see the * with precedence 14.  14 is
    // greater than 13, so we will create a binary expression from "b" and "c", return that, and 
    // join it with "a" producing:
    //
    //      +
    //     / \
    //    a   *
    //       / \
    //      b   c
    //
    // If we instead had: "a * b + c", we would first parser 'a' with precedence 0.  We would then see 
    // the * with precedence 14.  14 is greater than 0 so we will decide to create a binary expression
    // with the result of parsing the sub expression "b + c".  We'll then parse the term 'b' (passing in
    // precedence 14).  We will then see the + with precedence 13.  13 is less than 14, so we won't 
    // continue parsing subexpressions and will just return the expression 'b'.  The caller will join 
    // that into "a * b" (and will be back at precedence 0). It will then see the + with precedence 11.
    // 11 is greater than 0 so it will parse the sub expression and make a binary expression out of it
    // producing:
    //
    //        +
    //       / \
    //      *   c
    //     / \
    //    a   b
    enum ExpressionPrecedence {
        // Intuitively, commas have the lowest precedence.  "a || b, c" is "(a || b), c", not
        // "a || (b, c)"
        CommaExpressionPrecedence = 1,

        AssignmentExpressionPrecedence = 2,

        ConditionalExpressionPrecedence = 3,

        // REVIEW: Should ArrowFunctions have higher, lower, or the same precedence as ternary?
        ArrowFunctionPrecedence = 4,

        LogicalOrExpressionPrecedence = 5,
        LogicalAndExpressionPrecedence = 6,
        BitwiseOrExpressionPrecedence = 7,
        BitwiseExclusiveOrExpressionPrecedence = 8,
        BitwiseAndExpressionPrecedence = 9,
        EqualityExpressionPrecedence = 10,
        RelationalExpressionPrecedence = 11,
        ShiftExpressionPrecdence = 12,
        AdditiveExpressionPrecedence = 13,
        MultiplicativeExpressionPrecedence = 14,

        // Intuitively, unary expressions have the highest precedence.  After all, if you have:
        //   !foo || bar
        //
        // Then you have "(!foo) || bar", not "!(foo || bar)"
        UnaryExpressionPrecedence = 15,
    }

    // The current state of the parser wrt to list parsing.  The way to read these is as:
    // CurrentProduction_SubList.  i.e. "Block_Statements" means "we're parsing a Block, and we're 
    // currently parsing list of statements within it".  This is used by the list parsing mechanism
    // to parse the elements of the lists, and recover from errors we encounter when we run into 
    // unexpected code.
    // 
    // For example, when we are in ArgumentList_Arguments, we will continue trying to consume code 
    // as long as "isArgument" is true.  If we run into a token for which "isArgument" is not true 
    // we will do the following:
    //
    // If the token is a StopToken for ArgumentList_Arguments (like ")" ) then we will stop parsing
    // the list of arguments with no error.
    //
    // Otherwise, we *do* report an error for this unexpected token, and then enter error recovery 
    // mode to decide how to try to recover from this unexpected token.
    //
    // Error recovery will walk up the list of states we're in seeing if the token is a stop token
    // for that construct *or* could start another element within what construct.  For example, if
    // the unexpected token was '}' then that would be a stop token for Block_Statements. 
    // Alternatively, if the unexpected token was 'return', then that would be a start token for 
    // the next statment in Block_Statements.
    // 
    // If either of those cases are true, We will then return *without* consuming  that token. 
    // (Remember, we've already reported an error).  Now we're just letting the higher up parse 
    // constructs eventually try to consume that token.
    //
    // If none of the higher up states consider this a stop or start token, then we will simply 
    // consume the token and add it to our list of 'skipped tokens'.  We will then repeat the 
    // above algorithm until we resynchronize at some point.
    enum ListParsingState {
        SourceUnit_ModuleElements = 1 << 0,
        ClassDeclaration_ClassElements = 1 << 1,
        ModuleDeclaration_ModuleElements = 1 << 2,
        SwitchStatement_SwitchClauses = 1 << 3,
        SwitchClause_Statements = 1 << 4,
        Block_Statements = 1 << 5,
        TryBlock_Statements = 1 << 6,
        CatchBlock_Statements = 1 << 7,
        EnumDeclaration_EnumElements = 1 << 8,
        ObjectType_TypeMembers = 1 << 9,
        ExtendsOrImplementsClause_TypeNameList = 1 << 10,
        VariableDeclaration_VariableDeclarators_AllowIn = 1 << 11,
        VariableDeclaration_VariableDeclarators_DisallowIn = 1 << 12,
        ArgumentList_AssignmentExpressions = 1 << 13,
        ObjectLiteralExpression_PropertyAssignments = 1 << 14,
        ArrayLiteralExpression_AssignmentExpressions = 1 << 15,
        ParameterList_Parameters = 1 << 16,
        TypeArgumentList_Types = 1 << 17,
        TypeParameterList_TypeParameters = 1 << 18,

        FirstListParsingState = SourceUnit_ModuleElements,
        LastListParsingState = TypeArgumentList_Types,
    }

    // Allows one to easily move over a syntax tree.  Used during incremental parsing to move over
    // the previously parsed tree to provide nodes and tokens that can be reused when parsing the
    // updated text.
    class SyntaxCursor {
        private _elements: ISyntaxElement[] = [];
        private _index: number = 0;
        private _pinCount: number = 0;

        constructor(sourceUnit: SourceUnitSyntax) {
            sourceUnit.insertChildrenInto(this._elements, 0);
        }

        public isFinished(): bool {
            return this._index === this._elements.length;
        }

        public currentElement(): ISyntaxElement {
            if (this.isFinished()) {
                return null;
            }

            return this._elements[this._index];
        }

        public currentNode(): SyntaxNode {
            var element = this.currentElement();
            return element !== null && element.isNode() ? <SyntaxNode>element : null;
        }

        public moveToFirstChild() {
            if (this.isFinished()) {
                return;
            }

            var element = this._elements[this._index];
            if (element.isToken()) {
                // If we're already on a token, there's nothing to do.
                return;
            }

            // Otherwise, break the node we're pointing at into its children.  We'll then be 
            // pointing at the first child
            var node = <SyntaxNode>element;

            // Remove the item that we're pointing at.
            this._elements.splice(this._index, 1);

            // And add its children into the position it was at.
            node.insertChildrenInto(this._elements, this._index);
        }

        public moveToNextSibling() {
            if (this.isFinished()) {
                return;
            }

            if (this._pinCount > 0) {
                // If we're currently pinned, then just move our index forward.  We'll then be 
                // pointing at the next sibling.
                this._index++;
                return;
            }

            // if we're not pinned, we better be pointed at the first item in the list.
            // Debug.assert(this._index === 0);

            // Just shift ourselves over so we forget the current element we're pointing at and 
            // we're pointing at the next slibing.
            this._elements.shift();
        }

        public getAndPinCursorIndex(): number {
            this._pinCount++;
            return this._index;
        }

        public releaseAndUnpinCursorIndex(index: number) {
            // this._index = index;

            // Debug.assert(this._pinCount > 0);
            this._pinCount--;
            if (this._pinCount === 0) {
                // The first pin was given out at index 0.  So we better be back at index 0.
                // Debug.assert(this._index === 0);
            }
        }

        public rewindToPinnedCursorIndex(index: number): void {
            // Debug.assert(index >= 0 && index <= this._elements.length);
            // Debug.assert(this._pinCount > 0);
            this._index = index;
        }

        public pinCount(): number {
            return this._pinCount;
        }

        private moveToFirstToken(): void {
            var element: ISyntaxElement;

            while (!this.isFinished()) {
                element = this.currentElement();
                if (element.isNode()) {
                    this.moveToFirstChild();
                    continue;
                }

                // Debug.assert(element.isToken());
                return;
            }
        }

        public currentToken(): ISyntaxToken {
            this.moveToFirstToken();
            if (this.isFinished()) {
                return null;
            }

            var element = this.currentElement();

            // Debug.assert(element.isToken());
            return <ISyntaxToken>element;
        }

        public peekToken(n: number): ISyntaxToken {
            this.moveToFirstToken();
            var pin = this.getAndPinCursorIndex();
            try {
                for (var i = 0; i < n; i++) {
                    this.moveToNextSibling();
                    this.moveToFirstToken();
                }

                return this.currentToken();
            }
            finally {
                this.rewindToPinnedCursorIndex(pin);
                this.releaseAndUnpinCursorIndex(pin);
            }
        }
    }
    
    // Interface that represents the source that the parser pulls tokens from.  Essentially, this 
    // is the interface that the parser needs an underlying scanner to provide.  This allows us to
    // separate out "what" the parser does with the tokens it retrieves versus "how" it obtains
    // the tokens.  i.e. all the logic for parsing language constructs sits in ParserImpl, while 
    // all the logic for retrieving tokens sits in individual IParserSources.
    //
    // By separating out this interface, we also make incremental parsing much easier.  Instead of
    // having the parser directly sit on top of the scanner, we sit it on this abstraction.  Then
    // in incremental scenarios, we can use the IncrementalParserSource to pull tokens (or even 
    // full nodes) from the previous tree when possible.  Of course, we'll still end up using a 
    // scanner for new text.  But that can all happen inside the source, with none of the logic in
    // the parser having to be aware of it.
    //
    // In general terms, a parser source represents a position within a text.  At that position, 
    // one can ask for the 'currentToken' that the source is pointing at.  The 'previousToken' that
    // precedes this token (generally used for automatic semicolon insertion, and other minor 
    // parsing decisions).  Then, once the parser consumes that token it can ask the source to
    // 'moveToNextToken'.
    //
    // Additional special abilities include:
    //  1) Being able to peek an arbitrary number of tokens ahead efficiently.
    //  2) Being able to retrieve fully parsed nodes from the source, not just tokens. This happens
    //     in incremental scenarios when the source is certain that the node is completley safe to
    //     reuse.
    //  3) Being able to get a 'rewind point' to the current location.  This allows the parser to
    //     speculatively parse as much as it wants, and then reset itself back to that point, 
    //     ensuring that no state changes that occurred after getting the 'rewing point' are 
    //     observable.
    //  4) Being able to reinterpret the current token being pointed at as a regular expression 
    //     token.  This is necessary as the scanner does not have enough information to correctly
    //     distinguish "/" or "/=" as divide tokens, versus "/..../" as a regex token.  If the 
    //     parser sees a "/" in a place where a divide is not allowed, but a regex would be, then
    //     it can call into the source and ask if a regex token could be returned instead.  The 
    //     sources are smart enough to do that and not be affected by any additional work they may
    //     have done when they originally scanned that token.
    interface IParserSource {
        // The absolute index that the current token starts at.  'currentToken' and 'currentNode'
        // have their fullStart at this position.  previousToken has it's fullEnd at this position.
        absolutePosition(): number;

        // The token that comes before the 'currentToken' that hte source is pointing at. Initially
        // null. 
        previousToken(): ISyntaxToken;

        // The current syntax node the source is pointing at.  Only available in incremental settings.
        // The source can point at a node if that node doesn't intersect any of the text changes in
        // the file, and doesn't contain certain unacceptable constructs.  For example, if the node
        // contains skipped text, then it will not be reused.
        currentNode(): SyntaxNode;

        // The current token the source is pointing at.
        currentToken(): ISyntaxToken;

        // The current token reinterpretted as a regex token.  This must only be called when the 
        // source is pointing at a "/" or "/=" token. 
        currentTokenAllowingRegularExpression(): ISyntaxToken;

        // Peek any number of tokens ahead from the current location in source.  peekToken(0) is
        // equivalent to 'currentToken', peekToken(1) is the next token, peekToken(2) the token
        // after that, etc.  If the caller peeks past the end of the text, then EndOfFile tokens
        // will be returned.
        peekToken(n: number): ISyntaxToken;

        // Called to move the source to the next node or token once the parser has consumed the 
        // current one.
        moveToNextNode(): void;
        moveToNextToken(): void;

        // Gets a rewind point that the parser can use to move back to after it speculatively 
        // parses something.  The source guarantees that if the parser calls 'rewind' with that 
        // point that it will be mostly in the same state that it was in when 'getRewindPoint'
        // was called.  i.e. calling currentToken, peekToken, tokenDiagnostics, etc. will result
        // in the same values.  One allowed exemption to this is 'currentNode'.  If a rewind point
        // is requested and rewound, then getting the currentNode may not be possible.  However,
        // as this is purely a performance optimization, it will not affect correctness.
        //
        // Note: that rewind points are not free (but they should also not be too expensive).  So
        // they should be used judiciously.  While a rewind point is held by the parser, the source
        // is not free to do things that it would normally do.  For example, it cannot throw away
        // tokens that it has scanned on or after the rewind point as it must keep them alive for
        // the parser to move back to.
        //
        // Rewind points also work in a stack fashion.  The first rewind point given out must be
        // the last rewind point released.  Do not release them out of order, or bad things can 
        // happen.
        //
        // Do *NOT* forget to release a rewind point.  Always put them in a finally block to ensure
        // that they are released.  If they are not released, things will still work, you will just
        // consume far more memory than necessary.
        getRewindPoint(): IParserRewindPoint;

        // Rewinds the source to the position and state it was at when this rewind point was created.
        // This does not need to be called if the parser decides it does not need to rewind.  For 
        // example, the parser may speculatively parse out a lambda expression when it sees something
        // ambiguous like "(a = b, c = ...".  If it succeeds parsing that as a lambda, then it will
        // just return that result.  However, if it fails *then* it will rewind and try it again as
        // a parenthesized expression.  
        rewind(rewindPoint: IParserRewindPoint): void;

        // Called when the parser is done speculative parsing and no longer needs the rewind point.
        // Must be called for every rewing point retrived.
        releaseRewindPoint(rewindPoint: IParserRewindPoint): void;

        // Retrieves the diagnostics generated while the source was producing nodes or tokens. 
        // Should generally only be called after the document has been completely parsed.
        tokenDiagnostics(): SyntaxDiagnostic[];
        
        languageVersion(): LanguageVersion;
    }

    // Parser source used in batch scenarios.  Directly calls into an underlying text scanner and
    // supports none of the functionality to reuse nodes.  Good for when you just want want to do
    // a single parse of a file.
    class NormalParserSource implements IParserSource {
        // The sliding window that we store tokens in.
        private slidingWindow: SlidingWindow;

        // The scanner we're pulling tokens from.
        private scanner: Scanner1;

        // The previous token to the current token.  Set when we advance to the next token.
        private _previousToken: ISyntaxToken = null;

        // The absolute position we're at in the text we're reading from.
        private _absolutePosition: number = 0;

        // The diagnostics we get while scanning.  Note: this never gets rewound when we do a normal
        // rewind.  That's because rewinding doesn't affect the tokens created.  It only affects where
        // in the token stream we're pointing at.  However, it will get modified if we we decide to
        // reparse a / or /= as a regular expression.
        private _tokenDiagnostics: SyntaxDiagnostic[] = [];

        // Pool of rewind points we give out if the parser needs one.
        private rewindPointPool: IParserRewindPoint[] = [];
        private rewindPointPoolCount = 0;

        constructor(fileName: string,
                    text: ISimpleText,
                    languageVersion: LanguageVersion) {
            this.slidingWindow = new SlidingWindow(this, ArrayUtilities.createArray(/*defaultWindowSize:*/ 32, null), null);
            this.scanner = new Scanner1(fileName, text, languageVersion);
        }

        public languageVersion(): LanguageVersion {
            return this.scanner.languageVersion();
        }

        private currentNode(): SyntaxNode {
            // The normal parser source never returns nodes.  They're only returned by the 
            // incremental parser source.
            return null;
        }

        private moveToNextNode(): void {
            // Should never get called.
            throw Errors.invalidOperation();
        }

        public absolutePosition() {
            return this._absolutePosition;
        }

        public previousToken(): ISyntaxToken {
            return this._previousToken;
        }

        public tokenDiagnostics(): SyntaxDiagnostic[] {
            return this._tokenDiagnostics;
        }

        private getOrCreateRewindPoint(): IParserRewindPoint {
            if (this.rewindPointPoolCount === 0) {
                return <IParserRewindPoint>{};
            }

            this.rewindPointPoolCount--;
            var result = this.rewindPointPool[this.rewindPointPoolCount];
            this.rewindPointPool[this.rewindPointPoolCount] = null;
            return result;
        }

        public getRewindPoint(): IParserRewindPoint {
            var slidingWindowIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            var rewindPoint = this.getOrCreateRewindPoint();

            rewindPoint.slidingWindowIndex = slidingWindowIndex;
            rewindPoint.previousToken = this._previousToken;
            rewindPoint.absolutePosition = this._absolutePosition;

            rewindPoint.pinCount = this.slidingWindow.pinCount();

            return rewindPoint;
        }

        public isPinned(): bool {
            return this.slidingWindow.pinCount() > 0;
        }

        public rewind(rewindPoint: IParserRewindPoint): void {
            this.slidingWindow.rewindToPinnedIndex(rewindPoint.slidingWindowIndex);

            this._previousToken = rewindPoint.previousToken;
            this._absolutePosition = rewindPoint.absolutePosition;
        }

        public releaseRewindPoint(rewindPoint: IParserRewindPoint): void {
            // Debug.assert(this.slidingWindow.pinCount() === rewindPoint.pinCount);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex((<any>rewindPoint).absoluteIndex);

            this.rewindPointPool[this.rewindPointPoolCount] = rewindPoint;
            this.rewindPointPoolCount++;
        }

        private fetchMoreItems(allowRegularExpression: bool, sourceIndex: number, window: any[], destinationIndex: number, spaceAvailable: number): number {
            // Assert disabled because it is actually expensive enugh to affect perf.
            // Debug.assert(spaceAvailable > 0);
            window[destinationIndex] = this.scanner.scan(this._tokenDiagnostics, allowRegularExpression);
            return 1;
        }

        public peekToken(n: number): ISyntaxToken {
            return this.slidingWindow.peekItemN(n);
        }

        public moveToNextToken(): void {
            var currentToken = this.currentToken();
            this._absolutePosition += currentToken.fullWidth();
            this._previousToken = currentToken;

            this.slidingWindow.moveToNextItem();
        }

        public currentToken(): ISyntaxToken {
            return this.slidingWindow.currentItem(/*allowRegularExpression:*/ false);
        }

        private removeDiagnosticsOnOrAfterPosition(position: number): void {
            // walk backwards, removing any diagnostics that came after the the current token's
            // full start position.
            var tokenDiagnosticsLength = this._tokenDiagnostics.length;
            while (tokenDiagnosticsLength > 0) {
                var diagnostic = this._tokenDiagnostics[tokenDiagnosticsLength - 1];
                if (diagnostic.start() >= position) {
                    tokenDiagnosticsLength--;
                }
                else {
                    break;
                }
            }

            this._tokenDiagnostics.length = tokenDiagnosticsLength;
        }

        public resetToPosition(absolutePosition: number, previousToken: ISyntaxToken): void {
            this._absolutePosition = absolutePosition;
            this._previousToken = previousToken;

            // First, remove any diagnostics that came after this position.
            this.removeDiagnosticsOnOrAfterPosition(absolutePosition);

            // Now, tell our sliding window to throw away all tokens after this position as well.
            this.slidingWindow.disgardAllItemsFromCurrentIndexOnwards();

            // Now tell the scanner to reset its position to this position as well.  That way
            // when we try to scan the next item, we'll be at the right location.
            this.scanner.setAbsoluteIndex(absolutePosition);
        }

        public currentTokenAllowingRegularExpression(): ISyntaxToken {
            // We better be on a divide token right now.
            // Debug.assert(SyntaxFacts.isAnyDivideToken(this.currentToken().tokenKind));

            // First, we're going to rewind all our data to the point where this / or /= token started.
            // That's because if it does turn out to be a regular expression, then any tokens or token 
            // diagnostics we produced after the original / may no longer be valid.  This would actually
            // be a  fairly expected case.  For example, if you had:  / ... gibberish ... /, we may have 
            // produced several diagnostics in the process of scanning the tokens after the first / as
            // they may not have been legal javascript okens.
            //
            // We also need to remove all the tokens we've gotten from the slash and onwards.  They may
            // not have been what the scanner would have produced if it decides that this is actually
            // a regular expresion.
            this.resetToPosition(this._absolutePosition, this._previousToken);

            // Now actually fetch the token again from the scanner. This time let it know that it
            // can scan it as a regex token if it wants to.
            var token = this.slidingWindow.currentItem(/*allowRegularExpression:*/ true);

            // We have better gotten some sort of regex token.  Otherwise, something *very* wrong has
            // occurred.
            // Debug.assert(SyntaxFacts.isAnyDivideOrRegularExpressionToken(token.tokenKind));

            return token;
        }
    }

    // Parser source used in incremental scenarios. This parser source wraps an old tree, text 
    // change and new text, and uses all three to provide nodes and tokens to the parser.  In
    // general, nodes from the old tree are returned as long as they do not intersect with the text 
    // change.  Then, once the text change is reached, tokens from the old tree are returned as 
    // long as they do not intersect with the text change.  Then, the text that is actually changed
    // will be scanned using a normal scanner.  Then, once the new text is scanned, the source will
    // attempt to sync back up with nodes or tokens that started where the new tokens end. Once it
    // can do that, then all subsequent data will come from the original tree.
    //
    // This allows for an enormous amount of tree reuse in common scenarios.  Situations that 
    // prevent this level of reuse include substantially destructive operations like introducing
    // "/*" without a "*/" nearby to terminate the comment.
    class IncrementalParserSource implements IParserSource {
        // The underlying parser source that we will use to scan tokens from any new text, or any 
        // tokens from the old tree that we decide we can't use for any reason.  We will also 
        // continue scanning tokens from this source until we've decided that we're resynchronized
        // and can read in subsequent data from the old tree.
        //
        // This parser source also keeps track of the absolute position in the text that we're in,
        // the previous token, and any token diagnostics produced.  That way we dont' have to track
        // that ourselves.
        private _normalParserSource: NormalParserSource;

        // The range of text in the *original* text that was changed, and the new length of it after
        // the change.
        private _changeRange: TextChangeRange;

        // This number represents how our position in the old tree relates to the position we're 
        // pointing at in the new text.  If it is 0 then our positions are in sync and we can read
        // nodes or tokens from the old tree.  If it is non-zero, then our positions are not in 
        // sync and we cannot use nodes or tokens from the old tree.
        //
        // Now, changeDelta could be negative or positive.  Negative means 'the position we're at
        // in the original tree is behind the position we're at in the text'.  In this case we 
        // keep throwing out old nodes or tokens (and thus move forward in the original tree) until
        // changeDelta becomes 0 again or positive.  If it becomes 0 then we are resynched and can
        // read nodes or tokesn from the tree.
        //
        // If changeDelta is positive, that means the current node or token we're pointing at in 
        // the old tree is at a further ahead position than the position we're pointing at in the
        // new text.  In this case we have no choice but to scan tokens from teh new text.  We will
        // continue to do so until, again, changeDelta becomes 0 and we've resynced, or change delta
        // becomes negative and we need to skip nodes or tokes in the original tree.
        private _changeDelta: number = 0;

        // The cursor we use to navigate through and retrieve nodes and tokens from the old tree.
        private _oldSourceUnitCursor: SyntaxCursor;

        constructor(oldSyntaxTree: SyntaxTree,
                    textChangeRange: TextChangeRange,
                    newText: ISimpleText) {
            var oldSourceUnit = oldSyntaxTree.sourceUnit();
            this._oldSourceUnitCursor = new SyntaxCursor(oldSourceUnit);

            // In general supporting multiple individual edits is just not that important.  So we 
            // just collapse this all down to a single range to make the code here easier.  The only
            // time this could be problematic would be if the user made a ton of discontinuous edits.
            // For example, doing a column select on a *large* section of a code.  If this is a 
            // problem, we can always update this code to handle multiple changes.
            this._changeRange = IncrementalParserSource.extendToAffectedRange(textChangeRange, oldSourceUnit);

            // The old tree's length, plus whatever length change was caused by the edit better 
            // equal the new text's length!
            // Debug.assert((oldSourceUnit.fullWidth() - this._changeRange.span().length() + this._changeRange.newLength()) === newText.length());

            // Set up a scanner so that we can scan tokens out of the new text.
            this._normalParserSource = new NormalParserSource(oldSyntaxTree.fileName(), newText, oldSyntaxTree.languageVersion());
        }

        private static extendToAffectedRange(changeRange:TextChangeRange,
                                             sourceUnit: SourceUnitSyntax): TextChangeRange {
            // Consider the following code:
            //      void foo() { /; }
            //
            // If the text changes with an insertion of / just before the semicolon then we end up with:
            //      void foo() { //; }
            //
            // If we were to just use the changeRange a is, then we would not rescan the { token 
            // (as it does not intersect hte actual original change range).  Because an edit may
            // change the token touching it, we actually need to look back *at least* one token so
            // that the prior token sees that change.  
            //
            // Note: i believe (outside of regex tokens) max lookahead is just one token for 
            // TypeScript.  However, if this turns out to be wrong, we may have to increase how much
            // futher we look back. 
            //
            // Note: lookahead handling for regex characters is handled specially in during 
            // incremental parsing, and does not need to be handled here.

            var maxLookahead = 1;

            var start = changeRange.span().start();

            // the first iteration aligns us with the change start. subsequent iteration move us to
            // the left by maxLookahead tokens.  We only need to do this as long as we're not at the
            // start of the tree.
            for (var i = 0; start > 0 && i <= maxLookahead; i++) {
                var token = sourceUnit.findToken(start);

                // Debug.assert(token.kind() !== SyntaxKind.None);
                // Debug.assert(token.kind() === SyntaxKind.EndOfFileToken || token.fullWidth() > 0);

                var position = token.fullStart();

                start = MathPrototype.max(0, position - 1);
            }

            var finalSpan = TextSpan.fromBounds(start, changeRange.span().end());
            var finalLength = changeRange.newLength() + (changeRange.span().start() - start);

            return new TextChangeRange(finalSpan, finalLength);
        }

        public languageVersion(): LanguageVersion {
            return this._normalParserSource.languageVersion();
        }

        public absolutePosition() {
            return this._normalParserSource.absolutePosition();
        }

        public previousToken() {
            return this._normalParserSource.previousToken();
        }

        private tokenDiagnostics(): SyntaxDiagnostic[] {
            return this._normalParserSource.tokenDiagnostics();
        }

        private getRewindPoint(): IParserRewindPoint {
            // Get a rewind point for our new text reader and for our old source unit cursor.
            var rewindPoint = this._normalParserSource.getRewindPoint();
            var oldSourceUnitCursorIndex = this._oldSourceUnitCursor.getAndPinCursorIndex();

            // Store where we were when the rewind point was created.
            rewindPoint.changeDelta = this._changeDelta;
            rewindPoint.changeRange = this._changeRange;
            rewindPoint.oldSourceUnitCursorIndex = oldSourceUnitCursorIndex;

            // Debug.assert(rewindPoint.pinCount === this._oldSourceUnitCursor.pinCount());

            return rewindPoint;
        }

        private rewind(rewindPoint: IParserRewindPoint): void {
            // Restore our state to the values when the rewind point was created.
            this._changeRange = rewindPoint.changeRange;
            this._changeDelta = rewindPoint.changeDelta;
            this._oldSourceUnitCursor.rewindToPinnedCursorIndex(rewindPoint.oldSourceUnitCursorIndex);

            this._normalParserSource.rewind(rewindPoint);
        }

        private releaseRewindPoint(rewindPoint: IParserRewindPoint): void {
            // Release both the new text reader and the old text cursor.
            this._oldSourceUnitCursor.releaseAndUnpinCursorIndex(rewindPoint.oldSourceUnitCursorIndex);
            this._normalParserSource.releaseRewindPoint(rewindPoint);
        }

        private canReadFromOldSourceUnit() {
            // If we're currently pinned, then do not want to touch the cursor.  If we end up 
            // reading from the old source unit, we'll try to then set the position of the normal
            // parser source to an absolute position (in moveToNextToken).  Doing is unsupported
            // while the underlying source is pinned.
            if (this._normalParserSource.isPinned()) {
                return false;
            }

            // If our current absolute position is in the middle of the changed range in the new text
            // then we definitely can't read from the old source unit right now.
            if (this._changeRange !== null && this._changeRange.newSpan().intersectsWithPosition(this.absolutePosition())) {
                return false;
            }

            // First, try to sync up with the new text if we're behind.
            this.syncCursorToNewTextIfBehind();

            // Now, if we're synced up *and* we're not currently pinned in the new text scanner,
            // then we can read a node from the cursor.  If we're pinned in the scanner then we
            // can't read a node from the cursor because we will mess up the pinned scanner when
            // we try to move it forward past this node.
            return this._changeDelta === 0 &&
                   !this._oldSourceUnitCursor.isFinished();
        }
        
        public currentNode(): SyntaxNode {
            if (this.canReadFromOldSourceUnit()) {
                // Try to read a node.  If we can't then our caller will call back in and just try
                // to get a token.
                return this.tryGetNodeFromOldSourceUnit();
            }

            // Either we were ahead of the old text, or we were pinned.  No node can be read here.
            return null;
        }

        public currentToken(): ISyntaxToken {
            if (this.canReadFromOldSourceUnit()) {
                var token = this.tryGetTokenFromOldSourceUnit();
                if (token !== null) {
                    return token;
                }
            }

            // Either we couldn't read from the old source unit, or we weren't able to successfully
            // get a token from it.  In this case we need to read a token from the underlying text.
            return this._normalParserSource.currentToken();
        }

        public currentTokenAllowingRegularExpression(): ISyntaxToken {
            // Just delegate to the underlying source to handle this.
            return this._normalParserSource.currentTokenAllowingRegularExpression();
        }

        private syncCursorToNewTextIfBehind() {
            while (true) {
                if (this._oldSourceUnitCursor.isFinished()) {
                    // Can't sync up if the cursor is finished.
                    break;
                }

                if (this._changeDelta >= 0) {
                    // Nothing to do if we're synced up or ahead of the text.
                    break;
                }

                // We're behind in the original tree.  Throw out a node or token in an attempt to 
                // catch up to the position we're at in the new text.

                var currentElement = this._oldSourceUnitCursor.currentElement();

                // If we're pointing at a node, and that node's width is less than our delta,
                // then we can just skip that node.  Otherwise, if we're pointing at a node
                // whose width is greater than the delta, then crumble it and try again.
                // Otherwise, we must be pointing at a token.  Just skip it and try again.
                    
                if (currentElement.isNode() && (currentElement.fullWidth() > Math.abs(this._changeDelta))) {
                    // We were pointing at a node whose width was more than changeDelta.  Crumble the 
                    // node and try again.  Note: we haven't changed changeDelta.  So the callers loop
                    // will just repeat this until we get to a node or token that we can skip over.
                    this._oldSourceUnitCursor.moveToFirstChild();
                }
                else {
                    this._oldSourceUnitCursor.moveToNextSibling();

                    // Get our change delta closer to 0 as we skip past this item.
                    this._changeDelta += currentElement.fullWidth();

                    // If this was a node, then our changeDelta is 0 or negative.  If this was a 
                    // token, then we could still be negative (and we have to read another token),
                    // we could be zero (we're done), or we could be positive (we've moved ahead
                    // of the new text).  Only if we're negative will we continue looping.
                }
            }

            // At this point, we must be either:
            //   a) done with the cursor
            //   b) (ideally) caught up to the new text position.
            //   c) ahead of the new text position.
            // In case 'b' we can try to reuse a node from teh old tree.
            // Debug.assert(this._oldSourceUnitCursor.isFinished() || this._changeDelta >= 0);
        }

        private intersectsWithChangeRangeSpanInOriginalText(start: number, length: number) {
            return this._changeRange !== null && this._changeRange.span().intersectsWith(start, length);
        }

        private tryGetNodeFromOldSourceUnit(): SyntaxNode {
            // Debug.assert(this.canReadFromOldSourceUnit());

            // Keep moving the cursor down to the first node that is safe to return.  A node is 
            // safe to return if:
            //  a) it does not intersect the changed text.
            //  b) it does not contain skipped text.
            //  c) it does not have any zero width tokens in it.
            //  d) it does not have a regex token in it.
            //
            // TODO: we should also only be able to get a node if we're in the same 'strict' 
            // context we were in when we parsed the node.
            while (true) {
                var node = this._oldSourceUnitCursor.currentNode();
                if (node === null) {
                    // Couldn't even read a node, nothing to return.
                    return null;
                }

                if (!this.intersectsWithChangeRangeSpanInOriginalText(this.absolutePosition(), node.fullWidth())) {
                    // Didn't intersect with the change range.
                    if (!node.hasSkippedText() &&
                        !node.hasZeroWidthToken() &&
                        !node.hasRegularExpressionToken()) {

                        // Didn't contain anything that would make it unusable.  Awesome.  This is
                        // a node we can reuse.
                        return node;
                    }
                }

                // We couldn't use currentNode. Try to move to its first child (in case that's a 
                // node).  If it is we can try using that.  Otherwise we'll just bail out in the
                // next iteration of the loop.
                this._oldSourceUnitCursor.moveToFirstChild();
            }
        }

        private canReuseTokenFromOldSourceUnit(position: number, token: ISyntaxToken): bool {
            // A token is safe to return if:
            //  a) it does not intersect the changed text.
            //  b) it does not contain skipped text.
            //  c) it is not zero width.
            //  d) it is not a regex token.
            //  e) it is not a parser generated token.
            //
            // NOTE: It is safe to get a token regardless of what our strict context was/is.  That's 
            // because the strict context doesn't change what tokens are scanned, only how the 
            // parser reacts to them.

            if (token !== null) {
                if (!this.intersectsWithChangeRangeSpanInOriginalText(position, token.fullWidth())) {
                    // Didn't intersect with the change range.
                    if (!token.hasSkippedText() &&
                        token.width() > 0 &&
                        !SyntaxFacts.isAnyDivideOrRegularExpressionToken(token.tokenKind) &&
                        !SyntaxFacts.isParserGenerated(token.tokenKind)) {

                        // Didn't contain anything that would make it unusable.  Awesome.  This is
                        // a token we can reuse.
                        return true;
                    }
                }
            }

            return false;
        }

        private tryGetTokenFromOldSourceUnit(): ISyntaxToken {
            // Debug.assert(this.canReadFromOldSourceUnit());

            // get the current token that the cursor is pointing at.
            var token = this._oldSourceUnitCursor.currentToken();

            return this.canReuseTokenFromOldSourceUnit(this.absolutePosition(), token) 
                ? token : null;
        }

        public peekToken(n: number): ISyntaxToken {
            if (this.canReadFromOldSourceUnit()) {
                var token = this.tryPeekTokenFromOldSourceUnit(n);
                if (token !== null) {
                    return token;
                }
            }

            // Couldn't peek this far in the old tree.  Get the token from the new text.
            return this._normalParserSource.peekToken(n);
        }

        private tryPeekTokenFromOldSourceUnit(n: number): ISyntaxToken {
            // Debug.assert(this.canReadFromOldSourceUnit());

            // In order to peek the 'nth' token we need all the tokens up to that point.  That way
            // we know we know position that the nth token is at.  The position is necessary so 
            // that we can test if this token (or any that precede it cross the change range).
            var currentPosition = this.absolutePosition();
            for (var i = 0; i < n; i++) {
                var interimToken = this._oldSourceUnitCursor.peekToken(i);
                if (!this.canReuseTokenFromOldSourceUnit(currentPosition, interimToken)) {
                    return null;
                }

                currentPosition += interimToken.fullWidth();
            }

            var token = this._oldSourceUnitCursor.peekToken(n);
            return this.canReuseTokenFromOldSourceUnit(currentPosition, token) 
                ? token : null;
        }

        private moveToNextNode(): void {
            // A node could have only come from the old source unit cursor.  Update it and our 
            // current state.
            // Debug.assert(this._changeDelta === 0);

            // Get the current node we were pointing at, and move to the next element.
            var currentElement = this._oldSourceUnitCursor.currentElement();
            var currentNode = this._oldSourceUnitCursor.currentNode();

            // We better still be pointing at the node.
            // Debug.assert(currentElement === currentNode);
            this._oldSourceUnitCursor.moveToNextSibling();

            // Update the underlying source with where it should now be currently pointing, and 
            // what the previous token is before that position.
            var absolutePosition = this.absolutePosition() + currentNode.fullWidth();
            var previousToken = currentNode.lastToken();
            this._normalParserSource.resetToPosition(absolutePosition, previousToken);

            // Debug.assert(previousToken !== null);
            // Debug.assert(previousToken.width() > 0);

            if (this._changeRange !== null) {
                // If we still have a change range, then this node must have ended before the 
                // change range starts.  Thus, we don't need to call 'skipPastChanges'.
                // Debug.assert(this.absolutePosition() < this._changeRange.span().start());
            }
        }

        private moveToNextToken(): void {
            // This token may have come from the old source unit, or from the new text.  Handle
            // both accordingly.
            var currentToken = this.currentToken();

            if (this._oldSourceUnitCursor.currentToken() === currentToken) {
                // The token came from the old source unit.  So our tree and text must be in sync.
                // Debug.assert(this._changeDelta === 0);

                // Move the cursor past this token.
                this._oldSourceUnitCursor.moveToNextSibling();

                // Debug.assert(!this._normalParserSource.isPinned());
                
                // Update the underlying source with where it should now be currently pointing, and 
                // what the previous token is before that position.  We don't need to do this when
                // the token came from the new text as the source will automatically be placed in
                // the right position.
                var absolutePosition = this.absolutePosition() + currentToken.fullWidth();
                var previousToken = currentToken;
                this._normalParserSource.resetToPosition(absolutePosition, previousToken);

                // Debug.assert(previousToken !== null);
                // Debug.assert(previousToken.width() > 0);

                if (this._changeRange !== null) {
                    // If we still have a change range, then this token must have ended before the 
                    // change range starts.  Thus, we don't need to call 'skipPastChanges'.
                    // Debug.assert(this.absolutePosition() < this._changeRange.span().start());
                }
            }
            else {
                // the token came from the new text.  We have to update our delta appropriately.
                this._changeDelta -= currentToken.fullWidth();

                // Move our underlying source forward.
                this._normalParserSource.moveToNextToken();

                // Because we read a token from the new text, we may have moved ourselves past the
                // change range.  If we did, then we may also have to update our change delta to
                // compensate for the length change between the old and new text.
                if (this._changeRange !== null) {
                    // var changeEndInNewText = this._changeRange.span().start() + this._changeRange.newLength();
                    var changeRangeSpanInNewText = this._changeRange.newSpan();
                    if (this.absolutePosition() >= changeRangeSpanInNewText.end()) {
                        this._changeDelta += this._changeRange.newLength() - this._changeRange.span().length();
                        this._changeRange = null;
                    }
                }
            }
        }
    }

    // Contains the actual logic to parse typescript/javascript.  This is the code that generally
    // represents the logic necessary to handle all the language grammar constructs.  When the 
    // language changes, this should generally only be the place necessary to fix up.
    class ParserImpl {
        // Underlying source where we pull nodes and tokens from.
        private source: IParserSource;
        private fileName: string;
        private lineMap: LineMap;

        private parseOptions: ParseOptions;

        // TODO: do we need to store/restore this when speculative parsing?  I don't think so.  The
        // parsing logic already handles storing/restoring this and should work properly even if we're
        // speculative parsing.
        private listParsingState: ListParsingState = 0;

        // Whether or not we are in strict parsing mode.  All that changes in strict parsing mode is
        // that some tokens that would be considered identifiers may be considered keywords.  When 
        // rewinding, we need to store and restore this as the mode may have changed.
        //
        // TODO: do we need to store/restore this when speculative parsing?  I don't think so.  The
        // parsing logic already handles storing/restoring this and should work properly even if we're
        // speculative parsing.
        private isInStrictMode: bool = false;

        // Current state of the parser.  If we need to rewind we will store and reset these values as
        // appropriate.

        // Diagnostics created when parsing invalid code.  Any diagnosics created when speculative 
        // parsing need to removed when rewinding.  To do this we store the count of diagnostics when 
        // we start speculative parsing.  And if we rewind, we restore this to the same count that we 
        // started at.
        private diagnostics: SyntaxDiagnostic[] = [];

        private factory: Syntax.IFactory = Syntax.normalModeFactory;

        constructor(fileName: string, lineMap: LineMap, source: IParserSource, parseOptions: ParseOptions) {
            this.fileName = fileName;
            this.lineMap = lineMap;
            this.source = source;
            this.parseOptions = parseOptions;
        }

        private getRewindPoint(): IParserRewindPoint {
            var rewindPoint = this.source.getRewindPoint();

            rewindPoint.diagnosticsCount = this.diagnostics.length;

            // Values we keep around for debug asserting purposes.
            rewindPoint.isInStrictMode = this.isInStrictMode;
            rewindPoint.listParsingState = this.listParsingState;

            return rewindPoint;
        }

        private rewind(rewindPoint: IParserRewindPoint): void {
            this.source.rewind(rewindPoint);

            this.diagnostics.length = rewindPoint.diagnosticsCount;
        }

        private releaseRewindPoint(rewindPoint: IParserRewindPoint): void {
            // Debug.assert(this.listParsingState === rewindPoint.listParsingState);
            // Debug.assert(this.isInStrictMode === rewindPoint.isInStrictMode);

            this.source.releaseRewindPoint(rewindPoint);
        }

        private currentTokenStart(): number {
            return this.source.absolutePosition() + this.currentToken().leadingTriviaWidth();
        }

        private previousTokenStart(): number {
            if (this.previousToken() === null) {
                return 0;
            }
            
            return this.source.absolutePosition() -
                   this.previousToken().fullWidth() +
                   this.previousToken().leadingTriviaWidth();
        }

        private previousTokenEnd(): number {
            if (this.previousToken() === null) {
                return 0;
            }

            return this.previousTokenStart() + this.previousToken().width();
        }

        private currentNode(): SyntaxNode {
            var node = this.source.currentNode();

            // We can only reuse a node if it was parsed under the same strict mode that we're 
            // currently in.  i.e. if we originally parsed a node in non-strict mode, but then
            // the user added 'using strict' at hte top of the file, then we can't use that node
            // again as the presense of strict mode may cause us to parse the tokens in the file
            // differetly.
            //
            // Note: we *can* reuse tokens when the strict mode changes.  That's because tokens
            // are unaffected by strict mode.  It's just the parser will decide what to do with it
            // differently depending on what mode it is in.
            if (node === null || node.parsedInStrictMode() !== this.isInStrictMode) {
                return null;
            }

            return node;
        }

        private currentToken(): ISyntaxToken {
            return this.source.currentToken();
        }

        private currentTokenAllowingRegularExpression(): ISyntaxToken {
            return this.source.currentTokenAllowingRegularExpression();
        }

        private peekToken(n: number): ISyntaxToken {
            return this.source.peekToken(n);
        }

        private eatAnyToken(): ISyntaxToken {
            var token = this.currentToken();
            this.moveToNextToken();
            return token;
        }

        private moveToNextToken(): void {
            this.source.moveToNextToken();
        }

        private previousToken(): ISyntaxToken {
            return this.source.previousToken();
        }

        private eatNode(): SyntaxNode {
            var node = this.source.currentNode();
            this.source.moveToNextNode();
            return node;
        }

        //this method is called very frequently
        //we should keep it simple so that it can be inlined.
        private eatToken(kind: SyntaxKind): ISyntaxToken {
            // Assert disabled because it is actually expensive enugh to affect perf.
            // Debug.assert(SyntaxFacts.isTokenKind(kind))

            var token = this.currentToken();
            if (token.tokenKind === kind) {
                this.moveToNextToken();
                return token;
            }

            //slow part of EatToken(SyntaxKind kind)
            return this.createMissingToken(kind, token);
        }

        // Eats the token if it is there.  Otherwise does nothing.  Will not report errors.
        private tryEatToken(kind: SyntaxKind): ISyntaxToken {
            if (this.currentToken().tokenKind === kind) {
                return this.eatToken(kind);
            }

            return null;
        }

        // Eats the keyword if it is there.  Otherwise does nothing.  Will not report errors.
        private tryEatKeyword(kind: SyntaxKind): ISyntaxToken {
            if (this.currentToken().tokenKind === kind) {
                return this.eatKeyword(kind);
            }

            return null;
        }

        private eatKeyword(kind: SyntaxKind): ISyntaxToken {
            // Debug.assert(SyntaxFacts.isTokenKind(kind))

            var token = this.currentToken();
            if (token.tokenKind === kind) {
                this.moveToNextToken();
                return token;
            }

            //slow part of EatToken(SyntaxKind kind)
            return this.createMissingToken(kind, token);
        }

        // An identifier is basically any word, unless it is a reserved keyword.  so 'foo' is an 
        // identifier and 'return' is not.  Note: a word may or may not be an identifier depending 
        // on the state of the parser.  For example, 'yield' is an identifier *unless* the parser 
        // is in strict mode.
        private isIdentifier(token: ISyntaxToken): bool {
            var tokenKind = token.tokenKind;

            if (tokenKind === SyntaxKind.IdentifierName) {
                return true;
            }

            // Keywords are only identifiers if they're FutureReservedStrictWords and we're in 
            // strict mode.  *Or* if it's a typescript 'keyword'. 
            if (tokenKind >= SyntaxKind.FirstFutureReservedStrictKeyword) {
                if (tokenKind <= SyntaxKind.LastFutureReservedStrictKeyword) {
                    // Could be a keyword or identifier.  It's an identifier if we're not in strict
                    // mode.
                    return !this.isInStrictMode;
                }
                
                // If it's typescript keyword, then it's actually a javascript identifier.
                return tokenKind <= SyntaxKind.LastTypeScriptKeyword;
            }

            // Anything else is not an identifier.
            return false;
        }

        // This method should be called when the grammar calls for an *IdentifierName* and not an
        // *Identifier*.
        private eatIdentifierNameToken(): ISyntaxToken {
            var token = this.currentToken();

            // If we have an identifier name, then consume and return it.
            if (token.tokenKind === SyntaxKind.IdentifierName) {
                this.moveToNextToken();
                return token;
            }

            // If we have a keyword, then it cna be used as an identifier name.  However, we need 
            // to convert it to an identifier so that no later parts of the systems see it as a 
            // keyword.
            if (SyntaxFacts.isAnyKeyword(token.tokenKind)) {
                this.moveToNextToken();
                return Syntax.convertToIdentifierName(token);
            }

            return this.createMissingToken(SyntaxKind.IdentifierName, token);
        }

        // This method should be called when the grammar calls for an *Identifier* and not an
        // *IdentifierName*.
        private eatIdentifierToken(): ISyntaxToken {
            var token = this.currentToken();
            if (this.isIdentifier(token)) {
                this.moveToNextToken();
                return token;
            }

            return this.createMissingToken(SyntaxKind.IdentifierName, token);
        }

        private canEatAutomaticSemicolon(allowWithoutNewLine: bool): bool {
            var token = this.currentToken();

            // An automatic semicolon is always allowed if we're at the end of the file.
            if (token.tokenKind === SyntaxKind.EndOfFileToken) {
                return true;
            }

            // Or if the next token is a close brace (regardless of which line it is on).
            if (token.tokenKind === SyntaxKind.CloseBraceToken) {
                return true;
            }

            if (allowWithoutNewLine) {
                return true;
            }

            // It is also allowed if there is a newline between the last token seen and the next one.
            if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                return true;
            }

            return false;
        }

        private canEatExplicitOrAutomaticSemicolon(allowWithoutNewline: bool): bool {
            var token = this.currentToken();

            if (token.tokenKind === SyntaxKind.SemicolonToken) {
                return true;
            }

            return this.canEatAutomaticSemicolon(allowWithoutNewline);
        }

        private eatExplicitOrAutomaticSemicolon(allowWithoutNewline: bool): ISyntaxToken {
            var token = this.currentToken();

            // If we see a semicolon, then we can definitely eat it.
            if (token.tokenKind === SyntaxKind.SemicolonToken) {
                return this.eatToken(SyntaxKind.SemicolonToken);
            }

            // Check if an automatic semicolon could go here.  If so, synthesize one.  However, if the
            // user has the option set to error on automatic semicolons, then add an error to that
            // token as well.
            if (this.canEatAutomaticSemicolon(allowWithoutNewline)) {
                // Note: the missing token needs to go between real tokens.  So we place it at the 
                // fullstart of the current token.
                var semicolonToken = Syntax.emptyToken(SyntaxKind.SemicolonToken);

                if (!this.parseOptions.allowAutomaticSemicolonInsertion()) {
                    // Report the missing semicolon at the end of the *previous* token.

                    this.addDiagnostic(
                        new SyntaxDiagnostic(this.fileName, this.previousTokenEnd(), 0, DiagnosticCode.Automatic_semicolon_insertion_not_allowed, null));
                }

                return semicolonToken;
            }

            // No semicolon could be consumed here at all.  Just call the standard eating function
            // so we get the token and the error for it.
            return this.eatToken(SyntaxKind.SemicolonToken);
        }

        private isKeyword(kind: SyntaxKind): bool {
            if (kind >= SyntaxKind.FirstKeyword) {
                if (kind <= SyntaxKind.LastFutureReservedKeyword) {
                    return true;
                }

                if (this.isInStrictMode) {
                    return kind <= SyntaxKind.LastFutureReservedStrictKeyword;
                }
            }

            return false;
        }

        private createMissingToken(expectedKind: SyntaxKind, actual: ISyntaxToken): ISyntaxToken {
            var diagnostic = this.getExpectedTokenDiagnostic(expectedKind, actual);
            this.addDiagnostic(diagnostic);

            // The missing token will be at the full start of the current token.  That way empty tokens
            // will always be between real tokens and not inside an actual token.
            return Syntax.emptyToken(expectedKind);
        }

        private getExpectedTokenDiagnostic(expectedKind: SyntaxKind, actual: ISyntaxToken): SyntaxDiagnostic {
            var token = this.currentToken();

            // They wanted something specific, just report that that token was missing.
            if (SyntaxFacts.isAnyKeyword(expectedKind) || SyntaxFacts.isAnyPunctuation(expectedKind)) {
                return new SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token.width(), DiagnosticCode._0_expected, [SyntaxFacts.getText(expectedKind)]);
            }
            else {
                // They wanted an identifier.

                // If the user supplied a keyword, give them a specialized message.
                if (actual !== null && SyntaxFacts.isAnyKeyword(actual.tokenKind)) {
                    return new SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token.width(), DiagnosticCode.Identifier_expected__0_is_a_keyword, [SyntaxFacts.getText(actual.tokenKind)]);
                }
                else {
                    // Otherwise just report that an identifier was expected.
                    return new SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token.width(), DiagnosticCode.Identifier_expected, null);
                }
            }

            // throw Errors.notYetImplemented();
        }

        private static getPrecedence(expressionKind: SyntaxKind): ExpressionPrecedence {
            switch (expressionKind) {
                case SyntaxKind.CommaExpression:
                    return ExpressionPrecedence.CommaExpressionPrecedence;

                case SyntaxKind.AssignmentExpression:
                case SyntaxKind.AddAssignmentExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                case SyntaxKind.DivideAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                case SyntaxKind.SignedRightShiftAssignmentExpression:
                case SyntaxKind.UnsignedRightShiftAssignmentExpression:
                    return ExpressionPrecedence.AssignmentExpressionPrecedence;

                case SyntaxKind.ConditionalExpression:
                    return ExpressionPrecedence.ConditionalExpressionPrecedence;

                case SyntaxKind.LogicalOrExpression:
                    return ExpressionPrecedence.LogicalOrExpressionPrecedence;

                case SyntaxKind.LogicalAndExpression:
                    return ExpressionPrecedence.LogicalAndExpressionPrecedence;

                case SyntaxKind.BitwiseOrExpression:
                    return ExpressionPrecedence.BitwiseOrExpressionPrecedence;

                case SyntaxKind.BitwiseExclusiveOrExpression:
                    return ExpressionPrecedence.BitwiseExclusiveOrExpressionPrecedence;

                case SyntaxKind.BitwiseAndExpression:
                    return ExpressionPrecedence.BitwiseAndExpressionPrecedence;

                case SyntaxKind.EqualsWithTypeConversionExpression:
                case SyntaxKind.NotEqualsWithTypeConversionExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.NotEqualsExpression:
                    return ExpressionPrecedence.EqualityExpressionPrecedence;

                case SyntaxKind.LessThanExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.InstanceOfExpression:
                case SyntaxKind.InExpression:
                    return ExpressionPrecedence.RelationalExpressionPrecedence;

                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.SignedRightShiftExpression:
                case SyntaxKind.UnsignedRightShiftExpression:
                    return ExpressionPrecedence.ShiftExpressionPrecdence;

                case SyntaxKind.AddExpression:
                case SyntaxKind.SubtractExpression:
                    return ExpressionPrecedence.AdditiveExpressionPrecedence;

                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.ModuloExpression:
                    return ExpressionPrecedence.MultiplicativeExpressionPrecedence;

                case SyntaxKind.PlusExpression:
                case SyntaxKind.NegateExpression:
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.DeleteExpression:
                case SyntaxKind.TypeOfExpression:
                case SyntaxKind.VoidExpression:
                case SyntaxKind.PreIncrementExpression:
                case SyntaxKind.PreDecrementExpression:
                    return ExpressionPrecedence.UnaryExpressionPrecedence;
            }

            throw Errors.invalidOperation();
        }
        
        private addSkippedTokenAfterNodeOrToken(nodeOrToken: ISyntaxNodeOrToken, skippedToken: ISyntaxToken): ISyntaxNodeOrToken {
            if (nodeOrToken.isToken()) {
                return this.addSkippedTokenAfterToken(<ISyntaxToken>nodeOrToken, skippedToken);
            }
            else if (nodeOrToken.isNode()) {
                return this.addSkippedTokenAfterNode(<SyntaxNode>nodeOrToken, skippedToken);
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private addSkippedTokenAfterNode(node: SyntaxNode, skippedToken: ISyntaxToken): SyntaxNode {
            var oldToken = node.lastToken();
            var newToken = this.addSkippedTokenAfterToken(oldToken, skippedToken);

            return node.replaceToken(oldToken, newToken);
        }

        private addSkippedTokensBeforeNode(node: SyntaxNode, skippedTokens: ISyntaxToken[]): SyntaxNode {
            if (skippedTokens.length > 0) {
                var oldToken = node.firstToken();
                var newToken = this.addSkippedTokensBeforeToken(oldToken, skippedTokens);

                return node.replaceToken(oldToken, newToken);
            }

            return node;
        }

        private addSkippedTokensBeforeToken(token: ISyntaxToken, skippedTokens: ISyntaxToken[]): ISyntaxToken {
            // Debug.assert(token.fullWidth() > 0 || token.tokenKind === SyntaxKind.EndOfFileToken);
            // Debug.assert(skippedTokens.length > 0);

            var leadingTrivia: ISyntaxTrivia[] = [];
            for (var i = 0, n = skippedTokens.length; i < n; i++) {
                this.addSkippedTokenToTriviaArray(leadingTrivia, skippedTokens[i]);
            }

            this.addTriviaTo(token.leadingTrivia(), leadingTrivia);

            // Don't need this array anymore.  Give it back so we can reuse it.
            this.returnArray(skippedTokens);
            return token.withLeadingTrivia(Syntax.triviaList(leadingTrivia));
        }

        private addSkippedTokensAfterToken(token: ISyntaxToken, skippedTokens: ISyntaxToken[]): ISyntaxToken {
            // Debug.assert(token.fullWidth() > 0);
            if (skippedTokens.length === 0) {
                this.returnArray(skippedTokens);
                return token;
            }

            var trailingTrivia = token.trailingTrivia().toArray();

            for (var i = 0, n = skippedTokens.length; i < n; i++) {
                this.addSkippedTokenToTriviaArray(trailingTrivia, skippedTokens[i]);
            }

            // Don't need this array anymore.  Give it back so we can reuse it.
            this.returnArray(skippedTokens);
            return token.withTrailingTrivia(Syntax.triviaList(trailingTrivia));
        }

        private addSkippedTokenAfterToken(token: ISyntaxToken, skippedToken: ISyntaxToken): ISyntaxToken {
            // Debug.assert(token.fullWidth() > 0);

            var trailingTrivia = token.trailingTrivia().toArray();
            this.addSkippedTokenToTriviaArray(trailingTrivia, skippedToken);

            return token.withTrailingTrivia(Syntax.triviaList(trailingTrivia));
        }

        private addSkippedTokenToTriviaArray(array: ISyntaxTrivia[], skippedToken: ISyntaxToken): void {
            // Debug.assert(skippedToken.text().length > 0);
            
            // first, add the leading trivia of the skipped token to the array
            this.addTriviaTo(skippedToken.leadingTrivia(), array);

            // now, add the text of the token as skipped text to the trivia array.
            array.push(Syntax.trivia(SyntaxKind.SkippedTextTrivia, skippedToken.text()));

            // Finally, add the trailing trivia of the skipped token to the trivia array.
            this.addTriviaTo(skippedToken.trailingTrivia(), array);
        }

        private addTriviaTo(list: ISyntaxTriviaList, array: ISyntaxTrivia[]): void {
            for (var i = 0, n = list.count(); i < n; i++) {
                array.push(list.syntaxTriviaAt(i));
            }
        }

        public parseSyntaxTree(isDeclaration: bool): SyntaxTree {
            var sourceUnit = this.parseSourceUnit();

            var allDiagnostics = this.source.tokenDiagnostics().concat(this.diagnostics);
            //if (allDiagnostics.length === 0) {
                // If we have no scanner/parser errors, then also check for grammar errors as well.
                //if (isDeclaration) {
                    sourceUnit.accept(new GrammarCheckerWalker(/*allDiagnostics*/));
                //}
            //}

            allDiagnostics.sort((a: SyntaxDiagnostic, b: SyntaxDiagnostic) => a.start() - b.start());

            return new SyntaxTree(sourceUnit, isDeclaration, allDiagnostics, this.fileName, this.lineMap, this.source.languageVersion(), this.parseOptions);
        }

        private setStrictMode(isInStrictMode: bool) {
            this.isInStrictMode = isInStrictMode;
            this.factory = isInStrictMode ? Syntax.strictModeFactory : Syntax.normalModeFactory;
        }

        private parseSourceUnit(): SourceUnitSyntax {
            // Note: technically we don't need to save and restore this here.  After all, this the top
            // level parsing entrypoint.  So it will always start as false and be reset to false when the
            // loop ends.  However, for sake of symmetry and consistancy we do this.
            var savedIsInStrictMode = this.isInStrictMode;

            var result = this.parseSyntaxList(ListParsingState.SourceUnit_ModuleElements, ParserImpl.updateStrictModeState);
            var moduleElements = result.list;

            this.setStrictMode(savedIsInStrictMode);

            var sourceUnit = this.factory.sourceUnit(moduleElements, this.currentToken());
            sourceUnit = <SourceUnitSyntax>this.addSkippedTokensBeforeNode(sourceUnit, result.skippedTokens);

            return sourceUnit;
        }

        private static updateStrictModeState(parser: ParserImpl, items: any[]): void {
            if (!parser.isInStrictMode) {
                // Check if all the items are directive prologue elements.
                for (var i = 0; i < items.length; i++) {
                    var item = items[i];
                    if (!SyntaxFacts.isDirectivePrologueElement(item)) {
                        return;
                    }
                }

                parser.setStrictMode(SyntaxFacts.isUseStrictDirective(items[items.length - 1]));
            }
        }

        private isModuleElement(inErrorRecovery: bool): bool {
            if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                return true;
            }

            return this.isImportDeclaration() ||
                   this.isExportAssignment() ||
                   this.isModuleDeclaration() ||
                   this.isInterfaceDeclaration() ||
                   this.isClassDeclaration() ||
                   this.isEnumDeclaration() ||
                   this.isStatement(inErrorRecovery);
        }
        
        private parseModuleElement(): IModuleElementSyntax {
            if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                return <IModuleElementSyntax>this.eatNode();
            }

            if (this.isImportDeclaration()) {
                return this.parseImportDeclaration();
            }
            else if (this.isExportAssignment()) {
                return this.parseExportAssignment();
            }
            else if (this.isModuleDeclaration()) {
                return this.parseModuleDeclaration();
            }
            else if (this.isInterfaceDeclaration()) {
                return this.parseInterfaceDeclaration();
            }
            else if (this.isClassDeclaration()) {
                return this.parseClassDeclaration();
            }
            else if (this.isEnumDeclaration()) {
                return this.parseEnumDeclaration();
            }
            else if (this.isStatement(/*inErrorRecovery:*/ false)) {
                return this.parseStatement();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private isImportDeclaration(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ImportKeyword;
        }

        private parseImportDeclaration(): ImportDeclarationSyntax {
            // Debug.assert(this.isImportDeclaration());

            var importKeyword = this.eatKeyword(SyntaxKind.ImportKeyword);
            var identifier = this.eatIdentifierToken();
            var equalsToken = this.eatToken(SyntaxKind.EqualsToken);
            var moduleReference = this.parseModuleReference();
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.importDeclaration(importKeyword, identifier, equalsToken, moduleReference, semicolonToken);
        }

        private isExportAssignment(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ExportKeyword &&
                   this.peekToken(1).tokenKind === SyntaxKind.EqualsToken;
        }

        private parseExportAssignment(): ExportAssignmentSyntax {
            // Debug.assert(this.isExportAssignment());

            var exportKeyword = this.eatKeyword(SyntaxKind.ExportKeyword);
            var equalsToken = this.eatToken(SyntaxKind.EqualsToken);
            var identifier = this.eatIdentifierToken();
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.exportAssignment(exportKeyword, equalsToken, identifier, semicolonToken);
        }

        private parseModuleReference(): ModuleReferenceSyntax {
            if (this.isExternalModuleReference()) {
                return this.parseExternalModuleReference();
            }
            else {
                return this.parseModuleNameModuleReference();
            }
        }

        private isExternalModuleReference(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ModuleKeyword &&
                   this.peekToken(1).tokenKind === SyntaxKind.OpenParenToken;
        }

        private parseExternalModuleReference(): ExternalModuleReferenceSyntax {
            // Debug.assert(this.isExternalModuleReference());

            var moduleKeyword = this.eatKeyword(SyntaxKind.ModuleKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var stringLiteral = this.eatToken(SyntaxKind.StringLiteral);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            return this.factory.externalModuleReference(moduleKeyword, openParenToken, stringLiteral, closeParenToken);
        }

        private parseModuleNameModuleReference(): ModuleNameModuleReferenceSyntax {
            var name = this.parseName();
            return this.factory.moduleNameModuleReference(name);
        }

        // NOTE: This will allow all identifier names.  Even the ones that are keywords.
        private parseIdentifierName(): INameSyntax {
            var identifierName = this.eatIdentifierNameToken();
            return identifierName;
        }

        private isName(): bool {
            return this.isIdentifier(this.currentToken());
        }

        private tryParseTypeArgumentList(inExpression: bool): TypeArgumentListSyntax {
            if (this.currentToken().kind() !== SyntaxKind.LessThanToken) {
                return null;
            }

            var lessThanToken: ISyntaxToken;
            var greaterThanToken: ISyntaxToken;
            var result: { skippedTokens: ISyntaxToken[]; list: ISeparatedSyntaxList; };
            var typeArguments: ISeparatedSyntaxList;

            if (!inExpression) {
                // if we're not in an expression, this must be a type argument list.  Just parse
                // it out as such.
                lessThanToken = this.eatToken(SyntaxKind.LessThanToken);
                // Debug.assert(lessThanToken.fullWidth() > 0);

                result = this.parseSeparatedSyntaxList(ListParsingState.TypeArgumentList_Types);
                typeArguments = result.list;
                lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                greaterThanToken = this.eatToken(SyntaxKind.GreaterThanToken);

                return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
            }

            // If we're in an expression, then we only want to consume this as a type argument list
            // if we're sure that it's a type arg list and not an arithmetic expression.

            var rewindPoint = this.getRewindPoint();
            try {
                // We've seen a '<'.  Try to parse it out as a type argument list.
                lessThanToken = this.eatToken(SyntaxKind.LessThanToken);
                // Debug.assert(lessThanToken.fullWidth() > 0);

                result = this.parseSeparatedSyntaxList(ListParsingState.TypeArgumentList_Types);
                typeArguments = result.list;
                lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                greaterThanToken = this.eatToken(SyntaxKind.GreaterThanToken);

                // We're in a context where '<' could be the start of a type argument list, or part
                // of an arithmetic expression.  We'll presume it's the latter unless we see the '>'
                // and a following token that guarantees that it's supposed to be a type argument list.
                if (greaterThanToken.fullWidth() === 0 || !this.canFollowTypeArgumentListInExpression(this.currentToken().kind())) {
                    this.rewind(rewindPoint);
                    return null;
                }

                return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
            }
            finally {
                this.releaseRewindPoint(rewindPoint);
            }
        }

        private canFollowTypeArgumentListInExpression(kind: SyntaxKind): bool {
            switch (kind) {
                case SyntaxKind.OpenParenToken:                 // foo<x>(   
                case SyntaxKind.DotToken:                       // foo<x>.
                    // These two cases are the only cases where this token can legally follow a
                    // type argument list.  So we definitely want to treat this as a type arg list.

                case SyntaxKind.CloseParenToken:                // foo<x>)
                case SyntaxKind.CloseBracketToken:              // foo<x>]
                case SyntaxKind.ColonToken:                     // foo<x>:
                case SyntaxKind.SemicolonToken:                 // foo<x>;
                case SyntaxKind.CommaToken:                     // foo<x>,
                case SyntaxKind.QuestionToken:                  // foo<x>?
                case SyntaxKind.EqualsEqualsToken:              // foo<x> ==
                case SyntaxKind.EqualsEqualsEqualsToken:        // foo<x> ===
                case SyntaxKind.ExclamationEqualsToken:         // foo<x> !=
                case SyntaxKind.ExclamationEqualsEqualsToken:   // foo<x> !==
                case SyntaxKind.AmpersandAmpersandToken:        // foo<x> &&
                case SyntaxKind.BarBarToken:                    // foo<x> ||
                case SyntaxKind.CaretToken:                     // foo<x> ^
                case SyntaxKind.AmpersandToken:                 // foo<x> &
                case SyntaxKind.BarToken:                       // foo<x> |
                case SyntaxKind.CloseBraceToken:                // foo<x> }
                case SyntaxKind.EndOfFileToken:                 // foo<x>
                    // these cases can't legally follow a type arg list.  However, they're not legal 
                    // expressions either.  The user is probably in the middle of a generic type. So
                    // treat it as such.
                    return true;

                default:
                    // Anything else treat as an expression.
                    return false;
            }
        }

        private parseName(): INameSyntax {
            var shouldContinue = this.isIdentifier(this.currentToken());
            var current: INameSyntax = this.eatIdentifierToken();

            while (shouldContinue && this.currentToken().tokenKind === SyntaxKind.DotToken) {
                var dotToken = this.eatToken(SyntaxKind.DotToken);

                shouldContinue = SyntaxFacts.isIdentifierNameOrAnyKeyword(this.currentToken());
                var identifier = this.eatIdentifierNameToken();

                current = this.factory.qualifiedName(current, dotToken, identifier);
            }

            return current;
        }

        private isEnumDeclaration(): bool {
            var index = 0;
            var token0 = this.peekToken(index);

            if (token0.tokenKind === SyntaxKind.ExportKeyword &&
                this.peekToken(index + 1).tokenKind === SyntaxKind.EnumKeyword) {
                return true;
            }

            return token0.tokenKind === SyntaxKind.EnumKeyword &&
                   this.isIdentifier(this.peekToken(index + 1));
        }

        private parseEnumDeclaration(): EnumDeclarationSyntax {
            // Debug.assert(this.isEnumDeclaration());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var enumKeyword = this.eatKeyword(SyntaxKind.EnumKeyword);
            var identifier = this.eatIdentifierToken();

            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);
            var enumElements: ISeparatedSyntaxList = Syntax.emptySeparatedList;

            if (openBraceToken.width() > 0) {
                var result = this.parseSeparatedSyntaxList(ListParsingState.EnumDeclaration_EnumElements);
                enumElements = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);

            return this.factory.enumDeclaration(exportKeyword, enumKeyword, identifier,
                openBraceToken, enumElements, closeBraceToken);
        }

        private isEnumElement(): bool {
            if (this.currentNode() !== null && this.currentNode().kind() === SyntaxKind.EnumElement) {
                return true;
            }

            var token0 = this.currentToken();
            return SyntaxFacts.isIdentifierNameOrAnyKeyword(token0) ||
                   token0.tokenKind === SyntaxKind.StringLiteral;
        }

        private parseEnumElement(): EnumElementSyntax {
            // Debug.assert(this.isEnumElement());
            if (this.currentNode() !== null && this.currentNode().kind() === SyntaxKind.EnumElement) {
                return <EnumElementSyntax>this.eatNode();
            }

            var identifier: ISyntaxToken = null;
            var stringLiteral: ISyntaxToken = null;

            if (SyntaxFacts.isIdentifierNameOrAnyKeyword(this.currentToken())) {
                identifier = this.eatIdentifierNameToken();
            }
            else {
                stringLiteral = this.eatToken(SyntaxKind.StringLiteral);
            }

            var equalsValueClause: EqualsValueClauseSyntax = null;
            if (this.isEqualsValueClause(/*inParameter*/ false)) {
                equalsValueClause = this.parseEqualsValueClause(/*allowIn:*/ true);
            }

            return this.factory.enumElement(identifier, stringLiteral, equalsValueClause);
        }

        private isClassDeclaration(): bool {
            var index = 0;
            var token0 = this.peekToken(index);

            if (token0.tokenKind === SyntaxKind.ExportKeyword &&
                this.peekToken(index + 1).tokenKind === SyntaxKind.ClassKeyword) {
                return true;
            }

            if (token0.tokenKind === SyntaxKind.DeclareKeyword &&
                this.peekToken(index + 1).tokenKind === SyntaxKind.ClassKeyword) {
                return true;
            }

            return token0.tokenKind === SyntaxKind.ClassKeyword &&
                   this.isIdentifier(this.peekToken(index + 1));
        }

        private parseClassDeclaration(): ClassDeclarationSyntax {
            // Debug.assert(this.isClassDeclaration());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var declareKeyword = this.tryEatKeyword(SyntaxKind.DeclareKeyword);

            var classKeyword = this.eatKeyword(SyntaxKind.ClassKeyword);
            var identifier = this.eatIdentifierToken();
            var typeParameterList = this.parseOptionalTypeParameterList(/*requireCompleteTypeParameterList:*/ false);

            var extendsClause: ExtendsClauseSyntax = null;
            if (this.isExtendsClause()) {
                extendsClause = this.parseExtendsClause();
            }

            var implementsClause: ImplementsClauseSyntax = null;
            if (this.isImplementsClause()) {
                implementsClause = this.parseImplementsClause();
            }

            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);
            var classElements: ISyntaxList = Syntax.emptyList;

            if (openBraceToken.width() > 0) {
                var result = this.parseSyntaxList(ListParsingState.ClassDeclaration_ClassElements);

                classElements = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);
            return this.factory.classDeclaration(
                exportKeyword, declareKeyword, classKeyword, identifier, typeParameterList, extendsClause,
                implementsClause, openBraceToken, classElements, closeBraceToken);
        }

        private isConstructorDeclaration(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ConstructorKeyword;
        }

        private static isPublicOrPrivateKeyword(token: ISyntaxToken): bool {
            return token.tokenKind === SyntaxKind.PublicKeyword || token.tokenKind === SyntaxKind.PrivateKeyword;
        }

        private isMemberAccessorDeclaration(): bool {
            var index = 0;

            if (ParserImpl.isPublicOrPrivateKeyword(this.currentToken())) {
                index++;
            }

            if (this.peekToken(index).tokenKind === SyntaxKind.StaticKeyword) {
                index++;
            }

            if (this.peekToken(index).tokenKind !== SyntaxKind.GetKeyword &&
                this.peekToken(index).tokenKind !== SyntaxKind.SetKeyword) {
                return false;
            }

            index++;
            return this.isIdentifier(this.peekToken(index));
        }

        private parseMemberAccessorDeclaration(): MemberAccessorDeclarationSyntax {
            // Debug.assert(this.isMemberAccessorDeclaration());

            var publicOrPrivateKeyword: ISyntaxToken = null;
            if (ParserImpl.isPublicOrPrivateKeyword(this.currentToken())) {
                publicOrPrivateKeyword = this.eatAnyToken();
            }

            var staticKeyword = this.tryEatKeyword(SyntaxKind.StaticKeyword);

            if (this.currentToken().tokenKind === SyntaxKind.GetKeyword) {
                return this.parseGetMemberAccessorDeclaration(publicOrPrivateKeyword, staticKeyword);
            }
            else if (this.currentToken().tokenKind === SyntaxKind.SetKeyword) {
                return this.parseSetMemberAccessorDeclaration(publicOrPrivateKeyword, staticKeyword);
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private parseGetMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken,
                                                  staticKeyword: ISyntaxToken): GetMemberAccessorDeclarationSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.GetKeyword);

            var getKeyword = this.eatKeyword(SyntaxKind.GetKeyword);
            var identifier = this.eatIdentifierToken();
            var parameterList = this.parseParameterList();
            var typeAnnotation = this.parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false);
            var block = this.parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);

            return this.factory.getMemberAccessorDeclaration(
                publicOrPrivateKeyword, staticKeyword, getKeyword, identifier, parameterList, typeAnnotation, block);
        }

        private parseSetMemberAccessorDeclaration(publicOrPrivateKeyword: ISyntaxToken,
                                                  staticKeyword: ISyntaxToken): SetMemberAccessorDeclarationSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.SetKeyword);

            var setKeyword = this.eatKeyword(SyntaxKind.SetKeyword);
            var identifier = this.eatIdentifierToken();
            var parameterList = this.parseParameterList();
            var block = this.parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);

            return this.factory.setMemberAccessorDeclaration(
                publicOrPrivateKeyword, staticKeyword, setKeyword, identifier, parameterList, block);
        }

        private isMemberVariableDeclaration(): bool {
            var index = 0;
            var token0 = this.peekToken(index);

            if (ParserImpl.isPublicOrPrivateKeyword(token0)) {
                index++;

                // ERROR RECOVERY: 
                // If we're following by an close curly or EOF, then consider this the start of a
                // variable declaration.
                if (this.peekToken(index).tokenKind === SyntaxKind.CloseBraceToken ||
                    this.peekToken(index).tokenKind === SyntaxKind.EndOfFileToken) {
                    return true;
                }
            }

            if (this.peekToken(index).tokenKind === SyntaxKind.StaticKeyword) {
                index++;

                // ERROR RECOVERY: 
                // If we're following by an close curly or EOF, then consider this the start of a
                // variable declaration.
                //
                // Also if we see 'static public' or 'static private', then treat this as the start
                // of a variable declaration.
                var token1 = this.peekToken(index);
                if (token1.tokenKind === SyntaxKind.CloseBraceToken ||
                    token1.tokenKind === SyntaxKind.EndOfFileToken ||
                    ParserImpl.isPublicOrPrivateKeyword(token1)) {
                    return true;
                }
            }

            // We must at least have an identifier name at this point.
            if (!SyntaxFacts.isIdentifierNameOrAnyKeyword(this.peekToken(index))) {
                return false;
            }

            // Now, according to the grammar, we've got a member variable.  However, in practice 
            // this can be a bit too permissive (especially in error contexts).  Do some additional
            // checking to make sure we don't try to parse what's next as a member when it clearly
            // is not.

            // For example, if we see a keyword, it is very likely that the user is not actually
            // typing a member name there, but is actually typing some other construct.  For example:
            //
            //   class C { class D { }
            //
            // THe second 'class' is technically an identifier name, but we really don't want to 
            // parse a member variable here.

            // So, if we see a keyword, we do a more rigorous check that this is actually a variable
            // declaration.  If not, we do not parse it as such.
            if (this.isIdentifier(this.peekToken(index))) {
                // It's a real identifier.  We can be confident this is a member.
                return true;
            }

            // We have a keyword.  only allow this as a member if it's of the form:
            //
            //      keyword;
            //      keyword = 
            //      keyword:
            switch (this.peekToken(index + 1).tokenKind) {
                case SyntaxKind.SemicolonToken:
                case SyntaxKind.EqualsToken:
                case SyntaxKind.ColonToken:
                    return true;
            }

            return false;
        }

        private isClassElement(inErrorRecovery: bool): bool {
            if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                return true;
            }

            // Note: the order of these calls is important.  Specifically, isMemberVariableDeclaration
            // checks for a subset of the conditions of the previous two calls.
            return this.isConstructorDeclaration() ||
                   this.isMemberFunctionDeclaration(inErrorRecovery) ||
                   this.isMemberAccessorDeclaration() ||
                   this.isMemberVariableDeclaration();
        }

        private parseConstructorDeclaration(): ConstructorDeclarationSyntax {
            // Debug.assert(this.isConstructorDeclaration());

            var constructorKeyword = this.eatKeyword(SyntaxKind.ConstructorKeyword);
            var parameterList = this.parseParameterList();

            var semicolonToken: ISyntaxToken = null;
            var block: BlockSyntax = null;

            if (this.isBlock()) {
                block = this.parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);
            }
            else {
                semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            }

            return this.factory.constructorDeclaration(constructorKeyword, parameterList, block, semicolonToken);
        }

        private isMemberFunctionDeclaration(inErrorRecovery: bool): bool {
            var index = 0;

            if (ParserImpl.isPublicOrPrivateKeyword(this.peekToken(index))) {
                index++;

                // 'public'/'private' may be a modifier or may be the name of the member function.
                // Check for the latter case.
                if (this.isCallSignature(index)) {
                    return true;
                }
            }

            var sawStatic = false;
            if (this.peekToken(index).tokenKind === SyntaxKind.StaticKeyword) {
                index++;
                sawStatic = true;

                // 'static' may be a modifier or may be the name of the member function.
                // Check for the latter case.
                if (this.isCallSignature(index)) {
                    return true;
                }
            }

            // Error Recovery:
            // We may have 'static public foo()' or 'static private foo()'. check for that 
            // common case so we can give a good error message.
            if (sawStatic && ParserImpl.isPublicOrPrivateKeyword(this.peekToken(index))) {
                index++;

                // We may also have "static public()" or "static private()". check for that.
                if (this.isCallSignature(index)) {
                    return true;
                }
            }

            if (this.isPropertyName(this.peekToken(index), inErrorRecovery)) {
                return this.isCallSignature(index + 1);
            }
        
            return false;
        }

        private parseMemberFunctionDeclaration(): MemberFunctionDeclarationSyntax {
            // Debug.assert(this.isMemberFunctionDeclaration());
            
            var publicOrPrivateKeyword: ISyntaxToken = null;
            if (ParserImpl.isPublicOrPrivateKeyword(this.currentToken())) {
                // 'public'/'private' may be a modifier, or may be the name of the member function.
                if (!this.isCallSignature(1)) {
                    publicOrPrivateKeyword = this.eatAnyToken();
                }
            }

            var staticKeyword: ISyntaxToken = null;
            if (this.currentToken().tokenKind === SyntaxKind.StaticKeyword) {
                // 'static' may be a modifier, or may be the name of the member function.
                if (!this.isCallSignature(1)) {
                    staticKeyword = this.eatKeyword(SyntaxKind.StaticKeyword);
                }
            }

            // If we see 'static' followed by 'public' then this is actually syntactically invalid.
            // However, it's a common enough type of error that we want to see it and give a useful
            // error message to clarify the issue.
            if (staticKeyword !== null && ParserImpl.isPublicOrPrivateKeyword(this.currentToken())) {
                // Ok.  We've seen 'static public' or 'static private'.

                // This is actually legal in some circumstances.  For example, it's legal to type:
                // 'static public() {}'.  So, if we're on a legal function signature, then parse
                // it normally.  Otherwise, treat this as an error, attach the 'public/private' token
                // as skipped text on the 'static' keyword, and continue on.

                if (!this.isCallSignature(1)) {
                    staticKeyword = this.handlePublicOrPrivateKeywordAfterStaticKeyword(staticKeyword);
                }
            }

            var propertyName = this.eatPropertyName();
            var callSignature = this.parseCallSignature(/*requireCompleteTypeParameterList:*/ false);

            // If we got an errant => then we want to parse what's coming up without requiring an
            // open brace.
            var newCallSignature = this.tryAddUnexpectedEqualsGreaterThanToken(callSignature);
            var parseBlockEvenWithNoOpenBrace = callSignature !== newCallSignature;
            callSignature = newCallSignature;

            var block: BlockSyntax = null;
            var semicolon: ISyntaxToken = null;

            if (parseBlockEvenWithNoOpenBrace || this.isBlock()) {
                block = this.parseBlock(parseBlockEvenWithNoOpenBrace, /*checkForStrictMode:*/ false);
            }
            else {
                semicolon = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            }

            return this.factory.memberFunctionDeclaration(publicOrPrivateKeyword, staticKeyword, propertyName, callSignature, block, semicolon);
        }

        private handlePublicOrPrivateKeywordAfterStaticKeyword(staticKeyword: ISyntaxToken): ISyntaxToken {
            Debug.assert(staticKeyword.tokenKind === SyntaxKind.StaticKeyword);

            this.addDiagnostic(new SyntaxDiagnostic(this.fileName,
                this.currentTokenStart(), this.currentToken().width(), DiagnosticCode._public_or_private_modifier_must_precede__static_, null));

            var publicOrPrivateKeyword = this.eatAnyToken();
            Debug.assert(publicOrPrivateKeyword.tokenKind === SyntaxKind.PublicKeyword || publicOrPrivateKeyword.tokenKind === SyntaxKind.PrivateKeyword);

            var skippedTokens = this.getArray();
            skippedTokens.push(publicOrPrivateKeyword);
            staticKeyword = this.addSkippedTokensAfterToken(staticKeyword, skippedTokens);

            return staticKeyword;
        }

        private parseMemberVariableDeclaration(): MemberVariableDeclarationSyntax {
            // Debug.assert(this.isMemberVariableDeclaration());

            var publicOrPrivateKeyword: ISyntaxToken = null;
            if (ParserImpl.isPublicOrPrivateKeyword(this.currentToken())) {
                publicOrPrivateKeyword = this.eatAnyToken();
            }

            var staticKeyword = this.tryEatKeyword(SyntaxKind.StaticKeyword);

            // If we see 'static' followed by 'public' then this is actually syntactically invalid.
            // However, it's a common enough type of error that we want to see it and give a useful
            // error message to clarify the issue.
            if (staticKeyword !== null && ParserImpl.isPublicOrPrivateKeyword(this.currentToken())) {
                // Ok.  We've seen 'static public' or 'static private'.

                // This is actually legal in some circumstances.  For example, it's legal to type:
                // 'static public = 0'.  The following list is what is legal:
                //
                //      static public;
                //      static public: SomeType ...
                //      static public = ...
                //
                // If we see any of those, then w parse it as we would normally.  However, if we
                // don't see that, then treat this as an error, attach the 'public/private' token
                // as skipped text on the 'static' keyword, and continue on.

                var token1 = this.peekToken(1);
                if (token1.tokenKind !== SyntaxKind.SemicolonToken &&
                    token1.tokenKind !== SyntaxKind.ColonToken &&
                    token1.tokenKind !== SyntaxKind.EqualsToken) {

                    staticKeyword = this.handlePublicOrPrivateKeywordAfterStaticKeyword(staticKeyword);
                }
            }

            var variableDeclarator = this.parseVariableDeclarator(/*allowIn:*/ true, /*allowIdentifierName:*/ true);
            var semicolon = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.memberVariableDeclaration(publicOrPrivateKeyword, staticKeyword, variableDeclarator, semicolon);
        }

        private parseClassElement(inErrorRecovery: bool): IClassElementSyntax {
            // Debug.assert(this.isClassElement());

            if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                return <IClassElementSyntax>this.eatNode();
            }

            if (this.isConstructorDeclaration()) {
                return this.parseConstructorDeclaration();
            }
            else if (this.isMemberFunctionDeclaration(inErrorRecovery)) {
                return this.parseMemberFunctionDeclaration();
            }
            else if (this.isMemberAccessorDeclaration()) {
                return this.parseMemberAccessorDeclaration();
            }
            else if (this.isMemberVariableDeclaration()) {
                return this.parseMemberVariableDeclaration();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private isFunctionDeclaration(): bool {
            var token0KeywordKind = this.currentToken().tokenKind;
            if (token0KeywordKind === SyntaxKind.FunctionKeyword) {
                return true;
            }

            if (token0KeywordKind === SyntaxKind.ExportKeyword &&
                this.peekToken(1).tokenKind === SyntaxKind.FunctionKeyword) {
                return true;
            }

            return token0KeywordKind === SyntaxKind.DeclareKeyword &&
                   this.peekToken(1).tokenKind === SyntaxKind.FunctionKeyword;
        }

        private tryAddUnexpectedEqualsGreaterThanToken(callSignature: CallSignatureSyntax): CallSignatureSyntax {
            var token0 = this.currentToken();

            var hasEqualsGreaterThanToken = token0.tokenKind === SyntaxKind.EqualsGreaterThanToken;
            if (hasEqualsGreaterThanToken) {
                // Previously the language allowed "function f() => expr;" as a shorthand for 
                // "function f() { return expr; }.
                // 
                // Detect if the user is typing this and attempt recovery.
                var diagnostic = new SyntaxDiagnostic(this.fileName,
                    this.currentTokenStart(), token0.width(), DiagnosticCode.Unexpected_token_, []);
                this.addDiagnostic(diagnostic);

                var token = this.eatAnyToken();
                return <CallSignatureSyntax>this.addSkippedTokenAfterNode(callSignature, token0);
            }

            return callSignature;
        }

        private parseFunctionDeclaration(): FunctionDeclarationSyntax {
            // Debug.assert(this.isFunctionDeclaration());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var declareKeyword = this.tryEatKeyword(SyntaxKind.DeclareKeyword);

            var functionKeyword = this.eatKeyword(SyntaxKind.FunctionKeyword);
            var identifier = this.eatIdentifierToken();
            var callSignature = this.parseCallSignature(/*requireCompleteTypeParameterList:*/ false);

            // If we got an errant => then we want to parse what's coming up without requiring an
            // open brace.
            var newCallSignature = this.tryAddUnexpectedEqualsGreaterThanToken(callSignature);
            var parseBlockEvenWithNoOpenBrace = callSignature !== newCallSignature;
            callSignature = newCallSignature;

            var semicolonToken: ISyntaxToken = null;
            var block: BlockSyntax = null;

            // Parse a block if we're on a bock, or if we saw a '=>'
            if (parseBlockEvenWithNoOpenBrace || this.isBlock()) {
                block = this.parseBlock(parseBlockEvenWithNoOpenBrace, /*checkForStrictMode:*/ true);
            }
            else {
                semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            }

            return this.factory.functionDeclaration(exportKeyword, declareKeyword, functionKeyword, identifier, callSignature, block, semicolonToken);
        }

        private isModuleDeclaration(): bool {
            var index = 0;
            var token0 = this.peekToken(index);

            // export module
            if (token0.tokenKind === SyntaxKind.ExportKeyword &&
                this.peekToken(index + 1).tokenKind === SyntaxKind.ModuleKeyword) {
                return true;
            }

            // declare module
            if (token0.tokenKind === SyntaxKind.DeclareKeyword &&
                this.peekToken(index + 1).tokenKind === SyntaxKind.ModuleKeyword) {
                return true;
            }

            // Module is not a javascript keyword.  So we need to use a bit of lookahead here to ensure
            // that we're actually looking at a module construct and not some javascript expression.
            return token0.tokenKind === SyntaxKind.ModuleKeyword &&
                   this.isIdentifier(this.peekToken(index + 1));
        }

        private parseModuleDeclaration(): ModuleDeclarationSyntax {
            // Debug.assert(this.isModuleDeclaration());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var declareKeyword = this.tryEatKeyword(SyntaxKind.DeclareKeyword);
            var moduleKeyword = this.eatKeyword(SyntaxKind.ModuleKeyword);

            var moduleName: INameSyntax = null;
            var stringLiteral: ISyntaxToken = null;

            if (this.currentToken().tokenKind === SyntaxKind.StringLiteral) {
                stringLiteral = this.eatToken(SyntaxKind.StringLiteral);
            }
            else {
                moduleName = this.parseName();
            }

            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);

            var moduleElements: ISyntaxList = Syntax.emptyList;
            if (openBraceToken.width() > 0) {
                var result = this.parseSyntaxList(ListParsingState.ModuleDeclaration_ModuleElements);
                moduleElements = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);

            return this.factory.moduleDeclaration(
                exportKeyword, declareKeyword, moduleKeyword, moduleName, stringLiteral,
                openBraceToken, moduleElements, closeBraceToken);
        }

        private isInterfaceDeclaration(): bool {
            var index = 0;
            var token0 = this.peekToken(index);

            // export interface
            if (token0.tokenKind === SyntaxKind.ExportKeyword &&
                this.peekToken(index + 1).tokenKind === SyntaxKind.InterfaceKeyword) {
                return true
            }

            // interface foo
            return token0.tokenKind === SyntaxKind.InterfaceKeyword &&
                   this.isIdentifier(this.peekToken(index + 1));
        }

        private parseInterfaceDeclaration(): InterfaceDeclarationSyntax {
            // Debug.assert(this.isInterfaceDeclaration());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var interfaceKeyword = this.eatKeyword(SyntaxKind.InterfaceKeyword);
            var identifier = this.eatIdentifierToken();
            var typeParameterList = this.parseOptionalTypeParameterList(/*requireCompleteTypeParameterList:*/ false);

            var extendsClause: ExtendsClauseSyntax = null;
            if (this.isExtendsClause()) {
                extendsClause = this.parseExtendsClause();
            }

            var objectType = this.parseObjectType();
            return this.factory.interfaceDeclaration(
                exportKeyword, interfaceKeyword, identifier, typeParameterList, extendsClause, objectType);
        }

        private parseObjectType(): ObjectTypeSyntax {
            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);

            var typeMembers: ISeparatedSyntaxList = Syntax.emptySeparatedList;
            if (openBraceToken.width() > 0) {
                var result = this.parseSeparatedSyntaxList(ListParsingState.ObjectType_TypeMembers);
                typeMembers = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);
            return this.factory.objectType(openBraceToken, typeMembers, closeBraceToken);
        }

        private isTypeMember(inErrorRecovery: bool): bool {
            if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                return true;
            }

            return this.isCallSignature(/*tokenIndex:*/ 0) ||
                   this.isConstructSignature() ||
                   this.isIndexSignature() ||
                   this.isMethodSignature(inErrorRecovery) ||
                   this.isPropertySignature(inErrorRecovery);
        }

        private parseTypeMember(): ITypeMemberSyntax {
            if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                return <ITypeMemberSyntax>this.eatNode();
            }

            if (this.isCallSignature(/*tokenIndex:*/ 0)) {
                return this.parseCallSignature(/*requireCompleteTypeParameterList:*/ false);
            }
            else if (this.isConstructSignature()) {
                return this.parseConstructSignature();
            }
            else if (this.isIndexSignature()) {
                return this.parseIndexSignature();
            }
            else if (this.isMethodSignature(/*inErrorRecovery:*/ false)) {
                // Note: it is important that isFunctionSignature is called before isPropertySignature.
                // isPropertySignature checks for a subset of isFunctionSignature.
                return this.parseMethodSignature();
            }
            else if (this.isPropertySignature(/*inErrorRecovery:*/ false)) {
                return this.parsePropertySignature();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private parseConstructSignature(): ConstructSignatureSyntax {
            // Debug.assert(this.isConstructSignature());

            var newKeyword = this.eatKeyword(SyntaxKind.NewKeyword);
            var callSignature = this.parseCallSignature(/*requireCompleteTypeParameterList:*/ false);

            return this.factory.constructSignature(newKeyword, callSignature);
        }

        private parseIndexSignature(): IndexSignatureSyntax {
            // Debug.assert(this.isIndexSignature());

            var openBracketToken = this.eatToken(SyntaxKind.OpenBracketToken);
            var identifier = this.eatIdentifierToken();
            var parameterTypeAnnotation = this.parseTypeAnnotation(/*allowStringLiteral:*/ false);
            var closeBracketToken = this.eatToken(SyntaxKind.CloseBracketToken);
            var typeAnnotation = this.parseTypeAnnotation(/*allowStringLiteral:*/ false);

            return this.factory.indexSignature(openBracketToken, identifier, parameterTypeAnnotation, closeBracketToken, typeAnnotation);
        }

        private parseMethodSignature(): MethodSignatureSyntax {
            // Debug.assert(this.isMethodSignature());

            var propertyName = this.eatPropertyName();
            var questionToken = this.tryEatToken(SyntaxKind.QuestionToken);
            var callSignature = this.parseCallSignature(/*requireCompleteTypeParameterList:*/ false);

            return this.factory.methodSignature(propertyName, questionToken, callSignature);
        }

        private parsePropertySignature(): PropertySignatureSyntax {
            // Debug.assert(this.isPropertySignature());

            var propertyName = this.eatPropertyName();
            var questionToken = this.tryEatToken(SyntaxKind.QuestionToken);
            var typeAnnotation = this.parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false);

            return this.factory.propertySignature(propertyName, questionToken, typeAnnotation);
        }

        private isCallSignature(tokenIndex: number): bool {
            var tokenKind = this.peekToken(tokenIndex).tokenKind;
            return tokenKind === SyntaxKind.OpenParenToken || tokenKind === SyntaxKind.LessThanToken;
        }

        private isConstructSignature(): bool {
            if (this.currentToken().tokenKind !== SyntaxKind.NewKeyword) {
                return false;
            }

            var token1 = this.peekToken(1);
            return token1.tokenKind === SyntaxKind.LessThanToken || token1.tokenKind === SyntaxKind.OpenParenToken;
        }

        private isIndexSignature(): bool {
            return this.currentToken().tokenKind === SyntaxKind.OpenBracketToken;
        }

        private isMethodSignature(inErrorRecovery: bool): bool {
            if (this.isPropertyName(this.currentToken(), inErrorRecovery)) {
                // id(
                if (this.isCallSignature(1)) {
                    return true;
                }

                // id?(
                if (this.peekToken(1).tokenKind === SyntaxKind.QuestionToken &&
                    this.isCallSignature(2)) {
                    return true;
                }
            }

            return false;
        }

        private isPropertySignature(inErrorRecovery: bool): bool {
            // Note: property names also start function signatures.  So it's important that we call this
            // after we calll isFunctionSignature.
            return this.isPropertyName(this.currentToken(), inErrorRecovery);
        }

        private isExtendsClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ExtendsKeyword;
        }

        private parseExtendsClause(): ExtendsClauseSyntax {
            // Debug.assert(this.isExtendsClause());

            var extendsKeyword = this.eatKeyword(SyntaxKind.ExtendsKeyword);
            // Debug.assert(extendsKeyword.fullWidth() > 0);

            var result = this.parseSeparatedSyntaxList(ListParsingState.ExtendsOrImplementsClause_TypeNameList);
            var typeNames = result.list;
            extendsKeyword = this.addSkippedTokensAfterToken(extendsKeyword, result.skippedTokens);

            return this.factory.extendsClause(extendsKeyword, typeNames);
        }

        private isImplementsClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ImplementsKeyword;
        }

        private parseImplementsClause(): ImplementsClauseSyntax {
            // Debug.assert(this.isImplementsClause());

            var implementsKeyword = this.eatKeyword(SyntaxKind.ImplementsKeyword);
            // Debug.assert(implementsKeyword.fullWidth() > 0);

            var result = this.parseSeparatedSyntaxList(ListParsingState.ExtendsOrImplementsClause_TypeNameList);
            var typeNames = result.list;
            implementsKeyword = this.addSkippedTokensAfterToken(implementsKeyword, result.skippedTokens);

            return this.factory.implementsClause(implementsKeyword, typeNames);
        }

        private isStatement(inErrorRecovery: bool): bool {
            if (this.currentNode() !== null && this.currentNode().isStatement()) {
                return true;
            }

            // ERROR RECOVERY
            switch (this.currentToken().tokenKind) {
                case SyntaxKind.PublicKeyword:
                case SyntaxKind.PrivateKeyword:
                case SyntaxKind.StaticKeyword:
                    // None of hte above are actually keywords.  And they might show up in a real
                    // statement (i.e. "public();").  However, if we can determine that they're
                    // parsable as a ClassElement then don't consider them a statement.  Note:
                    //
                    // It should not be possible for any class element that starts with public, private
                    // or static to be parsed as a statement.  So this is safe to do.
                    if (this.isClassElement(inErrorRecovery)) {
                        return false;
                    }
            }

            return this.isVariableStatement() ||
                   this.isLabeledStatement() ||
                   this.isFunctionDeclaration() ||
                   this.isIfStatement() ||
                   this.isBlock() ||
                   this.isExpressionStatement() ||
                   this.isReturnStatement() ||
                   this.isSwitchStatement() ||
                   this.isThrowStatement() ||
                   this.isBreakStatement() ||
                   this.isContinueStatement() ||
                   this.isForOrForInStatement() ||
                   this.isEmptyStatement(inErrorRecovery) ||
                   this.isWhileStatement() ||
                   this.isWithStatement() ||
                   this.isDoStatement() ||
                   this.isTryStatement() ||
                   this.isDebuggerStatement();
        }

        private parseStatement(): IStatementSyntax {
            if (this.currentNode() !== null && this.currentNode().isStatement()) {
                return <IStatementSyntax>this.eatNode();
            }

            if (this.isVariableStatement()) {
                return this.parseVariableStatement();
            }
            else if (this.isLabeledStatement()) {
                return this.parseLabeledStatement();
            }
            else if (this.isFunctionDeclaration()) {
                return this.parseFunctionDeclaration();
            }
            else if (this.isIfStatement()) {
                return this.parseIfStatement();
            }
            else if (this.isBlock()) {
                return this.parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);
            }
            else if (this.isReturnStatement()) {
                return this.parseReturnStatement();
            }
            else if (this.isSwitchStatement()) {
                return this.parseSwitchStatement();
            }
            else if (this.isThrowStatement()) {
                return this.parseThrowStatement();
            }
            else if (this.isBreakStatement()) {
                return this.parseBreakStatement();
            }
            else if (this.isContinueStatement()) {
                return this.parseContinueStatement();
            }
            else if (this.isForOrForInStatement()) {
                return this.parseForOrForInStatement();
            }
            else if (this.isEmptyStatement(/*inErrorRecovery:*/ false)) {
                return this.parseEmptyStatement();
            }
            else if (this.isWhileStatement()) {
                return this.parseWhileStatement();
            }
            else if (this.isWithStatement()) {
                return this.parseWithStatement();
            }
            else if (this.isDoStatement()) {
                return this.parseDoStatement();
            }
            else if (this.isTryStatement()) {
                return this.parseTryStatement();
            }
            else if (this.isDebuggerStatement()) {
                return this.parseDebuggerStatement();
            }
            else {
                // Fall back to parsing this as expression statement.
                return this.parseExpressionStatement();
            }
        }

        private isDebuggerStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.DebuggerKeyword;
        }

        private parseDebuggerStatement(): DebuggerStatementSyntax {
            // Debug.assert(this.isDebuggerStatement());

            var debuggerKeyword = this.eatKeyword(SyntaxKind.DebuggerKeyword);
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.debuggerStatement(debuggerKeyword, semicolonToken);
        }

        private isDoStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.DoKeyword;
        }

        private parseDoStatement(): DoStatementSyntax {
            // Debug.assert(this.isDoStatement());

            var doKeyword = this.eatKeyword(SyntaxKind.DoKeyword);
            var statement = this.parseStatement();
            var whileKeyword = this.eatKeyword(SyntaxKind.WhileKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var condition = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html
            // 157 min --- All allen at wirfs-brock.com CONF --- "do{;}while(false)false" prohibited in 
            // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby
            //  do;while(0)x will have a semicolon inserted before x.
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ true);

            return this.factory.doStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
        }

        private isLabeledStatement(): bool {
            return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === SyntaxKind.ColonToken;
        }

        private parseLabeledStatement(): LabeledStatementSyntax {
            // Debug.assert(this.isLabeledStatement());

            var identifier = this.eatIdentifierToken();
            var colonToken = this.eatToken(SyntaxKind.ColonToken);
            var statement = this.parseStatement();

            return this.factory.labeledStatement(identifier, colonToken, statement);
        }

        private isTryStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.TryKeyword;
        }

        private parseTryStatement(): TryStatementSyntax {
            // Debug.assert(this.isTryStatement());

            var tryKeyword = this.eatKeyword(SyntaxKind.TryKeyword);

            var savedListParsingState = this.listParsingState;
            this.listParsingState |= ListParsingState.TryBlock_Statements;
            var block = this.parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);
            this.listParsingState = savedListParsingState;

            var catchClause: CatchClauseSyntax = null;
            if (this.isCatchClause()) {
                catchClause = this.parseCatchClause();
            }

            // If we don't have a catch clause, then we must have a finally clause.  Try to parse
            // one out no matter what.
            var finallyClause: FinallyClauseSyntax = null;
            if (catchClause === null || this.isFinallyClause()) {
                finallyClause = this.parseFinallyClause();
            }

            return this.factory.tryStatement(tryKeyword, block, catchClause, finallyClause);
        }

        private isCatchClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CatchKeyword;
        }

        private parseCatchClause(): CatchClauseSyntax {
            // Debug.assert(this.isCatchClause());

            var catchKeyword = this.eatKeyword(SyntaxKind.CatchKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var identifier = this.eatIdentifierToken();
            var typeAnnotation = this.parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            var savedListParsingState = this.listParsingState;
            this.listParsingState |= ListParsingState.CatchBlock_Statements;
            var block = this.parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);
            this.listParsingState = savedListParsingState;

            return this.factory.catchClause(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block);
        }

        private isFinallyClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.FinallyKeyword;
        }

        private parseFinallyClause(): FinallyClauseSyntax {
            var finallyKeyword = this.eatKeyword(SyntaxKind.FinallyKeyword);
            var block = this.parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);

            return this.factory.finallyClause(finallyKeyword, block);
        }

        private isWithStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.WithKeyword;
        }

        private parseWithStatement(): WithStatementSyntax {
            // Debug.assert(this.isWithStatement());

            var withKeyword = this.eatKeyword(SyntaxKind.WithKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var condition = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var statement = this.parseStatement();

            return this.factory.withStatement(withKeyword, openParenToken, condition, closeParenToken, statement);
        }

        private isWhileStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.WhileKeyword;
        }

        private parseWhileStatement(): WhileStatementSyntax {
            // Debug.assert(this.isWhileStatement());

            var whileKeyword = this.eatKeyword(SyntaxKind.WhileKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var condition = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var statement = this.parseStatement();

            return this.factory.whileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
        }

        private isEmptyStatement(inErrorRecovery: bool): bool {
            // If we're in error recovery, then we don't want to treat ';' as an empty statement.
            // The problem is that ';' can show up in far too many contexts, and if we see one 
            // and assume it's a statement, then we may bail out innapropriately from whatever 
            // we're parsing.  For example, if we have a semicolon in the middle of a class, then
            // we really don't want to assume the class is over and we're on a statement in the
            // outer module.  We just want to consume and move on.
            if (inErrorRecovery) {
                return false;
            }

            return this.currentToken().tokenKind === SyntaxKind.SemicolonToken;
        }

        private parseEmptyStatement(): EmptyStatementSyntax {
            // Debug.assert(this.isEmptyStatement());

            var semicolonToken = this.eatToken(SyntaxKind.SemicolonToken);
            return this.factory.emptyStatement(semicolonToken);
        }

        private isForOrForInStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ForKeyword;
        }

        private parseForOrForInStatement(): BaseForStatementSyntax {
            // Debug.assert(this.isForOrForInStatement());

            var forKeyword = this.eatKeyword(SyntaxKind.ForKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);

            var currentToken = this.currentToken();
            if (currentToken.tokenKind === SyntaxKind.VarKeyword) {
                // for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
                // for ( var VariableDeclarationNoIn in Expression ) Statement
                return this.parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken);
            }
            else if (currentToken.tokenKind === SyntaxKind.SemicolonToken) {
                // for ( ; Expressionopt ; Expressionopt ) Statement
                return this.parseForStatement(forKeyword, openParenToken);
            }
            else {
                // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
                // for ( LeftHandSideExpression in Expression ) Statement
                return this.parseForOrForInStatementWithInitializer(forKeyword, openParenToken);
            }
        }

        private parseForOrForInStatementWithVariableDeclaration(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken): BaseForStatementSyntax {
            // Debug.assert(forKeyword.tokenKind === SyntaxKind.ForKeyword && openParenToken.tokenKind === SyntaxKind.OpenParenToken);
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.VarKeyword);

            // for ( var VariableDeclarationListNoIn; Expressionopt ; Expressionopt ) Statement
            // for ( var VariableDeclarationNoIn in Expression ) Statement

            var variableDeclaration = this.parseVariableDeclaration(/*allowIn:*/ false);

            if (this.currentToken().tokenKind === SyntaxKind.InKeyword) {
                return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
            }

            return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
        }

        private parseForInStatementWithVariableDeclarationOrInitializer(
                forKeyword: ISyntaxToken,
                openParenToken: ISyntaxToken,
                variableDeclaration: VariableDeclarationSyntax,
                initializer: IExpressionSyntax): ForInStatementSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.InKeyword);

            // for ( var VariableDeclarationNoIn in Expression ) Statement
            var inKeyword = this.eatKeyword(SyntaxKind.InKeyword);
            var expression = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var statement = this.parseStatement();

            return this.factory.forInStatement(forKeyword, openParenToken, variableDeclaration,
                initializer, inKeyword, expression, closeParenToken, statement);
        }

        private parseForOrForInStatementWithInitializer(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken): BaseForStatementSyntax {
            // Debug.assert(forKeyword.tokenKind === SyntaxKind.ForKeyword && openParenToken.tokenKind === SyntaxKind.OpenParenToken);

            // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
            // for ( LeftHandSideExpression in Expression ) Statement

            var initializer = this.parseExpression(/*allowIn:*/ false);
            if (this.currentToken().tokenKind === SyntaxKind.InKeyword) {
                return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            }
            else {
                return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            }
        }

        private parseForStatement(forKeyword: ISyntaxToken, openParenToken: ISyntaxToken): ForStatementSyntax {
            // Debug.assert(forKeyword.tokenKind === SyntaxKind.ForKeyword && openParenToken.tokenKind === SyntaxKind.OpenParenToken);

            // for ( ExpressionNoInopt; Expressionopt ; Expressionopt ) Statement
            var initializer: IExpressionSyntax = null;

            if (this.currentToken().tokenKind !== SyntaxKind.SemicolonToken &&
                this.currentToken().tokenKind !== SyntaxKind.CloseParenToken &&
                this.currentToken().tokenKind !== SyntaxKind.EndOfFileToken) {
                initializer = this.parseExpression(/*allowIn:*/ false);
            }

            return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
        }

        private parseForStatementWithVariableDeclarationOrInitializer(
                    forKeyword: ISyntaxToken,
                    openParenToken: ISyntaxToken,
                    variableDeclaration: VariableDeclarationSyntax,
                    initializer: IExpressionSyntax): ForStatementSyntax {

            // NOTE: From the es5 section on Automatic Semicolon Insertion.
            // a semicolon is never inserted automatically if the semicolon would then ... become 
            // one of the two semicolons in the header of a for statement
            var firstSemicolonToken = this.eatToken(SyntaxKind.SemicolonToken);

            var condition: IExpressionSyntax = null;
            if (this.currentToken().tokenKind !== SyntaxKind.SemicolonToken &&
                this.currentToken().tokenKind !== SyntaxKind.CloseParenToken &&
                this.currentToken().tokenKind !== SyntaxKind.EndOfFileToken) {
                condition = this.parseExpression(/*allowIn:*/ true);
            }

            // NOTE: See above.  Semicolons in for statements don't participate in automatic 
            // semicolon insertion.
            var secondSemicolonToken = this.eatToken(SyntaxKind.SemicolonToken);

            var incrementor: IExpressionSyntax = null;
            if (this.currentToken().tokenKind !== SyntaxKind.CloseParenToken &&
                this.currentToken().tokenKind !== SyntaxKind.EndOfFileToken) {
                incrementor = this.parseExpression(/*allowIn:*/ true);
            }

            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var statement = this.parseStatement();

            return this.factory.forStatement(forKeyword, openParenToken, variableDeclaration, initializer,
                firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement);
        }

        private isBreakStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.BreakKeyword;
        }

        private parseBreakStatement(): BreakStatementSyntax {
            // Debug.assert(this.isBreakStatement());

            var breakKeyword = this.eatKeyword(SyntaxKind.BreakKeyword);

            // If there is no newline after the break keyword, then we can consume an optional 
            // identifier.
            var identifier: ISyntaxToken = null;
            if (!this.canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                if (this.isIdentifier(this.currentToken())) {
                    identifier = this.eatIdentifierToken();
                }
            }

            var semicolon = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            return this.factory.breakStatement(breakKeyword, identifier, semicolon);
        }

        private isContinueStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ContinueKeyword;
        }

        private parseContinueStatement(): ContinueStatementSyntax {
            // Debug.assert(this.isContinueStatement());

            var continueKeyword = this.eatKeyword(SyntaxKind.ContinueKeyword);

            // If there is no newline after the break keyword, then we can consume an optional 
            // identifier.
            var identifier: ISyntaxToken = null;
            if (!this.canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                if (this.isIdentifier(this.currentToken())) {
                    identifier = this.eatIdentifierToken();
                }
            }

            var semicolon = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
            return this.factory.continueStatement(continueKeyword, identifier, semicolon);
        }

        private isSwitchStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.SwitchKeyword;
        }

        private parseSwitchStatement() {
            // Debug.assert(this.isSwitchStatement());

            var switchKeyword = this.eatKeyword(SyntaxKind.SwitchKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var expression = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);

            var switchClauses: ISyntaxList = Syntax.emptyList;
            if (openBraceToken.width() > 0) {
                var result = this.parseSyntaxList(ListParsingState.SwitchStatement_SwitchClauses);
                switchClauses = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);
            return this.factory.switchStatement(switchKeyword, openParenToken, expression,
                closeParenToken, openBraceToken, switchClauses, closeBraceToken);
        }

        private isCaseSwitchClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CaseKeyword;
        }

        private isDefaultSwitchClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.DefaultKeyword;
        }

        private isSwitchClause(): bool {
            if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                return true;
            }

            return this.isCaseSwitchClause() || this.isDefaultSwitchClause();
        }

        private parseSwitchClause(): SwitchClauseSyntax {
            // Debug.assert(this.isSwitchClause());
            if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                return <SwitchClauseSyntax>this.eatNode();
            }

            if (this.isCaseSwitchClause()) {
                return this.parseCaseSwitchClause();
            }
            else if (this.isDefaultSwitchClause()) {
                return this.parseDefaultSwitchClause();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private parseCaseSwitchClause(): CaseSwitchClauseSyntax {
            // Debug.assert(this.isCaseSwitchClause());

            var caseKeyword = this.eatKeyword(SyntaxKind.CaseKeyword);
            var expression = this.parseExpression(/*allowIn:*/ true);
            var colonToken = this.eatToken(SyntaxKind.ColonToken);
            var statements = Syntax.emptyList;

            // TODO: allow parsing of the list evne if there's no colon.  However, we have to make 
            // sure we add any skipped tokens to the right previous node or token.
            if (colonToken.fullWidth() > 0) {
                var result = this.parseSyntaxList(ListParsingState.SwitchClause_Statements);
                statements = result.list;
                colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
            }

            return this.factory.caseSwitchClause(caseKeyword, expression, colonToken, statements);
        }

        private parseDefaultSwitchClause(): DefaultSwitchClauseSyntax {
            // Debug.assert(this.isDefaultSwitchClause());

            var defaultKeyword = this.eatKeyword(SyntaxKind.DefaultKeyword);
            var colonToken = this.eatToken(SyntaxKind.ColonToken);
            var statements = Syntax.emptyList;

            // TODO: Allow parsing witha colon here.  However, ensure that we attach any skipped 
            // tokens to the defaultKeyword.
            if (colonToken.fullWidth() > 0) {
                var result = this.parseSyntaxList(ListParsingState.SwitchClause_Statements);
                statements = result.list;
                colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
            }

            return this.factory.defaultSwitchClause(defaultKeyword, colonToken, statements);
        }

        private isThrowStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ThrowKeyword;
        }

        private parseThrowStatement(): ThrowStatementSyntax {
            // Debug.assert(this.isThrowStatement());

            var throwKeyword = this.eatKeyword(SyntaxKind.ThrowKeyword);

            var expression: IExpressionSyntax = null;
            if (this.canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                // Because of automatic semicolon insertion, we need to report error if this 
                // throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'
                // directly as that might consume an expression on the following line.  
                var token = this.createMissingToken(SyntaxKind.IdentifierName, null);
                expression = token;
            }
            else {
                expression = this.parseExpression(/*allowIn:*/ true);
            }

            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.throwStatement(throwKeyword, expression, semicolonToken);
        }

        private isReturnStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ReturnKeyword;
        }

        private parseReturnStatement(): ReturnStatementSyntax {
            // Debug.assert(this.isReturnStatement());

            var returnKeyword = this.eatKeyword(SyntaxKind.ReturnKeyword);

            var expression: IExpressionSyntax = null;
            if (!this.canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                expression = this.parseExpression(/*allowIn:*/ true);
            }

            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.returnStatement(returnKeyword, expression, semicolonToken);
        }

        private isExpressionStatement(): bool {
            // As per the gramar, neither { nor 'function' can start an expression statement.
            var currentToken = this.currentToken();

            var kind = currentToken.tokenKind;
            if (kind === SyntaxKind.OpenBraceToken || kind === SyntaxKind.FunctionKeyword) {
                return false;
            }

            return this.isExpression();
        }

        private isAssignmentOrOmittedExpression(): bool {
            if (this.currentToken().tokenKind === SyntaxKind.CommaToken) {
                return true;
            }

            return this.isExpression();
        }

        private parseAssignmentOrOmittedExpression(): IExpressionSyntax {
            // Debug.assert(this.isAssignmentOrOmittedExpression());

            if (this.currentToken().tokenKind === SyntaxKind.CommaToken) {
                return this.factory.omittedExpression();
            }

            return this.parseAssignmentExpression(/*allowIn:*/ true);
        }

        private isExpression(): bool {
            var currentToken = this.currentToken();
            var kind = currentToken.tokenKind;

            switch (kind) {
                case SyntaxKind.NumericLiteral:
                case SyntaxKind.StringLiteral:
                case SyntaxKind.RegularExpressionLiteral:
                    return true;

                case SyntaxKind.OpenBracketToken: // For array literals.
                case SyntaxKind.OpenParenToken: // For parenthesized expressions
                    return true;

                case SyntaxKind.LessThanToken: // For cast expressions.
                    return true;

                // Prefix unary expressions.
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.ExclamationToken:
                    return true;

                case SyntaxKind.OpenBraceToken: // For object type literal expressions.
                    return true;

                // ERROR TOLERANCE:
                // If we see a => then we know the user was probably trying to type in an arrow 
                // function.  So allow this as the start of an expression, knowing that when we 
                // actually try to parse it we'll report the missing identifier.
                case SyntaxKind.EqualsGreaterThanToken:
                    return true;

                case SyntaxKind.SlashToken:
                case SyntaxKind.SlashEqualsToken:
                    // Note: if we see a / or /= token then we always consider this an expression.  Why?
                    // Well, either that / or /= is actually a regular expression, in which case we're 
                    // definitely an expression.  Or, it's actually a divide.  In which case, we *still*
                    // want to think of ourself as an expression.  "But wait", you say.  '/' doesn't
                    // start an expression.  That's true.  BUt like the above check for =>, for error
                    // tolerance, we will consider ourselves in an expression.  We'll then parse out an
                    // missing identifier and then will consume the / token naturally as a binary 
                    // expression.
                    return true;

                case SyntaxKind.SuperKeyword:
                case SyntaxKind.ThisKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                    return true;

                case SyntaxKind.NewKeyword: // For object creation expressions.
                    return true;

                // Prefix unary expressions
                case SyntaxKind.DeleteKeyword:
                case SyntaxKind.VoidKeyword:
                case SyntaxKind.TypeOfKeyword:
                    return true;

                // For function expressions.
                case SyntaxKind.FunctionKeyword:
                    return true;
            }

            if (this.isIdentifier(this.currentToken())) {
                return true;
            }

            return false;
        }

        private parseExpressionStatement(): ExpressionStatementSyntax {
            var expression = this.parseExpression(/*allowIn:*/ true);

            var semicolon = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.expressionStatement(expression, semicolon);
        }

        private isIfStatement(): bool {
            return this.currentToken().tokenKind === SyntaxKind.IfKeyword;
        }

        private parseIfStatement(): IfStatementSyntax {
            // Debug.assert(this.isIfStatement());

            var ifKeyword = this.eatKeyword(SyntaxKind.IfKeyword);
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var condition = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var statement = this.parseStatement();

            var elseClause: ElseClauseSyntax = null;
            if (this.isElseClause()) {
                elseClause = this.parseElseClause();
            }

            return this.factory.ifStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause);
        }

        private isElseClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ElseKeyword;
        }

        private parseElseClause(): ElseClauseSyntax {
            // Debug.assert(this.isElseClause());

            var elseKeyword = this.eatKeyword(SyntaxKind.ElseKeyword);
            var statement = this.parseStatement();

            return this.factory.elseClause(elseKeyword, statement);
        }

        private isVariableStatement(): bool {
            var token0KeywordKind = this.currentToken().tokenKind;
            if (token0KeywordKind === SyntaxKind.VarKeyword) {
                return true;
            }

            if (token0KeywordKind === SyntaxKind.ExportKeyword &&
                this.peekToken(1).tokenKind === SyntaxKind.VarKeyword) {
                return true;
            }

            return token0KeywordKind === SyntaxKind.DeclareKeyword &&
                   this.peekToken(1).tokenKind === SyntaxKind.VarKeyword;
        }

        private parseVariableStatement(): VariableStatementSyntax {
            // Debug.assert(this.isVariableStatement());

            var exportKeyword = this.tryEatKeyword(SyntaxKind.ExportKeyword);
            var declareKeyword = this.tryEatKeyword(SyntaxKind.DeclareKeyword);

            var variableDeclaration = this.parseVariableDeclaration(/*allowIn:*/ true);
            var semicolonToken = this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);

            return this.factory.variableStatement(exportKeyword, declareKeyword, variableDeclaration, semicolonToken);
        }

        private parseVariableDeclaration(allowIn: bool): VariableDeclarationSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.VarKeyword);

            var varKeyword = this.eatKeyword(SyntaxKind.VarKeyword);
            // Debug.assert(varKeyword.fullWidth() > 0);

            var listParsingState = allowIn
                ? ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn
                : ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn;

            var result = this.parseSeparatedSyntaxList(listParsingState);
            var variableDeclarators = result.list;
            varKeyword = this.addSkippedTokensAfterToken(varKeyword, result.skippedTokens);

            return this.factory.variableDeclaration(varKeyword, variableDeclarators);
        }

        private isVariableDeclarator(): bool {
            if (this.currentNode() !== null && this.currentNode().kind() === SyntaxKind.VariableDeclarator) {
                return true;
            }

            return this.isIdentifier(this.currentToken());
        }

        private parseVariableDeclarator(allowIn: bool, allowIdentifierName: bool): VariableDeclaratorSyntax {
            // TODO(cyrusn): What if the 'allowIn' context has changed between when we last parsed 
            // and now?  We could end up with an incorrect tree.  For example, say we had in the old 
            // tree "var i = a in b".  Then, in the new tree the declarator portion moved into:
            // "for (var i = a in b".  We would not want to reuse the declarator as the "in b" portion 
            // would need to be consumed by the for declaration instead.  Need to see if it is possible
            // to hit this case.
            if (this.currentNode() !== null && this.currentNode().kind() === SyntaxKind.VariableDeclarator) {
                return <VariableDeclaratorSyntax>this.eatNode();
            }

            var identifier = allowIdentifierName ? this.eatIdentifierNameToken() : this.eatIdentifierToken();
            var equalsValueClause: EqualsValueClauseSyntax = null;
            var typeAnnotation: TypeAnnotationSyntax = null;

            if (identifier.width() > 0) {
                typeAnnotation = this.parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false);

                if (this.isEqualsValueClause(/*inParameter*/ false)) {
                    equalsValueClause = this.parseEqualsValueClause(allowIn);
                }
            }

            return this.factory.variableDeclarator(identifier, typeAnnotation, equalsValueClause);
        }

        private isColonValueClause(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ColonToken;
        }

        private isEqualsValueClause(inParameter: bool): bool {
            var token0 = this.currentToken();
            if (token0.tokenKind === SyntaxKind.EqualsToken) {
                return true;
            }

            // It's not uncommon during typing for the user to miss writing the '=' token.  Check if
            // there is no newline after the last token and if we're on an expression.  If so, parse
            // this as an equals-value clause with a missing equals.
            if (!this.previousToken().hasTrailingNewLine()) {

                // The 'isExpression' call below returns true for "=>".  That's because it smartly
                // assumes that there is just a missing identifier and the user wanted a lambda.  
                // While this is sensible, we don't want to allow that here as that would mean we're
                // glossing over multiple erorrs and we're probably making things worse.  So don't
                // treat this as an equals value clause and let higher up code handle things.
                if (token0.tokenKind === SyntaxKind.EqualsGreaterThanToken) {
                    return false;
                }


                // There are two places where we allow equals-value clauses.  The first is in a 
                // variable declarator.  The second is with a parameter.  For variable declarators
                // it's more likely that a { would be a allowed (as an object literal).  While this
                // is also allowed for parameters, the risk is that we consume the { as an object
                // literal when it really will be for the block following the parameter.
                if (token0.tokenKind === SyntaxKind.OpenBraceToken &&
                    inParameter) {
                    return false;
                }

                return this.isExpression();
            }

            return false;
        }

        private parseEqualsValueClause(allowIn: bool): EqualsValueClauseSyntax {
            // Debug.assert(this.isEqualsValueClause());

            var equalsToken = this.eatToken(SyntaxKind.EqualsToken);
            var value = this.parseAssignmentExpression(allowIn);

            return this.factory.equalsValueClause(equalsToken, value);
        }

        private parseExpression(allowIn: bool): IExpressionSyntax {
            return this.parseSubExpression(0, allowIn);
        }

        // Called when you need to parse an expression, but you do not want to allow 'CommaExpressions'.
        // i.e. if you have "var a = 1, b = 2" then when we parse '1' we want to parse with higher 
        // precedence than 'comma'.  Otherwise we'll get: "var a = (1, (b = 2))", instead of
        // "var a = (1), b = (2)");
        private parseAssignmentExpression(allowIn: bool): IExpressionSyntax {
            return this.parseSubExpression(ExpressionPrecedence.AssignmentExpressionPrecedence, allowIn);
        }

        private parseUnaryExpression(): IUnaryExpressionSyntax {
            var currentTokenKind = this.currentToken().tokenKind; 
            if (SyntaxFacts.isPrefixUnaryExpressionOperatorToken(currentTokenKind)) {
                var operatorKind = SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken(currentTokenKind);

                var operatorToken = this.eatAnyToken();

                var operand = this.parseUnaryExpression();
                return this.factory.prefixUnaryExpression(operatorKind, operatorToken, operand);
            }
            else {
                return this.parseTerm(/*allowInvocation*/ true);
            }
        }

        private parseSubExpression(precedence: ExpressionPrecedence, allowIn: bool): IExpressionSyntax {
            // Because unary expression have the highest precedence, we can always parse one, regardless 
            // of what precedence was passed in.
            var leftOperand: IExpressionSyntax = this.parseUnaryExpression();
            leftOperand = this.parseBinaryOrConditionalExpressions(precedence, allowIn, leftOperand);

            return leftOperand;
        }

        private parseBinaryOrConditionalExpressions(precedence: number, allowIn: bool, leftOperand: IExpressionSyntax): IExpressionSyntax {
            while (true) {
                // We either have a binary operator here, or we're finished.
                var token0 = this.currentToken();
                var token0Kind = token0.tokenKind;

                // Check for binary expressions.
                if (SyntaxFacts.isBinaryExpressionOperatorToken(token0Kind)) {
                    // also, if it's the 'in' operator, only allow if our caller allows it.
                    if (token0Kind === SyntaxKind.InKeyword && !allowIn) {
                        break;
                    }

                    // check for >= or >> or >>= or >>> or >>>=.
                    //
                    // These are not created by the scanner since we want the individual > tokens for
                    // generics.
                    var mergedToken = this.tryMergeBinaryExpressionTokens();
                    var tokenKind = mergedToken === null ? token0Kind : mergedToken.syntaxKind;

                    var binaryExpressionKind = SyntaxFacts.getBinaryExpressionFromOperatorToken(tokenKind);
                    var newPrecedence = ParserImpl.getPrecedence(binaryExpressionKind);

                    // All binary operators must have precedence > 0!
                    // Debug.assert(newPrecedence > 0);

                    // Check the precedence to see if we should "take" this operator
                    if (newPrecedence < precedence) {
                        break;
                    }

                    // Same precedence, but not right-associative -- deal with this higher up in our stack "later"
                    if (newPrecedence === precedence && !this.isRightAssociative(binaryExpressionKind)) {
                        break;
                    }

                    // Precedence is okay, so we'll "take" this operator.  If we have a merged token, 
                    // then create a new synthesized token with all the operators combined.  In that 
                    // case make sure it has the right trivia associated with it.
                    var operatorToken = mergedToken === null
                        ? token0
                        : Syntax.token(mergedToken.syntaxKind)
                                .withLeadingTrivia(token0.leadingTrivia())
                                .withTrailingTrivia(this.peekToken(mergedToken.tokenCount - 1).trailingTrivia());

                    // Now skip the operator token we're on, or the tokens we merged.
                    var skipCount = mergedToken === null ? 1 : mergedToken.tokenCount;
                    for (var i = 0; i < skipCount; i++) {
                        this.eatAnyToken();
                    }

                    leftOperand = this.factory.binaryExpression(
                        binaryExpressionKind, leftOperand, operatorToken, this.parseSubExpression(newPrecedence, allowIn));
                    continue;
                }

                // Now check for conditional expression.
                // Only consume this as a ternary expression if our precedence is higher than the ternary 
                // level.  i.e. if we have "!f ? a : b" then we would not want to 
                // consume the "?" as part of "f" because the precedence of "!" is far too high.  However,
                // if we have: "x = f ? a : b", then we would want to consume the "?" as part of "f".
                //
                // Note: if we have "m = f ? x ? y : z : b, then we do want the second "?" to go with 'x'.
                if (token0Kind === SyntaxKind.QuestionToken && precedence <= ExpressionPrecedence.ConditionalExpressionPrecedence) {
                    var questionToken = this.eatToken(SyntaxKind.QuestionToken);

                    var whenTrueExpression = this.parseAssignmentExpression(allowIn);
                    var colon = this.eatToken(SyntaxKind.ColonToken);

                    var whenFalseExpression = this.parseAssignmentExpression(allowIn);
                    leftOperand = this.factory.conditionalExpression(
                        leftOperand, questionToken, whenTrueExpression, colon, whenFalseExpression);
                    continue;
                }

                // Not binary or ternary.  Nothing more to consume here.
                break;
            }

            return leftOperand;
        }

        private mergeTokensStorage: SyntaxKind[] = [];

        private tryMergeBinaryExpressionTokens(): { tokenCount: number; syntaxKind: SyntaxKind; } {
            var token0 = this.currentToken();

            // Only merge if we have a '>' token with no trailing trivia.
            if (token0.tokenKind === SyntaxKind.GreaterThanToken && !token0.hasTrailingTrivia()) {
                var storage = this.mergeTokensStorage;
                storage[0] = SyntaxKind.None;
                storage[1] = SyntaxKind.None;
                storage[2] = SyntaxKind.None;

                for (var i = 0; i < storage.length; i++) {
                    var nextToken = this.peekToken(i + 1);

                    // We can merge with the next token if it doesn't have any leading trivia.
                    if (!nextToken.hasLeadingTrivia()) {
                        storage[i] = nextToken.tokenKind;
                    }

                    // Stop merging additional tokens if this token has any trailing trivia.
                    if (nextToken.hasTrailingTrivia()) {
                        break;
                    }
                }

                if (storage[0] === SyntaxKind.GreaterThanToken) {
                    if (storage[1] === SyntaxKind.GreaterThanToken) {
                        if (storage[2] === SyntaxKind.EqualsToken) {
                            // >>>=
                            return { tokenCount: 4, syntaxKind: SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken };
                        }
                        else {
                            // >>>
                            return { tokenCount: 3, syntaxKind: SyntaxKind.GreaterThanGreaterThanGreaterThanToken };
                        }
                    }
                    else if (storage[1] === SyntaxKind.EqualsToken) {
                        // >>=
                        return { tokenCount: 3, syntaxKind: SyntaxKind.GreaterThanGreaterThanEqualsToken };
                    }
                    else {
                        // >>
                        return { tokenCount: 2, syntaxKind: SyntaxKind.GreaterThanGreaterThanToken };
                    }
                }
                else if (storage[0] === SyntaxKind.EqualsToken) {
                    // >=
                    return { tokenCount: 2, syntaxKind: SyntaxKind.GreaterThanEqualsToken };
                }
            }

            // Just use the normal logic as we're not merging the '>' with anything.
            return null;
        }

        private isRightAssociative(expressionKind: SyntaxKind): bool {
            switch (expressionKind) {
                case SyntaxKind.AssignmentExpression:
                case SyntaxKind.AddAssignmentExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                case SyntaxKind.DivideAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                case SyntaxKind.SignedRightShiftAssignmentExpression:
                case SyntaxKind.UnsignedRightShiftAssignmentExpression:
                    return true;
                default:
                    return false;
            }
        }

        private parseTerm(allowInvocation: bool): IUnaryExpressionSyntax {
            // NOTE: allowInvocation and insideObjectCreation are always the negation of the other.
            // We could remove one of them and just use the other.  However, i think this is much
            // easier to read and understand in this form.

            var term = this.parseTermWorker();
            if (term === null) {
                // Nothing else worked, just try to consume an identifier so we report an error.
                return this.eatIdentifierToken();
            }

            return this.parsePostFixExpression(term, allowInvocation);
        }

        private parsePostFixExpression(expression: IUnaryExpressionSyntax, allowInvocation: bool): IUnaryExpressionSyntax {
            while (true) {
                var currentTokenKind = this.currentToken().tokenKind;
                switch (currentTokenKind) {
                    case SyntaxKind.OpenParenToken:
                        if (!allowInvocation) {
                            return expression;
                        }

                        expression = this.factory.invocationExpression(expression, this.parseArgumentList(/*typeArgumentList:*/ null));
                        continue;

                    case SyntaxKind.LessThanToken:
                        if (!allowInvocation) {
                            return expression;
                        }

                        // See if this is the start of a generic invocation.  If so, consume it and
                        // keep checking for postfix expressions.  Otherwise, it's just a '<' that's 
                        // part of an arithmetic expression.  Break out so we consume it higher in the
                        // stack.
                        var argumentList = this.tryParseArgumentList();
                        if (argumentList !== null) {
                            expression = this.factory.invocationExpression(expression, argumentList);
                            continue;
                        }

                        break;

                    case SyntaxKind.OpenBracketToken:
                        expression = this.parseElementAccessExpression(expression);
                        continue;

                    case SyntaxKind.PlusPlusToken:
                    case SyntaxKind.MinusMinusToken:
                        // Because of automatic semicolon insertion, we should only consume the ++ or -- 
                        // if it is on the same line as the previous token.
                        if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                            break;
                        }

                        expression = this.factory.postfixUnaryExpression(
                            SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken(currentTokenKind), expression, this.eatAnyToken());
                        continue;

                    case SyntaxKind.DotToken:
                        expression = this.factory.memberAccessExpression(
                            expression, this.eatToken(SyntaxKind.DotToken), this.eatIdentifierNameToken());
                        continue;
                }

                return expression;
            }
        }

        private tryParseArgumentList(): ArgumentListSyntax {
            var typeArgumentList: TypeArgumentListSyntax = null;

            if (this.currentToken().tokenKind === SyntaxKind.LessThanToken) {
                // If we have a '<', then only parse this as a arugment list if the type arguments
                // are complete and we have an open paren.  if we don't, rewind and return nothing.
                var rewindPoint = this.getRewindPoint();
                try {
                    typeArgumentList = this.tryParseTypeArgumentList(/*inExpression:*/ true);
                    if (typeArgumentList === null || this.currentToken().tokenKind !== SyntaxKind.OpenParenToken) {
                        this.rewind(rewindPoint);
                        return null;
                    }
                }
                finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            }

            if (this.currentToken().tokenKind === SyntaxKind.OpenParenToken) {
                return this.parseArgumentList(typeArgumentList);
            }

            return null;
        }

        private parseArgumentList(typeArgumentList: TypeArgumentListSyntax): ArgumentListSyntax {
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var arguments = Syntax.emptySeparatedList;

            if (openParenToken.fullWidth() > 0) {
                var result = this.parseSeparatedSyntaxList(ListParsingState.ArgumentList_AssignmentExpressions);
                arguments = result.list;
                openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
            }

            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            return this.factory.argumentList(typeArgumentList, openParenToken, arguments, closeParenToken);
        }

        private parseElementAccessExpression(expression: IExpressionSyntax): ElementAccessExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.OpenBracketToken);

            var openBracketToken = this.eatToken(SyntaxKind.OpenBracketToken);
            var argumentExpression = this.parseExpression(/*allowIn:*/ true);
            var closeBracketToken = this.eatToken(SyntaxKind.CloseBracketToken);

            return this.factory.elementAccessExpression(expression, openBracketToken, argumentExpression, closeBracketToken);
        }

        private parseTermWorker(): IUnaryExpressionSyntax {
            var currentToken = this.currentToken();

            // ERROR RECOVERY TWEAK:
            // If we see a standalone => try to parse it as an arrow function as that's likely what
            // the user intended to write.
            if (currentToken.tokenKind === SyntaxKind.EqualsGreaterThanToken) {
                return this.parseSimpleArrowFunctionExpression();
            }

            if (this.isIdentifier(currentToken)) {
                if (this.isSimpleArrowFunctionExpression()) {
                    return this.parseSimpleArrowFunctionExpression();
                }
                else {
                    var identifier = this.eatIdentifierToken();
                    return identifier;
                }
            }

            var currentTokenKind = currentToken.tokenKind;
            switch (currentTokenKind) {
                case SyntaxKind.ThisKeyword:
                    return this.parseThisExpression();

                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                    return this.parseLiteralExpression();

                case SyntaxKind.NullKeyword:
                    return this.parseLiteralExpression();

                case SyntaxKind.NewKeyword:
                    return this.parseObjectCreationExpression();

                case SyntaxKind.FunctionKeyword:
                    return this.parseFunctionExpression();

                case SyntaxKind.SuperKeyword:
                    return this.parseSuperExpression();

                case SyntaxKind.TypeOfKeyword:
                    return this.parseTypeOfExpression();

                case SyntaxKind.DeleteKeyword:
                    return this.parseDeleteExpression();

                case SyntaxKind.VoidKeyword:
                    return this.parseVoidExpression();

                case SyntaxKind.NumericLiteral:
                    return this.parseLiteralExpression();

                case SyntaxKind.RegularExpressionLiteral:
                    return this.parseLiteralExpression();

                case SyntaxKind.StringLiteral:
                    return this.parseLiteralExpression();

                case SyntaxKind.OpenBracketToken:
                    return this.parseArrayLiteralExpression();

                case SyntaxKind.OpenBraceToken:
                    return this.parseObjectLiteralExpression();

                case SyntaxKind.OpenParenToken:
                    return this.parseParenthesizedOrArrowFunctionExpression();

                case SyntaxKind.LessThanToken:
                    return this.parseCastOrArrowFunctionExpression();

                case SyntaxKind.SlashToken:
                case SyntaxKind.SlashEqualsToken:
                    // If we see a standalone / or /= and we're expecting a term, then try to reparse
                    // it as a regular expression.  If we succeed, then return that.  Otherwise, fall
                    // back and just return a missing identifier as usual.  We'll then form a binary
                    // expression out of of the / as usual.
                    var result = this.tryReparseDivideAsRegularExpression();
                    if (result !== null) {
                        return result;
                    }
                    break;
            }

            // Wasn't able to parse this as a term. 
            return null;
        }

        private tryReparseDivideAsRegularExpression(): IUnaryExpressionSyntax {
            // If we see a / or /= token, then that may actually be the start of a regex in certain 
            // contexts.

            var currentToken = this.currentToken();
            // Debug.assert(SyntaxFacts.isAnyDivideToken(currentToken.tokenKind));

            // There are several contexts where we could never see a regex.  Don't even bother 
            // reinterpretting the / in these contexts.
            if (this.previousToken() !== null) {
                var previousTokenKind = this.previousToken().tokenKind;
                switch (previousTokenKind) {
                    case SyntaxKind.IdentifierName:
                        // Regular expressions can't follow identifiers.
                        return null;

                    // Regexs also can't follow certain keywords:
                    case SyntaxKind.ThisKeyword:
                    case SyntaxKind.TrueKeyword:
                    case SyntaxKind.FalseKeyword:
                        return null;

                    // A regular expression could follow other keywords.  i.e. "return /blah/;"
                    // TODO: be more specific about the keywords that a regex could follow.

                    case SyntaxKind.StringLiteral:
                    case SyntaxKind.NumericLiteral:
                    case SyntaxKind.RegularExpressionLiteral:
                    case SyntaxKind.PlusPlusToken:
                    case SyntaxKind.MinusMinusToken:
                    case SyntaxKind.CloseBracketToken:
                    case SyntaxKind.CloseBraceToken:
                        // A regular expression can't follow any of these.  It must be a divide. Note: this
                        // list *may* be incorrect (especially in the context of typescript).  We need to
                        // carefully review it.
                        return null;

                    // case SyntaxKind.CloseParenToken:
                    // It is tempting to say that if we have a slash after a close paren that it can't be 
                    // a regular expression.  after all, the normal case where we see that is "(1 + 2) / 3".
                    // However, it can appear in legal code.  Specifically:
                    //
                    //      for (...)
                    //          /regex/.Stuff...
                    //
                    // So we have to see if we can get a regular expression in that case.
                }
            }

            // Ok, from our quick lexical check, this could be a place where a regular expression could
            // go.  Now we have to do a bunch of work.  Ask the source to retrive the token at the 
            // current position again.  But this time allow it to retrieve it as a regular expression.
            currentToken = this.currentTokenAllowingRegularExpression();

            // Note: we *must* have gotten a /, /= or regular expression.  Or else something went *very*
            // wrong with our logic above.
            // Debug.assert(SyntaxFacts.isAnyDivideOrRegularExpressionToken(currentToken.tokenKind));

            if (currentToken.tokenKind === SyntaxKind.SlashToken || currentToken.tokenKind === SyntaxKind.SlashEqualsToken) {
                // Still came back as a / or /=.   This is not a regular expression literal.
                return null;
            }
            else if (currentToken.tokenKind === SyntaxKind.RegularExpressionLiteral) {
                return this.parseLiteralExpression();
            }
            else {
                // Something *very* wrong happened.  This is an internal parser fault that we need 
                // to figure out and fix.
                throw Errors.invalidOperation();
            }
        }

        private parseTypeOfExpression(): TypeOfExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.TypeOfKeyword);

            var typeOfKeyword = this.eatKeyword(SyntaxKind.TypeOfKeyword);
            var expression = this.parseUnaryExpression();

            return this.factory.typeOfExpression(typeOfKeyword, expression);
        }

        private parseDeleteExpression(): DeleteExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.DeleteKeyword);

            var deleteKeyword = this.eatKeyword(SyntaxKind.DeleteKeyword);
            var expression = this.parseUnaryExpression();

            return this.factory.deleteExpression(deleteKeyword, expression);
        }

        private parseVoidExpression(): VoidExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.VoidKeyword);

            var voidKeyword = this.eatKeyword(SyntaxKind.VoidKeyword);
            var expression = this.parseUnaryExpression();

            return this.factory.voidExpression(voidKeyword, expression);
        }

        private parseSuperExpression(): IUnaryExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.SuperKeyword);

            var superKeyword = this.eatKeyword(SyntaxKind.SuperKeyword);
            return superKeyword;
        }

        private parseFunctionExpression(): FunctionExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.FunctionKeyword);

            var functionKeyword = this.eatKeyword(SyntaxKind.FunctionKeyword);
            var identifier: ISyntaxToken = null;

            if (this.isIdentifier(this.currentToken())) {
                identifier = this.eatIdentifierToken();
            }

            var callSignature = this.parseCallSignature(/*requireCompleteTypeParameterList:*/ false);
            var block = this.parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ true);

            return this.factory.functionExpression(functionKeyword, identifier, callSignature, block);
        }

        private parseObjectCreationExpression(): ObjectCreationExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.NewKeyword);
            var newKeyword = this.eatKeyword(SyntaxKind.NewKeyword);

            // While parsing the sub term we don't want to allow invocations to be parsed.  that's because
            // we want "new Foo()" to parse as "new Foo()" (one node), not "new (Foo())".
            var expression = this.parseTerm(/*allowInvocation:*/ false);

            var argumentList = this.tryParseArgumentList();
            return this.factory.objectCreationExpression(newKeyword, expression, argumentList);
        }

        private parseCastOrArrowFunctionExpression(): IUnaryExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.LessThanToken);

            // We've got a '<'.  that could start a cast or an arrow function.  As it is highly
            // ambiguous, we need to check for enough data to indicate that's it's an arrow 
            // function.  Otherwise, we assume it's a cast.
            var rewindPoint = this.getRewindPoint();
            try {
                var arrowFunction = this.tryParseArrowFunctionExpression();
                if (arrowFunction !== null) {
                    return arrowFunction;
                }

                // wasn't an arrow function.  Try again as a cast expression.
                this.rewind(rewindPoint);
                return this.parseCastExpression();
            }
            finally {
                this.releaseRewindPoint(rewindPoint);
            }
        }
        
        private parseCastExpression(): CastExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.LessThanToken);

            var lessThanToken = this.eatToken(SyntaxKind.LessThanToken);
            var type = this.parseType();
            var greaterThanToken = this.eatToken(SyntaxKind.GreaterThanToken);
            var expression = this.parseUnaryExpression();

            return this.factory.castExpression(lessThanToken, type, greaterThanToken, expression);
        }

        private parseParenthesizedOrArrowFunctionExpression(): IUnaryExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.OpenParenToken);

            var result = this.tryParseArrowFunctionExpression();
            if (result !== null) {
                return result;
            }

            // Doesn't look like an arrow function, so parse this as a parenthesized expression.
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var expression = this.parseExpression(/*allowIn:*/ true);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);

            return this.factory.parenthesizedExpression(openParenToken, expression, closeParenToken);
        }

        private tryParseArrowFunctionExpression(): ArrowFunctionExpressionSyntax {
            var tokenKind = this.currentToken().tokenKind;
            // Debug.assert(tokenKind === SyntaxKind.OpenParenToken || tokenKind === SyntaxKind.LessThanToken);

            // Because arrow functions and parenthesized expressions look similar, we have to check far
            // enough ahead to be sure we've actually got an arrow function. For example, both nodes can
            // start with:
            //    (a = b, c = d, ..., e = f).
            //So we effectively need infinite lookahead to decide which node we're in.
            //
            // First, check for things that definitely have enough information to let us know it's an
            // arrow function.

            if (this.isDefinitelyArrowFunctionExpression()) {
                // We have something like "() =>" or "(a) =>".  Definitely a lambda, so parse it
                // unilaterally as such.
                return this.parseParenthesizedArrowFunctionExpression(/*requiresArrow:*/ false);
            }

            // Now, look for cases where we're sure it's not an arrow function.  This will help save us
            // a costly parse.
            if (!this.isPossiblyArrowFunctionExpression()) {
                return null;
            }

            // Then, try to actually parse it as a arrow function, and only return if we see an => 
            var rewindPoint = this.getRewindPoint();
            try {
                var arrowFunction = this.parseParenthesizedArrowFunctionExpression(/*requiresArrow:*/ true);
                if (arrowFunction === null) {
                    this.rewind(rewindPoint);
                }
                return arrowFunction;
            }
            finally {
                this.releaseRewindPoint(rewindPoint);
            }
        }

        private parseParenthesizedArrowFunctionExpression(requireArrow: bool): ParenthesizedArrowFunctionExpressionSyntax {
            var currentToken = this.currentToken();
            // Debug.assert(currentToken.tokenKind === SyntaxKind.OpenParenToken || currentToken.tokenKind === SyntaxKind.LessThanToken);

            var callSignature = this.parseCallSignature(/*requireCompleteTypeParameterList:*/ true);

            if (requireArrow && this.currentToken().tokenKind !== SyntaxKind.EqualsGreaterThanToken) {
                return null;
            }

            var equalsGreaterThanToken = this.eatToken(SyntaxKind.EqualsGreaterThanToken);
            var body = this.parseArrowFunctionBody();

            return this.factory.parenthesizedArrowFunctionExpression(callSignature, equalsGreaterThanToken, body);
        }

        private parseArrowFunctionBody(): ISyntaxNodeOrToken {
            if (this.isBlock()) {
                return this.parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ false);
            }
            else {
                return this.parseAssignmentExpression(/*allowIn:*/ true);
            }
        }

        private isSimpleArrowFunctionExpression(): bool {
            // ERROR RECOVERY TWEAK:
            if (this.currentToken().tokenKind === SyntaxKind.EqualsGreaterThanToken) {
                return true;
            }

            return this.isIdentifier(this.currentToken()) &&
                   this.peekToken(1).tokenKind === SyntaxKind.EqualsGreaterThanToken;
        }

        private parseSimpleArrowFunctionExpression(): SimpleArrowFunctionExpressionSyntax {
            // Debug.assert(this.isSimpleArrowFunctionExpression());

            var identifier = this.eatIdentifierToken();
            var equalsGreaterThanToken = this.eatToken(SyntaxKind.EqualsGreaterThanToken);
            var body = this.parseArrowFunctionBody();

            return this.factory.simpleArrowFunctionExpression(
                identifier, equalsGreaterThanToken, body);
        }

        private isBlock(): bool {
            return this.currentToken().tokenKind === SyntaxKind.OpenBraceToken;
        }

        private isDefinitelyArrowFunctionExpression(): bool {
            var token0 = this.currentToken();
            if (token0.tokenKind !== SyntaxKind.OpenParenToken) {
                // If it didn't start with an (, then it could be generic.  That's too complicated 
                // and we can't say it's 'definitely' an arrow function.             
                return false;
            }

            var token1 = this.peekToken(1);
            var token2: ISyntaxToken;

            if (token1.tokenKind === SyntaxKind.CloseParenToken) {
                // ()
                // Definitely an arrow function.  Could never be a parenthesized expression.  
                // *However*, because of error situations, we could end up with things like "().foo".
                // In this case, we don't want to think of this as the start of an arrow function.
                // To prevent this, we are a little stricter, and we require that we at least see:
                //      "():"  or  "() =>"  or "() {}".  Note: the last one is illegal.  However it
                // most likely is a missing => and not a parenthesized expression.
                token2 = this.peekToken(2);
                return token2.tokenKind === SyntaxKind.ColonToken ||
                       token2.tokenKind === SyntaxKind.EqualsGreaterThanToken ||
                       token2.tokenKind === SyntaxKind.OpenBraceToken;
            }

            if (token1.tokenKind === SyntaxKind.DotDotDotToken) {
                // (...
                // Definitely an arrow function.  Could never be a parenthesized expression.
                return true;
            }

            if (!this.isIdentifier(token1)) {
                // All other arrow functions must start with (id
                // so this is definitely not an arrow function.
                return false;
            }

            // (id
            //
            // Lots of options here.  Check for things that make us certain it's an
            // arrow function.
            token2 = this.peekToken(2);
            if (token2.tokenKind === SyntaxKind.ColonToken) {
                // (id:
                // Definitely an arrow function.  Could never be a parenthesized expression.
                return true;
            }

            var token3 = this.peekToken(3);
            if (token2.tokenKind === SyntaxKind.QuestionToken) {
                // (id?
                // Could be an arrow function, or a parenthesized conditional expression.

                // Check for the things that could only be arrow functions.
                if (token3.tokenKind === SyntaxKind.ColonToken ||
                    token3.tokenKind === SyntaxKind.CloseParenToken ||
                    token3.tokenKind === SyntaxKind.CommaToken) {
                    // (id?:
                    // (id?)
                    // (id?,
                    // These are the only cases where this could be an arrow function.
                    // And none of them can be parenthesized expression.
                    return true;
                }
            }

            if (token2.tokenKind === SyntaxKind.CloseParenToken) {
                // (id)
                // Could be an arrow function, or a parenthesized conditional expression.

                if (token3.tokenKind === SyntaxKind.EqualsGreaterThanToken) {
                    // (id) =>
                    // Definitely an arrow function.  Could not be a parenthesized expression.
                    return true;
                }

                // Note: "(id):" *looks* like it could be an arrow function.  However, it could
                // show up in:  "foo ? (id): 
                // So we can't return true here for that case.
            }

            // TODO: Add more cases if you're sure that there is enough information to know to 
            // parse this as an arrow function.  Note: be very careful here.

            // Anything else wasn't clear enough.  Try to parse the expression as an arrow function and bail out
            // if we fail.
            return false;
        }

        private isPossiblyArrowFunctionExpression(): bool {
            var token0 = this.currentToken();
            if (token0.tokenKind !== SyntaxKind.OpenParenToken) {
                // If it didn't start with an (, then it could be generic.  That's too complicated 
                // and we have to say it's possibly an arrow function.
                return true;
            }

            var token1 = this.peekToken(1);

            if (!this.isIdentifier(token1)) {
                // All other arrow functions must start with (id
                // so this is definitely not an arrow function.
                return false;
            }

            var token2 = this.peekToken(2);
            if (token2.tokenKind === SyntaxKind.EqualsToken) {
                // (id =
                //
                // This *could* be an arrow function.  i.e. (id = 0) => { }
                // Or it could be a parenthesized expression.  So we'll have to actually
                // try to parse it.
                return true;
            }

            if (token2.tokenKind === SyntaxKind.CommaToken) {
                // (id,

                // This *could* be an arrow function.  i.e. (id, id2) => { }
                // Or it could be a parenthesized expression (as javascript supports
                // the comma operator).  So we'll have to actually try to parse it.
                return true;
            }

            if (token2.tokenKind === SyntaxKind.CloseParenToken) {
                // (id)

                var token3 = this.peekToken(3);
                if (token3.tokenKind === SyntaxKind.ColonToken) {
                    // (id):
                    //
                    // This could be an arrow function. i.e. (id): number => { }
                    // Or it could be parenthesized exprssion: foo ? (id) :
                    // So we'll have to actually try to parse it.
                    return true;
                }
            }

            // Nothing else could be an arrow function.
            return false;
        }

        private parseObjectLiteralExpression(): ObjectLiteralExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.OpenBraceToken);

            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);
            // Debug.assert(openBraceToken.fullWidth() > 0);

            var result = this.parseSeparatedSyntaxList(ListParsingState.ObjectLiteralExpression_PropertyAssignments);
            var propertyAssignments = result.list;
            openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);

            return this.factory.objectLiteralExpression(
                openBraceToken, propertyAssignments, closeBraceToken);
        }

        private parsePropertyAssignment(): PropertyAssignmentSyntax {
            // Debug.assert(this.isPropertyAssignment(/*inErrorRecovery:*/ false));
            if (this.isGetAccessorPropertyAssignment()) {
                return this.parseGetAccessorPropertyAssignment();
            }
            else if (this.isSetAccessorPropertyAssignment()) {
                return this.parseSetAccessorPropertyAssignment();
            }
            else if (this.isSimplePropertyAssignment(/*inErrorRecovery:*/ false)) {
                return this.parseSimplePropertyAssignment();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private isPropertyAssignment(inErrorRecovery: bool): bool {
            return this.isGetAccessorPropertyAssignment() ||
                   this.isSetAccessorPropertyAssignment() ||
                   this.isSimplePropertyAssignment(inErrorRecovery);
        }

        private isGetAccessorPropertyAssignment(): bool {
            return this.currentToken().tokenKind === SyntaxKind.GetKeyword &&
                   this.isPropertyName(this.peekToken(1), /*inErrorRecovery:*/ false);
        }

        private parseGetAccessorPropertyAssignment(): GetAccessorPropertyAssignmentSyntax {
            // Debug.assert(this.isGetAccessorPropertyAssignment());

            var getKeyword = this.eatKeyword(SyntaxKind.GetKeyword);
            var propertyName = this.eatPropertyName();
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var typeAnnotation = this.parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false);
            var block = this.parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ true);

            return this.factory.getAccessorPropertyAssignment(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block);
        }

        private isSetAccessorPropertyAssignment(): bool {
            return this.currentToken().tokenKind === SyntaxKind.SetKeyword &&
                   this.isPropertyName(this.peekToken(1), /*inErrorRecovery:*/ false);
        }

        private parseSetAccessorPropertyAssignment(): SetAccessorPropertyAssignmentSyntax {
            // Debug.assert(this.isSetAccessorPropertyAssignment());

            var setKeyword = this.eatKeyword(SyntaxKind.SetKeyword);
            var propertyName = this.eatPropertyName();
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var parameter = this.parseParameter();
            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            var block = this.parseBlock(/*parseStatementsEvenWithNoOpenBrace:*/ false, /*checkForStrictMode:*/ true);

            return this.factory.setAccessorPropertyAssignment(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block);
        }

        private isSimplePropertyAssignment(inErrorRecovery: bool): bool {
            return this.isPropertyName(this.currentToken(), inErrorRecovery);
        }

        private eatPropertyName(): ISyntaxToken {
            return SyntaxFacts.isIdentifierNameOrAnyKeyword(this.currentToken())
                ? this.eatIdentifierNameToken()
                : this.eatAnyToken();
        }

        private parseSimplePropertyAssignment(): SimplePropertyAssignmentSyntax {
            // Debug.assert(this.isSimplePropertyAssignment(/*inErrorRecovery:*/ false));

            var propertyName = this.eatPropertyName();
            var colonToken = this.eatToken(SyntaxKind.ColonToken);
            var expression = this.parseAssignmentExpression(/*allowIn:*/ true);

            return this.factory.simplePropertyAssignment(propertyName, colonToken, expression);
        }

        private isPropertyName(token: ISyntaxToken, inErrorRecovery: bool): bool {
            // NOTE: we do *not* want to check "this.isIdentifier" here.  Any IdentifierName is 
            // allowed here, even reserved words like keywords.
            if (SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                // Except: if we're in error recovery, then we don't want to consider keywords. 
                // After all, if we have:
                //
                //      { a: 1
                //      return
                //
                // we don't want consider 'return' to be the next property in the object literal.
                if (inErrorRecovery) {
                    return this.isIdentifier(token);
                }
                else {
                    return true;
                }
            }

            switch (token.tokenKind) {
                case SyntaxKind.StringLiteral:
                case SyntaxKind.NumericLiteral:
                    return true;

                default:
                    return false;
            }
        }

        private parseArrayLiteralExpression(): ArrayLiteralExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.OpenBracketToken);

            var openBracketToken = this.eatToken(SyntaxKind.OpenBracketToken);
            // Debug.assert(openBracketToken.fullWidth() > 0);

            var result = this.parseSeparatedSyntaxList(ListParsingState.ArrayLiteralExpression_AssignmentExpressions);
            var expressions = result.list;
            openBracketToken = this.addSkippedTokensAfterToken(openBracketToken, result.skippedTokens);

            var closeBracketToken = this.eatToken(SyntaxKind.CloseBracketToken);

            return this.factory.arrayLiteralExpression(openBracketToken, expressions, closeBracketToken);
        }

        private parseLiteralExpression(): IUnaryExpressionSyntax {
            // TODO: add appropriate asserts here.
            return this.eatAnyToken();
        }

        private parseThisExpression(): IUnaryExpressionSyntax {
            // Debug.assert(this.currentToken().tokenKind === SyntaxKind.ThisKeyword);
            var thisKeyword = this.eatKeyword(SyntaxKind.ThisKeyword);
            return thisKeyword;
        }

        private parseBlock(parseBlockEvenWithNoOpenBrace: bool, checkForStrictMode: bool): BlockSyntax {
            var openBraceToken = this.eatToken(SyntaxKind.OpenBraceToken);

            var statements: ISyntaxList = Syntax.emptyList;

            if (parseBlockEvenWithNoOpenBrace || openBraceToken.width() > 0) {
                var savedIsInStrictMode = this.isInStrictMode;
                
                var processItems = checkForStrictMode ? ParserImpl.updateStrictModeState : null;
                var result = this.parseSyntaxList(ListParsingState.Block_Statements, processItems);
                statements = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

                this.setStrictMode(savedIsInStrictMode);
            }

            var closeBraceToken = this.eatToken(SyntaxKind.CloseBraceToken);

            return this.factory.block(openBraceToken, statements, closeBraceToken);
        }

        private parseCallSignature(requireCompleteTypeParameterList: bool): CallSignatureSyntax {
            var typeParameterList = this.parseOptionalTypeParameterList(requireCompleteTypeParameterList);
            var parameterList = this.parseParameterList();
            var typeAnnotation = this.parseOptionalTypeAnnotation(/*allowStringLiteral:*/ false);

            return this.factory.callSignature(typeParameterList, parameterList, typeAnnotation);
        }

        private parseOptionalTypeParameterList(requireCompleteTypeParameterList: bool): TypeParameterListSyntax {
            if (this.currentToken().tokenKind !== SyntaxKind.LessThanToken) {
                return null;
            }

            var rewindPoint = this.getRewindPoint();
            try {
                var lessThanToken = this.eatToken(SyntaxKind.LessThanToken);
                // Debug.assert(lessThanToken.fullWidth() > 0);
                
                var result = this.parseSeparatedSyntaxList(ListParsingState.TypeParameterList_TypeParameters);
                var typeParameterList = result.list;
                lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                var greaterThanToken = this.eatToken(SyntaxKind.GreaterThanToken);

                // return null if we were required to have a '>' token and we did not  have one.
                if (requireCompleteTypeParameterList && greaterThanToken.fullWidth() === 0) {
                    this.rewind(rewindPoint);
                    return null;
                }

                return this.factory.typeParameterList(lessThanToken, typeParameterList, greaterThanToken);
            }
            finally {
                this.releaseRewindPoint(rewindPoint);
            }
        }

        private isTypeParameter(): bool {
            return this.isIdentifier(this.currentToken());
        }
        
        private parseTypeParameter(): TypeParameterSyntax {
            // Debug.assert(this.isTypeParameter());
            var identifier = this.eatIdentifierToken();
            var constraint = this.parseOptionalConstraint();

            return this.factory.typeParameter(identifier, constraint);
        }

        private parseOptionalConstraint(): ConstraintSyntax {
            if (this.currentToken().kind() !== SyntaxKind.ExtendsKeyword) {
                return null;
            }

            var extendsKeyword = this.eatKeyword(SyntaxKind.ExtendsKeyword);
            var type = this.parseType();

            return this.factory.constraint(extendsKeyword, type);
        }

        private parseParameterList(): ParameterListSyntax {
            var openParenToken = this.eatToken(SyntaxKind.OpenParenToken);
            var parameters: ISeparatedSyntaxList = Syntax.emptySeparatedList;

            if (openParenToken.width() > 0) {
                var result = this.parseSeparatedSyntaxList(ListParsingState.ParameterList_Parameters);
                parameters = result.list;
                openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
            }

            var closeParenToken = this.eatToken(SyntaxKind.CloseParenToken);
            return this.factory.parameterList(openParenToken, parameters, closeParenToken);
        }

        private isTypeAnnotation(): bool {
            return this.currentToken().tokenKind === SyntaxKind.ColonToken;
        }

        private parseOptionalTypeAnnotation(allowStringLiteral: bool): TypeAnnotationSyntax {
            return this.isTypeAnnotation()
                ? this.parseTypeAnnotation(allowStringLiteral)
                : null;
        }

        private parseTypeAnnotation(allowStringLiteral: bool): TypeAnnotationSyntax {
            // Debug.assert(this.isTypeAnnotation());

            var colonToken = this.eatToken(SyntaxKind.ColonToken);
            var type = allowStringLiteral && this.currentToken().tokenKind === SyntaxKind.StringLiteral
                ? this.eatToken(SyntaxKind.StringLiteral)
                : this.parseType();

            return this.factory.typeAnnotation(colonToken, type);
        }

        private isType(): bool {
            return this.isPredefinedType() ||
                   this.isTypeLiteral() ||
                   this.isName();
        }

        private parseType(): ITypeSyntax {
            var type = this.parseNonArrayType();

            while (this.currentToken().tokenKind === SyntaxKind.OpenBracketToken) {
                var openBracketToken = this.eatToken(SyntaxKind.OpenBracketToken);
                var closeBracketToken = this.eatToken(SyntaxKind.CloseBracketToken);

                type = this.factory.arrayType(type, openBracketToken, closeBracketToken);
            }

            return type;
        }

        private parseNonArrayType(): ITypeSyntax {
            if (this.isPredefinedType()) {
                return this.parsePredefinedType();
            }
            else if (this.isTypeLiteral()) {
                return this.parseTypeLiteral();
            }
            else {
                return this.parseNameOrGenericType();
            }
        }

        private parseNameOrGenericType(): ITypeSyntax {
            var name = this.parseName();
            var typeArgumentList = this.tryParseTypeArgumentList(/*inExpression:*/ false);

            return typeArgumentList === null
                ? name
                : this.factory.genericType(name, typeArgumentList);
        }

        private parseTypeLiteral(): ITypeSyntax {
            // Debug.assert(this.isTypeLiteral(/*allowFunctionType:*/ true, /*allowConstructorType:*/ true));
            if (this.isObjectType()) {
                return this.parseObjectType();
            }
            else if (this.isFunctionType()) {
                return this.parseFunctionType();
            }
            else if (this.isConstructorType()) {
                return this.parseConstructorType();
            }
            else {
                throw Errors.invalidOperation();
            }
        }

        private parseFunctionType(): FunctionTypeSyntax {
            // Debug.assert(this.isFunctionType());

            var typeParameterList = this.parseOptionalTypeParameterList(/*requireCompleteTypeParameterList:*/ false);
            var parameterList = this.parseParameterList();
            var equalsGreaterThanToken = this.eatToken(SyntaxKind.EqualsGreaterThanToken);
            var returnType = this.parseType();

            return this.factory.functionType(typeParameterList, parameterList, equalsGreaterThanToken, returnType);
        }

        private parseConstructorType(): ConstructorTypeSyntax {
            // Debug.assert(this.isConstructorType());

            var newKeyword = this.eatKeyword(SyntaxKind.NewKeyword);
            var parameterList = this.parseParameterList();
            var equalsGreaterThanToken = this.eatToken(SyntaxKind.EqualsGreaterThanToken);
            var type = this.parseType();

            return this.factory.constructorType(newKeyword, null, parameterList, equalsGreaterThanToken, type);
        }

        private isTypeLiteral(): bool {
            return this.isObjectType() ||
                   this.isFunctionType() ||
                   this.isConstructorType();
        }

        private isObjectType(): bool {
            return this.currentToken().tokenKind === SyntaxKind.OpenBraceToken;
        }

        private isFunctionType(): bool {
            var tokenKind = this.currentToken().tokenKind;
            return tokenKind === SyntaxKind.OpenParenToken || tokenKind === SyntaxKind.LessThanToken;
        }

        private isConstructorType(): bool {
            return this.currentToken().tokenKind === SyntaxKind.NewKeyword;
        }

        private parsePredefinedType(): ITypeSyntax {
            // Debug.assert(this.isPredefinedType());
            return this.eatAnyToken();
        }

        private isPredefinedType(): bool {
            switch (this.currentToken().tokenKind) {
                case SyntaxKind.AnyKeyword:
                case SyntaxKind.NumberKeyword:
                case SyntaxKind.BooleanKeyword:
                case SyntaxKind.BoolKeyword:
                case SyntaxKind.StringKeyword:
                case SyntaxKind.VoidKeyword:
                    return true;
            }

            return false;
        }

        private isParameter(): bool {
            if (this.currentNode() !== null && this.currentNode().kind() === SyntaxKind.Parameter) {
                return true;
            }

            var token = this.currentToken();
            if (token.tokenKind === SyntaxKind.DotDotDotToken) {
                return true;
            }

            if (ParserImpl.isPublicOrPrivateKeyword(token)) {
                return true;
            }

            return this.isIdentifier(token);
        }

        private parseParameter(): ParameterSyntax {
            if (this.currentNode() !== null && this.currentNode().kind() === SyntaxKind.Parameter) {
                return <ParameterSyntax>this.eatNode();
            }

            var dotDotDotToken = this.tryEatToken(SyntaxKind.DotDotDotToken);

            var publicOrPrivateToken: ISyntaxToken = null;
            if (ParserImpl.isPublicOrPrivateKeyword(this.currentToken())) {
                publicOrPrivateToken = this.eatAnyToken();
            }

            var identifier = this.eatIdentifierToken();
            var questionToken = this.tryEatToken(SyntaxKind.QuestionToken);
            var typeAnnotation = this.parseOptionalTypeAnnotation(/*allowStringLiteral:*/ true);

            var equalsValueClause: EqualsValueClauseSyntax = null;
            if (this.isEqualsValueClause(/*inParameter*/ true)) {
                equalsValueClause = this.parseEqualsValueClause(/*allowIn:*/ true);
            }

            return this.factory.parameter(
                dotDotDotToken, publicOrPrivateToken, identifier, questionToken, typeAnnotation, equalsValueClause);
        }

        private parseSyntaxList(currentListType: ListParsingState,
                                processItems: (parser: ParserImpl, items: any[]) => void = null): { skippedTokens: ISyntaxToken[]; list: ISyntaxList; } {
            var savedListParsingState = this.listParsingState;
            this.listParsingState |= currentListType;

            var result = this.parseSyntaxListWorker(currentListType, processItems);

            this.listParsingState = savedListParsingState;

            return result;
        }

        private parseSeparatedSyntaxList(currentListType: ListParsingState): { skippedTokens: ISyntaxToken[]; list: ISeparatedSyntaxList; } {
            var savedListParsingState = this.listParsingState;
            this.listParsingState |= currentListType;

            var result = this.parseSeparatedSyntaxListWorker(currentListType);

            this.listParsingState = savedListParsingState;

            return result;
        }

        // Returns true if we should abort parsing.
        private abortParsingListOrMoveToNextToken(currentListType: ListParsingState,
                                                  itemCount: number,
                                                  items: ISyntaxNodeOrToken[],
                                                  skippedTokens: ISyntaxToken[]): bool {
            // Ok.  We're at a token that is not a terminator for the list and wasn't the start of 
            // an item in the list. Definitely report an error for this token.
            this.reportUnexpectedTokenDiagnostic(currentListType);

            // Now, check if the token is a terminator for one our parent lists, or the start of an
            // item in one of our parent lists.  If so, we won't want to consume the token.  We've 
            // already reported the error, so just return to our caller so that a higher up 
            // production can consume it.
            for (var state = ListParsingState.LastListParsingState;
                 state >= ListParsingState.FirstListParsingState;
                 state >>= 1) {

                if ((this.listParsingState & state) !== 0) {
                    if (this.isExpectedListTerminator(state, itemCount) || this.isExpectedListItem(state, /*inErrorRecovery:*/ true)) {
                        // Abort parsing this list.
                        return true;
                    }
                }
            }

            // Otherwise, if none of the lists we're in can capture this token, then we need to 
            // unilaterally skip it.  Note: we've already reported an error above.
            var skippedToken = this.currentToken();

            // Consume this token and move onto the next item in the list.
            this.moveToNextToken();

            this.addSkippedTokenToList(items, skippedTokens, skippedToken);

            // Continue parsing this list.  Attach this token to whatever we've seen already.
            return false;
        }
        
        private addSkippedTokenToList(items: ISyntaxNodeOrToken[], skippedTokens: ISyntaxToken[], skippedToken: ISyntaxToken): void {
            // Now, add this skipped token to the last item we successfully parsed in the list.  Or
            // add it to the list of skipped tokens if we haven't parsed anything.  Our caller will
            // have to deal with them.
            for (var i = items.length - 1; i >= 0; i--) {
                var item = items[i];
                var lastToken = item.lastToken();
                if (lastToken.fullWidth() > 0) {
                    items[i] = this.addSkippedTokenAfterNodeOrToken(item, skippedToken);
                    return;
                }
            }
            
            // Didn't have anything in the list we could add to.  Add to the skipped items array
            // for our caller to handle.
            skippedTokens.push(skippedToken);
        }

        private tryParseExpectedListItem(currentListType: ListParsingState,
                                         inErrorRecovery: bool,
                                         items: ISyntaxElement[],
                                         processItems: (parser: ParserImpl, items: any[]) => void ): void {
            if (this.isExpectedListItem(currentListType, inErrorRecovery)) {
                var item = this.parseExpectedListItem(currentListType);
                // Debug.assert(item !== null);

                items.push(item);

                if (processItems !== null) {
                    processItems(this, items);
                }
            }
        }

        private listIsTerminated(currentListType: ListParsingState, itemCount: number): bool {
            return this.isExpectedListTerminator(currentListType, itemCount) ||
                   this.currentToken().tokenKind === SyntaxKind.EndOfFileToken;
        }

        private arrayPool: any[][] = [];
        private getArray(): any[] {
            if (this.arrayPool.length > 0) {
                return this.arrayPool.pop();
            }

            return [];
        }

        private returnArray(array: any[]) {
            array.length = 0;
            this.arrayPool.push(array);
        }

        private parseSyntaxListWorker(currentListType: ListParsingState,
                                      processItems: (parser: ParserImpl, items: any[]) => void ): { skippedTokens: ISyntaxToken[]; list: ISyntaxList; } {
            var items: SyntaxNode[] = this.getArray();
            var skippedTokens: ISyntaxToken[] = this.getArray();

            while (true) {
                // Try to parse an item of the list.  If we fail then decide if we need to abort or 
                // continue parsing.
                var oldItemsCount = items.length;
                this.tryParseExpectedListItem(currentListType, /*inErrorRecovery:*/ false, items, processItems);

                var newItemsCount = items.length;
                if (newItemsCount === oldItemsCount) {
                    // We weren't able to parse out a list element.

                    // That may have been because the list is complete.  In that case, break out 
                    // and return the items we were able parse.
                    if (this.listIsTerminated(currentListType, newItemsCount)) {
                        break
                    }

                    // List wasn't complete and we didn't get an item.  Figure out if we should bail out
                    // or skip a token and continue.
                    var abort = this.abortParsingListOrMoveToNextToken(currentListType, newItemsCount, items, skippedTokens);
                    if (abort) {
                        break;
                    }
                }

                // We either parsed an element.  Or we failed to, but weren't at the end of the list
                // and didn't want to abort. Continue parsing elements.
            }

            var result = Syntax.list(items);

            // Can't return if it has more then 1 element.  In that case, the list will have been
            // copied into the SyntaxList.
            if (items.length <= 1) {
                this.returnArray(items);
            }

            return { skippedTokens: skippedTokens, list: result };
        }

        private parseSeparatedSyntaxListWorker(currentListType: ListParsingState): { skippedTokens: ISyntaxToken[]; list: ISeparatedSyntaxList; } {
            var items: ISyntaxNodeOrToken[] = this.getArray();
            var skippedTokens: ISyntaxToken[] = this.getArray();
            Debug.assert(items.length === 0);
            Debug.assert(skippedTokens.length === 0);
            Debug.assert(skippedTokens !== items);

            var allowAutomaticSemicolonInsertion = this.allowsAutomaticSemicolonInsertion(currentListType);
            var separatorKind = this.separatorKind(currentListType);

            var inErrorRecovery = false;
            var listWasTerminated = false;
            while (true) {
                // Try to parse an item of the list.  If we fail then decide if we need to abort or 
                // continue parsing.
                var oldItemsCount = items.length;
                // Debug.assert(oldItemsCount % 2 === 0);
                this.tryParseExpectedListItem(currentListType, inErrorRecovery, items, null);
                
                var newItemsCount = items.length;
                if (newItemsCount === oldItemsCount) {
                    // We weren't able to parse out a list element.
                    // Debug.assert(items === null || items.length % 2 === 0);
                    
                    // That may have been because the list is complete.  In that case, break out 
                    // and return the items we were able parse.
                    if (this.listIsTerminated(currentListType, newItemsCount)) {
                        listWasTerminated = true;
                        break;
                    }
                    
                    // List wasn't complete and we didn't get an item.  Figure out if we should bail out
                    // or skip a token and continue.
                    var abort = this.abortParsingListOrMoveToNextToken(currentListType, oldItemsCount, items, skippedTokens);
                    if (abort) {
                        break;
                    }
                    else {
                        // We just skipped a token.  We're now in error recovery mode.
                        inErrorRecovery = true;
                        continue;
                    }
                }

                // Debug.assert(newItemsCount % 2 === 1);

                // We were able to successfully parse out a list item.  So we're no longer in error
                // recovery.
                inErrorRecovery = false;

                // Now, we have to see if we have a separator or not.  If we do have a separator
                // we've got to consume it and continue trying to parse list items.
                if (this.currentToken().tokenKind === separatorKind) {
                    // Consume the last separator and continue parsing list elements.
                    items.push(this.eatToken(separatorKind));
                    continue;
                }

                // We didn't see the expected separator.  There are two reasons this might happen.
                // First, we may actually be at the end of the list.  If we are, then we're done
                // parsing list elements.  
                if (this.listIsTerminated(currentListType, newItemsCount)) {
                    listWasTerminated = true;
                    break;
                }

                // Otherwise, it might be a case where we can parse out an implicit semicolon.

                // Note: it's important that we check this *after* the check above for
                // 'listIsTerminated'.  Consider the following case:
                //
                //      {
                //          a       // <-- just finished parsing 'a'
                //      }
                //
                // Automatic semicolon insertion rules state: "When, as the program is parsed from
                // left to right, a token (called the offending token) is encountered that is not 
                // allowed by any production of the grammar".  So we should only ever insert a 
                // semicolon if we couldn't consume something normally.  in the above case, we can
                // consume the '}' just fine.  So ASI doesn't apply.

                if (allowAutomaticSemicolonInsertion && this.canEatAutomaticSemicolon(/*allowWithoutNewline:*/ false)) {
                    items.push(this.eatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false));
                    // Debug.assert(items.length % 2 === 0);
                    continue;
                }

                // We weren't at the end of the list.  And thre was no separator we could parse out.
                // Try parse the separator we expected, and continue parsing more list elements.
                // This time mark that we're in error recovery mode though.
                //
                // Note: trying to eat this token will emit the appropriate diagnostic.
                items.push(this.eatToken(separatorKind));

                // Now that we're in 'error recovery' mode we cantweak some parsing rules as 
                // appropriate.  For example, if we have:
                //
                //      var v = { a
                //      return
                //
                // Then we'll be missing the comma.  As such, we want to parse 'return' in a less
                // tolerant manner.  Normally 'return' could be a property in an object literal.
                // However, in error recovery mode, we do *not* want it to be.
                //
                // Continue trying to parse out list elements.
                inErrorRecovery = true;
            }

            // Now that we're done parsing, ensure the list is properly formed.
            var allowTrailingSeparator = this.allowsTrailingSeparator(currentListType);
            var requiresAtLeastOneItem = this.requiresAtLeastOneItem(currentListType);

            // If this list requires at least one argument, then report an error if we haven't 
            // gotten any.
            if (requiresAtLeastOneItem && items.length === 0) {
                this.reportUnexpectedTokenDiagnostic(currentListType);
            }
            else {
                // If the list ended with a trailing separator, and that's not allowed, then report
                // an error for it.  Only do this if the list was successfully terminated.  We don't
                // want to report multiple errors if we're missing the closing terminator and we 
                // have a trailing separator.
                if (listWasTerminated &&
                    !allowTrailingSeparator &&
                    items.length > 0 &&
                    items.length % 2 === 0 &&
                    items[items.length - 1] === this.previousToken()) {

                    this.addDiagnostic(new SyntaxDiagnostic(this.fileName,
                        this.previousTokenStart(), this.previousToken().width(), DiagnosticCode.Trailing_separator_not_allowed, null));
                }
            }
            
            var result = Syntax.separatedList(items);

            // Can't return if it has more then 1 element.  In that case, the list will have been
            // copied into the SyntaxList.
            if (items.length <= 1) {
                this.returnArray(items);
            }

            return { skippedTokens: skippedTokens, list: result };
        }

        private allowsTrailingSeparator(currentListType: ListParsingState): bool {
            switch (currentListType) {
                case ListParsingState.EnumDeclaration_EnumElements:
                case ListParsingState.ObjectType_TypeMembers:
                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return true;

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                case ListParsingState.ArgumentList_AssignmentExpressions:
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                case ListParsingState.ParameterList_Parameters:
                    // TODO: It would be great to allow trailing separators for parameters.
                case ListParsingState.TypeArgumentList_Types:
                case ListParsingState.TypeParameterList_TypeParameters:
                    return false;

                case ListParsingState.SourceUnit_ModuleElements:
                case ListParsingState.ClassDeclaration_ClassElements:
                case ListParsingState.ModuleDeclaration_ModuleElements:
                case ListParsingState.SwitchStatement_SwitchClauses:
                case ListParsingState.SwitchClause_Statements:
                case ListParsingState.Block_Statements:
                default:
                    throw Errors.notYetImplemented();
            }
        }

        private requiresAtLeastOneItem(currentListType: ListParsingState): bool {
            switch (currentListType) {
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                case ListParsingState.TypeArgumentList_Types:
                case ListParsingState.TypeParameterList_TypeParameters:
                    return true;

                case ListParsingState.ObjectType_TypeMembers:
                case ListParsingState.EnumDeclaration_EnumElements:
                case ListParsingState.ArgumentList_AssignmentExpressions:
                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                case ListParsingState.ParameterList_Parameters:
                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return false;

                case ListParsingState.SourceUnit_ModuleElements:
                case ListParsingState.ClassDeclaration_ClassElements:
                case ListParsingState.ModuleDeclaration_ModuleElements:
                case ListParsingState.SwitchStatement_SwitchClauses:
                case ListParsingState.SwitchClause_Statements:
                case ListParsingState.Block_Statements:
                default:
                    throw Errors.notYetImplemented();
            }
        }

        private allowsAutomaticSemicolonInsertion(currentListType: ListParsingState): bool {
            switch (currentListType) {
                case ListParsingState.ObjectType_TypeMembers:
                    return true;

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                case ListParsingState.EnumDeclaration_EnumElements:
                case ListParsingState.ArgumentList_AssignmentExpressions:
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                case ListParsingState.ParameterList_Parameters:
                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                case ListParsingState.TypeArgumentList_Types:
                case ListParsingState.TypeParameterList_TypeParameters:
                    return false;

                case ListParsingState.SourceUnit_ModuleElements:
                case ListParsingState.ClassDeclaration_ClassElements:
                case ListParsingState.ModuleDeclaration_ModuleElements:
                case ListParsingState.SwitchStatement_SwitchClauses:
                case ListParsingState.SwitchClause_Statements:
                case ListParsingState.Block_Statements:
                default:
                    throw Errors.notYetImplemented();
            }
        }

        private separatorKind(currentListType: ListParsingState): SyntaxKind {
            switch (currentListType) {
                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                case ListParsingState.ArgumentList_AssignmentExpressions:
                case ListParsingState.EnumDeclaration_EnumElements:
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                case ListParsingState.ParameterList_Parameters:
                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                case ListParsingState.TypeArgumentList_Types:
                case ListParsingState.TypeParameterList_TypeParameters:
                    return SyntaxKind.CommaToken;

                case ListParsingState.ObjectType_TypeMembers:
                    return SyntaxKind.SemicolonToken;

                case ListParsingState.SourceUnit_ModuleElements:
                case ListParsingState.ClassDeclaration_ClassElements:
                case ListParsingState.ModuleDeclaration_ModuleElements:
                case ListParsingState.SwitchStatement_SwitchClauses:
                case ListParsingState.SwitchClause_Statements:
                case ListParsingState.Block_Statements:
                default:
                    throw Errors.notYetImplemented();
            }
        }

        private reportUnexpectedTokenDiagnostic(listType: ListParsingState): void {
            var token = this.currentToken();

            var diagnostic = new SyntaxDiagnostic(this.fileName,
                this.currentTokenStart(), token.width(), DiagnosticCode.Unexpected_token__0_expected, [this.getExpectedListElementType(listType)]);
            this.addDiagnostic(diagnostic);
        }

        private addDiagnostic(diagnostic: SyntaxDiagnostic): void {
            // Except: if we already have a diagnostic for this position, don't report another one.
            if (this.diagnostics.length > 0 &&
                this.diagnostics[this.diagnostics.length - 1].start() === diagnostic.start()) {
                return;
            }

            this.diagnostics.push(diagnostic);
        }

        private isExpectedListTerminator(currentListType: ListParsingState, itemCount: number): bool {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return this.isExpectedSourceUnit_ModuleElementsTerminator();

                case ListParsingState.ClassDeclaration_ClassElements:
                    return this.isExpectedClassDeclaration_ClassElementsTerminator();

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return this.isExpectedModuleDeclaration_ModuleElementsTerminator();

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return this.isExpectedSwitchStatement_SwitchClausesTerminator();

                case ListParsingState.SwitchClause_Statements:
                    return this.isExpectedSwitchClause_StatementsTerminator();

                case ListParsingState.Block_Statements:
                    return this.isExpectedBlock_StatementsTerminator();

                case ListParsingState.TryBlock_Statements:
                    return this.isExpectedTryBlock_StatementsTerminator();

                case ListParsingState.CatchBlock_Statements:
                    return this.isExpectedCatchBlock_StatementsTerminator();

                case ListParsingState.EnumDeclaration_EnumElements:
                    return this.isExpectedEnumDeclaration_EnumElementsTerminator();

                case ListParsingState.ObjectType_TypeMembers:
                    return this.isExpectedObjectType_TypeMembersTerminator();

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return this.isExpectedArgumentList_AssignmentExpressionsTerminator();

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                    return this.isExpectedExtendsOrImplementsClause_TypeNameListTerminator();

                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                    return this.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator(itemCount);

                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    return this.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator();

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return this.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator();

                case ListParsingState.ParameterList_Parameters:
                    return this.isExpectedParameterList_ParametersTerminator();

                case ListParsingState.TypeArgumentList_Types:
                    return this.isExpectedTypeArgumentList_TypesTerminator();

                case ListParsingState.TypeParameterList_TypeParameters:
                    return this.isExpectedTypeParameterList_TypeParametersTerminator();

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return this.isExpectedLiteralExpression_AssignmentExpressionsTerminator();

                default:
                    throw Errors.invalidOperation();
            }
        }

        private isExpectedSourceUnit_ModuleElementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.EndOfFileToken;
        }

        private isExpectedEnumDeclaration_EnumElementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedModuleDeclaration_ModuleElementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedObjectType_TypeMembersTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedLiteralExpression_AssignmentExpressionsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBracketToken;
        }

        private isExpectedTypeArgumentList_TypesTerminator(): bool {
            var token = this.currentToken();
            if (token.tokenKind === SyntaxKind.GreaterThanToken) {
                return true;
            }

            // If we're at a token that can follow the type argument list, then we'll also consider
            // the list terminated.
            if (this.canFollowTypeArgumentListInExpression(token.tokenKind)) {
                return true;
            }

            // TODO: add more cases as necessary for error tolerance.
            return false;
        }

        private isExpectedTypeParameterList_TypeParametersTerminator(): bool {
            var token = this.currentToken();
            if (token.tokenKind === SyntaxKind.GreaterThanToken) {
                return true;
            }

            // These commonly follow type parameter lists.
            if (token.tokenKind === SyntaxKind.OpenParenToken ||
                token.tokenKind === SyntaxKind.OpenBraceToken ||
                token.tokenKind === SyntaxKind.ExtendsKeyword ||
                token.tokenKind === SyntaxKind.ImplementsKeyword) {
                return true;
            }

            // TODO: add more cases as necessary for error tolerance.
            return false;
        }

        private isExpectedParameterList_ParametersTerminator(): bool {
            var token = this.currentToken();
            if (token.tokenKind === SyntaxKind.CloseParenToken) {
                return true;
            }

            // We may also see a { in an error case.  i.e.:
            // function (a, b, c  {
            if (token.tokenKind === SyntaxKind.OpenBraceToken) {
                return true;
            }

            // We may also see a => in an error case.  i.e.:
            // (f: number => { ... }
            if (token.tokenKind === SyntaxKind.EqualsGreaterThanToken) {
                return true;
            }

            return false;
        }

        private isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator(): bool {
            // This is the case when we're parsing variable declarations in a for/for-in statement.
            if (this.currentToken().tokenKind === SyntaxKind.SemicolonToken ||
                this.currentToken().tokenKind === SyntaxKind.CloseParenToken) {
                return true;
            }

            if (this.currentToken().tokenKind === SyntaxKind.InKeyword) {
                return true;
            }

            return false;
        }

        private isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator(itemCount: number): bool {
            //// This is the case when we're parsing variable declarations in a variable statement.

            // If we just parsed a comma, then we can't terminate this list.  i.e.:
            //      var a = bar, // <-- just consumed the comma
            //          b = baz;
            if (this.previousToken().tokenKind === SyntaxKind.CommaToken) {
                return false;
            }

            // ERROR RECOVERY TWEAK:
            // For better error recovery, if we see a => then we just stop immediately.  We've got an
            // arrow function here and it's going to be veyr unlikely that we'll resynchronize and get
            // another variable declaration.
            if (this.currentToken().tokenKind === SyntaxKind.EqualsGreaterThanToken) {
                return true;
            }

            // We're done when we can eat a semicolon and we've parsed at least one item.
            return itemCount > 0 && this.canEatExplicitOrAutomaticSemicolon(/*allowWithoutNewline:*/ false);
        }

        private isExpectedExtendsOrImplementsClause_TypeNameListTerminator(): bool {
            if (this.currentToken().tokenKind === SyntaxKind.ExtendsKeyword ||
                this.currentToken().tokenKind === SyntaxKind.ImplementsKeyword) {
                return true;
            }

            if (this.currentToken().tokenKind === SyntaxKind.OpenBraceToken ||
                this.currentToken().tokenKind === SyntaxKind.CloseBraceToken) {
                return true;
            }

            return false;
        }

        private isExpectedArgumentList_AssignmentExpressionsTerminator(): bool {
            var token0 = this.currentToken();
            return token0.tokenKind === SyntaxKind.CloseParenToken ||
                   token0.tokenKind === SyntaxKind.SemicolonToken;
        }

        private isExpectedClassDeclaration_ClassElementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedSwitchStatement_SwitchClausesTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedSwitchClause_StatementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken ||
                   this.isSwitchClause();
        }

        private isExpectedBlock_StatementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CloseBraceToken;
        }

        private isExpectedTryBlock_StatementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.CatchKeyword ||
                   this.currentToken().tokenKind === SyntaxKind.FinallyKeyword;
        }

        private isExpectedCatchBlock_StatementsTerminator(): bool {
            return this.currentToken().tokenKind === SyntaxKind.FinallyKeyword;
        }

        private isExtendsOrImplementsClause(): bool {
            if (this.currentToken().tokenKind === SyntaxKind.ImplementsKeyword ||
                this.currentToken().tokenKind === SyntaxKind.ExtendsKeyword) {

                return this.isIdentifier(this.peekToken(1));
            }

            return false;
        }

        private isExtendsOrImplementsClauseTypeName(): bool {
            if (this.isName()) {
                // We want to make sure that the "extends" in "extends foo" or the "implements" in
                // "implements foo" is not considered a type name.
                return !this.isExtendsOrImplementsClause();
            }
            
            return false;
        }

        private isExpectedListItem(currentListType: ListParsingState, inErrorRecovery: bool): any {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return this.isModuleElement(inErrorRecovery);

                case ListParsingState.ClassDeclaration_ClassElements:
                    return this.isClassElement(inErrorRecovery);

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return this.isModuleElement(inErrorRecovery);

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return this.isSwitchClause();

                case ListParsingState.SwitchClause_Statements:
                    return this.isStatement(inErrorRecovery);

                case ListParsingState.Block_Statements:
                    return this.isStatement(inErrorRecovery);

                case ListParsingState.TryBlock_Statements:
                case ListParsingState.CatchBlock_Statements:
                    // These two are special.  They're just augmentations of "Block_Statements" 
                    // used so we can abort out of the try block if we see a 'catch' or 'finally'
                    // keyword.  There are no additional list items that they add, so we just
                    // return 'false' here.
                    return false;

                case ListParsingState.EnumDeclaration_EnumElements:
                    return this.isEnumElement();
                
                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    return this.isVariableDeclarator();

                case ListParsingState.ObjectType_TypeMembers:
                    return this.isTypeMember(inErrorRecovery);

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return this.isExpression();

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                    return this.isExtendsOrImplementsClauseTypeName();

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return this.isPropertyAssignment(inErrorRecovery);

                case ListParsingState.ParameterList_Parameters:
                    return this.isParameter();

                case ListParsingState.TypeArgumentList_Types:
                    return this.isType();

                case ListParsingState.TypeParameterList_TypeParameters:
                    return this.isTypeParameter();

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return this.isAssignmentOrOmittedExpression();

                default:
                    throw Errors.invalidOperation();
            }
        }

        private parseExpectedListItem(currentListType: ListParsingState): ISyntaxNodeOrToken {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return this.parseModuleElement();

                case ListParsingState.ClassDeclaration_ClassElements:
                    return this.parseClassElement(/*inErrorRecovery:*/ false);

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return this.parseModuleElement();

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return this.parseSwitchClause();

                case ListParsingState.SwitchClause_Statements:
                    return this.parseStatement();

                case ListParsingState.Block_Statements:
                    return this.parseStatement();

                case ListParsingState.EnumDeclaration_EnumElements:
                    return this.parseEnumElement();

                case ListParsingState.ObjectType_TypeMembers:
                    return this.parseTypeMember();

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return this.parseAssignmentExpression(/*allowIn:*/ true);

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                    return this.parseNameOrGenericType();

                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                    return this.parseVariableDeclarator(/*allowIn:*/ true, /*allowIdentifierName:*/ false);

                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    return this.parseVariableDeclarator(/*allowIn:*/ false, /*allowIdentifierName:*/ false);

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return this.parsePropertyAssignment();

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return this.parseAssignmentOrOmittedExpression();

                case ListParsingState.ParameterList_Parameters:
                    return this.parseParameter();

                case ListParsingState.TypeArgumentList_Types:
                    return this.parseType();

                case ListParsingState.TypeParameterList_TypeParameters:
                    return this.parseTypeParameter();

                default:
                    throw Errors.invalidOperation();
            }
        }

        private getExpectedListElementType(currentListType: ListParsingState): string {
            switch (currentListType) {
                case ListParsingState.SourceUnit_ModuleElements:
                    return Strings.module__class__interface__enum__import_or_statement;

                case ListParsingState.ClassDeclaration_ClassElements:
                    return Strings.constructor__function__accessor_or_variable;

                case ListParsingState.ModuleDeclaration_ModuleElements:
                    return Strings.module__class__interface__enum__import_or_statement;

                case ListParsingState.SwitchStatement_SwitchClauses:
                    return Strings.case_or_default_clause;

                case ListParsingState.SwitchClause_Statements:
                    return Strings.statement;

                case ListParsingState.Block_Statements:
                    return Strings.statement;

                case ListParsingState.VariableDeclaration_VariableDeclarators_AllowIn:
                case ListParsingState.VariableDeclaration_VariableDeclarators_DisallowIn:
                    return Strings.identifier;

                case ListParsingState.EnumDeclaration_EnumElements:
                    return Strings.identifier;

                case ListParsingState.ObjectType_TypeMembers:
                    return Strings.call__construct__index__property_or_function_signature;

                case ListParsingState.ArgumentList_AssignmentExpressions:
                    return Strings.expression;

                case ListParsingState.ExtendsOrImplementsClause_TypeNameList:
                    return Strings.type_name;

                case ListParsingState.ObjectLiteralExpression_PropertyAssignments:
                    return Strings.property_or_accessor;

                case ListParsingState.ParameterList_Parameters:
                    return Strings.parameter;

                case ListParsingState.TypeArgumentList_Types:
                    return Strings.type;

                case ListParsingState.TypeParameterList_TypeParameters:
                    return Strings.type_parameter;

                case ListParsingState.ArrayLiteralExpression_AssignmentExpressions:
                    return Strings.expression;

                default:
                    throw Errors.invalidOperation();
            }
        }
    }

    class GrammarCheckerWalker extends PositionTrackingWalker {
    }

    export function parse(fileName: string,
                          text: ISimpleText,
                          isDeclaration: bool,
                          languageVersion: LanguageVersion = LanguageVersion.EcmaScript5,
                          options?: ParseOptions = null): SyntaxTree {
        var source = new NormalParserSource(fileName, text, languageVersion);
        options = options || new ParseOptions();

        return new ParserImpl(fileName, text.lineMap(), source, options).parseSyntaxTree(isDeclaration);
    }

    export function incrementalParse(oldSyntaxTree: SyntaxTree,
                                     textChangeRange: TextChangeRange,
                                     newText: ISimpleText): SyntaxTree {
        if (textChangeRange.isUnchanged()) {
            return oldSyntaxTree;
        }
        
        var source = new IncrementalParserSource(oldSyntaxTree, textChangeRange, newText);

        return new ParserImpl(oldSyntaxTree.fileName(), newText.lineMap(), source, oldSyntaxTree.parseOptions()).parseSyntaxTree(oldSyntaxTree.isDeclaration());
    }
}
///<reference path='References.ts' />

module TypeScript.TextFactory {
    /// <summary>
    /// Return startLineBreak = index-1, lengthLineBreak = 2   if there is a \r\n at index-1
    /// Return startLineBreak = index,   lengthLineBreak = 1   if there is a 1-char newline at index
    /// Return startLineBreak = index+1, lengthLineBreak = 0   if there is no newline at index.
    /// </summary>
    function getStartAndLengthOfLineBreakEndingAt(
        text: IText, index: number, info: LinebreakInfo): void {

        var c = text.charCodeAt(index);
        if (c === CharacterCodes.lineFeed) {
            if (index > 0 && text.charCodeAt(index - 1) === CharacterCodes.carriageReturn) {
                // "\r\n" is the only 2-character line break.
                info.startPosition = index - 1;
                info.length = 2;
            }
            else {
                info.startPosition = index;
                info.length = 1;
            }
        }
        else if (TextUtilities.isAnyLineBreakCharacter(c)) {
            info.startPosition = index;
            info.length = 1;
        }
        else {
            info.startPosition = index + 1;
            info.length = 0;
        }
    }

    class LinebreakInfo {
        constructor(public startPosition: number,
                     public length: number) {
        }
    }

    class TextLine implements ITextLine {
        private _text: IText = null;
        private _textSpan: TextSpan = null;
        private _lineBreakLength: number;
        private _lineNumber: number;

        constructor(text: IText, body: TextSpan, lineBreakLength: number, lineNumber: number) {
            Contract.throwIfNull(text);
            Contract.throwIfFalse(lineBreakLength >= 0);
            Contract.requires(lineNumber >= 0);
            this._text = text;
            this._textSpan = body;
            this._lineBreakLength = lineBreakLength;
            this._lineNumber = lineNumber;
        }

        public start(): number {
            return this._textSpan.start();
        }

        public end(): number {
            return this._textSpan.end();
        }

        public endIncludingLineBreak(): number {
            return this.end() + this._lineBreakLength;
        }

        public extent(): TextSpan {
            return this._textSpan;
        }

        public extentIncludingLineBreak(): TextSpan {
            return TextSpan.fromBounds(this.start(), this.endIncludingLineBreak());
        }

        public toString(): string {
            return this._text.toString(this._textSpan);
        }

        public lineNumber(): number {
            return this._lineNumber;
        }
    }

    class TextBase implements IText {
        /// <summary>
        /// The line start position of each line.
        /// </summary>
        private lazyLineStarts: number[] = null;

        /// <summary>
        /// The length of the text represented by <see cref="T:StringText"/>.
        /// </summary>
        public length(): number {
            throw Errors.abstract();
        }

        /// <summary>
        /// Returns a character at given position.
        /// </summary>
        /// <param name="position">The position to get the character from.</param>
        /// <returns>The character.</returns>
        /// <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
        /// greater than <see cref="T:"/> length.</exception>
        public charCodeAt(position: number): number {
            throw Errors.abstract();
        }

        checkSubSpan(span: TextSpan): void {
            if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                throw Errors.argumentOutOfRange("span");
            }
        }

        /// <summary>
        /// Provides a string representation of the StringText located within given span.
        /// </summary>
        /// <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        public toString(span?: TextSpan = null): string {
            throw Errors.abstract();
        }

        public subText(span: TextSpan): IText {
            this.checkSubSpan(span);

            return new SubText(this, span);
        }

        public substr(start: number, length: number, intern: bool): string {
            throw Errors.abstract();
        }

        /// <summary>
        /// Copy a range of characters from this IText to a destination array.
        /// </summary>
        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            throw Errors.abstract();
        }

        /// <summary>
        /// The length of the text represented by <see cref="T:StringText"/>.
        /// </summary>
        public lineCount(): number {
            return this.lineStarts().length;
        }

        /// <summary>
        /// The sequence of lines represented by <see cref="T:StringText"/>.
        /// </summary>
        public lines(): ITextLine[] {
            var lines: ITextLine[] = [];

            var length = this.lineCount();
            for (var i = 0; i < length; ++i) {
                lines[i] = this.getLineFromLineNumber(i);
            }

            return lines;
        }

        public lineMap(): LineMap {
            return new LineMap(this.lineStarts(), this.length());
        }

        private lineStarts(): number[] {
            if (this.lazyLineStarts === null) {
                this.lazyLineStarts = TextUtilities.parseLineStarts(this);
            }

            return this.lazyLineStarts;
        }

        private linebreakInfo = new LinebreakInfo(0, 0);
        public getLineFromLineNumber(lineNumber: number): ITextLine {
            var lineStarts = this.lineStarts();

            if (lineNumber < 0 || lineNumber >= lineStarts.length) {
                throw Errors.argumentOutOfRange("lineNumber");
            }

            var first = lineStarts[lineNumber];
            if (lineNumber === lineStarts.length - 1) {
                return new TextLine(this, new TextSpan(first, this.length() - first), 0, lineNumber);
            }
            else {
                getStartAndLengthOfLineBreakEndingAt(this, lineStarts[lineNumber + 1] - 1, this.linebreakInfo);
                return new TextLine(this, new TextSpan(first, this.linebreakInfo.startPosition - first), this.linebreakInfo.length, lineNumber);
            }

        }

        private lastLineFoundForPosition: ITextLine = null;
        public getLineFromPosition(position: number): ITextLine {
            // After asking about a location on a particular line
            // it is common to ask about other position in the same line again.
            // try to see if this is the case.
            var lastFound = this.lastLineFoundForPosition;
            if (lastFound !== null &&
                lastFound.start() <= position &&
                lastFound.endIncludingLineBreak() > position) {
                return lastFound;
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            var result = this.getLineFromLineNumber(lineNumber);
            this.lastLineFoundForPosition = result;
            return result;
        }

        public getLineNumberFromPosition(position: number): number {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }

            if (position === this.length()) {
                // this can happen when the user tried to get the line of items
                // that are at the absolute end of this text (i.e. the EndOfLine
                // token, or missing tokens that are at the end of the text).
                // In this case, we want the last line in the text.
                return this.lineCount() - 1;
            }

            // Binary search to find the right line
            var lineNumber = ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }

            return lineNumber;
        }

        public getLinePosition(position: number): LineAndCharacter {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            return new LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
        }
    }

    /// <summary>
    /// An IText that represents a subrange of another IText.
    /// </summary>
    class SubText extends TextBase {
        private text: IText;
        private span: TextSpan;

        constructor(text: IText, span: TextSpan) {
            super();

            if (text === null) {
                throw Errors.argumentNull("text");
            }

            if (span.start() < 0 ||
                span.start() >= text.length() ||
                 span.end() < 0 ||
                 span.end() > text.length()) {
                throw Errors.argument("span");
            }

            this.text = text;
            this.span = span;
        }

        public length(): number {
            return this.span.length();
        }

        public charCodeAt(position: number): number {
            if (position < 0 || position > this.length()) {
                throw Errors.argumentOutOfRange("position");
            }

            return this.text.charCodeAt(this.span.start() + position);
        }

        public subText(span: TextSpan): IText {
            this.checkSubSpan(span);

            return new SubText(this.text, this.getCompositeSpan(span.start(), span.length()));
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            var span = this.getCompositeSpan(sourceIndex, count);
            this.text.copyTo(span.start(), destination, destinationIndex, span.length());
        }

        private getCompositeSpan(start: number, length: number): TextSpan {
            var compositeStart = MathPrototype.min(this.text.length(), this.span.start() + start);
            var compositeEnd = MathPrototype.min(this.text.length(), compositeStart + length);
            return new TextSpan(compositeStart, compositeEnd - compositeStart);
        }
    }

    /// <summary>
    /// Implementation of IText based on a <see cref="T:System.String"/> input
    /// </summary>
    class StringText extends TextBase {
        /// <summary>
        /// Underlying string on which this IText instance is based
        /// </summary>
        private source: string = null;

        /// <summary>
        /// Initializes an instance of <see cref="T:StringText"/> with provided data.
        /// </summary>
        constructor(data: string) {
            super();

            if (data === null) {
                throw Errors.argumentNull("data");
            }

            this.source = data;
        }

        /// <summary>
        /// The length of the text represented by <see cref="T:StringText"/>.
        /// </summary>
        public length(): number {
            return this.source.length;
        }

        /// <summary>
        /// Returns a character at given position.
        /// </summary>
        /// <param name="position">The position to get the character from.</param>
        /// <returns>The character.</returns>
        /// <exception cref="T:ArgumentOutOfRangeException">When position is negative or 
        /// greater than <see cref="T:"/> length.</exception>
        public charCodeAt(position: number): number {
            if (position < 0 || position >= this.source.length) {
                throw Errors.argumentOutOfRange("position");
            }

            return this.source.charCodeAt(position);
        }

        public substr(start: number, length: number, intern: bool) {
            return this.source.substr(start, length);
        }

        /// <summary>
        /// Provides a string representation of the StringText located within given span.
        /// </summary>
        /// <exception cref="T:ArgumentOutOfRangeException">When given span is outside of the text range.</exception>
        public toString(span?: TextSpan = null): string {
            if (span === null) {
                span = new TextSpan(0, this.length());
            }

            this.checkSubSpan(span);

            if (span.start() === 0 && span.length() === this.length()) {
                return this.source;
            }

            return this.source.substr(span.start(), span.length());
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            StringUtilities.copyTo(this.source, sourceIndex, destination, destinationIndex, count);
        }
    }

    export function createText(value: string): IText {
        return new StringText(value);
    }
}

module TypeScript.SimpleText {
    /// <summary>
    /// An IText that represents a subrange of another IText.
    /// </summary>
    class SimpleSubText implements ISimpleText {
        private text: ISimpleText = null;
        private span: TextSpan = null;

        constructor(text: ISimpleText, span: TextSpan) {
            if (text === null) {
                throw Errors.argumentNull("text");
            }

            if (span.start() < 0 ||
                span.start() >= text.length() ||
                 span.end() < 0 ||
                 span.end() > text.length()) {
                throw Errors.argument("span");
            }

            this.text = text;
            this.span = span;
        }

        private checkSubSpan(span: TextSpan): void {
            if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                throw Errors.argumentOutOfRange("span");
            }
        }

        private checkSubPosition(position: number): void {
            if (position < 0 || position >= this.length()) {
                throw Errors.argumentOutOfRange("position");
            }
        }

        public length(): number {
            return this.span.length();
        }

        public subText(span: TextSpan): ISimpleText {
            this.checkSubSpan(span);

            return new SimpleSubText(this.text, this.getCompositeSpan(span.start(), span.length()));
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            var span = this.getCompositeSpan(sourceIndex, count);
            this.text.copyTo(span.start(), destination, destinationIndex, span.length());
        }

        public substr(start: number, length: number, intern: bool): string {
            var span = this.getCompositeSpan(start, length);
            return this.text.substr(span.start(), span.length(), intern);
        }

        private getCompositeSpan(start: number, length: number): TextSpan {
            var compositeStart = MathPrototype.min(this.text.length(), this.span.start() + start);
            var compositeEnd = MathPrototype.min(this.text.length(), compositeStart + length);
            return new TextSpan(compositeStart, compositeEnd - compositeStart);
        }

        public charCodeAt(index: number): number {
            this.checkSubPosition(index);
            return this.text.charCodeAt(this.span.start() + index);
        }

        public lineMap(): LineMap {
            return LineMap.fromSimpleText(this);
        }
    }

    class SimpleStringText implements ISimpleText {
        constructor(private value: string) {
        }

        public length(): number {
            return this.value.length;
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            StringUtilities.copyTo(this.value, sourceIndex, destination, destinationIndex, count);
        }

        private static charArray: number[] = ArrayUtilities.createArray(1024, 0);

        public substr(start: number, length: number, intern: bool): string {
            if (intern) {
                // use a shared array instance of the length of this substring isn't too large.
                var array = length <= SimpleStringText.charArray.length
                    ? SimpleStringText.charArray
                    : ArrayUtilities.createArray(length, /*defaultValue:*/0);
                this.copyTo(start, array, 0, length);
                return Collections.DefaultStringTable.addCharArray(array, 0, length);
            }

            return this.value.substr(start, length);
        }

        public subText(span: TextSpan): ISimpleText {
            return new SimpleSubText(this, span);
        }

        public charCodeAt(index: number): number {
            return this.value.charCodeAt(index);
        }

        public lineMap(): LineMap {
            return LineMap.fromSimpleText(this);
        }
    }

    // Class which wraps a host IScriptSnapshot and exposes an ISimpleText for newer compiler code. 
    class ScriptSnapshotText implements ISimpleText {
        private _length: number;
        public segment: string;
        public segmentStart: number;
        private _lineMap: LineMap = null;

        constructor(public scriptSnapshot: IScriptSnapshot) {
            this._length = this.scriptSnapshot.getLength();

            // initialize values so the first call to fetchSegment will actually retrieve new data.
            this.segment = "";
            this.segmentStart = 0;
            this.fetchSegment(0, 1024);
        }

        // Ensures we have a segment that contains the range [start, end).  The segment may start 
        // before 'start' and may end after 'end'. 
        private fetchSegment(start: number, end: number): void {
            if (start >= this.segmentStart && end <= (this.segmentStart + this.segment.length)) {
                // We're in bounds of the last fetched segment.  Nothing to do.
                return;
            }

            // Always try to fetch at least 1k.  Unless it would go past the end of the array.
            var lengthToFetch = this.max(1024, end - start);
            var fetchEnd = this.min(start + lengthToFetch, this._length);

            this.segment = this.scriptSnapshot.getText(start, fetchEnd);
            this.segmentStart = start;
        }

        private max(a: number, b: number): number {
            return a >= b ? a : b;
        }

        private min(a: number, b: number): number {
            return a <= b ? a : b;
        }

        public charCodeAt(index: number): number {
            this.fetchSegment(index, /*end:*/ index + 1);
            return this.segment[index - this.segmentStart];
        }

        public length(): number {
            return this._length;
        }

        public copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void {
            this.fetchSegment(sourceIndex, sourceIndex + count);
            StringUtilities.copyTo(this.segment, sourceIndex - this.segmentStart, destination, destinationIndex, count);
        }

        public substr(start: number, length: number, intern: bool): string {
            this.fetchSegment(start, start + length);
            return this.segment.substr(start - this.segmentStart, length);
        }

        public subText(span: TextSpan): ISimpleText {
            return new SimpleSubText(this, span);
        }

        public lineMap(): LineMap {
            if (this._lineMap === null) {
                var lineStartPositions = this.scriptSnapshot.getLineStartPositions();
                this._lineMap = new LineMap(lineStartPositions, this.length());
            }

            return this._lineMap;
        }
    }

    export function fromString(value: string): ISimpleText {
        return new SimpleStringText(value);
    }

    export function fromScriptSnapshot(scriptSnapshot: IScriptSnapshot): ISimpleText {
        return new ScriptSnapshotText(scriptSnapshot);
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {
    export class DataMap {
        public map: any = {};

        public link(id: string, data: any) {
            this.map[id] = data;
        }

        public unlink(id: string) {
            this.map[id] = undefined;
        }

        //public unlinkChildren(ast:AST) {
        //    TypeScript.getAstWalkerFactory().walk(ast, (ast: AST, parent: AST): AST => { this.unlink(ast); });
        //}

        public read(id: string) {
            return this.map[id];
        }

        public flush() {
            this.map = {};
        }

        public unpatch() { return null; }
    }

    export class PatchedDataMap extends DataMap {
        public diffs: any = {};

        constructor(public parent: DataMap) {
            super();
        }

        public link(id: string, data: any) {
            this.diffs[id] = data;
        }

        public unlink(id: string) {
            this.diffs[id] = undefined;
        }

        public read(id: string) {

            var data = this.diffs[id];

            if (data) {
                return data;
            }

            return this.parent.read(id);
        }

        public flush() {
            this.diffs = {};
        }

        public unpatch() {
            this.flush();
            return this.parent;
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {

    export enum PullElementFlags {
        None = 0,
        Exported = 1,
        Private = 1 << 1,
        Public = 1 << 2,
        Ambient = 1 << 3,
        Static = 1 << 4,
        LocalStatic = 1 << 5,
        GetAccessor = 1 << 6,
        SetAccessor = 1 << 7,
        Optional = 1 << 8,
        Call = 1 << 9,
        Constructor = 1 << 10,
        Index = 1 << 11,
        Signature = 1 << 12,
        Enum = 1 << 13,
        FatArrow = 1 << 14,

        ClassConstructorVariable = 1 << 15,
        InitializedModule = 1 << 16,
        InitializedDynamicModule = 1 << 17,

        MustCaptureThis = 1 << 18,
        Constant = 1 << 19,

        ExpressionElement = 1 << 20,

        ImplicitVariable = ClassConstructorVariable | InitializedModule | InitializedDynamicModule,
        SomeInitializedModule = InitializedModule | InitializedDynamicModule,
    }

    export enum PullElementKind {
        None = 0,

        Script = 1,
        Global = 1 << 1,
        Primitive = 1 << 2,

        Container = 1 << 3,
        Class = 1 << 4,
        Interface = 1 << 5,
        DynamicModule = 1 << 6,
        Enum = 1 << 7,
        Array = 1 << 8,
        TypeAlias = 1 << 9,
        ObjectLiteral = 1 << 10,

        Variable = 1 << 11,
        Parameter = 1 << 12,
        Property = 1 << 13,
        TypeParameter = 1 << 14,

        Function = 1 << 15,
        ConstructorMethod = 1 << 16,
        Method = 1 << 17,
        FunctionExpression = 1 << 18,

        GetAccessor = 1 << 19,
        SetAccessor = 1 << 20,

        CallSignature = 1 << 21,
        ConstructSignature = 1 << 22,
        IndexSignature = 1 << 23,

        ObjectType = 1 << 24,
        FunctionType = 1 << 25,
        ConstructorType = 1 << 26,

        SomeFunction = Function | ConstructorMethod | Method | FunctionExpression | GetAccessor | SetAccessor | CallSignature | ConstructSignature | IndexSignature,

        // Warning: SomeValue and SomeType (along with their constituents) must be disjoint
        SomeValue = Variable | Parameter | Property | SomeFunction,

        SomeType = Script | Global | Primitive | Container | Class | Interface | DynamicModule |
                    Enum | Array | TypeAlias | ObjectType | FunctionType | ConstructorType | TypeParameter,

        SomeContainer = Container | DynamicModule,

        SomeSignature = CallSignature | ConstructSignature | IndexSignature,

        SomeAccessor = GetAccessor | SetAccessor,
    }

    export enum SymbolLinkKind {
        TypedAs,
        ContextuallyTypedAs,
        ProvidesInferredType,
        ArrayType,

        ArrayOf,

        PublicMember,
        PrivateMember,

        ConstructorMethod,

        Aliases,

        ContainedBy,

        Extends,
        Implements,

        Parameter,
        ReturnType,

        CallSignature,
        ConstructSignature,
        IndexSignature,

        TypeParameter,
        TypeArgument,
        TypeParameterSpecializedTo,
        SpecializedTo,

        TypeConstraint,

        GetterFunction,
        SetterFunction,
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {
    export var pullDeclID = 0;
    export var lastBoundPullDeclId = 0;

    export class PullDecl {
        private declType: PullElementKind;

        private declName: string;

        private symbol: PullSymbol = null;

        // use this to store the signature symbol for a function declaration
        private signatureSymbol: PullSignatureSymbol = null;

        private childDecls: PullDecl[] = [];
        private typeParameters: PullDecl[] = [];

        private childDeclTypeCache: any = new BlockIntrinsics();
        private childDeclValueCache: any = new BlockIntrinsics();
        private childDeclTypeParameterCache: any = new BlockIntrinsics();

        private declID = pullDeclID++;

        private declFlags: PullElementFlags = PullElementFlags.None;

        private span: TextSpan;

        private scriptName: string;

        private diagnostics: IDiagnostic[] = null;

        private parentDecl: PullDecl = null;

        // In the case of classes, initialized modules and enums, we need to track the implicit
        // value set to the constructor or instance type.  We can use this field to make sure that on
        // edits and updates we don't leak the val decl or symbol
        private synthesizedValDecl: PullDecl = null;

        constructor(declName: string, declType: PullElementKind, declFlags: PullElementFlags, span: TextSpan, scriptName: string) {
            this.declName = declName;
            this.declType = declType;
            this.declFlags = declFlags;
            this.span = span;
            this.scriptName = scriptName;
        }

        public getDeclID() { return this.declID; }

        public getName() { return this.declName; }
        public getKind() { return this.declType }

        public setSymbol(symbol: PullSymbol) { this.symbol = symbol; }
        public getSymbol(): PullSymbol { return this.symbol; }

        public setSignatureSymbol(signature: PullSignatureSymbol): void { this.signatureSymbol = signature; }
        public getSignatureSymbol(): PullSignatureSymbol { return this.signatureSymbol; }

        public getFlags(): PullElementFlags { return this.declFlags; }
        public setFlags(flags: PullElementFlags) { this.declFlags = flags; }

        public getSpan(): TextSpan { return this.span; }
        public setSpan(span: TextSpan) { this.span = span; }

        public getScriptName(): string { return this.scriptName; }

        public setValueDecl(valDecl: PullDecl) { this.synthesizedValDecl = valDecl; }
        public getValueDecl() { return this.synthesizedValDecl; }

        public getParentDecl(): PullDecl {
            return this.parentDecl;
        }

        public setParentDecl(parentDecl: PullDecl) {
            this.parentDecl = parentDecl;
        }

        public addDiagnostic(diagnostic: IDiagnostic) {
            if (!this.diagnostics) {
                this.diagnostics = [];
            }

            //error.adjustOffset(this.span.start());

            this.diagnostics[this.diagnostics.length] = diagnostic;
        }

        public getDiagnostics(): IDiagnostic[] {
            return this.diagnostics;
        }

        public setErrors(diagnostics: PullDiagnostic[]) {
            if (diagnostics) {
                this.diagnostics = [];

                // adjust the spans as we parent the errors to the new decl
                for (var i = 0; i < diagnostics.length; i++) {
                    diagnostics[i].adjustOffset(this.span.start());
                    this.diagnostics[this.diagnostics.length] = diagnostics[i];
                }
            }
        }

        public resetErrors() {
            this.diagnostics = [];
        }

        // returns 'true' if the child decl was successfully added
        // ('false' is returned if addIfDuplicate is false and there is a collision)
        public addChildDecl(childDecl: PullDecl, addIfDuplicate? = true) {
            // check if decl exists
            // merge if necessary
            var declName = childDecl.getName();

            if (!addIfDuplicate) { // PULLTODO: Check decl type?
                for (var i = 0; i < this.childDecls.length; i++) {
                    if (this.childDecls[i].getName() == declName) {
                        return false;
                    }
                }
            }

            if (childDecl.getKind() & PullElementKind.TypeParameter) {
                this.typeParameters[this.typeParameters.length] = childDecl;
            }
            else {
                this.childDecls[this.childDecls.length] = childDecl;
            }

            // add to the appropriate cache
            var cache = (childDecl.getKind() & PullElementKind.SomeType) ? (childDecl.getKind() & PullElementKind.TypeParameter) ? this.childDeclTypeParameterCache : this.childDeclTypeCache : this.childDeclValueCache;
            var cacheVal = <PullDecl[]>cache[declName];
            if (!cacheVal) {
                cacheVal = [];
            }

            cacheVal[cacheVal.length] = childDecl;
            cache[declName] = cacheVal;

            return true;
        }

        public findChildDecls(declName: string, declKind: PullElementKind): PullDecl[] {
            // find the decl with the optional type
            // if necessary, cache the decl
            // may be wise to return a chain of decls, or take a parent decl as a parameter
            var cache = (declKind & PullElementKind.SomeType) ? this.childDeclTypeCache : this.childDeclValueCache;
            var cacheVal = <PullDecl[]>cache[declName];

            if (cacheVal) {
                return cacheVal;
            }
            else {
                if (declKind & PullElementKind.SomeType) {
                    cacheVal = this.childDeclTypeParameterCache[declName];

                    if (cacheVal) {
                        return cacheVal;
                    }
                }

                return [];
            }
        }

        public getChildDecls() { return this.childDecls; }
        public getTypeParameters() { return this.typeParameters; }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {
    export var pullSymbolID = 0
    export var lastBoundPullSymbolID = 0;
    export var globalTyvarID = 0;

    export class PullSymbol {

        // private state
        private pullSymbolID = pullSymbolID++;

        private outgoingLinks: LinkList = new LinkList();
        private incomingLinks: LinkList = new LinkList();
        private declarations: LinkList = new LinkList();

        private name: string;

        private cachedPathIDs: any = {};

        private declKind: PullElementKind;

        // caches - free these on invalidate
        private cachedContainerLink: PullSymbolLink = null;
        private cachedTypeLink: PullSymbolLink = null;

        private hasBeenResolved = false;

        private isOptional = false;

        private inResolution = false;

        private isSynthesized = false;

        private resolvingTypeArguments = false;

        private isBound = false;

        private rebindingID = 0;

        private isVarArg = false;

        private isSpecialized = false;
        private isBeingSpecialized = false;

        public typeChangeUpdateVersion = -1;
        public addUpdateVersion = -1;
        public removeUpdateVersion = -1;

        public docComments: string = null;

        // public surface area
        public getSymbolID() { return this.pullSymbolID; }

        public isType() {
            return (this.declKind & PullElementKind.SomeType) != 0;
        }

        public isSignature() {
            return (this.declKind & PullElementKind.SomeSignature) != 0;
        }

        public isArray() {
            return (this.declKind & PullElementKind.Array) != 0;
        }

        public isPrimitive() {
            return this.declKind == PullElementKind.Primitive;
        }

        public isAccessor() {
            return false;
        }

        constructor(name: string, declKind: PullElementKind) {
            this.name = name;
            this.declKind = declKind;
        }

        public isAlias() { return false; }
        public isContainer() { return false; }        

        public getName() { return this.name; }

        public getKind() { return this.declKind; }
        public setKind(declType: PullElementKind) { this.declKind = declType; }

        public setIsOptional() { this.isOptional = true; }
        public getIsOptional() { return this.isOptional; }

        public getIsVarArg() { return this.isVarArg; }
        public setIsVarArg() { this.isVarArg = true; }

        public setIsSynthesized() { this.isSynthesized = true; }
        public getIsSynthesized() { return this.isSynthesized; }

        public setIsSpecialized() { this.isSpecialized = true; this.isBeingSpecialized = false; }
        public currentlyBeingSpecialized() { return this.isBeingSpecialized; }
        public setIsBeingSpecialized() { this.isBeingSpecialized = true; }        

        public setIsBound(rebindingID: number) {
            this.isBound = true;
            this.rebindingID = rebindingID;
        }

        public getRebindingID() {
            return this.rebindingID;
        }

        public getIsBound() { return this.isBound; }

        public addCacheID(cacheID: string) {
            if (!this.cachedPathIDs[cacheID]) {
                this.cachedPathIDs[cacheID] = true;
            }
        }

        public invalidateCachedIDs(cache: any) {
            for (var id in this.cachedPathIDs) {
                if (cache[id]) {
                    cache[id] = undefined;
                }
            }
        }

        // declaration methods
        public addDeclaration(decl: PullDecl) { this.declarations.addItem(decl); }

        public getDeclarations() { return <PullDecl[]>this.declarations.find(d => d); }

        public removeDeclaration(decl: PullDecl) { this.declarations.remove(d => d === decl); }

        public updateDeclarations(map: (item: PullDecl, context: any) => void , context: any) {
            this.declarations.update(map, context);
        }

        // link methods
        public addOutgoingLink(linkTo: PullSymbol, kind: SymbolLinkKind) {
            var link = new PullSymbolLink(this, linkTo, kind);
            this.outgoingLinks.addItem(link);
            linkTo.incomingLinks.addItem(link);

            return link;
        }

        public findOutgoingLinks(p: (psl: PullSymbolLink) => bool) {
            return <PullSymbolLink[]>this.outgoingLinks.find(p);
        }

        public findIncomingLinks(p: (psl: PullSymbolLink) => bool) {
            return <PullSymbolLink[]>this.incomingLinks.find(p);
        }

        public removeOutgoingLink(link: PullSymbolLink) {
            if (link) {
                this.outgoingLinks.remove(p => p === link);
                link.end.incomingLinks.remove(p => p === link);
            }
        }

        public updateOutgoingLinks(map: (item: PullSymbolLink, context: any) => void , context: any) {
            this.outgoingLinks.update(map, context);
        }

        public updateIncomingLinks(map: (item: PullSymbolLink, context: any) => void , context: any) {
            this.incomingLinks.update(map, context);
        }

        public setContainer(containerSymbol: PullTypeSymbol) {
            //containerSymbol.addOutgoingLink(this, relationshipKind);

            var link = this.addOutgoingLink(containerSymbol, SymbolLinkKind.ContainedBy);
            this.cachedContainerLink = link;

            containerSymbol.addContainedByLink(link);
        }

        public getContainer(): PullTypeSymbol {
            if (this.cachedContainerLink) {
                return <PullTypeSymbol>this.cachedContainerLink.end;
            }

            var containerList = this.findOutgoingLinks(link => link.kind == SymbolLinkKind.ContainedBy);

            if (containerList.length) {
                this.cachedContainerLink = containerList[0];
                return <PullTypeSymbol>this.cachedContainerLink.end;
            }

            return null;
        }

        public unsetContainer() {
            if (this.cachedContainerLink) {
                this.removeOutgoingLink(this.cachedContainerLink);
            }
            else {

                // PULLTODO: If we can guarantee that no link will exist without caching, we won't need to search
                var containerList = this.findOutgoingLinks(link => link.kind == SymbolLinkKind.ContainedBy);

                if (containerList.length) {
                    this.removeOutgoingLink(containerList[0]);
                }
            }

            this.invalidate();
        }

        public setType(typeRef: PullTypeSymbol) {

            // PULLTODO: Remove once we're certain that duplicate types can never be set
            //if (this.cachedTypeLink) {
            //    CompilerDiagnostics.Alert("Type '" + this.name + "' is having its type reset from '" + this.cachedTypeLink.end.getName() + "' to '" + typeRef.getName() + "'");
            //}

            if (this.cachedTypeLink) {
                this.unsetType();
            }

            var link = this.addOutgoingLink(typeRef, SymbolLinkKind.TypedAs);
            this.cachedTypeLink = link;
        }

        public getType(): PullTypeSymbol {
            if (this.cachedTypeLink) {
                return <PullTypeSymbol>this.cachedTypeLink.end;
            }

            var typeList = this.findOutgoingLinks(link => link.kind == SymbolLinkKind.TypedAs);

            if (typeList.length) {
                this.cachedTypeLink = typeList[0];
                return <PullTypeSymbol>this.cachedTypeLink.end;
            }

            return null;
        }

        public unsetType() {
            var foundType = false;

            if (this.cachedTypeLink) {
                this.removeOutgoingLink(this.cachedTypeLink);
                foundType = true;
            }
            else {
                var typeList = this.findOutgoingLinks(link => link.kind == SymbolLinkKind.TypedAs);

                if (typeList.length) {
                    this.removeOutgoingLink(typeList[0]);
                }

                foundType = true;
            }

            if (foundType) {
                this.invalidate();
            }
        }

        public isTyped() {
            return this.getType() != null;
        }

        public setResolved() {
            this.hasBeenResolved = true;
            this.inResolution = false;
        }
        public isResolved() { return this.hasBeenResolved; }

        public startResolving() {
            this.inResolution = true;
        }
        public isResolving() {
            return this.inResolution;
        }

        public startResolvingTypeArguments() {
            this.resolvingTypeArguments = true;
        }

        public isResolvingTypeArguments() {
            return this.resolvingTypeArguments;
        }

        public doneResolvingTypeArguments() {
            this.resolvingTypeArguments = false;
        }

        public setUnresolved() {
            this.hasBeenResolved = false;
            this.isBound = false;
        }

        public invalidate() {

            //this.removeOutgoingLink(this.cachedContainerLink);
            //this.removeOutgoingLink(this.cachedTypeLink);

            //this.cachedContainerLink = null;

            this.docComments = null;

            this.hasBeenResolved = false;
            this.isBound = false;

            // reset the errors for its decl
            this.declarations.update((pullDecl: PullDecl) => pullDecl.resetErrors(), null);
        }

        public hasFlag(flag: PullElementFlags): bool {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if ((declarations[i].getFlags() & flag) !== PullElementFlags.None) {
                    return true;
                }
            }
            return false;
        }

        public allDeclsHaveFlag(flag: PullElementFlags): bool {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if (!((declarations[i].getFlags() & flag) !== PullElementFlags.None)) {
                    return false;
                }
            }
            return true;
        }        

        public pathToRoot() {
            var path: PullSymbol[] = [];
            var node = this;
            while (node) {
                if (node.isType()) {
                    var associatedContainerSymbol = (<PullTypeSymbol>node).getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        node = associatedContainerSymbol;
                    }
                }
                path[path.length] = node;
                node = node.getContainer();
            }
            return path;
        }

        public findCommonAncestorPath(b: PullSymbol): PullSymbol[] {
            var aPath = this.pathToRoot();
            if (aPath.length == 1) {
                // Global symbol
                return aPath;
            }

            var bPath: PullSymbol[];
            if (b) {
                bPath = b.pathToRoot();
            } else {
                return aPath;
            }

            var commonNodeIndex = -1;
            for (var i = 0, aLen = aPath.length; i < aLen; i++) {
                var aNode = aPath[i];
                for (var j = 0, bLen = bPath.length; j < bLen; j++) {
                    var bNode = bPath[j];
                    if (aNode == bNode) {
                        commonNodeIndex = i;
                        break;
                    }
                }
                if (commonNodeIndex >= 0) {
                    break;
                }
            }

            if (commonNodeIndex >= 0) {
                return aPath.slice(0, commonNodeIndex);
            }
            else {
                return aPath;
            }
        }

        public toString() {
            var str = this.getNameAndTypeName();
            return str;
        }

        public fullName() {
            var path = this.pathToRoot();
            var fullName = "";
            for (var i = 1; i < path.length; i++) {
                fullName = path[i].getName() + "." + fullName;
            }
            fullName = fullName + this.getName();
            return fullName;
        }

        public getScopedName(scopeSymbol?: PullSymbol) {
            var path = this.findCommonAncestorPath(scopeSymbol);
            var fullName = "";
            for (var i = 1; i < path.length; i++) {
                var kind = path[i].getKind();
                if (kind == PullElementKind.Container) {
                    fullName = path[i].getName() + "." + fullName;
                } else {
                    break;
                }
            }
            fullName = fullName + this.getName();
            return fullName;
        }

        public getScopedNameEx(scopeSymbol?: PullSymbol, getPrettyTypeName?: bool) {
            var name = this.getScopedName(scopeSymbol);
            return MemberName.create(name);
        }

        public getTypeName(scopeSymbol?: PullSymbol, getPrettyTypeName?: bool) {
            var memberName = this.getTypeNameEx(scopeSymbol, getPrettyTypeName);
            return memberName.toString();
        }

        public getTypeNameEx(scopeSymbol?: PullSymbol, getPrettyTypeName?: bool) {
            var type = this.getType();
            if (type) {
                return type.getScopedNameEx(scopeSymbol, getPrettyTypeName);
            }
            return MemberName.create("");
        }

        public getNameAndTypeName(scopeSymbol?: PullSymbol) {
            var nameAndTypeName = this.getNameAndTypeNameEx(scopeSymbol);
            return nameAndTypeName.toString();
        }

        public getNameAndTypeNameEx(scopeSymbol?: PullSymbol) {
            var type = this.getType();
            var nameEx = this.getScopedNameEx(scopeSymbol);
            if (type) {
                var nameStr = nameEx.toString() + (this.getIsOptional() ? "?" : "");
                if (this.declKind != PullElementKind.Property) {
                    var signatures = type.getCallSignatures();
                    var typeName = new MemberNameArray();
                    var signatureName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, nameStr, false, false, scopeSymbol);
                    typeName.addAll(signatureName);
                    return typeName;
                } else {
                    var typeNameEx = type.getScopedNameEx(scopeSymbol);
                    var memberName = MemberName.create(typeNameEx, nameStr + ": ", "");
                    return memberName;
                }
            }
            return nameEx;
        }

        static getTypeParameterString(typars: PullTypeSymbol[], scopeSymbol?: PullSymbol) {
            var typarString = "";
            if (typars && typars.length) {
                typarString = "<";
                for (var i = 0; i < typars.length; i++) {
                    if (i) {
                        typarString += ", ";
                    }
                    typarString += typars[i].getScopedNameEx(scopeSymbol).toString();
                }
                typarString += ">";
            }
            return typarString;
        }
    }

    export class PullSignatureSymbol extends PullSymbol {
        private parameterLinks: PullSymbolLink[] = null;
        private typeParameterLinks: PullSymbolLink[] = null;

        private returnTypeLink: PullSymbolLink = null;

        private hasOptionalParam = false;
        private nonOptionalParamCount = 0;

        private hasVarArgs = false;

        private specializationCache: any = {}

        private memberTypeParameterNameCache: any = null;

        private hasAGenericParameter = false;

        constructor(kind: PullElementKind) {
            super("", kind);
        }

        public isDefinition() { return false; }

        public hasVariableParamList() { return this.hasVarArgs; }
        public setHasVariableParamList() { this.hasVarArgs = true; }

        public setHasGenericParameter() { this.hasAGenericParameter = true; }
        public hasGenericParameter() { return this.hasAGenericParameter; }

        public isGeneric() { return this.hasAGenericParameter || (this.typeParameterLinks && this.typeParameterLinks.length != 0); }

        public addParameter(parameter: PullSymbol, isOptional = false) {
            if (!this.parameterLinks) {
                this.parameterLinks = [];
            }

            var link = this.addOutgoingLink(parameter, SymbolLinkKind.Parameter);
            this.parameterLinks[this.parameterLinks.length] = link;
            this.hasOptionalParam = isOptional;

            if (!isOptional) {
                this.nonOptionalParamCount++;
            }
        }

        public addSpecialization(signature: PullSignatureSymbol, typeArguments: PullTypeSymbol[]) {
            if (typeArguments && typeArguments.length) {
                this.specializationCache[getIDForTypeSubstitutions(typeArguments)] = signature;
            }
        }

        public getSpecialization(typeArguments): PullSignatureSymbol {
            var sig = <PullSignatureSymbol>this.specializationCache[getIDForTypeSubstitutions(typeArguments)];

            if (sig) {
                return sig;
            }

            return null;
        }

        public addTypeParameter(parameter: PullTypeParameterSymbol) {
            if (!this.typeParameterLinks) {
                this.typeParameterLinks = [];
            }

            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new BlockIntrinsics();
            }

            var link = this.addOutgoingLink(parameter, SymbolLinkKind.TypeParameter);
            this.typeParameterLinks[this.typeParameterLinks.length] = link;

            this.memberTypeParameterNameCache[link.end.getName()] = link.end;
        }

        public getNonOptionalParameterCount() { return this.nonOptionalParamCount; }

        public setReturnType(returnType: PullTypeSymbol) {

            if (returnType) {
                if (this.returnTypeLink) {
                    this.removeOutgoingLink(this.returnTypeLink);
                }
                this.returnTypeLink = this.addOutgoingLink(returnType, SymbolLinkKind.ReturnType);
            }
        }

        public getParameters() {
            var params: PullSymbol[] = [];

            if (this.parameterLinks) {
                for (var i = 0; i < this.parameterLinks.length; i++) {
                    params[params.length] = this.parameterLinks[i].end;
                }
            }

            return params;
        }

        public getTypeParameters(): PullTypeParameterSymbol[] {
            var params: PullTypeParameterSymbol[] = [];

            if (this.typeParameterLinks) {
                for (var i = 0; i < this.typeParameterLinks.length; i++) {
                    params[params.length] = <PullTypeParameterSymbol>this.typeParameterLinks[i].end;
                }
            }

            return params;
        }

        public findTypeParameter(name: string): PullTypeParameterSymbol {
            var memberSymbol: PullTypeParameterSymbol;

            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new BlockIntrinsics();

                if (this.typeParameterLinks) {
                    for (var i = 0; i < this.typeParameterLinks.length; i++) {
                        this.memberTypeParameterNameCache[this.typeParameterLinks[i].end.getName()] = this.typeParameterLinks[i].end;
                    }
                }
            }

            memberSymbol = this.memberTypeParameterNameCache[name];

            return memberSymbol;
        }

        public removeParameter(parameterSymbol: PullSymbol) {
            var paramLink: PullSymbolLink;

            if (this.parameterLinks) {
                for (var i = 0; i < this.parameterLinks.length; i++) {
                    if (parameterSymbol == this.parameterLinks[i].end) {
                        paramLink = this.parameterLinks[i];
                        this.removeOutgoingLink(paramLink);
                        break;
                    }
                }
            }

            this.invalidate();
        }

        public mimicSignature(signature: PullSignatureSymbol) {
            // mimic type parameters
            var typeParameters = signature.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;

            if (typeParameters) {
                for (var i = 0; i < typeParameters.length; i++) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());
                    typeParameter.addDeclaration(typeParameters[i].getDeclarations()[0]);
                    this.addTypeParameter(typeParameter);
                }
            }

            // mimic paremeteres (optionality, varargs)
            var parameters = signature.getParameters();
            var parameter: PullSymbol;

            if (parameters) {
                for (var j = 0; j < parameters.length; j++) {
                    parameter = new PullSymbol(parameters[j].getName(), PullElementKind.Parameter);
                    parameter.addDeclaration(parameters[j].getDeclarations()[0]);
                    if (parameters[j].getIsOptional()) {
                        parameter.setIsOptional();
                    }
                    if (parameters[j].getIsVarArg()) {
                        parameter.setIsVarArg();
                        this.setHasVariableParamList();
                    }
                    this.addParameter(parameter);
                }
            }

            // Don't set the return type, since that will just lead to redundant
            // calls to setReturnType when we re-resolve the signature for
            // specialization

            // var returnType = signature.getReturnType();

            // if (returnType) {
            //     this.setReturnType(returnType);
            // }
        }

        public getReturnType(): PullTypeSymbol {
            if (this.returnTypeLink) {
                return <PullTypeSymbol> this.returnTypeLink.end;
            }
            else {
                var rtl = this.findOutgoingLinks((p) => p.kind == SymbolLinkKind.ReturnType);

                if (rtl.length) {
                    this.returnTypeLink = rtl[0];
                    return <PullTypeSymbol> this.returnTypeLink.end;
                }

                return null;
            }
        }

        public invalidate() {

            this.parameterLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.Parameter);
            this.nonOptionalParamCount = 0;
            this.hasOptionalParam = false;
            this.hasAGenericParameter = false;

            // re-compute non-optional arg count, etc
            if (this.parameterLinks) {
                for (var i = 0; i < this.parameterLinks.length; i++) {

                    this.parameterLinks[i].end.invalidate();

                    if (!this.parameterLinks[i].end.getIsOptional()) {
                        this.nonOptionalParamCount++;
                    }
                    else {
                        this.hasOptionalParam;
                        break;
                    }
                }
            }

            super.invalidate();
        }

        static getSignatureTypeMemberName(candidateSignature: PullSignatureSymbol, signatures: PullSignatureSymbol[], scopeSymbol: PullSymbol) {
            var allMemberNames = new MemberNameArray();
            var signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, "", false, false, scopeSymbol, true, candidateSignature);
            allMemberNames.addAll(signatureMemberName);
            return allMemberNames;
        }

        static getSignaturesTypeNameEx(signatures: PullSignatureSymbol[], prefix: string, shortform: bool, brackets: bool, scopeSymbol?: PullSymbol, getPrettyTypeName?: bool, candidateSignature?: PullSignatureSymbol) {
            var result: MemberName[] = [];
            var len = signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }

            var i = 0
            var foundDefinition = false;
            if (candidateSignature && candidateSignature.isDefinition() && len > 1) {
                // Overloaded signature with candidateSignature = definition - cannot be used.
                candidateSignature = null;
            }

            for (; i < len; i++) {
                // the definition signature shouldn't be printed if there are overloads
                if (len > 1 && signatures[i].isDefinition()) {
                    foundDefinition = true;
                    continue;
                }

                var signature = signatures[i];
                if (getPrettyTypeName && candidateSignature) {
                    signature = candidateSignature;
                }

                result.push(signature.getSignatureTypeNameEx(prefix, shortform, brackets, scopeSymbol));
                if (getPrettyTypeName) {
                    break;
                }
            }

            if (getPrettyTypeName && len > 1) {
                var lastMemberName = <MemberNameArray>result[result.length - 1];
                for (i = i + 1; i < len; i++) {
                    if (signatures[i].isDefinition()) {
                        foundDefinition = true;
                        break;
                    }
                }
                var overloadString = " (+ " + (foundDefinition ? len - 2 : len - 1) + " overload(s))";
                lastMemberName.add(MemberName.create(overloadString));
            }

            return result;
        }

        public toString() {
            var s = this.getSignatureTypeNameEx(this.getScopedNameEx().toString(), false, false).toString();
            return s;
        }

        public getSignatureTypeNameEx(prefix: string, shortform: bool, brackets: bool, scopeSymbol?: PullSymbol) {
            var builder = new MemberNameArray();
            var typeParameters = this.getTypeParameters();
            var typeParameterString = PullSymbol.getTypeParameterString(typeParameters, scopeSymbol);
            if (brackets) {
                builder.prefix = prefix + typeParameterString + "[";
            }
            else {
                builder.prefix = prefix + typeParameterString + "(";
            }

            // TODO : shkamat : variable args
            var params = this.getParameters();
            var paramLen = params.length;
            var len = paramLen;
            for (var i = 0 ; i < params.length; i++) {
                var paramType = params[i].getType();
                var typeString = paramType ? ": " : "";
                builder.add(MemberName.create(params[i].getScopedNameEx(scopeSymbol).toString() + (params[i].getIsOptional() ? "?" : "") + typeString));
                if (paramType) {
                    builder.add(paramType.getScopedNameEx(scopeSymbol));
                }
                if (i < paramLen - 1) {
                    builder.add(MemberName.create(", "));
                }
            }

            if (shortform) {
                if (brackets) {
                    builder.add(MemberName.create("] => "));
                }
                else {
                    builder.add(MemberName.create(") => "));
                }
            }
            else {
                if (brackets) {
                    builder.add(MemberName.create("]: "));
                }
                else {
                    builder.add(MemberName.create("): "));
                }
            }

            var returnType = this.getReturnType();

            if (returnType) {
                builder.add(returnType.getScopedNameEx(scopeSymbol));
            }
            else {
                builder.add(MemberName.create("any"));
            }

            return builder;
        }
    }

    export class PullTypeSymbol extends PullSymbol {
        private memberLinks: PullSymbolLink[] = null;
        private typeParameterLinks: PullSymbolLink[] = null;
        private specializationLinks: PullSymbolLink[] = null;
        private containedByLinks: PullSymbolLink[] = null;

        private memberNameCache: any = null;
        private memberTypeNameCache: any = null;
        private memberTypeParameterNameCache: any = null;
        private containedMemberCache: any = null;

        private typeArguments: PullTypeSymbol[] = null;

        private specializedTypeCache: any = null;

        private memberCache: PullSymbol[] = null;

        private implementedTypeLinks: PullSymbolLink[] = null;
        private extendedTypeLinks: PullSymbolLink[] = null;

        private callSignatureLinks: PullSymbolLink[] = null;
        private constructSignatureLinks: PullSymbolLink[] = null;
        private indexSignatureLinks: PullSymbolLink[] = null;

        private arrayType: PullTypeSymbol = null;

        private isSpecialized = false;
        private isBeingSpecialized = false;
        private hasGenericSignature = false;

        private invalidatedSpecializations = false;

        private associatedContainerTypeSymbol: PullTypeSymbol = null;

        public isType() { return true; }
        public isClass() { return false; }
        public hasMembers() { return this.memberLinks && this.memberLinks.length != 0; }
        public isFunction() { return false; }
        public isTypeParameter() { return false; }
        public isTypeVariable() { return false; }

        public setHasGenericSignature() { this.hasGenericSignature = true; }

        public setAssociatedContainerType(type: PullTypeSymbol) {
            this.associatedContainerTypeSymbol = type;
        }

        public getAssociatedContainerType() {
            return this.associatedContainerTypeSymbol;
        }

        public getType() { return this; }

        public getArrayType() { return this.arrayType; }

        public getElementType(): PullTypeSymbol {
            var arrayOfLinks = this.findOutgoingLinks(link => link.kind == SymbolLinkKind.ArrayOf);

            if (arrayOfLinks.length) {
                return <PullTypeSymbol>arrayOfLinks[0].end;
            }

            return null;
        }
        public setArrayType(arrayType: PullTypeSymbol) {
            this.arrayType = arrayType;

            arrayType.addOutgoingLink(this, SymbolLinkKind.ArrayOf);
        }

        public addContainedByLink(containedByLink: PullSymbolLink) {
            if (!this.containedByLinks) {
                this.containedByLinks = [];
            }

            if (!this.containedMemberCache) {
                this.containedMemberCache = {};
            }

            this.containedByLinks[this.containedByLinks.length] = containedByLink;
            this.containedMemberCache[containedByLink.start.getName()] = containedByLink.start;
        }

        public findContainedMember(name: string): PullSymbol {

            if (!this.containedByLinks) {
                this.containedByLinks = this.findIncomingLinks(psl => psl.kind == SymbolLinkKind.ContainedBy);
                this.containedMemberCache = {};

                for (var i = 0; i < this.containedByLinks.length; i++) {
                    this.containedMemberCache[this.containedByLinks[i].start.getName()] = this.containedByLinks[i].start;
                }
            }

            return this.containedMemberCache[name];
        }

        public addMember(memberSymbol: PullSymbol, linkKind: SymbolLinkKind) {

            var link = this.addOutgoingLink(memberSymbol, linkKind);

            memberSymbol.setContainer(this);
            
            if (!this.memberCache) {
                this.memberCache = [];
            }

            if (!this.memberNameCache) {
                this.memberNameCache = new BlockIntrinsics();
            }

            if (!this.memberLinks) {
                this.memberLinks = [];
            }

            if (!memberSymbol.isType()) {
                this.memberLinks[this.memberLinks.length] = link;

                this.memberCache[this.memberCache.length] = memberSymbol;

                if (!this.memberNameCache) {
                    this.memberNameCache = new BlockIntrinsics();
                }
                this.memberNameCache[memberSymbol.getName()] = memberSymbol;
            }
            else {
                if ((<PullTypeSymbol>memberSymbol).isTypeParameter()) {
                    if (!this.typeParameterLinks) {
                        this.typeParameterLinks = [];
                    }
                    if (!this.memberTypeParameterNameCache) {
                        this.memberTypeParameterNameCache = new BlockIntrinsics();
                    }
                    this.typeParameterLinks[this.typeParameterLinks.length] = link;
                    this.memberTypeParameterNameCache[memberSymbol.getName()] = memberSymbol;
                }
                else {
                    if (!this.memberTypeNameCache) {
                        this.memberTypeNameCache = new BlockIntrinsics();
                    }
                    this.memberLinks[this.memberLinks.length] = link;
                    this.memberTypeNameCache[memberSymbol.getName()] = memberSymbol;
                    this.memberCache[this.memberCache.length] = memberSymbol;
                }
            }
        }

        public removeMember(memberSymbol: PullSymbol) {
            var memberLink: PullSymbolLink;
            var child: PullSymbol;

            var links = (memberSymbol.isType() && (<PullTypeSymbol>memberSymbol).isTypeParameter()) ? this.typeParameterLinks : this.memberLinks;

            if (links) {
                for (var i = 0; i < links.length; i++) {
                    if (memberSymbol == links[i].end) {
                        memberLink = links[i];
                        child = memberLink.end;
                        child.unsetContainer();
                        this.removeOutgoingLink(memberLink);
                        break;
                    }
                }
            }

            this.invalidate();
        }

        public getMembers(): PullSymbol[] {

            if (this.memberCache) {
                return this.memberCache;
            }
            else {
                var members: PullSymbol[] = [];

                if (this.memberLinks) {
                    for (var i = 0; i < this.memberLinks.length; i++) {
                        members[members.length] = this.memberLinks[i].end;
                    }
                }

                if (members.length) {
                    this.memberCache = members;
                }

                return members;
            }
        }

        public getTypeParameters(): PullTypeParameterSymbol[] {
            var members: PullTypeParameterSymbol[] = [];

            if (this.typeParameterLinks) {
                for (var i = 0; i < this.typeParameterLinks.length; i++) {
                    members[members.length] = <PullTypeParameterSymbol>this.typeParameterLinks[i].end;
                }
            }

            return members;
        }

        public isGeneric(): bool { return (this.typeParameterLinks && this.typeParameterLinks.length != 0) || this.hasGenericSignature; }

        public addSpecialization(specializedVersionOfThisType: PullTypeSymbol, substitutingTypes: PullTypeSymbol[]): void {

            if (!substitutingTypes || !substitutingTypes.length) {
                return;
            }

            if (!this.specializedTypeCache) {
                this.specializedTypeCache = {};
            }

            if (!this.specializationLinks) {
                this.specializationLinks = [];
            }

            this.specializationLinks[this.specializationLinks.length] = this.addOutgoingLink(specializedVersionOfThisType, SymbolLinkKind.SpecializedTo);

            this.specializedTypeCache[getIDForTypeSubstitutions(substitutingTypes)] = specializedVersionOfThisType;
        }

        public getSpecialization(substitutingTypes: PullTypeSymbol[]): PullTypeSymbol {
            if (!this.specializedTypeCache) {
                this.specializedTypeCache = {};

                return null;
            }

            var specialization = <PullTypeSymbol>this.specializedTypeCache[getIDForTypeSubstitutions(substitutingTypes)];

            if (!specialization) {
                return null;
            }

            return specialization;
        }

        public getKnownSpecializations(): PullTypeSymbol[] {
            var specializations: PullTypeSymbol[] = [];

            if (this.specializedTypeCache) {
                for (var specializationID in this.specializedTypeCache) {
                    specializations[specializations.length] = this.specializedTypeCache[specializationID];
                }
            }

            return specializations;
        }

        public invalidateSpecializations() {

            if (this.invalidatedSpecializations) {
                return;
            }

            var specializations = this.getKnownSpecializations();
            var i = 0;

            for (i = 0; i < specializations.length; i++) {
                specializations[i].invalidate();
            }

            if (this.specializationLinks && this.specializationLinks.length) {
            
                for (i = 0; i < this.specializationLinks.length; i++) {
                    this.removeOutgoingLink(this.specializationLinks[i]);
                }
            }

            this.specializedTypeCache = null;

            this.invalidatedSpecializations = true;
        }

        public getTypeArguments() { return this.typeArguments; }
        public setTypeArguments(typeArgs: PullTypeSymbol[]) { this.typeArguments = typeArgs; }

        public addCallSignature(callSignature: PullSignatureSymbol) {

            if (!this.callSignatureLinks) {
                this.callSignatureLinks = [];
            }

            var link = this.addOutgoingLink(callSignature, SymbolLinkKind.CallSignature);
            this.callSignatureLinks[this.callSignatureLinks.length] = link;

            if (callSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        }

        public addCallSignatures(callSignatures: PullSignatureSymbol[]) {

            if (!this.callSignatureLinks) {
                this.callSignatureLinks = [];
            }

            for (var i = 0; i < callSignatures.length; i++) {
                this.addCallSignature(callSignatures[i]);
            }
        }

        public addConstructSignature(constructSignature: PullSignatureSymbol) {

            if (!this.constructSignatureLinks) {
                this.constructSignatureLinks = [];
            }

            var link = this.addOutgoingLink(constructSignature, SymbolLinkKind.ConstructSignature);
            this.constructSignatureLinks[this.constructSignatureLinks.length] = link;

            if (constructSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        }

        public addConstructSignatures(constructSignatures: PullSignatureSymbol[]) {

            if (!this.constructSignatureLinks) {
                this.constructSignatureLinks = [];
            }

            for (var i = 0; i < constructSignatures.length; i++) {
                this.addConstructSignature(constructSignatures[i]);
            }
        }

        public addIndexSignature(indexSignature: PullSignatureSymbol) {
            if (!this.indexSignatureLinks) {
                this.indexSignatureLinks = [];
            }

            var link = this.addOutgoingLink(indexSignature, SymbolLinkKind.IndexSignature);
            this.indexSignatureLinks[this.indexSignatureLinks.length] = link;

            if (indexSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        }

        public addIndexSignatures(indexSignatures: PullSignatureSymbol[]) {
            if (!this.indexSignatureLinks) {
                this.indexSignatureLinks = [];
            }

            for (var i = 0; i < indexSignatures.length; i++) {
                this.addIndexSignature(indexSignatures[i]);
            }
        }

        public getCallSignatures(): PullSignatureSymbol[] {
            var members: PullSymbol[] = [];

            if (this.callSignatureLinks) {
                for (var i = 0; i < this.callSignatureLinks.length; i++) {
                    members[members.length] = this.callSignatureLinks[i].end;
                }
            }

            return <PullSignatureSymbol[]>members;
        }

        public getConstructSignatures(): PullSignatureSymbol[] {
            var members: PullSymbol[] = [];

            if (this.constructSignatureLinks) {
                for (var i = 0; i < this.constructSignatureLinks.length; i++) {
                    members[members.length] = this.constructSignatureLinks[i].end;
                }
            }

            return <PullSignatureSymbol[]>members;
        }

        public getIndexSignatures(): PullSignatureSymbol[] {
            var members: PullSymbol[] = [];

            if (this.indexSignatureLinks) {
                for (var i = 0; i < this.indexSignatureLinks.length; i++) {
                    members[members.length] = this.indexSignatureLinks[i].end;
                }
            }

            return <PullSignatureSymbol[]>members;
        }

        public removeCallSignature(signature: PullSignatureSymbol, invalidate = true) {
            var signatureLink: PullSymbolLink;

            if (this.callSignatureLinks) {
                for (var i = 0; i < this.callSignatureLinks.length; i++) {
                    if (signature == this.callSignatureLinks[i].end) {
                        signatureLink = this.callSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }

            if (invalidate) {
                this.invalidate();
            }
        }

        public recomputeCallSignatures() {
            this.callSignatureLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.CallSignature);
        }

        public removeConstructSignature(signature: PullSignatureSymbol, invalidate = true) {
            var signatureLink: PullSymbolLink;

            if (this.constructSignatureLinks) {
                for (var i = 0; i < this.constructSignatureLinks.length; i++) {
                    if (signature == this.constructSignatureLinks[i].end) {
                        signatureLink = this.constructSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }

            if (invalidate) {
                this.invalidate();
            }
        }

        public recomputeConstructSignatures() {
            this.constructSignatureLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.ConstructSignature);
        }

        public removeIndexSignature(signature: PullSignatureSymbol, invalidate = true) {
            var signatureLink: PullSymbolLink;

            if (this.indexSignatureLinks) {
                for (var i = 0; i < this.indexSignatureLinks.length; i++) {
                    if (signature == this.indexSignatureLinks[i].end) {
                        signatureLink = this.indexSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }

            if (invalidate) {
                this.invalidate();
            }
        }

        public recomputeIndexSignatures() {
            this.indexSignatureLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.IndexSignature);
        }

        public addImplementedType(interfaceType: PullTypeSymbol) {
            if (!this.implementedTypeLinks) {
                this.implementedTypeLinks = [];
            }

            var link = this.addOutgoingLink(interfaceType, SymbolLinkKind.Implements);
            this.implementedTypeLinks[this.implementedTypeLinks.length] = link;
        }

        public getImplementedTypes(): PullTypeSymbol[] {
            var members: PullSymbol[] = [];

            if (this.implementedTypeLinks) {
                for (var i = 0; i < this.implementedTypeLinks.length; i++) {
                    members[members.length] = this.implementedTypeLinks[i].end;
                }
            }

            return <PullTypeSymbol[]>members;
        }

        public removeImplementedType(implementedType: PullTypeSymbol) {
            var typeLink: PullSymbolLink;

            if (this.implementedTypeLinks) {
                for (var i = 0; i < this.implementedTypeLinks.length; i++) {
                    if (implementedType == this.implementedTypeLinks[i].end) {
                        typeLink = this.implementedTypeLinks[i];
                        this.removeOutgoingLink(typeLink);
                        break;
                    }
                }
            }

            this.invalidate();
        }

        public addExtendedType(extendedType: PullTypeSymbol) {
            if (!this.extendedTypeLinks) {
                this.extendedTypeLinks = [];
            }

            var link = this.addOutgoingLink(extendedType, SymbolLinkKind.Extends);
            this.extendedTypeLinks[this.extendedTypeLinks.length] = link;

            // var parentMembers = extendedType.getMembers();

            // PULLTODO: Restrict member list to public properties only
            // for (var i = 0; i < parentMembers.length; i++) {
            //     this.addMember(parentMembers[i], SymbolLinkKind.PublicMember);
            // }
        }

        public getExtendedTypes(): PullTypeSymbol[] {
            var members: PullSymbol[] = [];

            if (this.extendedTypeLinks) {
                for (var i = 0; i < this.extendedTypeLinks.length; i++) {
                    members[members.length] = this.extendedTypeLinks[i].end;
                }
            }

            return <PullTypeSymbol[]>members;
        }

        public hasBase(potentialBase: PullTypeSymbol) {

            if (this == potentialBase) {
                return true;
            }

            var extendedTypes = this.getExtendedTypes();
            var i = 0;

            for (i = 0; i < extendedTypes.length; i++) {
                if (extendedTypes[i].hasBase(potentialBase)) {
                    return true;
                }
            }

            var implementedTypes = this.getImplementedTypes();

            for (i = 0; i < implementedTypes.length; i++) {
                if (implementedTypes[i].hasBase(potentialBase)) {
                    return true;
                }
            }

            return false;
        }

        public removeExtendedType(extendedType: PullTypeSymbol) {
            var typeLink: PullSymbolLink;

            if (this.extendedTypeLinks) {
                for (var i = 0; i < this.extendedTypeLinks.length; i++) {
                    if (extendedType == this.extendedTypeLinks[i].end) {
                        typeLink = this.extendedTypeLinks[i];
                        this.removeOutgoingLink(typeLink);
                        break;
                    }
                }
            }

            this.invalidate();
        }

        public findMember(name: string): PullSymbol {
            var memberSymbol: PullSymbol;
            var i = 0;

            if (!this.memberNameCache) {
                this.populateMemberCache();
            }

            memberSymbol = this.memberNameCache[name];

            if (memberSymbol) {
                return memberSymbol;
            }

            // check parents
            if (!memberSymbol && this.extendedTypeLinks) {

                for (i = 0 ; i < this.extendedTypeLinks.length; i++) {
                    memberSymbol = (<PullTypeSymbol>this.extendedTypeLinks[i].end).findMember(name);

                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }

            if (!memberSymbol && this.implementedTypeLinks) {

                for (i = 0 ; i < this.implementedTypeLinks.length; i++) {
                    memberSymbol = (<PullTypeSymbol>this.implementedTypeLinks[i].end).findMember(name);

                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }

            // when all else fails, look for a nested type name
            return this.findNestedType(name);
        }

        public findNestedType(name: string): PullTypeSymbol {
            var memberSymbol: PullTypeSymbol;

            if (!this.memberTypeNameCache) {
                this.populateMemberTypeCache();
            }

            memberSymbol = this.memberTypeNameCache[name];

            return memberSymbol;
        }

        private populateMemberCache() {
            if (!this.memberNameCache) {
                this.memberNameCache = new BlockIntrinsics();
                this.memberCache = [];

                if (this.memberLinks) {
                    for (var i = 0; i < this.memberLinks.length; i++) {
                        this.memberNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                        this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                    }
                }
            }
        }

        private populateMemberTypeCache() {
            if (!this.memberTypeNameCache) {
                this.memberTypeNameCache = new BlockIntrinsics();

                var setAll = false;

                if (!this.memberCache) {
                    this.memberCache = [];
                    this.memberNameCache = new BlockIntrinsics();
                    setAll = true;
                }

                if (this.memberLinks) {
                    for (var i = 0; i < this.memberLinks.length; i++) {
                        if (this.memberLinks[i].end.isType()) {
                            this.memberTypeNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                            this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                        }
                        else if (setAll) {
                            this.memberNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                            this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                        }
                    }
                }
            }
        }

        public getAllMembers(searchDeclKind: PullElementKind, includePrivate: bool): PullSymbol[] {

            var allMembers: PullSymbol[] = [];
            var i = 0;
            var j = 0;
            var m = 0;
            var n = 0;

            // Update the cache id needed
            if (!this.memberTypeNameCache) {
                this.populateMemberTypeCache();
            }

            // Add members
            for (i = 0, n = this.memberCache.length; i < n; i++) {
                var member = this.memberCache[i];
                if ((member.getKind() & searchDeclKind) && (includePrivate || !member.hasFlag(PullElementFlags.Private))) {
                    allMembers[allMembers.length] = member;
                }
            }

            // Add parent members
            if (this.extendedTypeLinks) {

                for (i = 0, n = this.extendedTypeLinks.length; i < n; i++) {
                    var extendedMembers = (<PullTypeSymbol>this.extendedTypeLinks[i].end).getAllMembers(searchDeclKind, includePrivate);

                    for (j = 0, m = extendedMembers.length; j < m; j++) {
                        var extendedMember = extendedMembers[j];
                        if (!this.memberNameCache[extendedMember.getName()]) {
                            allMembers[allMembers.length] = extendedMember;
                        }
                    }
                }
            }

            if (this.implementedTypeLinks) {

                for (i = 0 ; i < this.implementedTypeLinks.length; i++) {
                    var implementedMembers = (<PullTypeSymbol>this.implementedTypeLinks[i].end).getAllMembers(searchDeclKind, includePrivate);

                    for (j = 0, m = implementedMembers.length; j < m; j++) {
                        var implementedMember = implementedMembers[j];
                        if (!this.memberNameCache[implementedMember.getName()]) {
                            allMembers[allMembers.length] = implementedMember;
                        }
                    }
                }
            }

            return allMembers;
        }

        public findTypeParameter(name: string): PullTypeParameterSymbol {
            var memberSymbol: PullTypeParameterSymbol;

            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new BlockIntrinsics();

                if (this.typeParameterLinks) {
                    for (var i = 0; i < this.typeParameterLinks.length; i++) {
                        this.memberTypeParameterNameCache[this.typeParameterLinks[i].end.getName()] = this.typeParameterLinks[i].end;
                    }
                }
            }

            memberSymbol = this.memberTypeParameterNameCache[name];

            return memberSymbol;
        }

        public cleanTypeParameters() {
            if (this.typeParameterLinks) {
                for (var i = 0; i < this.typeParameterLinks.length; i++) {
                    this.removeOutgoingLink(this.typeParameterLinks[i]);
                }
            }

            this.typeParameterLinks = null;
            this.memberTypeParameterNameCache = null;
        }

        public setResolved() {
            this.invalidatedSpecializations = true;
            super.setResolved();
        }

        public invalidate() {

            this.memberNameCache = null;
            this.memberCache = null;
            this.memberTypeNameCache = null;
            this.containedMemberCache = null;

            this.invalidatedSpecializations = false;

            this.containedByLinks = null;

            this.memberLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.PrivateMember ||
                                                              psl.kind == SymbolLinkKind.PublicMember);

            this.typeParameterLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.TypeParameter);

            this.callSignatureLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.CallSignature);

            this.constructSignatureLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.ConstructSignature);

            this.indexSignatureLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.IndexSignature);

            this.implementedTypeLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.Implements);

            this.extendedTypeLinks = this.findOutgoingLinks(psl => psl.kind == SymbolLinkKind.Extends);

            super.invalidate();
        }

        public getScopedName(scopeSymbol?: PullSymbol): string {
            var name = super.getScopedName(scopeSymbol);

            var typars = this.getTypeArguments();
            if (!typars || !typars.length) {
                typars = this.getTypeParameters();
            }

            var typarString = PullSymbol.getTypeParameterString(typars);
            return name + typarString;
        }

        private isNamedTypeSymbol() {
            var kind = this.getKind();
            if (kind == PullElementKind.Primitive || // primitives
                kind == PullElementKind.Class || // class
                kind == PullElementKind.Container || // module
                kind == PullElementKind.Enum || // enum
                kind == PullElementKind.TypeParameter || //TypeParameter
                ((kind == PullElementKind.Interface || kind == PullElementKind.ObjectType) && this.getName() != "")) {
                return true;
            }

            return false;
        }

        public toString() {
            var s = this.getScopedNameEx().toString();
            return s;
        }

        public getScopedNameEx(scopeSymbol?: PullSymbol, getPrettyTypeName?: bool) {
            if (!this.isNamedTypeSymbol()) {
                return this.getMemberTypeNameEx(true, scopeSymbol, getPrettyTypeName);
            }

            return super.getScopedNameEx(scopeSymbol, getPrettyTypeName);
        }

        public hasOnlyOverloadCallSignatures() {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            return members.length == 0 && constructSignatures.length == 0 && callSignatures.length > 1;
        }

        public getMemberTypeNameEx(topLevel: bool, scopeSymbol?: PullSymbol, getPrettyTypeName?: bool): MemberName {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            var indexSignatures = this.getIndexSignatures();

            if (members.length > 0 || callSignatures.length > 0 || constructSignatures.length > 0 || indexSignatures.length > 0) {
                var allMemberNames = new MemberNameArray();
                var curlies = !topLevel || indexSignatures.length != 0;
                var delim = "; ";
                for (var i = 0; i < members.length; i++) {
                    var memberTypeName = members[i].getNameAndTypeNameEx(scopeSymbol);

                    if (memberTypeName.isArray() && (<MemberNameArray>memberTypeName).delim == delim) {
                        allMemberNames.addAll((<MemberNameArray>memberTypeName).entries);
                    } else {
                        allMemberNames.add(memberTypeName);
                    }
                    curlies = true;
                }

                // Use pretty Function overload signature if this is just a call overload
                var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.hasOnlyOverloadCallSignatures();

                var signatureCount = callSignatures.length + constructSignatures.length + indexSignatures.length;
                if (signatureCount != 0 || members.length != 0) {
                    var useShortFormSignature = !curlies && (signatureCount == 1);
                    var signatureMemberName: MemberName[];

                    if (callSignatures.length > 0) {
                        signatureMemberName =
                            PullSignatureSymbol.getSignaturesTypeNameEx(callSignatures, "", useShortFormSignature, false, scopeSymbol, getPrettyFunctionOverload);
                        allMemberNames.addAll(signatureMemberName);
                    }

                    if (constructSignatures.length > 0) {
                        signatureMemberName =
                            PullSignatureSymbol.getSignaturesTypeNameEx(constructSignatures, "new", useShortFormSignature, false, scopeSymbol);
                        allMemberNames.addAll(signatureMemberName);
                    }

                    if (indexSignatures.length > 0) {
                        signatureMemberName =
                            PullSignatureSymbol.getSignaturesTypeNameEx(indexSignatures, "", useShortFormSignature, true, scopeSymbol);
                        allMemberNames.addAll(signatureMemberName);
                    }

                    if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                        allMemberNames.prefix = "{ ";
                        allMemberNames.suffix = "}";
                        allMemberNames.delim = delim;
                    } else if (allMemberNames.entries.length > 1) {
                        allMemberNames.delim = delim;
                    }

                    return allMemberNames;
                }
            }

            return MemberName.create("{}");
        }
    }

    export class PullPrimitiveTypeSymbol extends PullTypeSymbol {
        constructor(name: string) {
            super(name, PullElementKind.Primitive);
        }

        public isResolved() { return true; }
        
        public invalidate() {
            // do nothing...
        }
    }

    // PULLTODO: Unify concepts of constructor method and container
    // type instance types
    export class PullClassTypeSymbol extends PullTypeSymbol {

        private constructorMethod: PullSymbol = null;
        private hasDefaultConstructor = false;

        constructor(name: string) {
            super(name, PullElementKind.Class);
        }

        public isClass() {
            return true;
        }

        public setHasDefaultConstructor(hasOne=true) {
            this.hasDefaultConstructor = hasOne;
        }

        public getHasDefaultConstructor() {
            return this.hasDefaultConstructor;
        }

        public getConstructorMethod() {
            return this.constructorMethod;
        }

        public setConstructorMethod(constructorMethod: PullSymbol) {
            this.constructorMethod = constructorMethod;
        }

        public invalidate() {

            if (this.constructorMethod) {
                this.constructorMethod.invalidate();
            }

            super.invalidate();
        }
    }

    // represents the module "namespace" type
    export class PullContainerTypeSymbol extends PullTypeSymbol {
        public instanceSymbol: PullSymbol  = null;

        constructor(name: string, kind = PullElementKind.Container) {
            super(name, kind);
        }

        public isContainer() { return true; }

        public setInstanceSymbol(symbol: PullSymbol) {
            this.instanceSymbol = symbol;
        }

        public getInstanceSymbol(): PullSymbol {
            return this.instanceSymbol;
        }

        public invalidate() {

            if (this.instanceSymbol) {
                this.instanceSymbol.invalidate();
            }

            super.invalidate();
        }
    }

    export class PullTypeAliasSymbol extends PullTypeSymbol {

        private typeAliasLink: PullSymbolLink = null;
        private isUsedAsValue = false;

        constructor(name: string) {
            super(name, PullElementKind.TypeAlias);
        }

        public isAlias() { return true; }

        public setAliasedType(type: PullTypeSymbol) {
            if (this.typeAliasLink) {
                this.removeOutgoingLink(this.typeAliasLink);
            }

            this.typeAliasLink = this.addOutgoingLink(type, SymbolLinkKind.Aliases);
        }

        public getType(): PullTypeSymbol {
            if (this.typeAliasLink) {
                return this.typeAliasLink.end;
            }

            return null;
        }

        public setType(type: PullTypeSymbol) {
            this.setAliasedType(type);
        }

        public setIsUsedAsValue() {
            this.isUsedAsValue = true;
        }

        public getIsUsedAsValue() {
            return this.isUsedAsValue;
        }

        public getMembers(): PullSymbol[] {
            if (this.typeAliasLink) {
                return (<PullTypeSymbol>this.typeAliasLink.end).getMembers();
            }

            return [];
        }

        public getCallSignatures(): PullSignatureSymbol[] {
            if (this.typeAliasLink) {
                return (<PullTypeSymbol>this.typeAliasLink.end).getCallSignatures();
            }

            return [];
        }

        public getConstructSignatures(): PullSignatureSymbol[] {
            if (this.typeAliasLink) {
                return (<PullTypeSymbol>this.typeAliasLink.end).getConstructSignatures();
            }

            return [];
        }

        public getIndexSignatures(): PullSignatureSymbol[] {
            if (this.typeAliasLink) {
                return (<PullTypeSymbol>this.typeAliasLink.end).getIndexSignatures();
            }

            return [];
        }        

        public findMember(name: string): PullSymbol {
            if (this.typeAliasLink) {
                return (<PullTypeSymbol>this.typeAliasLink.end).findMember(name);
            }

            return null;
        }

        public findNestedType(name: string): PullTypeSymbol {
            if (this.typeAliasLink) {
                return (<PullTypeSymbol>this.typeAliasLink.end).findNestedType(name);
            }

            return null;
        }

        public getAllMembers(searchDeclKind: PullElementKind, includePrivate: bool): PullSymbol[] {
            if (this.typeAliasLink) {
                return (<PullTypeSymbol>this.typeAliasLink.end).getAllMembers(searchDeclKind, includePrivate);
            }

            return [];
        }

        public invalidate() {
            this.isUsedAsValue = false;

            super.invalidate();
        }
    }

    export class PullDefinitionSignatureSymbol extends PullSignatureSymbol {
        public isDefinition() { return true; }
    }

    export class PullFunctionTypeSymbol extends PullTypeSymbol {
        private definitionSignature: PullDefinitionSignatureSymbol = null;

        constructor() {
            super("", PullElementKind.FunctionType);
        }

        public isFunction() { return true; }

        public invalidate() {

            var callSignatures = this.getCallSignatures();

            if (callSignatures.length) {
                for (var i = 0; i < callSignatures.length; i++) {
                    callSignatures[i].invalidate();
                }
            }

            this.definitionSignature = null;

            super.invalidate();
        }

        public addSignature(signature: PullSignatureSymbol) {
            this.addCallSignature(signature);

            if (signature.isDefinition()) {
                this.definitionSignature = <PullDefinitionSignatureSymbol>signature;
            }
        }

        public getDefinitionSignature() { return this.definitionSignature; }
    }

    export class PullConstructorTypeSymbol extends PullTypeSymbol {
        private definitionSignature: PullDefinitionSignatureSymbol = null;

        constructor() {
            super("", PullElementKind.ConstructorType);
        }

        public isFunction() { return true; }
        public isConstructor() { return true; }

        public invalidate() {

            this.definitionSignature = null;

            super.invalidate();
        }

        public addSignature(signature: PullSignatureSymbol) {
            this.addConstructSignature(signature);

            if (signature.isDefinition()) {
                this.definitionSignature = <PullDefinitionSignatureSymbol>signature;
            }
        }

        public addTypeParameter(typeParameter: PullTypeParameterSymbol) {

            this.addMember(typeParameter, SymbolLinkKind.TypeParameter);

            var constructSignatures = this.getConstructSignatures();

            for (var i = 0; i < constructSignatures.length; i++) {
                constructSignatures[i].addTypeParameter(typeParameter);
            }
        }

        public getDefinitionSignature() { return this.definitionSignature; }
    }

    export class PullTypeParameterSymbol extends PullTypeSymbol {
        private constraintLink: PullSymbolLink = null;

        constructor(name: string) {
            super(name, PullElementKind.TypeParameter);
        }

        public isTypeParameter() { return true; }

        public setConstraint(constraintType: PullTypeSymbol) {

            if (this.constraintLink) {
                this.removeOutgoingLink(this.constraintLink);
            }

            this.constraintLink = this.addOutgoingLink(constraintType, SymbolLinkKind.TypeConstraint);
        }

        public getConstraint(): PullTypeSymbol {
            if (this.constraintLink) {
                return <PullTypeSymbol>this.constraintLink.end;
            }

            return null;
        }

        public isGeneric() { return true; }

        public getName() {
            var name = super.getName();

            if (this.constraintLink) {
                name += " extends " + this.constraintLink.end.toString();
            }
        
            return name;
        }
    }

    // transient type variables...
    export class PullTypeVariableSymbol extends PullTypeParameterSymbol {

        constructor(name: string) {
            super(name);
        }

        private tyvarID =  globalTyvarID++;

        public isTypeParameter() { return true; }
        public isTypeVariable() { return true; }
    }


    export class PullAccessorSymbol extends PullSymbol {

        private getterSymbolLink: PullSymbolLink = null;
        private setterSymbolLink: PullSymbolLink = null;

        constructor(name: string) {
            super(name, PullElementKind.Property);
        }

        public isAccessor() { return true; }

        public setSetter(setter: PullSymbol) {
            this.setterSymbolLink = this.addOutgoingLink(setter, SymbolLinkKind.SetterFunction);
        }

        public getSetter(): PullSymbol {
            var setter: PullSymbol = null;

            if (this.setterSymbolLink) {
                setter = this.setterSymbolLink.end;
            }

            return setter;
        }

        public removeSetter() {
            if (this.setterSymbolLink) {
                this.removeOutgoingLink(this.setterSymbolLink);
            }
        }

        public setGetter(getter: PullSymbol) {
            this.getterSymbolLink = this.addOutgoingLink(getter, SymbolLinkKind.GetterFunction);
        }

        public getGetter(): PullSymbol {
            var getter: PullSymbol = null;

            if (this.getterSymbolLink) {
                getter = this.getterSymbolLink.end;
            }

            return getter;
        }

        public removeGetter() {
            if (this.getterSymbolLink) {
                this.removeOutgoingLink(this.getterSymbolLink);
            }
        }

        public invalidate() {
            if (this.getterSymbolLink) {
                this.getterSymbolLink.end.invalidate();
            }

            if (this.setterSymbolLink) {
                this.setterSymbolLink.end.invalidate();
            }

            super.invalidate();
        }
    }

    export class PullArrayTypeSymbol extends PullTypeSymbol {
        private elementType: PullTypeSymbol = null;

        public isArray() { return true; }
        public getElementType() { return this.elementType; }
        public isGeneric() { return true; }

        constructor() {
            super("Array", PullElementKind.Array);
        }

        public setElementType(type: PullTypeSymbol) {
            this.elementType = type;
        }

        public getScopedNameEx(scopeSymbol?: PullSymbol, getPrettyTypeName?: bool) {
            var elementMemberName = this.elementType ? this.elementType.getScopedNameEx(scopeSymbol, getPrettyTypeName) : MemberName.create("any");
            return MemberName.create(elementMemberName, "", "[]");
        }

        public getMemberTypeNameEx(topLevel: bool, scopeSymbol?: PullSymbol, getPrettyTypeName?: bool): MemberName {
            var elementMemberName = this.elementType ? this.elementType.getMemberTypeNameEx(false, scopeSymbol, getPrettyTypeName) : MemberName.create("any");
            return MemberName.create(elementMemberName, "", "[]");
        }
    }

    // PULLTODO: This should be a part of the resolver class
    export function specializeToArrayType(typeToReplace: PullTypeSymbol, typeToSpecializeTo: PullTypeSymbol, resolver: PullTypeResolver, context: PullTypeResolutionContext) {

        var arrayInterfaceType = resolver.getCachedArrayType();

        // For the time-being, only specialize interface types
        // this way we can assume only public members and non-static methods
        if (!arrayInterfaceType || (arrayInterfaceType.getKind() & PullElementKind.Interface) == 0) {
            return null;
        }

        // PULLREVIEW: Accept both generic and non-generic arrays for now
        if (arrayInterfaceType.isGeneric()) {
            var enclosingDecl = arrayInterfaceType.getDeclarations()[0];
            return specializeType(arrayInterfaceType, [typeToSpecializeTo], resolver, enclosingDecl, context);
        }

        if (typeToSpecializeTo.getArrayType()) {
            return typeToSpecializeTo.getArrayType();
        }

        // PULLTODO: Recursive reference bug
        var newArrayType: PullTypeSymbol = new PullArrayTypeSymbol();
        newArrayType.addDeclaration(arrayInterfaceType.getDeclarations()[0]);

        typeToSpecializeTo.setArrayType(newArrayType);
        newArrayType.addOutgoingLink(typeToSpecializeTo, SymbolLinkKind.ArrayOf);

        var field: PullSymbol = null;
        var newField: PullSymbol = null;
        var fieldType: PullTypeSymbol = null;

        var method: PullSymbol = null;
        var methodType: PullFunctionTypeSymbol = null;
        var newMethod: PullSymbol = null;
        var newMethodType: PullFunctionTypeSymbol = null;

        var signatures: PullSignatureSymbol[] = null;
        var newSignature: PullSignatureSymbol = null;

        var parameters: PullSymbol[] = null;
        var newParameter: PullSymbol = null;
        var parameterType: PullTypeSymbol = null;

        var returnType: PullTypeSymbol = null;
        var newReturnType: PullTypeSymbol = null;

        var members = arrayInterfaceType.getMembers();

        for (var i = 0; i < members.length; i++) {
            resolver.resolveDeclaredSymbol(members[i], null, context);

            if (members[i].getKind() == PullElementKind.Method) { // must be a method
                method = <PullFunctionTypeSymbol> members[i];

                resolver.resolveDeclaredSymbol(method, null, context);

                methodType = <PullFunctionTypeSymbol>method.getType();

                newMethod = new PullSymbol(method.getName(), PullElementKind.Method);
                newMethodType = new PullFunctionTypeSymbol();
                newMethod.setType(newMethodType);

                newMethod.addDeclaration(method.getDeclarations()[0]);

                signatures = methodType.getCallSignatures();

                // specialize each signature
                for (var j = 0; j < signatures.length; j++) {

                    newSignature = new PullSignatureSymbol(PullElementKind.CallSignature);
                    newSignature.addDeclaration(signatures[j].getDeclarations()[0]);

                    parameters = signatures[j].getParameters();
                    returnType = signatures[j].getReturnType();

                    if (returnType == typeToReplace) {
                        newSignature.setReturnType(typeToSpecializeTo);
                    }
                    else {
                        newSignature.setReturnType(returnType);
                    }

                    for (var k = 0; k < parameters.length; k++) {
                        newParameter = new PullSymbol(parameters[k].getName(), parameters[k].getKind());

                        parameterType = parameters[k].getType();

                        if (parameterType === null) { continue; }


                        if (parameterType == typeToReplace) {
                            newParameter.setType(typeToSpecializeTo);
                        }
                        else {
                            newParameter.setType(parameterType);
                        }

                        newSignature.addParameter(newParameter);
                    }

                    newMethodType.addSignature(newSignature);
                }

                newArrayType.addMember(newMethod, SymbolLinkKind.PublicMember);
            }

            else { // must be a field
                field = members[i];

                newField = new PullSymbol(field.getName(), field.getKind());
                newField.addDeclaration(field.getDeclarations()[0]);

                fieldType = field.getType();

                if (fieldType == typeToReplace) {
                    newField.setType(typeToSpecializeTo);
                }
                else {
                    newField.setType(fieldType);
                }

                newArrayType.addMember(newField, SymbolLinkKind.PublicMember);
            }
        }
        newArrayType.addOutgoingLink(arrayInterfaceType, SymbolLinkKind.ArrayType);
        return newArrayType;
    }

    export function specializeType(typeToSpecialize: PullTypeSymbol, typeArguments: PullTypeSymbol[], resolver: PullTypeResolver, enclosingDecl: PullDecl, context: PullTypeResolutionContext, ast?: AST): PullTypeSymbol {

        if (typeToSpecialize.isPrimitive() || !typeToSpecialize.isGeneric()) {
            return typeToSpecialize;
        }

        if (typeToSpecialize.currentlyBeingSpecialized()) {
            return typeToSpecialize;
        }

        if (typeToSpecialize.isTypeParameter()) {

            if (context.specializingToAny) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }

            var subsitution = context.findSpecializationForType(typeToSpecialize);

            if (subsitution != typeToSpecialize) {
                return subsitution;
            }

            if (typeArguments.length) {
                return typeArguments[0];
            }
        }

        // In this case, we have an array type that may have been specialized to a type variable
        if (typeToSpecialize.isArray()) {

            var elementType = (<PullArrayTypeSymbol>typeToSpecialize).getElementType();

            var newElementType = specializeType(elementType, typeArguments, resolver, enclosingDecl, context, ast);

            // we re-specialize so that we can re-use any cached array type symbols
            var newArrayType = specializeType(resolver.getCachedArrayType(), [newElementType], resolver, enclosingDecl, context);

            return newArrayType;
        }

        var typeParameters = typeToSpecialize.getTypeParameters();

        var isArray = typeToSpecialize == resolver.getCachedArrayType() || typeToSpecialize.isArray();

        //if (!typeParameters.length) {
        //    return typeToSpecialize;
        //}

        var i = 0;
        var j = 0;

        if (!typeArguments.length) {
            for (i = 0; i < typeParameters.length; i++) {
                typeArguments[typeArguments.length] = resolver.semanticInfoChain.anyTypeSymbol;
            }
        }

        var newType: PullTypeSymbol = isArray ? typeArguments[0].getArrayType() : typeToSpecialize.getSpecialization(typeArguments);

        if (newType) {
            if (!newType.isResolved() && !newType.currentlyBeingSpecialized()) {
                typeToSpecialize.invalidateSpecializations();
            }
            else {
                return newType;
            }
        }

        var newTypeDecl = typeToSpecialize.getDeclarations()[0];

        newType = typeToSpecialize.isClass() ? new PullClassTypeSymbol(typeToSpecialize.getName()) :
                    isArray ? new PullArrayTypeSymbol() :
                    typeToSpecialize.isTypeParameter() ? // watch out for replacing one tyvar with another
                        new PullTypeVariableSymbol(typeToSpecialize.getName()) :
                        new PullTypeSymbol(typeToSpecialize.getName(), typeToSpecialize.getKind());
        newType.addDeclaration(newTypeDecl);

        newType.setIsBeingSpecialized();

        newType.setTypeArguments(typeArguments);

        typeToSpecialize.addSpecialization(newType, typeArguments);

        if (isArray) {
            (<PullArrayTypeSymbol>newType).setElementType(typeArguments[0]);
            typeArguments[0].setArrayType(newType);
        }

        // create the type replacement map

        var typeReplacementMap: any = {};

        for (i = 0; i < typeParameters.length; i++) {
            if (typeParameters[i] != typeArguments[i]) {
                typeReplacementMap[typeParameters[i].getSymbolID().toString()] = typeArguments[i];
            }
            newType.addMember(typeParameters[i], SymbolLinkKind.TypeParameter);
        }

        // specialize any extends/implements types
        var extendedTypesToSpecialize = typeToSpecialize.getExtendedTypes();
        var typeDecl: PullDecl;
        var typeAST: TypeDeclaration;
        var unitPath: string;

        if (extendedTypesToSpecialize.length) {
            typeDecl = typeToSpecialize.getDeclarations()[0];
            typeAST = <TypeDeclaration>resolver.semanticInfoChain.getASTForDecl(typeDecl, typeDecl.getScriptName());
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(typeDecl.getScriptName());
            context.pushTypeSpecializationCache(typeReplacementMap);
            var extendTypeSymbol = resolver.resolveTypeReference(new TypeReference(typeAST.extendsList.members[0], 0), typeDecl, context);
            resolver.setUnitPath(unitPath);
            context.popTypeSpecializationCache();

            newType.addExtendedType(extendTypeSymbol);
        }

        var implementedTypesToSpecialize = typeToSpecialize.getImplementedTypes();

        if (implementedTypesToSpecialize.length) {
            typeDecl = typeToSpecialize.getDeclarations()[0];
            typeAST = <TypeDeclaration>resolver.semanticInfoChain.getASTForDecl(typeDecl, typeDecl.getScriptName());
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(typeDecl.getScriptName());
            context.pushTypeSpecializationCache(typeReplacementMap);
            var implementedTypeSymbol = resolver.resolveTypeReference(new TypeReference(typeAST.implementsList.members[0], 0), typeDecl, context);
            resolver.setUnitPath(unitPath);
            context.popTypeSpecializationCache();

            newType.addImplementedType(implementedTypeSymbol);
        }

        var callSignatures = typeToSpecialize.getCallSignatures();
        var constructSignatures = typeToSpecialize.getConstructSignatures();
        var indexSignatures = typeToSpecialize.getIndexSignatures();
        var members = typeToSpecialize.getMembers();

        // specialize call signatures
        var newSignature: PullSignatureSymbol;
        var signature: PullSignatureSymbol;

        var decl: PullDecl = null;
        var decls: PullDecl[] = null;
        var declAST: AST = null;
        var parameters: PullSymbol[];
        var newParameters: PullSymbol[];
        var returnType: PullTypeSymbol = null;
        var p = 0;

        for (i = 0; i < callSignatures.length; i++) {
            signature = callSignatures[i];

            if (signature.currentlyBeingSpecialized()) {
                continue;
            }

            context.pushTypeSpecializationCache(typeReplacementMap);

            decl = signature.getDeclarations()[0];
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(decl.getScriptName());

            newSignature = new PullSignatureSymbol(signature.getKind());

            newSignature.mimicSignature(signature);
            declAST = resolver.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());

            decl.setSignatureSymbol(newSignature);
            resolver.resolveAST(declAST, false, newTypeDecl, context);
            decl.setSignatureSymbol(signature);

            parameters = signature.getParameters();
            newParameters = newSignature.getParameters();

            for (p = 0; p < parameters.length; p++) {
                newParameters[p].setType(parameters[p].getType());
            }
            newSignature.setResolved();

            resolver.setUnitPath(unitPath);

            returnType = newSignature.getReturnType();

            if (!returnType) {
                newSignature.setReturnType(signature.getReturnType());
            }

            signature.setIsBeingSpecialized();
            newSignature.addDeclaration(decl);
            newSignature = specializeSignature(newSignature, true, typeReplacementMap, [], resolver, newTypeDecl, context);
            signature.setIsSpecialized();

            context.popTypeSpecializationCache();

            if (!newSignature) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }            

            newType.addCallSignature(newSignature);

            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }

        // specialize construct signatures
        for (i = 0; i < constructSignatures.length; i++) {
            signature = constructSignatures[i];

            context.pushTypeSpecializationCache(typeReplacementMap);

            decl = signature.getDeclarations()[0];
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(decl.getScriptName());

            newSignature = new PullSignatureSymbol(signature.getKind());

            newSignature.mimicSignature(signature);
            declAST = resolver.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());

            decl.setSignatureSymbol(newSignature);
            resolver.resolveAST(declAST, false, newTypeDecl, context);
            decl.setSignatureSymbol(signature);

            parameters = signature.getParameters();
            newParameters = newSignature.getParameters();

            // we need to clone the parameter types, but the return type
            // was set during resolution
            for (p = 0; p < parameters.length; p++) {
                newParameters[p].setType(parameters[p].getType());
            }
            newSignature.setResolved();

            resolver.setUnitPath(unitPath);

            returnType = newSignature.getReturnType();

            if (!returnType) {
                newSignature.setReturnType(signature.getReturnType());
            }            

            signature.setIsBeingSpecialized();
            newSignature.addDeclaration(decl);
            newSignature = specializeSignature(newSignature, true, typeReplacementMap, [], resolver, newTypeDecl, context);
            signature.setIsSpecialized();

            context.popTypeSpecializationCache();

            if (!newSignature) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }

            newType.addConstructSignature(newSignature);

            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }

        // specialize index signatures
        for (i = 0; i < indexSignatures.length; i++) {
            signature = indexSignatures[i];

            context.pushTypeSpecializationCache(typeReplacementMap);

            decl = signature.getDeclarations()[0];
            unitPath = resolver.getUnitPath();
            resolver.setUnitPath(decl.getScriptName());

            newSignature = new PullSignatureSymbol(signature.getKind());

            newSignature.mimicSignature(signature);
            declAST = resolver.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());

            decl.setSignatureSymbol(newSignature);
            resolver.resolveAST(declAST, false, newTypeDecl, context);
            decl.setSignatureSymbol(signature);

            parameters = signature.getParameters();
            newParameters = newSignature.getParameters();

            // we need to clone the parameter types, but the return type
            // was set during resolution
            for (p = 0; p < parameters.length; p++) {
                newParameters[p].setType(parameters[p].getType());
            }
            newSignature.setResolved();

            resolver.setUnitPath(unitPath);

            returnType = newSignature.getReturnType();

            if (!returnType) {
                newSignature.setReturnType(signature.getReturnType());
            }            

            signature.setIsBeingSpecialized();
            newSignature.addDeclaration(decl);
            newSignature = specializeSignature(newSignature, true, typeReplacementMap, [], resolver, newTypeDecl, context);
            signature.setIsSpecialized();

            context.popTypeSpecializationCache();

            if (!newSignature) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }
            
            newType.addIndexSignature(newSignature);

            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }        

        // specialize members

        var field: PullSymbol = null;
        var newField: PullSymbol = null;

        var fieldType: PullTypeSymbol = null;
        var newFieldType: PullTypeSymbol = null;
        var replacementType: PullTypeSymbol = null;

        var fieldSignatureSymbol: PullSignatureSymbol = null;

        for (i = 0; i < members.length; i++) {
            field = members[i];

            decls = field.getDeclarations();

            newField = new PullSymbol(field.getName(), field.getKind());

            for (j = 0; j < decls.length; j++) {
                newField.addDeclaration(decls[j]);
            }

            if (field.getIsOptional()) {
                newField.setIsOptional();
            }

            if (!field.isResolved()) {
                resolver.resolveDeclaredSymbol(field, newTypeDecl, context);
            }            

            fieldType = field.getType();

            if (!fieldType) {
                fieldType = new PullTypeVariableSymbol("tyvar" + globalTyvarID);
            }

            //newField.setType(fieldType);

            replacementType = <PullTypeSymbol>typeReplacementMap[fieldType.getSymbolID().toString()];

            if (replacementType) {
                newField.setType(replacementType);
                decl = decls[0];

                for (j = 0; j < decls.length; j++) {
                    newField.addDeclaration(decls[j]);
                }
            }
            else {
                // re-resolve all field decls using the current replacements
                if (fieldType.isGeneric()) {
                    // field.invalidate();
                    // if (fieldType.isFunction()) {
                    //     fieldType.invalidate();
                    // }

                    unitPath = resolver.getUnitPath();
                    resolver.setUnitPath(decls[0].getScriptName());

                    context.pushTypeSpecializationCache(typeReplacementMap);

                    // for (j = 0; j < decls.length; j++) {
                    //     decl = decls[j];

                    //     newField.addDeclaration(decl);

                    //     if (fieldType.getCallSignatures().length) {
                    //         fieldSignatureSymbol = decl.getSignatureSymbol();
                    //         fieldSignatureSymbol.invalidate();
                    //     }

                    //     declAST = resolver.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());
                    //     fieldType = (resolver.resolveAST(declAST, false, newTypeDecl, context)).getType();
                        
                    //     if (fieldType.isFunction()) {
                    //         fieldType.addDeclaration(decl);
                    //     }
                    // }

                    newFieldType = specializeType(fieldType, typeArguments, resolver, newTypeDecl, context, ast);

                    resolver.setUnitPath(unitPath);

                    context.popTypeSpecializationCache();

                    newField.setType(newFieldType);
                }
                else {
                    newField.setType(fieldType);
                }
            }

            newType.addMember(newField, (field.hasFlag(PullElementFlags.Private)) ? SymbolLinkKind.PrivateMember : SymbolLinkKind.PublicMember);
        }

        // specialize the constructor and statics, if need be
        if (typeToSpecialize.isClass()) {
            var constructorMethod = (<PullClassTypeSymbol>typeToSpecialize).getConstructorMethod();
            var newConstructorMethod = new PullSymbol(constructorMethod.getName(), PullElementKind.ConstructorMethod);
            var newConstructorType = specializeType(constructorMethod.getType(), typeArguments, resolver, newTypeDecl, context, ast);

            newConstructorMethod.setType(newConstructorType);

            var constructorDecls: PullDecl[] = constructorMethod.getDeclarations();

            for (i = 0; i < constructorDecls.length; i++) {
                newConstructorMethod.addDeclaration(constructorDecls[i]);
                newConstructorType.addDeclaration(constructorDecls[i]);
            }

            (<PullClassTypeSymbol>newType).setConstructorMethod(newConstructorMethod);
        }

        newType.setIsSpecialized();

        newType.setResolved();

        return newType;
    }

    // PULLTODO: Replace typeReplacementMap with use of context
    export function specializeSignature(signature: PullSignatureSymbol,
        skipLocalTypeParameters: bool,
        typeReplacementMap: any,
        typeArguments: PullTypeSymbol[],
        resolver: PullTypeResolver,
        enclosingDecl: PullDecl,
        context: PullTypeResolutionContext,
        ast?: AST): PullSignatureSymbol {

        if (signature.currentlyBeingSpecialized()) {
            return signature;
        }        

        signature.setIsBeingSpecialized();

        var newSignature = signature.getSpecialization(typeArguments);
        var i = 0;

        if (newSignature) {
            return newSignature;
        }

        newSignature = new PullSignatureSymbol(signature.getKind());
        newSignature.addDeclaration(signature.getDeclarations()[0]);

        if (signature.hasVariableParamList()) {
            newSignature.setHasVariableParamList();
        }

        if (signature.hasGenericParameter()) {
            newSignature.setHasGenericParameter();
        }

        signature.addSpecialization(newSignature, typeArguments);      

        var parameters = signature.getParameters();
        var typeParameters = signature.getTypeParameters();
        var returnType = signature.getReturnType();

        // if (!returnType) {
        //     returnType = new PullTypeVariableSymbol();
        // }

        for (i = 0; i < typeParameters.length; i++) {
            newSignature.addTypeParameter(typeParameters[i]);
        }

        if (signature.hasGenericParameter()) {
            newSignature.setHasGenericParameter();
        }

        context.pushTypeSpecializationCache(typeReplacementMap);
        var newReturnType = specializeType(returnType, typeArguments, resolver, enclosingDecl, context, ast);
        context.popTypeSpecializationCache();      

        // if (newReturnType != returnType) {

        //     newReturnType.addDeclaration(returnType.getDeclarations()[0]);
        // }

        newSignature.setReturnType(newReturnType);

        var newParameter: PullSymbol;
        var newParameterType: PullTypeSymbol;
        var newParameterElementType: PullTypeSymbol;
        var parameterType: PullTypeSymbol;
        var replacementParameterType: PullTypeSymbol;
        var localTypeParameters: any = {};

        // if we specialize the signature recursive (through, say, the specialization of a method whilst specializing
        // its class), we need to prevent accidental specialization of type parameters that shadow type parameters in the
        // enclosing type.  (E.g., "class C<T> { public m<T>() {...} }" )
        if (skipLocalTypeParameters) {
            for (i = 0; i < typeParameters.length; i++) {
                localTypeParameters[typeParameters[i].getName()] = true;
            }
        }

        for (var k = 0; k < parameters.length; k++) {

            newParameter = new PullSymbol(parameters[k].getName(), parameters[k].getKind());
            newParameter.addDeclaration(parameters[k].getDeclarations()[0]);

            parameterType = parameters[k].getType();

            context.pushTypeSpecializationCache(typeReplacementMap);
            newParameterType = !localTypeParameters[parameterType.getName()] ? specializeType(parameterType, typeArguments, resolver, enclosingDecl, context, ast) : parameterType;
            context.popTypeSpecializationCache();

            // if (newParameterType != parameterType) {
            //     newParameterType.addDeclaration(parameterType.getDeclarations()[0]);
            // }

            if (parameters[k].getIsOptional()) {
                newParameter.setIsOptional();
            }

            newParameter.setType(newParameterType);
            newSignature.addParameter(newParameter, newParameter.getIsOptional());
        }

        signature.setIsSpecialized();

        return newSignature;
    }

    export function getIDForTypeSubstitutions(types: PullTypeSymbol[]): string {
        var substitution = "";

        for (var i = 0; i < types.length; i++) {
            substitution += types[i].getSymbolID().toString() + "#";
        }

        return substitution;
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {

    export class PullSymbolBindingContext {

        private parentChain: PullTypeSymbol[] = [];
        private declPath: string[] = [];
        public semanticInfo: SemanticInfo;
        public reBindingAfterChange = false;
        public startingDeclForRebind = pullDeclID; // note that this gets set on creation

        constructor(public semanticInfoChain: SemanticInfoChain, public scriptName: string) {
            this.semanticInfo = this.semanticInfoChain.getUnit(this.scriptName);
        }

        public getParent(n = 0): PullTypeSymbol { return this.parentChain ? this.parentChain[this.parentChain.length - 1 - n] : null; }
        public getDeclPath() { return this.declPath; }

        public pushParent(parentDecl: PullTypeSymbol) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
                this.declPath[this.declPath.length] = parentDecl.getName();
            }
        }

        public popParent() {
            if (this.parentChain.length) {
                this.parentChain.length--;
                this.declPath.length--;
            }
        }
    }

    export var time_in_findSymbol = 0;

    export function findSymbolInContext(name: string, declKind: PullElementKind, context: PullSymbolBindingContext, typeLookupPath: string[]): PullSymbol {
        var startTime = new Date().getTime();
        var contextSymbolPath: string[] = context.getDeclPath();
        var nestedSymbolPath: string[] = [];
        var copyOfContextSymbolPath = [];
        var symbol: PullSymbol = null;
        var i = 0;
        var endTime: number;

        // first, search within the given symbol path
        if (typeLookupPath.length) {

            for (i = 0; i < typeLookupPath.length; i++) {
                nestedSymbolPath[nestedSymbolPath.length] = typeLookupPath[i];
            }

            nestedSymbolPath[nestedSymbolPath.length] = name;

            while (nestedSymbolPath.length >= 2) {
                symbol = context.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);

                if (symbol) {
                    endTime = new Date().getTime();
                    time_in_findSymbol += endTime - startTime;
                    return symbol;
                }
                nestedSymbolPath.length -= 2;
                nestedSymbolPath[nestedSymbolPath.length] = name;
            }
        }

        // next, link back up to the enclosing context
        if (contextSymbolPath.length) {
            
            for (i = 0; i < contextSymbolPath.length; i++) {
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i];
            }

            for (i = 0; i < typeLookupPath.length; i++) {
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = typeLookupPath[i];
            }

            copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;

            while (copyOfContextSymbolPath.length >= 2) {
                symbol = context.semanticInfoChain.findSymbol(copyOfContextSymbolPath, declKind);

                if (symbol) {
                    endTime = new Date().getTime();
                    time_in_findSymbol += endTime - startTime;
                    return symbol;
                }

                copyOfContextSymbolPath.length -= 2;
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
            }
        }

        // finally, try searching globally
        symbol = context.semanticInfoChain.findSymbol([name], declKind);

        endTime = new Date().getTime();
        time_in_findSymbol += endTime - startTime;

        return symbol;
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {
    export class CandidateInferenceInfo {
        public typeParameter: PullTypeParameterSymbol = null;
        public isFixed = false;
        public inferenceCandidates: PullTypeSymbol[] = [];

        public addCandidate(candidate: PullTypeSymbol) {
            if (!this.isFixed) {
                this.inferenceCandidates[this.inferenceCandidates.length] = candidate;
            }
        }
    }

    export class ArgumentInferenceContext {
        public inferenceCache: any = {};
        public candidateCache: any = {};


        public alreadyRelatingTypes(objectType: PullTypeSymbol, parameterType: PullTypeSymbol) {
            var comboID = (objectType.getSymbolID() << 16) | parameterType.getSymbolID();

            if (this.inferenceCache[comboID]) {
                return true;
            }
            else {
                this.inferenceCache[comboID] = true;
                return false;
            }            
        }

        public getInferenceInfo(param: PullTypeParameterSymbol) {
            var info = <CandidateInferenceInfo>this.candidateCache[param.getSymbolID().toString()];

            if (!info) {
                info = new CandidateInferenceInfo();
                info.typeParameter = param;
                this.candidateCache[param.getSymbolID().toString()] = info;
            }

            return info;
        }

        public addCandidateForInference(param: PullTypeParameterSymbol, candidate: PullTypeSymbol, fix: bool) {
            var info = this.getInferenceInfo(param);

            if (candidate) {
                info.addCandidate(candidate);
            }

            if (!info.isFixed) {
                info.isFixed = fix;
            }
        }

        public getInferenceCandidates(): any[] {
            var inferenceCandidates: any[] = [];
            var info: CandidateInferenceInfo;
            var val;

            for (var infoKey in this.candidateCache) {
                info = <CandidateInferenceInfo>this.candidateCache[infoKey];

                for (var i = 0; i < info.inferenceCandidates.length; i++) {
                    val = {};
                    val[info.typeParameter.getSymbolID().toString()] = info.inferenceCandidates[i];
                    inferenceCandidates[inferenceCandidates.length] = val;
                }
            }

            return inferenceCandidates;
        }

        public inferArgumentTypes(resolver: PullTypeResolver, context: PullTypeResolutionContext): { results: { param: PullTypeParameterSymbol; type: PullTypeSymbol; }[]; unfit: bool; } {
            var info: CandidateInferenceInfo = null;

            var collection: IPullTypeCollection;

            var bestCommonType: PullTypeSymbol;

            var results: { param: PullTypeParameterSymbol; type: PullTypeSymbol; }[] = [];

            var unfit = false;

            for (var infoKey in this.candidateCache) {
                info = <CandidateInferenceInfo>this.candidateCache[infoKey];

                if (!info.inferenceCandidates.length) {
                    continue;
                }

                collection = {
                    getLength: () => { return info.inferenceCandidates.length; },
                    setTypeAtIndex: (index: number, type: PullTypeSymbol) => { },
                    getTypeAtIndex: (index: number) => {
                        return info.inferenceCandidates[index].getType();
                    }
                }

                bestCommonType = resolver.findBestCommonType(info.inferenceCandidates[0], null, collection, true, context, new TypeComparisonInfo());

                if (!bestCommonType) {
                    bestCommonType = resolver.semanticInfoChain.undefinedTypeSymbol;
                }

                if (bestCommonType == resolver.semanticInfoChain.undefinedTypeSymbol) {
                    unfit = true;
                }

                results[results.length] = { param: info.typeParameter, type: bestCommonType };
            }

            return { results: results, unfit: unfit };
        }
    }

    export class PullContextualTypeContext {

        public provisionallyTypedSymbols: PullSymbol[] = [];
        public provisionalDiagnostic: PullDiagnostic[] = [];

        constructor(public contextualType: PullTypeSymbol,
                     public provisional: bool,
                     public substitutions: any) { }

        public recordProvisionallyTypedSymbol(symbol: PullSymbol) {
            this.provisionallyTypedSymbols[this.provisionallyTypedSymbols.length] = symbol;
        }

        public invalidateProvisionallyTypedSymbols() {
            for (var i = 0; i < this.provisionallyTypedSymbols.length; i++) {
                this.provisionallyTypedSymbols[i].invalidate();
            }
        }

        public postDiagnostic(error: PullDiagnostic) {
            this.provisionalDiagnostic[this.provisionalDiagnostic.length] = error;
        }

        public hadProvisionalErrors() {
            return this.provisionalDiagnostic.length > 0;
        }
    }

    export class PullTypeResolutionContext {
        private contextStack: PullContextualTypeContext[] = [];
        private typeSpecializationStack: any[] = [];

        public resolvingTypeReference = false;

        public resolveAggressively = false;

        public searchTypeSpace = false;

        public specializingToAny = false;

        constructor (public emitting = false) {}

        public pushContextualType(type: PullTypeSymbol, provisional: bool, substitutions: any) {
            this.contextStack.push(new PullContextualTypeContext(type, provisional, substitutions));
        }

        public popContextualType(): PullContextualTypeContext {
            var tc = this.contextStack.pop();

            tc.invalidateProvisionallyTypedSymbols();

            return tc;
        }

        public findSubstitution(type: PullTypeSymbol) {
            var substitution: PullTypeSymbol = null;

            if (this.contextStack.length) {
                for (var i = this.contextStack.length - 1; i >= 0; i--) {
                    if (this.contextStack[i].substitutions) {
                        substitution = this.contextStack[i].substitutions[type.getSymbolID().toString()];

                        if (substitution) {
                            break;
                        }
                    }
                }
            }

            return substitution;
        }

        public getContextualType(): PullTypeSymbol {
            var context = !this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1];

            if (context) {
                var type = context.contextualType;

                // if it's a type parameter, return the upper bound
                if (type.isTypeParameter() && (<PullTypeParameterSymbol>type).getConstraint()) {
                    type = (<PullTypeParameterSymbol>type).getConstraint();
                }

                var substitution = this.findSubstitution(type);

                return substitution ? substitution : type;
            }

            return null;
        }

        public inProvisionalResolution() {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        }

        public setTypeInContext(symbol: PullSymbol, type: PullTypeSymbol) {
            var substitution: PullTypeSymbol = this.findSubstitution(type);

            symbol.setType(substitution ? substitution : type);

            if (this.contextStack.length && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].recordProvisionallyTypedSymbol(symbol);
            }
        }

        public pushTypeSpecializationCache(cache) {
            this.typeSpecializationStack[this.typeSpecializationStack.length] = cache;
        }

        public popTypeSpecializationCache() {
            if (this.typeSpecializationStack.length) {
                this.typeSpecializationStack.length--;
            }
        }

        public findSpecializationForType(type: PullTypeSymbol) {
            var specialization: PullTypeSymbol = null;

            for (var i = this.typeSpecializationStack.length - 1; i >= 0; i--) {
                specialization = (this.typeSpecializationStack[i])[type.getSymbolID().toString()];

                if (specialization) {
                    return specialization;
                }
            }

            return type;
        }

        public postError(offset: number, length: number, fileName: string, message: string, enclosingDecl: PullDecl) {
            var error = new PullDiagnostic(offset, length, fileName, message);

            if (this.inProvisionalResolution()) {
                (this.contextStack[this.contextStack.length - 1]).postDiagnostic(error);
            }
            else if (enclosingDecl) {
                enclosingDecl.addDiagnostic(error);
            }
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />


module TypeScript {
    export interface IPullTypeCollection {
        // returns null when types are exhausted
        getLength(): number;
        setTypeAtIndex(index: number, type: PullTypeSymbol): void;
        getTypeAtIndex(index: number): PullTypeSymbol;
    }

    export interface IPullResolutionData {
        actuals: PullTypeSymbol[];
        exactCandidates: PullSignatureSymbol[];
        conversionCandidates: PullSignatureSymbol[];
        id: number;
    }

    export class PullResolutionDataCache {
        public cacheSize = 16;
        public rdCache: IPullResolutionData[] = [];
        public nextUp: number = 0;

        constructor() {
            for (var i = 0; i < this.cacheSize; i++) {
                this.rdCache[i] = {
                    actuals: <PullTypeSymbol[]>[],
                    exactCandidates: <PullSignatureSymbol[]>[],
                    conversionCandidates: <PullSignatureSymbol[]>[],
                    id: i
                };
            }
        }

        public getResolutionData(): IPullResolutionData {
            var rd: IPullResolutionData = null;

            if (this.nextUp < this.cacheSize) {
                rd = this.rdCache[this.nextUp];
            }

            if (rd == null) {
                this.cacheSize++;
                rd = {
                    actuals: <PullTypeSymbol[]>[],
                    exactCandidates: <PullSignatureSymbol[]>[],
                    conversionCandidates: <PullSignatureSymbol[]>[],
                    id: this.cacheSize
                };
                this.rdCache[this.cacheSize] = rd;
            }

            // cache operates as a stack - RD is always served up in-order
            this.nextUp++;

            return rd;
        }

        public returnResolutionData(rd: IPullResolutionData) {
            // Pop to save on array allocations, which are a bottleneck
            // REVIEW: On some VMs, Array.pop doesn't always pop the last value in the array
            rd.actuals.length = 0;
            rd.exactCandidates.length = 0;
            rd.conversionCandidates.length = 0;

            this.nextUp = rd.id;
        }
    }

    export interface PullApplicableSignature {
        signature: PullSignatureSymbol;
        hadProvisionalErrors: bool;
    }

    export interface PullAdditionalCallResolutionData {
        targetSymbol: PullSymbol;
        resolvedSignatures: PullSignatureSymbol[];
        candidateSignature: PullSignatureSymbol;
    }

    // The resolver associates types with a given AST
    export class PullTypeResolver {
        private cachedArrayInterfaceType: PullTypeSymbol = null;
        private cachedNumberInterfaceType: PullTypeSymbol = null;
        private cachedStringInterfaceType: PullTypeSymbol = null;
        private cachedBooleanInterfaceType: PullTypeSymbol = null;
        private cachedObjectInterfaceType: PullTypeSymbol = null;
        private cachedFunctionInterfaceType: PullTypeSymbol = null;
        private cachedIArgumentsInterfaceType: PullTypeSymbol = null;
        private cachedRegExpInterfaceType: PullTypeSymbol = null;

        private cachedFunctionArgumentsSymbol: PullSymbol = null;

        private assignableCache: any[] = <any>{};
        private subtypeCache: any[] = <any>{};
        private identicalCache: any[] = <any>{};

        private resolutionDataCache = new PullResolutionDataCache();

        private currentUnit: SemanticInfo = null;

        constructor(private compilationSettings: CompilationSettings,
                    public semanticInfoChain: SemanticInfoChain,
                    private unitPath: string) {
            this.cachedArrayInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Array", [], PullElementKind.Interface);
            this.cachedNumberInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Number", [], PullElementKind.Interface);
            this.cachedStringInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("String", [], PullElementKind.Interface);
            this.cachedBooleanInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Boolean", [], PullElementKind.Interface);
            this.cachedObjectInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Object", [], PullElementKind.Interface);
            this.cachedFunctionInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Function", [], PullElementKind.Interface);
            this.cachedIArgumentsInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("IArguments", [], PullElementKind.Interface);
            this.cachedRegExpInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("RegExp", [], PullElementKind.Interface);

            this.cachedFunctionArgumentsSymbol = new PullSymbol("arguments", PullElementKind.Variable);
            this.cachedFunctionArgumentsSymbol.setType(this.cachedIArgumentsInterfaceType ? this.cachedIArgumentsInterfaceType : this.semanticInfoChain.anyTypeSymbol);
            this.cachedFunctionArgumentsSymbol.setResolved();

            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        }

        public getUnitPath() { return this.unitPath; }

        public setUnitPath(unitPath: string) {
            this.unitPath = unitPath;

            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        }

        private getDeclForAST(ast: AST, unitPath?: string) {
            return this.semanticInfoChain.getDeclForAST(ast, unitPath ? unitPath : this.unitPath);
        }

        public getSymbolForAST(ast: AST, unitPath?: string) {
            return this.semanticInfoChain.getSymbolForAST(ast, unitPath ? unitPath : this.unitPath);
        }

        public setSymbolForAST(ast: AST, typeSymbol: PullSymbol, unitPath?: string) {
            return this.semanticInfoChain.setSymbolForAST(ast, typeSymbol, unitPath ? unitPath : this.unitPath);
        }

        public getASTForSymbol(symbol: PullSymbol, unitPath?: string) {
            return this.semanticInfoChain.getASTForSymbol(symbol, unitPath ? unitPath : this.unitPath);
        }

        public getASTForDecl(decl: PullDecl) {
            return this.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());
        }

        public getCachedArrayType() {
            return this.cachedArrayInterfaceType;
        }

        // returns a list of decls leading up to decl, inclusive
        // PULLTODO: Don't bother using spans - obtain cached Decls from syntax nodes
        public getPathToDecl(decl: PullDecl): PullDecl[] {

            if (!decl) {
                return [];
            }

            //var parentDecl: PullDecl = decl.getParentDecl();
            //var decls: PullDecl[] = [];

            //while (parentDecl) {
            //    decls[decls.length] = parentDecl;
            //    parentDecl = parentDecl.getParentDecl();
            //}

            //return decls;

            var decls: PullDecl[] = [];
            var searchDecls = this.semanticInfoChain.getUnit(decl.getScriptName()).getTopLevelDecls();

            var spanToFind = decl.getSpan();
            var candidateSpan: TextSpan = null;
            var searchKinds = PullElementKind.SomeType | PullElementKind.SomeFunction;
            var found = false;

            while (true) {
                // Of the top-level decls, find the one to search off of
                found = false;
                for (var i = 0; i < searchDecls.length; i++) {
                    candidateSpan = searchDecls[i].getSpan();

                    if (spanToFind.start() >= candidateSpan.start() && spanToFind.end() <= candidateSpan.end()) {
                        if (searchDecls[i].getKind() & searchKinds) { // only consider types, which have scopes
                            if (!(searchDecls[i].getKind() & PullElementKind.ObjectLiteral)) {
                                decls[decls.length] = searchDecls[i];
                            }
                            searchDecls = searchDecls[i].getChildDecls();
                            found = true;
                        }
                    }
                }

                if (!found) {
                    break;
                }
            }

            // if the decl is a function expression, it would not have been parented during binding
            if (decls.length && (decl.getKind() & (PullElementKind.SomeFunction |
                                                    PullElementKind.ObjectType |
                                                    PullElementKind.FunctionType |
                                                    PullElementKind.ConstructorType)) &&
                (decls[decls.length - 1] != decl)) {

                var parent = decl.getParentDecl();

                if (parent && decls[decls.length - 1] != parent && !(parent.getKind() & PullElementKind.ObjectLiteral)) {
                    decls[decls.length] = parent;
                }

                decls[decls.length] = decl;
            }

            return decls;
        }

        public getEnclosingDecl(decl: PullDecl): PullDecl {
            var declPath = this.getPathToDecl(decl);

            if (!declPath.length) {
                return null;
            }
            else if (declPath.length > 1 && declPath[declPath.length - 1] == decl) {
                return declPath[declPath.length - 2];
            }
            else {
                return declPath[declPath.length - 1];
            }
        }

        //  Given a path to a name, e.g. ["foo"] or ["Foo", "Baz", "bar"], find the associated symbol
        public findSymbolForPath(pathToName: string[], enclosingDecl: PullDecl, declKind: PullElementKind): PullSymbol {

            if (!pathToName.length) {
                return null;
            }

            var symbolName = pathToName[pathToName.length - 1];
            var contextDeclPath = this.getPathToDecl(enclosingDecl);

            var contextSymbolPath: string[] = [];
            var nestedSymbolPath: string[] = [];

            var i = 0;

            // first, search within the given symbol path
            // (copy path to name so as not to mutate the input array)
            for (i = 0; i < pathToName.length; i++) {
                nestedSymbolPath[nestedSymbolPath.length] = pathToName[i];
            }

            var symbol: PullSymbol = null;

            while (nestedSymbolPath.length >= 2) {
                symbol = this.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);

                if (symbol) {
                    return symbol;
                }
                nestedSymbolPath.length -= 2;
                nestedSymbolPath[nestedSymbolPath.length] = symbolName;
            }

            // next, try the enclosing context
            for (i = 0; i < contextDeclPath.length; i++) {
                contextSymbolPath[contextSymbolPath.length] = contextDeclPath[i].getName();
            }

            for (i = 0; i < pathToName.length; i++) {
                contextSymbolPath[contextSymbolPath.length] = pathToName[i];
            }

            while (contextSymbolPath.length >= 2) {
                symbol = this.semanticInfoChain.findSymbol(contextSymbolPath, declKind);

                if (symbol) {
                    return symbol;
                }
                contextSymbolPath.length -= 2;
                contextSymbolPath[contextSymbolPath.length] = symbolName;
            }

            // finally, try searching globally
            symbol = this.semanticInfoChain.findSymbol([symbolName], declKind);

            return symbol;
        }

        // search for an unqualified symbol name within a given decl path
        public getSymbolFromDeclPath(symbolName: string, declPath: PullDecl[], declSearchKind: PullElementKind): PullSymbol {
            var symbol: PullSymbol = null;

            // search backwards through the decl list
            //  - if the decl in question is a function, search its members
            //  - if the decl in question is a module, search the decl then the symbol
            //  - Otherwise, search globally

            var decl: PullDecl = null;
            var childDecls: PullDecl[];
            var declSymbol: PullTypeSymbol = null;
            var declMembers: PullSymbol[];
            var pathDeclKind: PullElementKind;
            var valDecl: PullDecl = null;

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.getKind();

                if (pathDeclKind & PullElementKind.Container) {

                    // first check locally
                    childDecls = decl.findChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }

                    if (declSearchKind & PullElementKind.SomeValue) {
                        valDecl = decl.getValueDecl();

                        if (valDecl) {
                            decl = valDecl;
                        }
                    }

                    // otherwise, check the members
                    declSymbol = decl.getSymbol().getType();
                    declMembers = declSymbol.getMembers();

                    var kind: PullElementKind;

                    for (var j = 0; j < declMembers.length; j++) {
                        // PULLTODO: declkind should equal declkind, or is it ok to just mask the value?
                        if (declMembers[j].getName() == symbolName) {
                            kind = declMembers[j].getKind();

                            if ((kind & declSearchKind) != 0) {
                                return declMembers[j];
                            }
                        }
                    }
                }
                else if ((declSearchKind & PullElementKind.SomeType) || !(pathDeclKind & PullElementKind.Class)) {
                    childDecls = decl.findChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }
                }
            }

            // otherwise, search globally
            symbol = this.semanticInfoChain.findSymbol([symbolName], declSearchKind);

            return symbol;
        }

        public getVisibleSymbolsFromDeclPath(declPath: PullDecl[]): PullSymbol[] {
            var symbols: PullSymbol[] = [];

            var decl: PullDecl = null;
            var childDecls: PullDecl[];
            var pathDeclKind: PullElementKind;
            var declSearchKind: PullElementKind = PullElementKind.SomeType | PullElementKind.SomeValue;
            var i = 0;
            var j = 0;
            var m = 0;
            var n = 0;

            var addSymbolsFromDecls = (decls: PullDecl[]) => {
                if (decls.length) {
                    var n = decls.length;
                    for (var j = 0; j < n; j++) {
                        if (decls[j].getKind() & declSearchKind) {
                            var symbol = decls[j].getSymbol();
                            if (symbol) {
                                symbols.push(symbol);
                            }
                        }
                    }
                }
            };

            for (i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.getKind();

                if (pathDeclKind & PullElementKind.SomeContainer) {
                    // Add locals
                    addSymbolsFromDecls(decl.getChildDecls())

                    // Add members
                    var declSymbol = <PullTypeSymbol>decl.getSymbol();
                    var members: PullSymbol[] = [];
                    if (declSymbol) {
                        // Look up all symbols on the module type
                        members = declSymbol.getMembers();
                    }

                    // Look up all symbols on the module instance type if it exists
                    var instanceSymbol = (<PullContainerTypeSymbol > declSymbol).getInstanceSymbol();
                    var searchTypeSymbol = instanceSymbol && instanceSymbol.getType();

                    if (searchTypeSymbol) {
                        members = members.concat(searchTypeSymbol.getMembers());
                    }

                    for (j = 0; j < members.length; j++) {
                        // PULLTODO: declkind should equal declkind, or is it ok to just mask the value?
                        if ((members[j].getKind() & declSearchKind) != 0) {
                            symbols.push(members[j]);
                        }
                    }
                    
                }
                else /*if (pathDeclKind & DeclKind.Function)*/ {
                    addSymbolsFromDecls(decl.getChildDecls())
                }
            }

            // Get the global symbols
            var units = this.semanticInfoChain.units;

            for (i = 0, n = units.length; i < n; i++) {
                var unit = units[i];
                if (unit === this.currentUnit && declPath.length != 0) {
                    // Current unit has already been processed. skip it.
                    continue;
                }
                var topLevelDecls = unit.getTopLevelDecls();
                if (topLevelDecls.length) {
                    for (j = 0, m = topLevelDecls.length; j < m; j++) {
                        var topLevelDecl = topLevelDecls[j];
                        if (topLevelDecl.getKind() === PullElementKind.Script || topLevelDecl.getKind() === PullElementKind.Global) {
                            addSymbolsFromDecls(topLevelDecl.getChildDecls());
                        }
                    }
                }
            }

            return symbols;
        }

        public getVisibleSymbols(enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol[] {

            var declPath: PullDecl[] = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            return this.getVisibleSymbolsFromDeclPath(declPath);
        }

        public getVisibleMembersFromExpresion(expression: AST, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol[] {
            var lhs: PullSymbol = this.resolveStatementOrExpression(expression, false, enclosingDecl, context);
            var lhsType = lhs.getType();

            if (!lhsType) {
                return null;
            }

            if (lhsType == this.semanticInfoChain.anyTypeSymbol) {
                return null;
            }

            // Figure out if privates are available under the current scope
            var includePrivate = false;
            var containerSymbol = lhsType;
            if (containerSymbol.getKind() === PullElementKind.ConstructorType) {
                containerSymbol = containerSymbol.getConstructSignatures()[0].getReturnType();
            }

            if (containerSymbol && containerSymbol.isClass()) {
                var declPath = this.getPathToDecl(enclosingDecl);
                if (declPath && declPath.length) {
                    var declarations = containerSymbol.getDeclarations();
                    for (var i = 0, n = declarations.length; i < n; i++) {
                        var declaration = declarations[i];
                        if (declPath.indexOf(declaration) >= 0) {
                            includePrivate = true;
                            break;
                        }
                    }
                }
            }

            if (context.searchTypeSpace) {
                return lhsType.getAllMembers(PullElementKind.SomeType, includePrivate);
            }
            else {
                if (lhsType == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType) {
                    lhsType = this.cachedNumberInterfaceType;
                }
                else if (lhsType == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType) {
                    lhsType = this.cachedStringInterfaceType;
                }
                else if (lhsType == this.semanticInfoChain.boolTypeSymbol && this.cachedBooleanInterfaceType) {
                    lhsType = this.cachedBooleanInterfaceType;
                }

                if (!lhsType.isResolved()) {
                    var potentiallySpecializedType = <PullTypeSymbol>this.resolveDeclaredSymbol(lhsType, enclosingDecl, context);

                    if (potentiallySpecializedType != lhsType) {
                        if (!lhs.isType()) {
                            context.setTypeInContext(lhs, potentiallySpecializedType);
                        }

                        lhsType = potentiallySpecializedType;
                    }
                }


                var members = lhsType.getAllMembers(PullElementKind.SomeValue, includePrivate);

                // Add any additional members
                /// TODO: add "prototype" for classes
                //if (lhsType.isClass()) {
                //    memebers.push("prototype");
                //}

                // could be an enum
                if ((lhsType.getKind() == PullElementKind.Enum) && this.cachedNumberInterfaceType) {
                    members = members.concat(this.cachedNumberInterfaceType.getAllMembers(PullElementKind.SomeValue, false));
                }

                return members;
            }
        }

        public isTypeArgumentOrWrapper(type: PullTypeSymbol) {
            if (!type) {
                return false;
            }

            if (!type.isGeneric()) {
                return false;
            }

            if (type.isTypeParameter()) {
                return true;
            }

            if (type.isArray()) {
                return this.isTypeArgumentOrWrapper((<PullArrayTypeSymbol>type).getElementType());
            }

            var typeArguments = type.getTypeArguments();

            if (typeArguments) {
                for (var i = 0; i < typeArguments.length; i++) {
                    if (this.isTypeArgumentOrWrapper(typeArguments[i])) {
                        return true;
                    }
                }
            }

            return false;
        }

        public findTypeSymbolForDynamicModule(idText: string, currentFileName: string, search: (id: string) =>PullTypeSymbol): PullTypeSymbol {
            var originalIdText = idText;
            var symbol = search(idText);
           
            if (symbol === null) {
                // perhaps it's a dynamic module?
                if (!symbol) {
                    idText = swapQuotes(originalIdText);
                    symbol = search(idText);
                }

                // Check the literal path first
                if (!symbol) {
                    idText = stripQuotes(originalIdText) + ".ts";
                    symbol = search(idText);
                }

                if (!symbol) {
                    idText = stripQuotes(originalIdText) + ".d.ts";
                    symbol = search(idText);
                }

                // If the literal path doesn't work, begin the search
                if (!symbol && !isRelative(originalIdText)) {
                    // check the full path first, as this is the most likely scenario
                    idText = originalIdText;

                    var strippedIdText = stripQuotes(idText);

                    // REVIEW: Technically, we shouldn't have to normalize here - we should normalize in addUnit.
                    // Still, normalizing here alows any language services to be free of assumptions
                    var path = getRootFilePath(switchToForwardSlashes(currentFileName));

                    while (symbol === null && path != "") {
                        idText = normalizePath(path + strippedIdText + ".ts");
                        symbol = search(idText);

                        // check for .d.ts
                        if (symbol === null) {
                            idText = changePathToDTS(idText);
                            symbol = search(idText);
                        }

                        if (symbol === null) {
                                                        if(path === '/') {
                                                                path = '';
                                                        } else {
                                                                path = normalizePath(path + "..");
                                                                path = path && path != '/' ? path + '/' : path;
                                                        }
                        }
                    }
                }
            }

            return symbol;
        }

        // Declaration Resolution

        public resolveDeclaration(declAST: AST, context: PullTypeResolutionContext, enclosingDecl?: PullDecl): PullSymbol {
            switch (declAST.nodeType) {
                case NodeType.ModuleDeclaration:
                    return this.resolveModuleDeclaration(<ModuleDeclaration>declAST, context);
                case NodeType.InterfaceDeclaration:
                    return this.resolveInterfaceDeclaration(<TypeDeclaration>declAST, context);
                case NodeType.ClassDeclaration:
                    return this.resolveClassDeclaration(<ClassDeclaration>declAST, context);
                case NodeType.FuncDecl:
                    {
                        var funcDecl = <FuncDecl>declAST;

                        if (funcDecl.isGetAccessor()) {
                            return this.resolveGetAccessorDeclaration(funcDecl, context);
                        }
                        else if (funcDecl.isSetAccessor()) {
                            return this.resolveSetAccessorDeclaration(funcDecl, context);
                        }
                        else {
                            return this.resolveFunctionDeclaration(<FuncDecl>declAST, context);
                        }
                    }
                case NodeType.VarDecl:
                case NodeType.ArgDecl:
                    return this.resolveVariableDeclaration(<BoundDecl>declAST, context, enclosingDecl);

                case NodeType.TypeParameter:
                    return this.resolveTypeParameterDeclaration(<TypeParameter>declAST, context);

                case NodeType.ImportDeclaration:
                    return this.resolveImportDeclaration(<ImportDeclaration>declAST, context);

                default:
                    throw new Error("Invalid declaration type");
            }
        }

        // PULLTODO: VERY IMPORTANT
        // Right now, the assumption is that the declaration's parse tree is still in memory
        // we need to add a cache-in/cache-out mechanism so that we can break the dependency on in-memory ASTs
        public resolveDeclaredSymbol(symbol: PullSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            if (!symbol || symbol.isResolved()) {
                return;
            }

            if (symbol.isResolving()) {
                symbol.setType(this.semanticInfoChain.anyTypeSymbol);

                return symbol;
            }

            var thisUnit = this.unitPath;

            var decls = symbol.getDeclarations();

            var ast: AST = null;

            var i = 0;

            // We want to walk and resolve all associated decls, so we can catch
            // cases like function overloads that may be spread across multiple
            // logical declarations
            for (i = 0; i < decls.length; i++) {
                var decl = decls[i];

                ast = this.semanticInfoChain.getASTForDecl(decl, decl.getScriptName());

                // if it's an object literal member, just return the symbol and wait for
                // the object lit to be resolved
                if (!ast || ast.nodeType == NodeType.Member) {
                    //var span = decl.getSpan();
                    //context.postError(span.minChar, span.limChar - span.minChar, this.unitPath, "Could not resolve location for symbol '" + symbol.getName() +"'", enclosingDecl);

                    // We'll return the cached results, and let the decl be corrected on the next invalidation
                    this.setUnitPath(thisUnit);
                    return symbol;
                }

                this.setUnitPath(decl.getScriptName());
                this.resolveDeclaration(ast, context, enclosingDecl);
            }

            var typeArgs = symbol.isType() ? (<PullTypeSymbol>symbol).getTypeArguments() : null;

            if (typeArgs && typeArgs.length) {
                var typeParameters = (<PullTypeSymbol>symbol).getTypeParameters();
                var typeCache: any = {}

                for (i = 0; i < typeParameters.length; i++) {
                    typeCache[typeParameters[i].getSymbolID().toString()] = typeArgs[i];
                }

                context.pushTypeSpecializationCache(typeCache);

                var specializedSymbol = specializeType((<PullTypeSymbol>symbol), typeArgs, this, enclosingDecl, context, ast);

                context.popTypeSpecializationCache();

                symbol = specializedSymbol;
            }

            this.setUnitPath(thisUnit);

            return symbol;
        }

        //
        // Resolve a module declaration
        //
        // The module and its members are pre-bound, so no further resolution is necessary
        //
        public resolveModuleDeclaration(ast: ModuleDeclaration, context: PullTypeResolutionContext): PullTypeSymbol {
            var declSymbol = <PullTypeSymbol>this.semanticInfoChain.getSymbolForAST(ast, this.unitPath);

            return declSymbol;
        }

        //
        // Resolve a class declaration
        //
        // A class's implements and extends lists are not pre-bound, so they must be bound here
        // Once bound, we can add the parent type's members to the class
        //
        public resolveClassDeclaration(classDeclAST: ClassDeclaration, context: PullTypeResolutionContext): PullTypeSymbol {
            var classDecl: PullDecl = this.getDeclForAST(classDeclAST);
            var enclosingDecl = this.getEnclosingDecl(classDecl);
            var classDeclSymbol = <PullClassTypeSymbol>classDecl.getSymbol();
            var parentType: PullTypeSymbol = null;

            if (classDeclSymbol.isResolved()) {
                return classDeclSymbol;
            }
            
            var i = 0;

            if (classDeclAST.extendsList) {
                if (classDeclAST.extendsList.members.length > 1) {
                    context.postError(classDeclAST.name.minChar, classDeclAST.name.getLength(), this.unitPath, "A class may only extend one other type", enclosingDecl);
                }

                for (i = 0; i < classDeclAST.extendsList.members.length; i++) {
                    parentType = this.resolveTypeReference(new TypeReference(classDeclAST.extendsList.members[i], 0), classDecl, context);

                    if ((parentType.getKind() & (PullElementKind.Interface | PullElementKind.Class)) == 0) {
                        context.postError(classDeclAST.extendsList.members[i].minChar, classDeclAST.extendsList.members[i].getLength(), this.unitPath, "A class may only extend other class or interface types", enclosingDecl);
                    }

                    classDeclSymbol.addExtendedType(parentType);
                }
            }

            if (classDeclAST.implementsList) {
                var implementedType: PullTypeSymbol = null;
                for (i = 0; i < classDeclAST.implementsList.members.length; i++) {
                    implementedType = this.resolveTypeReference(new TypeReference(classDeclAST.implementsList.members[i], 0), classDecl, context);
                    classDeclSymbol.addImplementedType(implementedType);

                    if ((implementedType.getKind() & (PullElementKind.Interface | PullElementKind.Class)) == 0) {
                        context.postError(classDeclAST.implementsList.members[i].minChar, classDeclAST.implementsList.members[i].getLength(), this.unitPath, "A class may only implement other class or interface types", enclosingDecl);
                    }                    
                }
            }

            classDeclSymbol.setResolved();

            var classMembers = classDeclSymbol.getMembers();
            var constructorMethod = classDeclSymbol.getConstructorMethod();
            var classTypeParameters = classDeclSymbol.getTypeParameters();

            for (i = 0; i < classTypeParameters.length; i++) {
                this.resolveDeclaredSymbol(classTypeParameters[i], classDecl, context);
            }

            if (constructorMethod) {
                var constructorTypeSymbol = constructorMethod.getType();

                var constructSignatures = constructorTypeSymbol.getConstructSignatures();

                if (!constructSignatures.length) {
                    var constructorSignature: PullSignatureSymbol;
                    
                    // inherit parent's constructor signatures
                    if (parentType && parentType.isClass()) {
                        var parentClass = <PullClassTypeSymbol>parentType;
                        var parentConstructor = parentClass.getConstructorMethod();
                        var parentConstructorType = parentConstructor.getType();
                        var parentConstructSignatures = parentConstructorType.getConstructSignatures();

                        var parentConstructSignature: PullSignatureSymbol;
                        var parentParameters: PullSymbol[];
                        for (i = 0; i < parentConstructSignatures.length; i++) {
                            // create a new signature for each parent constructor
                            parentConstructSignature = parentConstructSignatures[i];
                            parentParameters = parentConstructSignature.getParameters();

                            constructorSignature = new PullSignatureSymbol(PullElementKind.ConstructSignature);
                            constructorSignature.setReturnType(classDeclSymbol);

                            for (var j = 0; j < parentParameters.length; j++) {
                                constructorSignature.addParameter(parentParameters[j], parentParameters[j].getIsOptional());
                            }

                            constructorTypeSymbol.addConstructSignature(constructorSignature);
                            constructorSignature.addDeclaration(classDecl);
                        }
                    }
                    else { // PULLREVIEW: This likely won't execute, unless there's some serious out-of-order resolution issues
                        constructorSignature = new PullSignatureSymbol(PullElementKind.ConstructSignature);
                        constructorSignature.setReturnType(classDeclSymbol);
                        constructorTypeSymbol.addConstructSignature(constructorSignature);
                        constructorSignature.addDeclaration(classDecl);
                    }
                }

                var constructorMembers = constructorTypeSymbol.getMembers();

                this.resolveDeclaredSymbol(constructorMethod, classDecl, context);

                for (i = 0; i < constructorMembers.length; i++) {
                    this.resolveDeclaredSymbol(constructorMembers[i], classDecl, context);
                }
            }

            for (i = 0; i < classMembers.length; i++) {
                this.resolveDeclaredSymbol(classMembers[i], classDecl, context);
            }

            return classDeclSymbol;
        }

        public resolveInterfaceDeclaration(interfaceDeclAST: TypeDeclaration, context: PullTypeResolutionContext): PullTypeSymbol {
            var interfaceDecl: PullDecl = this.getDeclForAST(interfaceDeclAST);
            var enclosingDecl = this.getEnclosingDecl(interfaceDecl);
            var interfaceDeclSymbol = <PullTypeSymbol>interfaceDecl.getSymbol();

            if (interfaceDeclSymbol.isResolved()) {
                return interfaceDeclSymbol;
            }
            var i = 0;

            if (interfaceDeclAST.extendsList) {
                var parentType: PullTypeSymbol = null;
                for (i = 0; i < interfaceDeclAST.extendsList.members.length; i++) {
                    parentType = this.resolveTypeReference(new TypeReference(interfaceDeclAST.extendsList.members[i], 0), interfaceDecl, context);

                    if ((parentType.getKind() & (PullElementKind.Interface | PullElementKind.Class)) == 0) {
                        context.postError(interfaceDeclAST.extendsList.members[i].minChar, interfaceDeclAST.extendsList.members[i].getLength(), this.unitPath, "An interface may only extend other class or interface types", enclosingDecl);
                    }
                                       
                    interfaceDeclSymbol.addExtendedType(parentType);
                }
            }

            if (interfaceDeclAST.implementsList) {
                context.postError(interfaceDeclAST.implementsList.minChar, interfaceDeclAST.implementsList.getLength(), this.unitPath, "An interface may not implement other types", enclosingDecl);            
            }

            interfaceDeclSymbol.setResolved();

            var interfaceMembers = interfaceDeclSymbol.getMembers();
            var interfaceTypeParameters = interfaceDeclSymbol.getTypeParameters();

            for (i = 0; i < interfaceMembers.length; i++) {
                this.resolveDeclaredSymbol(interfaceMembers[i], interfaceDecl, context);
            }

            for (i = 0; i < interfaceTypeParameters.length; i++) {
                this.resolveDeclaredSymbol(interfaceTypeParameters[i], interfaceDecl, context);
            }

            var callSignatures = interfaceDeclSymbol.getCallSignatures();
            var constructSignatures = interfaceDeclSymbol.getConstructSignatures();
            var indexSignatures = interfaceDeclSymbol.getIndexSignatures();

            for (i = 0; i < callSignatures.length; i++) {
                this.resolveDeclaredSymbol(callSignatures[i], interfaceDecl, context);
            }

            for (i = 0; i < constructSignatures.length; i++) {
                this.resolveDeclaredSymbol(constructSignatures[i], interfaceDecl, context);
            }

            for (i = 0; i < indexSignatures.length; i++) {
                this.resolveDeclaredSymbol(indexSignatures[i], interfaceDecl, context);
            }

            return interfaceDeclSymbol;
        }

        public resolveImportDeclaration(importStatementAST: ImportDeclaration, context: PullTypeResolutionContext): PullTypeSymbol {
            // internal or external? (Does it matter?)
            var importDecl: PullDecl = this.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = <PullTypeAliasSymbol>importDecl.getSymbol();
            
            var aliasName = importStatementAST.id.actualText;
            var aliasedType: PullTypeSymbol = null;

            // the alias name may be a string literal, in which case we'll need to convert it to a type
            // reference
            if (importStatementAST.alias.nodeType == NodeType.TypeRef) { // dotted name
                aliasedType = this.resolveTypeReference(<TypeReference>importStatementAST.alias, enclosingDecl, context);
            }
            else if (importStatementAST.alias.nodeType == NodeType.Name) { // name or dynamic module name
                var text = (<Identifier>importStatementAST.alias).actualText;

                if (!isQuoted(text)) {
                    aliasedType = this.resolveTypeReference(new TypeReference(importStatementAST.alias, 0), enclosingDecl, context);
                }
                else { // dynamic module name (string literal)
                    var modPath = (<StringLiteral>importStatementAST.alias).text;
                    var declPath = this.getPathToDecl(enclosingDecl);

                    importStatementAST.isDynamicImport = true;

                    aliasedType = this.findTypeSymbolForDynamicModule(modPath, importDecl.getScriptName(), (s: string) => <PullTypeSymbol>this.getSymbolFromDeclPath(s, declPath, PullElementKind.SomeType));

                    if (aliasedType) {
                        this.currentUnit.addDynamicModuleImport(importDeclSymbol);
                    }
                }
            }

            if (aliasedType) {

                if (!aliasedType.isContainer()) {
                    importDecl.addDiagnostic(new PullDiagnostic(importStatementAST.minChar, importStatementAST.getLength(), this.currentUnit.getPath(), "A module cannot be aliased to a non-module type"));
                }

                importDeclSymbol.setAliasedType(aliasedType);
                importDeclSymbol.setResolved();

                this.setSymbolForAST(importStatementAST.alias, aliasedType);
            }
            
            return importDeclSymbol;
        }

        public resolveFunctionTypeSignature(funcDeclAST: FuncDecl, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullTypeSymbol {
            var funcDeclSymbol = <PullFunctionTypeSymbol>this.semanticInfoChain.getSymbolForAST(funcDeclAST, this.unitPath);

            if (!funcDeclSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new DeclCollectionContext(semanticInfo);

                declCollectionContext.scriptName = this.unitPath;

                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }

                getAstWalkerFactory().walk(funcDeclAST, preCollectDecls, postCollectDecls, null, declCollectionContext);

                var functionDecl = this.getDeclForAST(funcDeclAST);

                var binder = new PullSymbolBinder(this.compilationSettings, this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                if (functionDecl.getKind() == PullElementKind.ConstructorType) {
                    binder.bindConstructorTypeDeclarationToPullSymbol(functionDecl);
                }
                else {
                    binder.bindFunctionTypeDeclarationToPullSymbol(functionDecl);
                }

                funcDeclSymbol = <PullFunctionTypeSymbol>functionDecl.getSymbol();
            }

            var signature = funcDeclSymbol.getKind() == PullElementKind.ConstructorType ?  funcDeclSymbol.getConstructSignatures()[0] : funcDeclSymbol.getCallSignatures()[0];

            // resolve the return type annotation
            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeRef = <TypeReference>funcDeclAST.returnTypeAnnotation;
                var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, enclosingDecl, context);

                signature.setReturnType(returnTypeSymbol);

                if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                    signature.setHasGenericParameter();

                    if (funcDeclSymbol) {
                        funcDeclSymbol.getType().setHasGenericSignature();
                    }
                }
            }
            else {
                signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
            }

            // link parameters and resolve their annotations
            if (funcDeclAST.arguments) {
                for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    this.resolveFunctionTypeSignatureParameter(<ArgDecl>funcDeclAST.arguments.members[i], null, signature, enclosingDecl, context);
                }
            }

            if (signature.hasGenericParameter()) {
                // PULLREVIEW: This is split into a spearate if statement to make debugging slightly easier...
                if (funcDeclSymbol) {
                    funcDeclSymbol.getType().setHasGenericSignature();
                }
            }

            funcDeclSymbol.setResolved();

            return funcDeclSymbol;
        }

        public resolveFunctionTypeSignatureParameter(argDeclAST: ArgDecl, contextParam: PullSymbol, signature: PullSignatureSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {

            var paramSymbol = this.semanticInfoChain.getSymbolForAST(argDeclAST, this.unitPath);

            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(<TypeReference>argDeclAST.typeExpr, enclosingDecl, context);

                context.setTypeInContext(paramSymbol, typeRef);

                // if the typeExprSymbol is generic, set the "hasGenericParameter" field on the enclosing signature
                if (this.isTypeArgumentOrWrapper(typeRef)) {
                    signature.setHasGenericParameter();
                }
            } // PULLTODO: default values?
            else {
                if (contextParam) {
                    context.setTypeInContext(paramSymbol, contextParam.getType());
                }
                else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }

            paramSymbol.setResolved();
        }

        public resolveFunctionExpressionParameter(argDeclAST: ArgDecl, contextParam: PullSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {

            var paramSymbol = this.getSymbolForAST(argDeclAST);

            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(<TypeReference>argDeclAST.typeExpr, enclosingDecl, context);

                context.setTypeInContext(paramSymbol, typeRef);

            } // PULLTODO: default values?
            else {
                if (contextParam) {
                    context.setTypeInContext(paramSymbol, contextParam.getType());
                }
                else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }

            paramSymbol.setResolved();
        }

        public resolveInterfaceTypeReference(interfaceDeclAST: NamedDeclaration, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullTypeSymbol {

            var interfaceSymbol = <PullTypeSymbol>this.semanticInfoChain.getSymbolForAST(interfaceDeclAST, this.unitPath);//new PullTypeSymbol("", PullElementKind.Interface);

            if (!interfaceSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new DeclCollectionContext(semanticInfo);

                declCollectionContext.scriptName = this.unitPath;

                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }

                getAstWalkerFactory().walk(interfaceDeclAST, preCollectDecls, postCollectDecls, null, declCollectionContext);

                var interfaceDecl = this.getDeclForAST(interfaceDeclAST);

                var binder = new PullSymbolBinder(this.compilationSettings, this.semanticInfoChain);

                binder.setUnit(this.unitPath);
                binder.bindObjectTypeDeclarationToPullSymbol(interfaceDecl);

                interfaceSymbol = <PullFunctionTypeSymbol>interfaceDecl.getSymbol();
            }

            if (interfaceDeclAST.members) {

                var memberSymbol: PullSymbol = null;
                var typeMembers = <ASTList> interfaceDeclAST.members;

                for (var i = 0; i < typeMembers.members.length; i++) {
                    memberSymbol = this.semanticInfoChain.getSymbolForAST(typeMembers.members[i], this.unitPath);

                    this.resolveDeclaredSymbol(memberSymbol, enclosingDecl, context);
                }
            }

            interfaceSymbol.setResolved();

            return interfaceSymbol;
        }

        public resolveTypeReference(typeRef: TypeReference, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullTypeSymbol {
            // the type reference can be
            // a name
            // a function
            // an interface
            // a dotted name
            // an array of any of the above

            if (!typeRef) {
                return null;
            }

            var typeDeclSymbol: PullTypeSymbol = null;
            var prevResolvingTypeReference = context.resolvingTypeReference;

            // a name
            if (typeRef.term.nodeType == NodeType.Name) {
                var typeName = <Identifier>typeRef.term;

                // if it's a known primitive name, cheat
                if (typeName.actualText == "any") {
                    typeDeclSymbol = this.semanticInfoChain.anyTypeSymbol;
                }
                else if (typeName.actualText == "string") {
                    typeDeclSymbol = this.semanticInfoChain.stringTypeSymbol;
                }
                else if (typeName.actualText == "number") {
                    typeDeclSymbol = this.semanticInfoChain.numberTypeSymbol;
                }
                else if (typeName.actualText == "bool") {
                    typeDeclSymbol = this.semanticInfoChain.boolTypeSymbol;
                }
                else if (typeName.actualText == "null") {
                    typeDeclSymbol = this.semanticInfoChain.nullTypeSymbol;
                }
                else if (typeName.actualText == "undefined") {
                    typeDeclSymbol = this.semanticInfoChain.undefinedTypeSymbol;
                }
                else if (typeName.actualText == "void") {
                    typeDeclSymbol = this.semanticInfoChain.voidTypeSymbol;
                }
                else if (typeName.actualText == "_element") {
                    typeDeclSymbol = this.semanticInfoChain.elementTypeSymbol;
                }
                else {
                    context.resolvingTypeReference = true;

                    typeDeclSymbol = <PullTypeSymbol>this.resolveTypeNameExpression(typeName, enclosingDecl, context);

                    context.resolvingTypeReference = prevResolvingTypeReference;
                }

                if (!typeDeclSymbol) {
                    context.postError(typeName.minChar, typeName.getLength(), this.unitPath, "Could not find type '" + typeName.actualText + "'", enclosingDecl);
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }

                // a function
            else if (typeRef.term.nodeType == NodeType.FuncDecl) {

                typeDeclSymbol = this.resolveFunctionTypeSignature(<FuncDecl>typeRef.term, enclosingDecl, context);
            }

                // an interface
            else if (typeRef.term.nodeType == NodeType.InterfaceDeclaration) {

                typeDeclSymbol = this.resolveInterfaceTypeReference(<NamedDeclaration>typeRef.term, enclosingDecl, context);
            }
            else if (typeRef.term.nodeType == NodeType.GenericType) {
                typeDeclSymbol = this.resolveGenericTypeReference(<GenericType>typeRef.term, enclosingDecl, context);
            }


                // a dotted name
            else if (typeRef.term.nodeType == NodeType.Dot) {

                // assemble the dotted name path
                var dottedName = <BinaryExpression> typeRef.term;

                // find the decl
                prevResolvingTypeReference = context.resolvingTypeReference;

                typeDeclSymbol = <PullTypeSymbol>this.resolveDottedTypeNameExpression(dottedName, enclosingDecl, context);

                context.resolvingTypeReference = prevResolvingTypeReference;

                if (!typeDeclSymbol) {
                    context.postError(dottedName.operand2.minChar, dottedName.operand2.getLength(), this.unitPath, "Could not find dotted type '" + (<Identifier>dottedName.operand2).actualText + "'", enclosingDecl);
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }

            if (!typeDeclSymbol) {
                context.postError(typeRef.term.minChar, typeRef.term.getLength(), this.unitPath, "Could not resolve type reference", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            // an array of any of the above
            // PULLTODO: Arity > 1
            if (typeRef.arrayCount) {

                var arraySymbol: PullTypeSymbol = typeDeclSymbol.getArrayType();

                // otherwise, create a new array symbol
                if (!arraySymbol) {
                    // for each member in the array interface symbol, substitute in the the typeDecl symbol for "_element"

                    if (!this.cachedArrayInterfaceType) {
                        this.cachedArrayInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Array", this.getPathToDecl(enclosingDecl), PullElementKind.Interface);
                    }

                    if (this.cachedArrayInterfaceType && !this.cachedArrayInterfaceType.isResolved()) {
                        this.resolveDeclaredSymbol(this.cachedArrayInterfaceType, enclosingDecl, context);
                    }

                    arraySymbol = specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, typeDeclSymbol, this, context);

                    if (!arraySymbol) {
                        arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                    }
                }

                if (typeRef.arrayCount > 1) {
                    var arity = typeRef.arrayCount - 1;
                    var existingArraySymbol: PullTypeSymbol = null;

                    while (arity) {
                        existingArraySymbol = arraySymbol.getArrayType();

                        if (!existingArraySymbol) {
                            arraySymbol = specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, arraySymbol, this, context);
                        }
                        else {
                            arraySymbol = existingArraySymbol;
                        }

                        arity--;
                    }
                }

                typeDeclSymbol = arraySymbol;
            }

            this.setSymbolForAST(typeRef, typeDeclSymbol);

            return typeDeclSymbol;
        }

        // Also resolves parameter declarations
        public resolveVariableDeclaration(varDecl: BoundDecl, context: PullTypeResolutionContext, enclosingDecl?: PullDecl): PullSymbol {

            var decl: PullDecl = this.getDeclForAST(varDecl);
            var declSymbol = decl.getSymbol();
            var declParameterSymbol: PullSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol() : null;
            var hadError = false;

            if (declSymbol.isResolved()) {
                return declSymbol.getType();
            }

            if (declSymbol.isResolving()) {
                // PULLTODO: Error or warning?
                declSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                declSymbol.setResolved();

                return this.semanticInfoChain.anyTypeSymbol;
            }

            declSymbol.startResolving();

            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl ? wrapperDecl : enclosingDecl;

            // Does this have a type expression? If so, that's the type
            if (varDecl.typeExpr) {
                var typeExprSymbol = this.resolveTypeReference(<TypeReference>varDecl.typeExpr, wrapperDecl, context);

                if (!typeExprSymbol) {
                    context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, "Could not resolve type expression for variable '" + varDecl.id.actualText + "'", decl);

                    declSymbol.setType(this.semanticInfoChain.anyTypeSymbol);

                    if (declParameterSymbol) {
                        declParameterSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }

                    hadError = true;
                }
                else {

                    // PULLREVIEW: If the type annotation is a container type, use the module instance type
                    if (typeExprSymbol.isContainer()) {
                        var instanceSymbol = (<PullContainerTypeSymbol>typeExprSymbol).getInstanceSymbol()

                        if (!instanceSymbol) {
                            context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, "Tried to set variable type to uninitialized module type'" + typeExprSymbol.toString() + "'", decl);
                            typeExprSymbol = this.semanticInfoChain.anyTypeSymbol;
                        }
                        else {
                            typeExprSymbol = instanceSymbol.getType();
                        }
                    }

                    context.setTypeInContext(declSymbol, typeExprSymbol);

                    if (declParameterSymbol) {
                        declParameterSymbol.setType(typeExprSymbol);
                    }

                    // if the typeExprSymbol is generic, set the "hasGenericParameter" field on the enclosing signature
                    // we filter out arrays, since for those we just want to know if their element type is a type parameter...
                    if ((varDecl.nodeType == NodeType.ArgDecl) && enclosingDecl && ((typeExprSymbol.isGeneric() && !typeExprSymbol.isArray()) || this.isTypeArgumentOrWrapper(typeExprSymbol))) {
                        var signature = enclosingDecl.getSignatureSymbol();
                        signature.setHasGenericParameter();
                    }
                }
            }

                // Does it have an initializer? If so, typecheck and use that
            else if (varDecl.init) {

                var initExprSymbol = this.resolveStatementOrExpression(varDecl.init, false, wrapperDecl, context);

                if (!initExprSymbol) {
                    context.postError(varDecl.minChar, varDecl.getLength(), this.unitPath, "Could not resolve type of initializer expression for variable '" + varDecl.id.actualText + "'", decl);

                    context.setTypeInContext(declSymbol, this.semanticInfoChain.anyTypeSymbol);

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }

                    hadError = true;
                }
                else {

                    context.setTypeInContext(declSymbol, this.widenType(initExprSymbol.getType()));
                    initExprSymbol.addOutgoingLink(declSymbol, SymbolLinkKind.ProvidesInferredType);

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, initExprSymbol.getType());
                        initExprSymbol.addOutgoingLink(declParameterSymbol, SymbolLinkKind.ProvidesInferredType);
                    }
                }
            }

                // Otherwise, it's of type 'any'
            else {
                context.setTypeInContext(declSymbol, this.semanticInfoChain.anyTypeSymbol);
                if (declParameterSymbol) {
                    declParameterSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                }
            }

            if (!hadError) {
                declSymbol.setResolved();

                if (declParameterSymbol) {
                    declParameterSymbol.setResolved();
                }
            }

            return declSymbol;
        }

        public resolveTypeParameterDeclaration(typeParameterAST: TypeParameter, context: PullTypeResolutionContext): PullTypeSymbol {
            var typeParameterDecl = this.getDeclForAST(typeParameterAST);
            var typeParameterSymbol = <PullTypeParameterSymbol>typeParameterDecl.getSymbol();

            if (typeParameterSymbol.isResolved() || typeParameterSymbol.isResolving()) {
                return typeParameterSymbol;
            }

            typeParameterSymbol.startResolving();

            if (typeParameterAST.constraint) {
                var constraintTypeSymbol = this.resolveTypeReference(<TypeReference>typeParameterAST.constraint, this.getEnclosingDecl(typeParameterDecl), context);

                if (!constraintTypeSymbol) {
                    context.postError(typeParameterAST.minChar, typeParameterAST.getLength(), this.unitPath, "Could not resolve constraint for type parameter '" + typeParameterDecl.getName() + "'", typeParameterDecl);
                }
                else if (constraintTypeSymbol.isTypeParameter() || constraintTypeSymbol.isPrimitive()) {
                    context.postError(typeParameterAST.constraint.minChar, typeParameterAST.constraint.getLength(), this.unitPath, "Type parameter constraints may not be type parameters or primitive types", typeParameterDecl);
                }
                else {
                    typeParameterSymbol.setConstraint(constraintTypeSymbol);
                }
            }

            typeParameterSymbol.setResolved();

            return typeParameterSymbol;
        }

        public resolveFunctionBodyReturnTypes(funcDeclAST: FuncDecl, signature: PullSignatureSymbol, useContextualType: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            var returnStatements: ReturnStatement[] = [];

            var preFindReturnExpressionTypes = function (ast: AST, parent: AST, walker: IAstWalker) {
                var go = true;

                switch (ast.nodeType) {
                    case NodeType.FuncDecl:
                        // don't recurse into a function decl - we don't want to confuse a nested
                        // return type with the top-level function's return type
                        go = false;
                        break;

                    case NodeType.Return:
                        var returnStatement: ReturnStatement = <ReturnStatement>ast;
                        returnStatements[returnStatements.length] = returnStatement;
                        go = false;
                        break;

                    default:
                        break;
                }

                walker.options.goChildren = go;

                return ast;
            }

            getAstWalkerFactory().walk(funcDeclAST.bod, preFindReturnExpressionTypes);

            if (!returnStatements.length) {
                if (useContextualType) {
                    var contextualType = this.widenType(context.getContextualType());

                    signature.setReturnType(contextualType);

                    var isVoidOrAny = contextualType == this.semanticInfoChain.anyTypeSymbol || contextualType == this.semanticInfoChain.voidTypeSymbol;
               
                    if (!isVoidOrAny) {
                        context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, "Function declared a non-void return type, but has no return expression", enclosingDecl);
                    }                    
                }
                else {
                    signature.setReturnType(this.semanticInfoChain.voidTypeSymbol);
                }
            }

            else {
                var returnExpressionSymbols: PullTypeSymbol[] = [];
                var i = 0;

                for (i = 0; i < returnStatements.length; i++) {
                    if (returnStatements[i].returnExpression) {
                        returnExpressionSymbols[returnExpressionSymbols.length] = this.resolveStatementOrExpression(returnStatements[i].returnExpression, useContextualType, enclosingDecl, context).getType();
                    }
                }

                if (!returnExpressionSymbols.length) {
                    signature.setReturnType(this.semanticInfoChain.voidTypeSymbol);
                }
                else {

                    // combine return expression types for best common type
                    var collection: IPullTypeCollection = {
                        getLength: () => { return returnExpressionSymbols.length; },
                        setTypeAtIndex: (index: number, type: PullTypeSymbol) => { },
                        getTypeAtIndex: (index: number) => {
                            return returnExpressionSymbols[index].getType();
                        }
                    }

                    var returnType = this.findBestCommonType(returnExpressionSymbols[0], null, collection, true, context, new TypeComparisonInfo());

                    signature.setReturnType(returnType ? this.widenType(returnType) : this.semanticInfoChain.anyTypeSymbol);

                    // link return expressions to signature type to denote inference
                    for (i = 0; i < returnExpressionSymbols.length; i++) {
                        returnExpressionSymbols[i].addOutgoingLink(signature, SymbolLinkKind.ProvidesInferredType);
                    }
                }
            }
        }

        public resolveFunctionDeclaration(funcDeclAST: FuncDecl, context: PullTypeResolutionContext): PullSymbol {

            var funcDecl: PullDecl = this.getDeclForAST(funcDeclAST);

            var funcSymbol = <PullFunctionTypeSymbol>funcDecl.getSymbol();

            var signature: PullSignatureSymbol = funcDecl.getSignatureSymbol();

            var hadError = false;

            var isConstructor = funcDeclAST.isConstructor || hasFlag(funcDeclAST.fncFlags, FncFlags.ConstructMember);

            if (signature) {

                if (signature.isResolved()) {
                    return funcSymbol;
                }

                if (signature.isResolving()) {
                    
                    // try to set the return type, even though we may be lacking in some information
                    if (funcDeclAST.returnTypeAnnotation) {
                        var returnTypeRef = <TypeReference>funcDeclAST.returnTypeAnnotation;
                        var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, funcDecl, context);
                        if (!returnTypeSymbol) {
                            context.postError(funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), this.unitPath, "Could not resolve return type reference for some reason...", funcDecl);
                            signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                            hadError = true;
                        } else {
                            if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                                signature.setHasGenericParameter();
                                if (funcSymbol) {
                                    funcSymbol.getType().setHasGenericSignature();
                                }
                            }
                            signature.setReturnType(returnTypeSymbol);

                            if (isConstructor && returnTypeSymbol == this.semanticInfoChain.voidTypeSymbol) {
                                context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, "Constructors may not have a return type of 'void'", funcDecl);
                            }                            
                        }
                    } 
                    else {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    }

                    signature.setResolved();
                    return funcSymbol;
                }

                signature.startResolving();

                // resolve parameter type annotations as necessary
                if (funcDeclAST.arguments) {
                    for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(<BoundDecl>funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }

                if (signature.isGeneric()) {
                    // PULLREVIEW: This is split into a spearate if statement to make debugging slightly easier...
                    if (funcSymbol) {
                        funcSymbol.getType().setHasGenericSignature();
                    }
                }

                // resolve the return type annotation
                if (funcDeclAST.returnTypeAnnotation) {
                    returnTypeRef = <TypeReference>funcDeclAST.returnTypeAnnotation;

                    // use the funcDecl for the enclosing decl, since we want to pick up any type parameters 
                    // on the function when resolving the return type
                    returnTypeSymbol = this.resolveTypeReference(returnTypeRef, funcDecl, context);

                    if (!returnTypeSymbol) {
                        context.postError(funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), this.unitPath, "Could not resolve return type reference for some reason...", funcDecl);
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);

                        hadError = true;
                    }
                    else {
                        if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                            signature.setHasGenericParameter();

                            if (funcSymbol) {
                                funcSymbol.getType().setHasGenericSignature();
                            }
                        }

                        signature.setReturnType(returnTypeSymbol);

                        if (isConstructor && returnTypeSymbol == this.semanticInfoChain.voidTypeSymbol) {
                            context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, "Constructors may not have a return type of 'void'", funcDecl);
                        }                           
                    }
                }
                // if there's no return-type annotation
                //     - if it's not a definition signature, set the return type to 'any'
                //     - if it's a definition sigature, take the best common type of all return expressions
                //     - if it's a constructor, we set the return type link during binding
                else if (!funcDeclAST.isConstructor) {
                    if (funcDeclAST.isSignature()) {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    }
                    else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, funcDecl, new PullTypeResolutionContext());
                    }
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            // don't resolve anything here that's not relevant to the type of the function!

            return funcSymbol;
        }

        public resolveGetAccessorDeclaration(funcDeclAST: FuncDecl, context: PullTypeResolutionContext): PullSymbol {

            var funcDecl: PullDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = <PullAccessorSymbol> funcDecl.getSymbol();

            var getterSymbol = accessorSymbol.getGetter();
            var getterTypeSymbol = <PullFunctionTypeSymbol>getterSymbol.getType();

            var signature: PullSignatureSymbol = getterTypeSymbol.getCallSignatures()[0];

            var hadError = false;

            if (signature) {

                if (signature.isResolved()) {
                    return accessorSymbol;
                }

                if (signature.isResolving()) {
                    // PULLTODO: Error or warning?
                    signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    signature.setResolved();

                    return accessorSymbol;
                }

                signature.startResolving();

                // resolve parameter type annotations as necessary
                if (funcDeclAST.arguments) {
                    for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(<BoundDecl>funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }

                if (signature.hasGenericParameter()) {
                    // PULLREVIEW: This is split into a spearate if statement to make debugging slightly easier...
                    if (getterSymbol) {
                        getterTypeSymbol.setHasGenericSignature();
                    }
                }

                // resolve the return type annotation
                if (funcDeclAST.returnTypeAnnotation) {
                    var returnTypeRef = <TypeReference>funcDeclAST.returnTypeAnnotation;

                    // use the funcDecl for the enclosing decl, since we want to pick up any type parameters 
                    // on the function when resolving the return type
                    var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, funcDecl, context);

                    if (!returnTypeSymbol) {
                        context.postError(funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), this.unitPath, "Could not resolve return type reference for some reason...", funcDecl);
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);

                        hadError = true;
                    }
                    else {

                        if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                            signature.setHasGenericParameter();

                            if (getterSymbol) {
                                getterTypeSymbol.setHasGenericSignature();
                            }
                        }

                        signature.setReturnType(returnTypeSymbol);
                    }
                }

                    // if there's no return-type annotation
                    //     - if it's not a definition signature, set the return type to 'any'
                    //     - if it's a definition sigature, take the best common type of all return expressions
                else {
                    if (funcDeclAST.isSignature()) {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    }
                    else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, funcDecl, new PullTypeResolutionContext());
                    }
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            var accessorType = signature.getReturnType();

            var setter = accessorSymbol.getSetter();

            if (setter) {
                var setterType = setter.getType();
                var setterSig = setterType.getCallSignatures()[0];

                if (setterSig.isResolved()) {
                    // compare setter parameter type and getter return type
                    var setterParameters = setterSig.getParameters();

                    if (setterParameters.length) {
                        var setterParameter = setterParameters[0];
                        var setterParameterType = setterParameter.getType();

                        if (!this.typesAreIdentical(accessorType, setterParameterType)) {
                            context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, "Getter and setter types do not agree", this.getEnclosingDecl(funcDecl));
                            accessorSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                        }
                    }
                }
                else {
                    accessorSymbol.setType(accessorType);
                }

            }
            else {
                accessorSymbol.setType(accessorType);
            }

            return accessorSymbol;
        }

        public resolveSetAccessorDeclaration(funcDeclAST: FuncDecl, context: PullTypeResolutionContext): PullSymbol {

            var funcDecl: PullDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = <PullAccessorSymbol> funcDecl.getSymbol();

            var setterSymbol = accessorSymbol.getSetter();
            var setterTypeSymbol = <PullFunctionTypeSymbol>setterSymbol.getType();

            var signature: PullSignatureSymbol = setterTypeSymbol.getCallSignatures()[0];

            var hadError = false;

            if (signature) {

                if (signature.isResolved()) {
                    return accessorSymbol;
                }

                if (signature.isResolving()) {
                    // PULLTODO: Error or warning?
                    signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    signature.setResolved();

                    return accessorSymbol;
                }

                signature.startResolving();

                // resolve parameter type annotations as necessary
                if (funcDeclAST.arguments) {
                    for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(<BoundDecl>funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }
                else {
                    context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, "Setters must take arguments", this.getEnclosingDecl(funcDecl));
                }

                if (signature.hasGenericParameter()) {
                    // PULLREVIEW: This is split into a spearate if statement to make debugging slightly easier...
                    if (setterSymbol) {
                        setterTypeSymbol.setHasGenericSignature();
                    }
                }

                // resolve the return type annotation
                if (funcDeclAST.returnTypeAnnotation) {
                    context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, "Setters may not contain return type annotations", this.getEnclosingDecl(funcDecl));
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            var parameters = signature.getParameters();

            if (parameters.length) {
                var accessorType = parameters[0].getType();

                var getter = accessorSymbol.getGetter();

                if (getter) {
                    var getterType = getter.getType();
                    var getterSig = getterType.getCallSignatures()[0];

                    if (getterSig.isResolved()) {
                        // compare setter parameter type and getter return type
                        var getterReturnType = getterSig.getReturnType();

                        if (!this.typesAreIdentical(accessorType, getterReturnType)) {

                            if (accessorType == this.semanticInfoChain.anyTypeSymbol) {
                                accessorSymbol.setType(getterReturnType);
                            }
                            else {
                                context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), this.unitPath, "Getter and setter types do not agree", this.getEnclosingDecl(funcDecl));
                                accessorSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                            }
                        }
                    }
                    else {
                        accessorSymbol.setType(accessorType);
                    }
                }
                else {
                    accessorSymbol.setType(accessorType);
                }
            }

            return accessorSymbol;
        }


        // Expression resolution

        public resolveAST(ast: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            switch (ast.nodeType) {
                case NodeType.ModuleDeclaration:
                case NodeType.InterfaceDeclaration:
                case NodeType.ClassDeclaration:
                case NodeType.VarDecl:
                case NodeType.ArgDecl:
                    return this.resolveDeclaration(ast, context, enclosingDecl);

                case NodeType.FuncDecl:
                    if (isTypedAssignment || ((<FuncDecl>ast).fncFlags & FncFlags.IsFunctionExpression)) {
                        return this.resolveStatementOrExpression(ast, isTypedAssignment, enclosingDecl, context);
                    }
                    else {
                        return this.resolveDeclaration(ast, context, enclosingDecl);
                    }

                default:
                    return this.resolveStatementOrExpression(ast, isTypedAssignment, enclosingDecl, context);
            }
        }

        public resolveStatementOrExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {


            switch (expressionAST.nodeType) {
                case NodeType.Name:
                    if (context.searchTypeSpace) {
                        return this.resolveTypeNameExpression(<Identifier>expressionAST, enclosingDecl, context);
                    }
                    else {
                        return this.resolveNameExpression(<Identifier>expressionAST, enclosingDecl, context);
                    }
                case GenericType:
                    return this.resolveGenericTypeReference(<GenericType>expressionAST, enclosingDecl, context);
                case NodeType.Dot:
                    if (context.searchTypeSpace) {
                        return this.resolveDottedTypeNameExpression(<BinaryExpression>expressionAST, enclosingDecl, context);
                    }
                    else {
                        return this.resolveDottedNameExpression(<BinaryExpression>expressionAST, enclosingDecl, context);
                    }

                case NodeType.FuncDecl:
                    {
                        var funcDecl = <FuncDecl>expressionAST;

                        if (funcDecl.isGetAccessor()) {
                            return this.resolveGetAccessorDeclaration(funcDecl, context);
                        }
                        else if (funcDecl.isSetAccessor()) {
                            return this.resolveSetAccessorDeclaration(funcDecl, context);
                        }
                        else {
                            return this.resolveFunctionExpression(funcDecl, isTypedAssignment, enclosingDecl, context);
                        }
                    }

                case NodeType.ObjectLit:
                    return this.resolveObjectLiteralExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.ArrayLit:
                    return this.resolveArrayLiteralExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.This:
                    return this.resolveThisExpression(expressionAST, enclosingDecl, context);
                case NodeType.Super:
                    return this.resolveSuperExpression(expressionAST, enclosingDecl, context);

                case NodeType.Call:
                    return this.resolveCallExpression(<CallExpression>expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.New:
                    return this.resolveNewExpression(<CallExpression>expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.TypeAssertion:
                    return this.resolveTypeAssertionExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.TypeRef:
                    return this.resolveTypeReference(<TypeReference>expressionAST, enclosingDecl, context);

                // primitives
                case NodeType.NumberLit:
                    return this.semanticInfoChain.numberTypeSymbol;
                case NodeType.QString:
                    return this.semanticInfoChain.stringTypeSymbol;
                case NodeType.Null:
                    return this.semanticInfoChain.nullTypeSymbol;
                case NodeType.True:
                case NodeType.False:
                    return this.semanticInfoChain.boolTypeSymbol;
                case NodeType.Void:
                    return this.semanticInfoChain.voidTypeSymbol;

                // assignment
                case NodeType.Asg:
                    return this.resolveAssignmentStatement(expressionAST, isTypedAssignment, enclosingDecl, context);

                // boolean operations
                case NodeType.Not:
                case NodeType.LogNot:
                case NodeType.Ne:
                case NodeType.Eq:
                case NodeType.Eqv:
                case NodeType.NEqv:
                case NodeType.Lt:
                case NodeType.Le:
                case NodeType.Ge:
                case NodeType.Gt:
                    return this.semanticInfoChain.boolTypeSymbol;

                case NodeType.Add:
                case NodeType.Sub:
                case NodeType.Mul:
                case NodeType.Div:
                case NodeType.Mod:
                case NodeType.Or:
                case NodeType.And:
                case NodeType.AsgAdd:
                case NodeType.AsgSub:
                case NodeType.AsgMul:
                case NodeType.AsgDiv:
                case NodeType.AsgMod:
                case NodeType.AsgOr:
                case NodeType.AsgAnd:
                    return this.resolveArithmeticExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.Pos:
                case NodeType.Neg:
                case NodeType.IncPost:
                case NodeType.IncPre:
                case NodeType.DecPost:
                case NodeType.DecPre:
                    return this.semanticInfoChain.numberTypeSymbol;

                case NodeType.Lsh:
                case NodeType.Rsh:
                case NodeType.Rs2:
                case NodeType.AsgLsh:
                case NodeType.AsgRsh:
                case NodeType.AsgRs2:
                    return this.semanticInfoChain.numberTypeSymbol;

                case NodeType.Index:
                    return this.resolveIndexExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.LogOr:
                    return this.resolveLogicalOrExpression(expressionAST, isTypedAssignment, enclosingDecl, context);
                case NodeType.LogAnd:
                    return this.resolveLogicalAndExpression(expressionAST, isTypedAssignment, enclosingDecl, context);

                case NodeType.Typeof:
                    return this.semanticInfoChain.stringTypeSymbol;

                case NodeType.Throw:
                    return this.semanticInfoChain.voidTypeSymbol;

                case NodeType.Delete:
                    return this.semanticInfoChain.boolTypeSymbol;

                case NodeType.ConditionalExpression:
                    return this.resolveConditionalExpression(<ConditionalExpression>expressionAST, enclosingDecl, context);

                case NodeType.Regex:
                    return this.cachedRegExpInterfaceType ? this.cachedRegExpInterfaceType : this.semanticInfoChain.anyTypeSymbol;
            }

            return this.semanticInfoChain.anyTypeSymbol;
        }

        public resolveNameExpression(nameAST: Identifier, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            if (nameAST.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var nameSymbol: PullSymbol = this.getSymbolForAST(nameAST);

            if (nameSymbol /*&& nameSymbol.isResolved()*/) {
                return nameSymbol;
            }

            var id = nameAST.actualText;

            var declPath: PullDecl[] = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            nameSymbol = this.getSymbolFromDeclPath(id, declPath, PullElementKind.SomeValue);

            // PULLREVIEW: until further notice, search out for modules or enums
            if (!nameSymbol) {
                nameSymbol = this.getSymbolFromDeclPath(id, declPath, PullElementKind.SomeType);

                //if (nameSymbol && nameSymbol.getKind() == PullElementKind.Interface) {
                //    nameSymbol = null;
                //}
            }

            if (!nameSymbol && id === "arguments" && enclosingDecl && (enclosingDecl.getKind() & PullElementKind.SomeFunction)) {
                nameSymbol = this.cachedFunctionArgumentsSymbol;
            }            

            if (!nameSymbol) {
                context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, "Could not find symbol '" + id + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            if (!nameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
            }

            this.setSymbolForAST(nameAST, nameSymbol);

            return nameSymbol;
        }

        public resolveDottedNameExpression(dottedNameAST: BinaryExpression, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {

            if ((<Identifier>dottedNameAST.operand2).isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }            

            var nameSymbol: PullSymbol = this.getSymbolForAST(dottedNameAST);

            if (nameSymbol /*&& nameSymbol.isResolved()*/) {
                return nameSymbol;
            }

            // assemble the dotted name path
            var rhsName = (<Identifier>dottedNameAST.operand2).actualText;

            var lhs: PullSymbol = this.resolveStatementOrExpression(dottedNameAST.operand1, false, enclosingDecl, context);
            var lhsType = lhs.getType();

            if (lhs.isAlias()) {
                (<PullTypeAliasSymbol>lhs).setIsUsedAsValue();
            }

            if (lhsType == this.semanticInfoChain.anyTypeSymbol) {
                return lhsType;
            }

            if (!lhsType) {
                context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find enclosing symbol for dotted name '" + rhsName + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            // if we're resolving a type reference, we really only want to check the constructor type
            if (lhsType == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType) {
                lhsType = this.cachedNumberInterfaceType;
            }
            else if (lhsType == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType) {
                lhsType = this.cachedStringInterfaceType;
            }
            else if (lhsType == this.semanticInfoChain.boolTypeSymbol && this.cachedBooleanInterfaceType) {
                lhsType = this.cachedBooleanInterfaceType;
            }

            if (!lhsType.isResolved()) {
                var potentiallySpecializedType = <PullTypeSymbol>this.resolveDeclaredSymbol(lhsType, enclosingDecl, context);

                if (potentiallySpecializedType != lhsType) {
                    if (!lhs.isType()) {
                        context.setTypeInContext(lhs, potentiallySpecializedType);
                    }

                    lhsType = potentiallySpecializedType;
                }
            }

            if (rhsName == "prototype") {

                if (lhsType.isClass()) {
                    return lhsType;
                }
                else {
                    var classInstanceType = lhsType.getAssociatedContainerType();

                    if (classInstanceType && classInstanceType.isClass()) {
                        return classInstanceType;
                    }
                }
            }

            // now for the name...
            nameSymbol = lhsType.findMember(rhsName);

            if (!nameSymbol) {

                // could be a static
                if (lhsType.isClass()) {
                    lhsType = (<PullClassTypeSymbol>lhsType).getConstructorMethod().getType();

                    nameSymbol = lhsType.findMember(rhsName);
                }
                    // could be an enum
                else if ((lhsType.getKind() == PullElementKind.Enum) && this.cachedNumberInterfaceType) {
                    lhsType = this.cachedNumberInterfaceType;

                    nameSymbol = lhsType.findMember(rhsName);
                }
                // could be a function symbol
                else if (lhsType.getCallSignatures().length && this.cachedFunctionInterfaceType) {
                    lhsType = this.cachedFunctionInterfaceType;

                    nameSymbol = lhsType.findMember(rhsName);
                }
                // could be a type parameter with a contraint
                else if (lhsType.isTypeParameter()) {
                    var constraint = (<PullTypeParameterSymbol>lhsType).getConstraint();

                    if (constraint) {
                        nameSymbol = constraint.findMember(rhsName);
                    }
                }
                else if (lhsType.isContainer()) {
                    var associatedInstance = (<PullContainerTypeSymbol>lhsType).getInstanceSymbol();

                    if (associatedInstance) {
                        var instanceType = associatedInstance.getType();

                        nameSymbol = instanceType.findMember(rhsName);
                    }
                }
                // could be a module instance
                else {
                    var associatedType = lhsType.getAssociatedContainerType();

                    if (associatedType) {
                        nameSymbol = associatedType.findMember(rhsName);
                    }
                }

                // could be an object member
                if (!nameSymbol && !lhsType.isPrimitive() && this.cachedObjectInterfaceType) {
                    nameSymbol = this.cachedObjectInterfaceType.findMember(rhsName);
                }                

                if (!nameSymbol) {
                    context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find dotted symbol name '" + rhsName + "'", enclosingDecl);
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }

            if (!nameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
            }

            this.setSymbolForAST(dottedNameAST, nameSymbol);
            this.setSymbolForAST(dottedNameAST.operand2, nameSymbol);

            return nameSymbol;
        }

        public resolveTypeNameExpression(nameAST: Identifier, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            if (nameAST.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var typeNameSymbol: PullTypeSymbol = <PullTypeSymbol>this.getSymbolForAST(nameAST);

            if (typeNameSymbol /*&& typeNameSymbol.isResolved()*/) {
                return typeNameSymbol;
            }

            var id = nameAST.actualText;

            var declPath: PullDecl[] = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            typeNameSymbol = <PullTypeSymbol>this.getSymbolFromDeclPath(id, declPath, PullElementKind.SomeType);

            if (!typeNameSymbol) {
                context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, "Could not find type '" + id + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            typeNameSymbol = context.findSpecializationForType(typeNameSymbol);

            if (!typeNameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(typeNameSymbol, enclosingDecl, context);
            }

            this.setSymbolForAST(nameAST, typeNameSymbol);

            return typeNameSymbol;
        }

        public resolveGenericTypeReference(genericTypeAST: GenericType, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullTypeSymbol {          

            var nameAST = <Identifier> genericTypeAST.name;

            if (nameAST.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }  

            var id = nameAST.actualText;

            var declPath: PullDecl[] = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            var genericTypeSymbol: PullTypeSymbol = null

            genericTypeSymbol = <PullTypeSymbol>this.getSymbolFromDeclPath(id, declPath, PullElementKind.SomeType);

            if (!genericTypeSymbol) {
                context.postError(nameAST.minChar, nameAST.getLength(), this.unitPath, "Could not find generic type '" + id + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            if (genericTypeSymbol.isResolving()) {
                return genericTypeSymbol;
            }

            if (!genericTypeSymbol.isResolved()) {
                genericTypeSymbol.startResolving();
                this.resolveDeclaredSymbol(genericTypeSymbol, enclosingDecl, context);
                genericTypeSymbol.setResolved();
            }

            // specialize the type arguments
            var typeArgs: PullTypeSymbol[] = [];
            var typeArg: PullTypeSymbol = null;

            if (!genericTypeSymbol.isResolvingTypeArguments()) {

                genericTypeSymbol.startResolvingTypeArguments();

                if (genericTypeAST.typeArguments && genericTypeAST.typeArguments.members.length) {
                    for (var i = 0; i < genericTypeAST.typeArguments.members.length; i++) {
                        typeArg = this.resolveTypeReference(<TypeReference>genericTypeAST.typeArguments.members[i], enclosingDecl, context);
                        typeArgs[i] = context.findSpecializationForType(typeArg);
                    }
                }

                genericTypeSymbol.doneResolvingTypeArguments();
            }

            var typeParameters = genericTypeSymbol.getTypeParameters();

            if (typeArgs.length && typeArgs.length != typeParameters.length) {
                context.postError(genericTypeAST.minChar, genericTypeAST.getLength(), this.unitPath, "Generic type '" + genericTypeSymbol.toString() + "' expects " + genericTypeSymbol.getTypeParameters().length + " type arguments, but " + typeArgs.length + " arguments were supplied", enclosingDecl);

                return this.semanticInfoChain.anyTypeSymbol;
            }

            var specializedSymbol = specializeType(genericTypeSymbol, typeArgs, this, enclosingDecl, context, genericTypeAST);

            // check constraints, if appropriate
            var typeConstraint: PullTypeSymbol = null;

            for (var iArg = 0; (iArg < typeArgs.length) && (iArg < typeParameters.length); iArg++) {

                typeConstraint = typeParameters[iArg].getConstraint();

                // test specialization type for assignment compatibility with the constraint
                if (typeConstraint) {
                    if (!this.sourceIsAssignableToTarget(typeArgs[iArg], typeConstraint, context)) {
                        context.postError(genericTypeAST.minChar, genericTypeAST.getLength(), this.getUnitPath(), "Type '" + typeArgs[iArg].toString() + "' does not satisfy the constraint '" + typeConstraint.toString() + "' for type parameter '" + typeParameters[iArg].toString() + "'", enclosingDecl);
                    }
                }
            }

            return specializedSymbol;
        }

        public resolveDottedTypeNameExpression(dottedNameAST: BinaryExpression, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {

            if ((<Identifier>dottedNameAST.operand2).isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }  

            var childTypeSymbol: PullTypeSymbol = <PullTypeSymbol>this.getSymbolForAST(dottedNameAST);

            if (childTypeSymbol /*&& childTypeSymbol.isResolved()*/) {
                return childTypeSymbol;
            }

            // assemble the dotted name path
            var rhsName = (<Identifier>dottedNameAST.operand2).actualText;

            var prevSearchTypeSpace = context.searchTypeSpace;
            context.searchTypeSpace = true;

            var lhs: PullSymbol = this.resolveStatementOrExpression(dottedNameAST.operand1, false, enclosingDecl, context);

            context.searchTypeSpace = prevSearchTypeSpace;

            var lhsType = lhs.getType();

            if (lhsType == this.semanticInfoChain.anyTypeSymbol) {
                return lhsType;
            }

            if (!lhsType) {
                context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find enclosing type for dotted type name '" + rhsName + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }


            // now for the name...
            childTypeSymbol = lhsType.findNestedType(rhsName);

            if (!childTypeSymbol) {
                context.postError(dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), this.unitPath, "Could not find dotted type name '" + rhsName + "'", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            if (!childTypeSymbol.isResolved()) {
                this.resolveDeclaredSymbol(childTypeSymbol, enclosingDecl, context);
            }

            this.setSymbolForAST(dottedNameAST, childTypeSymbol);

            return childTypeSymbol;
        }

        public resolveFunctionExpression(funcDeclAST: FuncDecl, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            var functionDecl = this.getDeclForAST(funcDeclAST);
            var funcDeclSymbol: PullSymbol = null;

            if (functionDecl) {
                funcDeclSymbol = functionDecl.getSymbol();
                if (funcDeclSymbol.isResolved()) {
                    return funcDeclSymbol;
                }
            }

            // if we have an assigning AST with a type, and the funcDecl has no parameter types or return type annotation
            // we'll contextually type it
            // otherwise, just process it as a normal function declaration

            var shouldContextuallyType = isTypedAssignment && !funcDeclAST.isParenthesized;

            var assigningFunctionTypeSymbol: PullFunctionTypeSymbol = null;
            var assigningFunctionSignature: PullSignatureSymbol = null;
            var i = 0;

            if (funcDeclAST.returnTypeAnnotation) {
                shouldContextuallyType = false;
            }

            if (shouldContextuallyType && funcDeclAST.arguments) {

                for (i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    if ((<ArgDecl>funcDeclAST.arguments.members[i]).typeExpr) {
                        shouldContextuallyType = false;
                        break;
                    }
                }
            }

            if (shouldContextuallyType) {

                assigningFunctionTypeSymbol = <PullFunctionTypeSymbol>context.getContextualType();

                if (assigningFunctionTypeSymbol) {
                    this.resolveDeclaredSymbol(assigningFunctionTypeSymbol, enclosingDecl, context);

                    if (assigningFunctionTypeSymbol) {
                        assigningFunctionSignature = assigningFunctionTypeSymbol.getCallSignatures()[0];
                    }
                }
            }

            // create a new function decl and symbol

            if (!funcDeclSymbol) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new DeclCollectionContext(semanticInfo);

                declCollectionContext.scriptName = this.unitPath;

                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }

                getAstWalkerFactory().walk(funcDeclAST, preCollectDecls, postCollectDecls, null, declCollectionContext);

                functionDecl = this.getDeclForAST(funcDeclAST);

                var binder = new PullSymbolBinder(this.compilationSettings, this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                binder.bindFunctionExpressionToPullSymbol(functionDecl);

                funcDeclSymbol = <PullFunctionTypeSymbol>functionDecl.getSymbol();
            }

            var signature = funcDeclSymbol.getType().getCallSignatures()[0];

            // link parameters and resolve their annotations
            if (funcDeclAST.arguments) {

                var contextParams: PullSymbol[] = [];
                var contextParam: PullSymbol = null;

                if (assigningFunctionSignature) {
                    contextParams = assigningFunctionSignature.getParameters();
                }

                for (i = 0; i < funcDeclAST.arguments.members.length; i++) {

                    if (i < contextParams.length) {
                        contextParam = contextParams[i];
                    }

                    this.resolveFunctionExpressionParameter(<ArgDecl>funcDeclAST.arguments.members[i], contextParam, enclosingDecl, context);
                }
            }

            // resolve the return type annotation
            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeRef = <TypeReference>funcDeclAST.returnTypeAnnotation;
                var returnTypeSymbol = this.resolveTypeReference(returnTypeRef, enclosingDecl, context);

                signature.setReturnType(returnTypeSymbol);

            }
            else {
                if (assigningFunctionSignature) {
                    var returnType = assigningFunctionSignature.getReturnType();

                    if (returnType) {
                        context.pushContextualType(returnType, context.inProvisionalResolution(), null);
                        //signature.setReturnType(returnType);
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, true, functionDecl, context);
                        context.popContextualType();
                    }
                    else {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    }
                }
                else {
                    this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, functionDecl, context);
                }
            }

            // set contextual type link
            if (assigningFunctionTypeSymbol) {
                funcDeclSymbol.addOutgoingLink(assigningFunctionTypeSymbol, SymbolLinkKind.ContextuallyTypedAs);
            }

            funcDeclSymbol.setResolved();

            return funcDeclSymbol;
        }

        static setSelfReferenceOnDecl(pullDecl: PullDecl) {
            pullDecl.setFlags(pullDecl.getFlags() | PullElementFlags.MustCaptureThis);
            return true;
        }

        // PULLTODO: Optimization: cache this for a given decl path
        public resolveThisExpression(ast: AST, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            if (!enclosingDecl) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var enclosingDeclKind = enclosingDecl.getKind();

            if (enclosingDeclKind == PullElementKind.Container) { // Dynamic modules are ok, though
                enclosingDecl.addDiagnostic(new PullDiagnostic(ast.minChar, ast.getLength(), this.currentUnit.getPath(), "'this' may not be referenced within module bodies"));
                return this.semanticInfoChain.anyTypeSymbol;

            }
            else if (!(enclosingDeclKind & (PullElementKind.SomeFunction | PullElementKind.Script))) {
                enclosingDecl.addDiagnostic(new PullDiagnostic(ast.minChar, ast.getLength(), this.currentUnit.getPath(), "Keyword 'this' cannot be referenced in initializers in a class body, or in super constructor calls"));
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var declPath: PullDecl[] = this.getPathToDecl(enclosingDecl);
            var decl: PullDecl;
            var classSymbol: PullClassTypeSymbol;

            // work back up the decl path, until you can find a class
            // PULLTODO: Obviously not completely correct, but this sufficiently unblocks testing of the pull model
            if (declPath.length) {
                var isFatArrowFunction = declPath[declPath.length - 1].getKind() == PullElementKind.FunctionExpression && (declPath[declPath.length - 1].getFlags() & PullElementFlags.FatArrow);
                var hasSetSelfReference = !isFatArrowFunction;
                var firstFncDecl: PullDecl = null;
                var i = 0;
                var declKind: PullElementKind;
                var declFlags: PullElementFlags;

                if (!hasSetSelfReference) {
                    for (i = declPath.length - 2; i >= 0; i--) {
                        decl = declPath[i];
                        declKind = decl.getKind();

                        if (declKind == PullElementKind.Function || declKind == PullElementKind.Method) {
                            hasSetSelfReference = PullTypeResolver.setSelfReferenceOnDecl(decl);
                        }
                        else if (declKind == PullElementKind.FunctionExpression) {
                            if (!(decl.getFlags() & PullElementFlags.FatArrow)) {
                                hasSetSelfReference = PullTypeResolver.setSelfReferenceOnDecl(decl);
                            }
                            else if (decl.getFlags() & PullElementFlags.MustCaptureThis) {
                                firstFncDecl = null;
                                break;
                            }
                            else if (!firstFncDecl) {
                                firstFncDecl = decl;
                            }
                        }
                        else {
                            break;
                        }
                    }

                    if (!hasSetSelfReference && firstFncDecl) {
                        hasSetSelfReference = PullTypeResolver.setSelfReferenceOnDecl(firstFncDecl);
                    }
                }

                var hadFatArrow = false;

                for (i = declPath.length - 1; i >= 0; i--) {
                    decl = declPath[i];
                    declKind = decl.getKind();
                    declFlags = decl.getFlags();

                    if (declFlags & PullElementFlags.Static) {
                        return this.semanticInfoChain.anyTypeSymbol;
                    }

                    if (declKind == PullElementKind.FunctionExpression) {
                        if (!(declFlags & PullElementFlags.FatArrow) && !hadFatArrow) {
                            return this.semanticInfoChain.anyTypeSymbol;
                        }
                        else {
                            hadFatArrow = true;
                        }
                    }

                    if (declKind == PullElementKind.Function) {
                        return this.semanticInfoChain.anyTypeSymbol;
                    }

                    if (declKind == PullElementKind.Class) {
                        classSymbol = <PullClassTypeSymbol>decl.getSymbol();

                        if (!hasSetSelfReference) {
                            hasSetSelfReference = PullTypeResolver.setSelfReferenceOnDecl(decl);
                        }
                        return classSymbol;
                    }

                    if (!hasSetSelfReference &&
                        (declKind == PullElementKind.Container ||
                        declKind == PullElementKind.DynamicModule ||
                        declKind == PullElementKind.Script)) {
                        hasSetSelfReference = PullTypeResolver.setSelfReferenceOnDecl(decl);
                        break;
                    }
                }
            }

            return this.semanticInfoChain.anyTypeSymbol;
        }

        // PULLTODO: Optimization: cache this for a given decl path
        public resolveSuperExpression(ast: AST, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            if (!enclosingDecl) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var declPath: PullDecl[] = enclosingDecl !== null ? this.getPathToDecl(enclosingDecl) : [];
            var decl: PullDecl;
            var declFlags: PullElementFlags;
            var classSymbol: PullClassTypeSymbol = null;

            // work back up the decl path, until you can find a class
            if (declPath.length) {
                for (var i = declPath.length - 1; i >= 0; i--) {
                    decl = declPath[i];
                    declFlags = decl.getFlags();

                    if (decl.getKind() == PullElementKind.FunctionExpression &&
                        !(declFlags & PullElementFlags.FatArrow)) {

                        break;
                    }
                    else if (declFlags & PullElementFlags.Static) {
                        break;
                    }
                    else if (decl.getKind() == PullElementKind.Class) {
                        classSymbol = <PullClassTypeSymbol>decl.getSymbol();

                        break;
                    }
                }
            }

            if (classSymbol) {
                var parents = classSymbol.getExtendedTypes();

                if (parents.length) {
                    return parents[0];
                }
            }

            return this.semanticInfoChain.anyTypeSymbol;
        }

        // if there's no type annotation on the assigning AST, we need to create a type from each binary expression
        // in the object literal
        public resolveObjectLiteralExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            var typeSymbol: PullTypeSymbol = <PullTypeSymbol>this.getSymbolForAST(expressionAST);
            var span: TextSpan;

            if (typeSymbol && typeSymbol.isResolved()) {
                return typeSymbol.getType();
            }

            // PULLTODO: Create a decl for the object literal

            // walk the members of the object literal,
            // create fields for each based on the value assigned in
            var objectLitAST = <UnaryExpression>expressionAST;

            span = TextSpan.fromBounds(objectLitAST.minChar, objectLitAST.limChar);

            var objectLitDecl = new PullDecl("", PullElementKind.ObjectLiteral, PullElementFlags.None, span, this.unitPath);

            if (enclosingDecl) {
                objectLitDecl.setParentDecl(enclosingDecl);
            }

            this.currentUnit.setDeclForAST(objectLitAST, objectLitDecl);
            this.currentUnit.setASTForDecl(objectLitDecl, objectLitAST);

            typeSymbol = new PullTypeSymbol("", PullElementKind.Interface);
            typeSymbol.addDeclaration(objectLitDecl);
            objectLitDecl.setSymbol(typeSymbol);

            var memberDecls = <ASTList>objectLitAST.operand;

            var contextualType: PullTypeSymbol = null;

            if (isTypedAssignment) {
                contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, enclosingDecl, context);
            }

            if (memberDecls) {
                var binex: BinaryExpression;
                var id: AST;
                var text: string;
                var idText: string;
                var memberSymbol: PullSymbol;
                var memberExprType: PullSymbol;
                var assigningSymbol: PullSymbol = null;
                var acceptedContextualType = false;

                for (var i = 0, len = memberDecls.members.length; i < len; i++) {
                    binex = <BinaryExpression>memberDecls.members[i];

                    id = binex.operand1;

                    if (id.nodeType == NodeType.Name) {
                        text = (<Identifier>id).text;
                    }
                    else if (id.nodeType == NodeType.QString) {
                        idText = (<StringLiteral>id).text;
                        text = idText.substring(1, idText.length - 1);
                    }
                    else {
                        return this.semanticInfoChain.anyTypeSymbol;
                    }

                    // PULLTODO: Collect these at decl collection time, add them to the var decl
                    span = TextSpan.fromBounds(binex.minChar, binex.limChar);

                    var decl = new PullDecl(text, PullElementKind.Property, PullElementFlags.Public, span, this.unitPath);

                    objectLitDecl.addChildDecl(decl);
                    decl.setParentDecl(objectLitDecl);

                    this.semanticInfoChain.getUnit(this.unitPath).setDeclForAST(binex, decl);
                    this.semanticInfoChain.getUnit(this.unitPath).setASTForDecl(decl, binex);

                    memberSymbol = new PullSymbol(text, PullElementKind.Property);

                    memberSymbol.addDeclaration(decl);
                    decl.setSymbol(memberSymbol);

                    if (contextualType) {
                        assigningSymbol = contextualType.findMember(text);

                        if (assigningSymbol) {

                            this.resolveDeclaredSymbol(assigningSymbol, enclosingDecl, context);

                            context.pushContextualType(assigningSymbol.getType(), context.inProvisionalResolution(), null);

                            acceptedContextualType = true;
                        }
                    }

                    // if operand 2 is a getter or a setter, we need to resolve it properly
                    if (binex.operand2.nodeType == NodeType.FuncDecl) {
                        var funcDeclAST = <FuncDecl>binex.operand2;

                        if (funcDeclAST.isAccessor()) {
                            var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                            var declCollectionContext = new DeclCollectionContext(semanticInfo);

                            declCollectionContext.scriptName = this.unitPath;

                            declCollectionContext.pushParent(objectLitDecl);

                            getAstWalkerFactory().walk(funcDeclAST, preCollectDecls, postCollectDecls, null, declCollectionContext);

                            var functionDecl = this.getDeclForAST(funcDeclAST);

                            var binder = new PullSymbolBinder(this.compilationSettings, this.semanticInfoChain);
                            binder.setUnit(this.unitPath);
                            binder.pushParent(typeSymbol, objectLitDecl);

                            if (funcDeclAST.isGetAccessor()) {
                                binder.bindGetAccessorDeclarationToPullSymbol(functionDecl);
                            }
                            else {
                                binder.bindSetAccessorDeclarationToPullSymbol(functionDecl);
                            }
                        }
                    }

                    memberExprType = this.resolveStatementOrExpression(binex.operand2, assigningSymbol != null, enclosingDecl, context);

                    if (acceptedContextualType) {
                        context.popContextualType();
                        acceptedContextualType = false;
                    }

                    context.setTypeInContext(memberSymbol, memberExprType.getType());

                    memberSymbol.setResolved();

                    this.setSymbolForAST(binex.operand1, memberSymbol);

                    typeSymbol.addMember(memberSymbol, SymbolLinkKind.PublicMember);
                }
            }

            typeSymbol.setResolved();

            this.setSymbolForAST(expressionAST, typeSymbol);

            return typeSymbol;
        }

        public resolveArrayLiteralExpression(expressionAST: AST, isTypedAssignment, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            var arrayLit = <UnaryExpression>expressionAST;

            var elements = <ASTList>arrayLit.operand;
            var elementType = this.semanticInfoChain.anyTypeSymbol;
            var elementTypes: PullTypeSymbol[] = [];
            var targetElementType: PullTypeSymbol = null;
            var comparisonInfo = new TypeComparisonInfo();
            comparisonInfo.onlyCaptureFirstError = true;

            // if the target type is an array type, extract the element type
            if (isTypedAssignment) {
                var contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, enclosingDecl, context);

                if (contextualType.isArray()) {
                    contextualType = contextualType.getElementType();
                }

                context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
            }

            if (elements) {

                for (var i = 0; i < elements.members.length; i++) {
                    elementTypes[elementTypes.length] = this.resolveStatementOrExpression(elements.members[i], isTypedAssignment, enclosingDecl, context).getType();
                }

                if (isTypedAssignment) {
                    context.popContextualType();
                }

                if (elementTypes.length) {
                    elementType = elementTypes[0];
                }

                var collection: IPullTypeCollection = {
                    getLength: () => { return elements.members.length; },
                    setTypeAtIndex: (index: number, type: PullTypeSymbol) => { elementTypes[index] = type; },
                    getTypeAtIndex: (index: number) => { return elementTypes[index]; }
                }

                elementType = this.findBestCommonType(elementType, targetElementType, collection, false, context, comparisonInfo);

                // if the array type is the undefined type, we should widen it to any
                // if it's of the null type, only widen it if it's not in a nested array element, so as not to 
                // short-circuit any checks for the best common type
                if (elementType == this.semanticInfoChain.undefinedTypeSymbol || elementType == this.semanticInfoChain.nullTypeSymbol) {
                    elementType = this.semanticInfoChain.anyTypeSymbol;
                }
            }
            if (!elementType) {
                context.postError(expressionAST.minChar, expressionAST.getLength(), this.unitPath, "Incompatible types in array literal expression", enclosingDecl);

                elementType = this.semanticInfoChain.anyTypeSymbol;
            }
            else if (targetElementType) {
                // for the case of zero-length 'any' arrays, we still want to set the contextual type, if
                // need be
                if (this.sourceIsAssignableToTarget(elementType, targetElementType, context)) {
                    elementType = targetElementType;
                }
            }

            var arraySymbol = elementType.getArrayType();

            // ...But in case we haven't...
            if (!arraySymbol) {

                if (!this.cachedArrayInterfaceType) {
                    this.cachedArrayInterfaceType = <PullTypeSymbol>this.getSymbolFromDeclPath("Array", this.getPathToDecl(enclosingDecl), PullElementKind.Interface);
                }

                if (this.cachedArrayInterfaceType && !this.cachedArrayInterfaceType.isResolved()) {
                    this.resolveDeclaredSymbol(this.cachedArrayInterfaceType, enclosingDecl, context);
                }

                arraySymbol = specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, elementType, this, context);

                if (!arraySymbol) {
                    arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            return arraySymbol;
        }

        public resolveIndexExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            var indexType = <PullTypeSymbol>this.resolveStatementOrExpression((<BinaryExpression>expressionAST).operand1, isTypedAssignment, enclosingDecl, context).getType();
            var elementType = indexType.getElementType();

            if (elementType) {
                return elementType;
            }

            return this.semanticInfoChain.anyTypeSymbol;
        }

        public resolveBitwiseOperator(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            var binex = <BinaryExpression>expressionAST;

            var leftType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();

            if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) &&
                this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {

                return this.semanticInfoChain.numberTypeSymbol;
            }
            else if ((leftType == this.semanticInfoChain.boolTypeSymbol) &&
                     (rightType == this.semanticInfoChain.boolTypeSymbol)) {

                return this.semanticInfoChain.boolTypeSymbol;
            }
            else if (leftType == this.semanticInfoChain.anyTypeSymbol) {
                if ((rightType == this.semanticInfoChain.anyTypeSymbol) ||
                    (rightType == this.semanticInfoChain.numberTypeSymbol) ||
                    (rightType == this.semanticInfoChain.boolTypeSymbol)) {

                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else if (rightType == this.semanticInfoChain.anyTypeSymbol) {
                if ((leftType == this.semanticInfoChain.numberTypeSymbol) ||
                    (leftType == this.semanticInfoChain.boolTypeSymbol)) {

                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }

            return this.semanticInfoChain.anyTypeSymbol;
        }

        public resolveArithmeticExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            var binex = <BinaryExpression>expressionAST;

            var leftType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();

            // PULLREVIEW: Eh?  I've preserved the logic from the current implementation, but it could use cleaning up
            if (this.isNullOrUndefinedType(leftType)) {
                leftType = rightType;
            }
            if (this.isNullOrUndefinedType(rightType)) {
                rightType = leftType;
            }

            leftType = this.widenType(leftType);
            rightType = this.widenType(rightType);

            if (expressionAST.nodeType == NodeType.Add || expressionAST.nodeType == NodeType.AsgAdd) {
                if (leftType == this.semanticInfoChain.stringTypeSymbol || rightType == this.semanticInfoChain.stringTypeSymbol) {
                    return this.semanticInfoChain.stringTypeSymbol;
                }
                else if (leftType == this.semanticInfoChain.numberTypeSymbol && rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else {
                    // could be an error
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else {
                if (leftType == this.semanticInfoChain.numberTypeSymbol && rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else if (leftType == this.semanticInfoChain.anyTypeSymbol || rightType == this.semanticInfoChain.anyTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else {
                    // error
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
        }

        public resolveLogicalOrExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            var binex = <BinaryExpression>expressionAST;

            var leftType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();

            if (leftType == this.semanticInfoChain.anyTypeSymbol || rightType == this.semanticInfoChain.anyTypeSymbol) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            else if (leftType == this.semanticInfoChain.boolTypeSymbol) {
                if (rightType == this.semanticInfoChain.boolTypeSymbol) {
                    return this.semanticInfoChain.boolTypeSymbol;
                }
                else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else if (leftType == this.semanticInfoChain.numberTypeSymbol) {
                if (rightType == this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                else {
                    return this.semanticInfoChain.anyTypeSymbol
                }
            }
            else if (leftType == this.semanticInfoChain.stringTypeSymbol) {
                if (rightType == this.semanticInfoChain.stringTypeSymbol) {
                    return this.semanticInfoChain.stringTypeSymbol;
                }
                else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }
            else if (this.sourceIsSubtypeOfTarget(leftType, rightType, context)) {
                return rightType;
            }
            else if (this.sourceIsSubtypeOfTarget(rightType, leftType, context)) {
                return leftType;
            }

            return this.semanticInfoChain.anyTypeSymbol;
        }

        public resolveLogicalAndExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {
            var binex = <BinaryExpression>expressionAST;

            var leftType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();
            var rightType = <PullTypeSymbol>this.resolveStatementOrExpression(binex.operand2, isTypedAssignment, enclosingDecl, context).getType();

            return rightType;
        }

        public resolveConditionalExpression(trinex: ConditionalExpression, enclosingDecl: PullDecl, context: PullTypeResolutionContext) {
            var condType = this.resolveAST(trinex.operand1, false, enclosingDecl, context).getType();
            var leftType = this.resolveAST(trinex.operand2, false, enclosingDecl, context).getType();
            var rightType = this.resolveAST(trinex.operand3, false, enclosingDecl, context).getType();

            if (this.typesAreIdentical(leftType, rightType)) {
                return leftType;
            }

            var collection: IPullTypeCollection = {
                getLength: () => { return 2; },
                setTypeAtIndex: (index: number, type: PullTypeSymbol) => { }, // no contextual typing here, so no need to do anything
                getTypeAtIndex: (index: number) => { return rightType; } // we only want the "second" type - the "first" is skipped
            }

            var bct = this.findBestCommonType(leftType, null, collection, false, context);

            if (bct) {
                return bct;
            }

            context.postError(trinex.minChar, trinex.getLength(), this.getUnitPath(), "Conditional expression types do not agree", enclosingDecl);

            return this.semanticInfoChain.anyTypeSymbol;
        }

        public resolveCallExpression(callEx: CallExpression, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext, additionalResults?: PullAdditionalCallResolutionData): PullSymbol {

            // resolve the target
            var targetSymbol = this.resolveStatementOrExpression(callEx.target, isTypedAssignment, enclosingDecl, context).getType();

            if (targetSymbol == this.semanticInfoChain.anyTypeSymbol) {
                return targetSymbol;
            }

            var isSuperCall = false;

            if (callEx.target.nodeType == NodeType.Super) {
                isSuperCall = true;

                if (targetSymbol.isClass()) { 
                    targetSymbol = (<PullClassTypeSymbol>targetSymbol).getConstructorMethod().getType();
                }
                else {
                    context.postError(callEx.minChar, callEx.getLength(), this.unitPath, "Invalid super call on non-class type '"+ targetSymbol.toString() + "'", enclosingDecl);
                    return this.semanticInfoChain.anyTypeSymbol;                    
                }
            }

            var signatures = isSuperCall ? (<PullFunctionTypeSymbol>targetSymbol).getConstructSignatures() : (<PullFunctionTypeSymbol>targetSymbol).getCallSignatures();

            var typeArgs: PullTypeSymbol[] = null;
            var typeReplacementMap: any = null;
            var i = 0;

            // resolve the type arguments, specializing if necessary
            if (callEx.typeArguments) {
                // specialize the type arguments
                typeArgs = [];

                var typeArg: PullTypeSymbol = null;

                if (callEx.typeArguments && callEx.typeArguments.members.length) {
                    for (i = 0; i < callEx.typeArguments.members.length; i++) {
                        typeArg = this.resolveTypeReference(<TypeReference>callEx.typeArguments.members[i], enclosingDecl, context);
                        typeArgs[i] = context.findSpecializationForType(typeArg);
                    }
                }
            }

            // next, walk the available signatures
            // if any are generic, and we don't have type arguments, try to infer
            // otherwise, try to specialize to the type arguments above
            if (targetSymbol.isGeneric()) {

                var resolvedSignatures: PullSignatureSymbol[] = [];
                var inferredTypeArgs: PullTypeSymbol[];
                var specializedSignature: PullSignatureSymbol;
                var typeParameters: PullTypeParameterSymbol[];
                var typeConstraint: PullTypeSymbol = null;

                for (i = 0; i < signatures.length; i++) {
                    typeParameters = signatures[i].getTypeParameters();
                    
                    if (signatures[i].isGeneric() && typeParameters.length) {
                        if (typeArgs) {
                            inferredTypeArgs = typeArgs;
                        }
                        else {
                            inferredTypeArgs = this.inferArgumentTypesForSignature(signatures[i], callEx.arguments, new TypeComparisonInfo(), enclosingDecl, context);
                        }

                        // if we could infer Args, or we have type arguments, then attempt to specialize the signature
                        if (inferredTypeArgs) {

                            if (inferredTypeArgs.length != typeParameters.length) {
                                continue;
                            }

                            typeReplacementMap = {};

                            for (var j = 0; j < typeParameters.length; j++) {
                                typeReplacementMap[typeParameters[j].getSymbolID().toString()] = inferredTypeArgs[j];

                                typeConstraint = typeParameters[j].getConstraint();

                                // test specialization type for assignment compatibility with the constraint
                                if (typeConstraint) {
                                    if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, context)) {
                                        context.postError(callEx.target.minChar, callEx.target.getLength(), this.getUnitPath(), "Type '" + inferredTypeArgs[j].toString() + "' does not satisfy the constraint '" + typeConstraint.toString() + "' for type parameter '" + typeParameters[j].toString() + "'", enclosingDecl);
                                    }
                                }
                            }

                            specializedSignature = specializeSignature(signatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);

                            if (specializedSignature) {
                                resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                            }
                        }
                    }
                    else {
                        resolvedSignatures[resolvedSignatures.length] = signatures[i];
                    }
                }
                // PULLTODO: Try to avoid copying here...
                signatures = resolvedSignatures;
            }

            // the target should be a function
            //if (!targetSymbol.isType()) {
            //    this.log("Attempting to call a non-function symbol");
            //    return this.semanticInfoChain.anyTypeSymbol;
            //}

            if (!signatures.length) {

                // if there are no call signatures, but the target is a subtype of 'Function', return 'any'
                if (this.cachedFunctionInterfaceType && this.sourceIsSubtypeOfTarget(targetSymbol, this.cachedFunctionInterfaceType, context)) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }

                context.postError(callEx.minChar, callEx.getLength(), this.unitPath, "Attempting to call on a type with no call signatures", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var signature = this.resolveOverloads(callEx, signatures, enclosingDecl, context);

            if (!signature) {
                context.postError(callEx.minChar, callEx.getLength(), this.unitPath, "Could not select overload for call expression", enclosingDecl);
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var returnType = signature.getReturnType();

            // contextually type arguments
            if (callEx.arguments) {
                var len = callEx.arguments.members.length;
                var params = signature.getParameters();
                var contextualType: PullTypeSymbol = null;
                var signatureDecl = signature.getDeclarations()[0];
                    
                for (i = 0; i < len; i++) {

                    if (params.length && i < params.length) {
                        if (typeReplacementMap) {
                            context.pushTypeSpecializationCache(typeReplacementMap);
                        }
                        this.resolveDeclaredSymbol(params[i], signatureDecl, context);
                        if (typeReplacementMap) {
                            context.popTypeSpecializationCache();
                        }
                        contextualType = params[i].getType();
                    }
                    else if (params.length) {
                        contextualType = params[params.length - 1].getType();
                        if (contextualType.isArray()) {
                            contextualType = contextualType.getElementType();
                        }
                    }

                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                    }

                    this.resolveStatementOrExpression(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }

            if (!returnType) {
                returnType = this.semanticInfoChain.anyTypeSymbol;
            }

            // Store any additional resolution results if needed
            if (additionalResults) {
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.resolvedSignatures = signatures;
                additionalResults.candidateSignature = signature;
            }

            return returnType;
        }

        public resolveNewExpression(callEx: CallExpression, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext, additionalResults?: PullAdditionalCallResolutionData): PullSymbol {

            var returnType: PullTypeSymbol = null;

            // resolve the target
            var targetSymbol = this.resolveStatementOrExpression(callEx.target, isTypedAssignment, enclosingDecl, context);

            var targetTypeSymbol = targetSymbol.isType() ? <PullTypeSymbol>targetSymbol : targetSymbol.getType();

            var i = 0;

            // PULLREVIEW: In the case of a generic instantiation of a class type,
            // we'll have gotten a 'GenericType' node, which will be resolved as the class type and not
            // the constructor type.  In this case, set the targetTypeSymbol to the constructor type
            if (targetTypeSymbol.isClass()) {
                targetTypeSymbol = (<PullClassTypeSymbol>targetTypeSymbol).getConstructorMethod().getType();
            }

            var constructSignatures = targetTypeSymbol.getConstructSignatures();

            var typeArgs: PullTypeSymbol[] = null;
            var typeReplacementMap: any = null;
            var usedCallSignaturesInstead = false;

            if (targetTypeSymbol == this.semanticInfoChain.anyTypeSymbol) {
                return this.semanticInfoChain.anyTypeSymbol;
            }            

            if (!constructSignatures.length) {
                constructSignatures = targetTypeSymbol.getCallSignatures();
                usedCallSignaturesInstead = true;
            }            

            if (constructSignatures.length) {

                // resolve the type arguments, specializing if necessary
                if (callEx.typeArguments) {
                    // specialize the type arguments
                    typeArgs = [];

                    var typeArg: PullTypeSymbol = null;

                    if (callEx.typeArguments && callEx.typeArguments.members.length) {
                        for (i = 0; i < callEx.typeArguments.members.length; i++) {
                            typeArg = this.resolveTypeReference(<TypeReference>callEx.typeArguments.members[i], enclosingDecl, context);
                            typeArgs[i] = context.findSpecializationForType(typeArg);
                        }
                    }
                }

                // next, walk the available signatures
                // if any are generic, and we don't have type arguments, try to infer
                // otherwise, try to specialize to the type arguments above
                if (targetTypeSymbol.isGeneric()) {

                    var resolvedSignatures: PullSignatureSymbol[] = [];
                    var inferredTypeArgs: PullTypeSymbol[];
                    var specializedSignature: PullSignatureSymbol;
                    var typeParameters: PullTypeParameterSymbol[];
                    var typeConstraint: PullTypeSymbol = null;

                    for (i = 0; i < constructSignatures.length; i++) {
                        if (constructSignatures[i].isGeneric()) {
                            if (typeArgs) {
                                inferredTypeArgs = typeArgs;
                            }
                            else {
                                inferredTypeArgs = this.inferArgumentTypesForSignature(constructSignatures[i], callEx.arguments, new TypeComparisonInfo(), enclosingDecl, context);
                            }

                            // if we could infer Args, or we have type arguments, then attempt to specialize the signature
                            if (inferredTypeArgs) {
                                typeParameters = constructSignatures[i].getTypeParameters();

                                if (inferredTypeArgs.length != typeParameters.length) {
                                    continue;
                                }

                                typeReplacementMap = {};

                                for (var j = 0; j < typeParameters.length; j++) {
                                    typeReplacementMap[typeParameters[j].getSymbolID().toString()] = inferredTypeArgs[j];

                                    typeConstraint = typeParameters[j].getConstraint();

                                    // test specialization type for assignment compatibility with the constraint
                                    if (typeConstraint) {
                                        if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, context)) {
                                            context.postError(callEx.target.minChar, callEx.target.getLength(), this.getUnitPath(), "Type '" + inferredTypeArgs[j].toString() + "' does not satisfy the constraint '" + typeConstraint.toString() + "' for type parameter '" + typeParameters[j].toString() + "'", enclosingDecl);
                                        }
                                    }
                                }

                                specializedSignature = specializeSignature(constructSignatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);

                                if (specializedSignature) {
                                    resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                                }
                            }
                        }
                        else {
                            resolvedSignatures[resolvedSignatures.length] = constructSignatures[i];
                        }
                    }
                    // PULLTODO: Try to avoid copying here...
                    constructSignatures = resolvedSignatures;
                }

                // the target should be a function
                //if (!targetSymbol.isType()) {
                //    this.log("Attempting to call a non-function symbol");
                //    return this.semanticInfoChain.anyTypeSymbol;
                //}

                var signature = this.resolveOverloads(callEx, constructSignatures, enclosingDecl, context);

                // if we haven't been able to choose an overload, default to the first one
                if (!signature) {
                    //signature = constructSignatures[0];
                    context.postError(callEx.minChar, callEx.getLength(), this.unitPath, "Could not select overload for 'new' expression", enclosingDecl);
                    return this.semanticInfoChain.anyTypeSymbol;
                }

                returnType = signature.getReturnType();

                if (usedCallSignaturesInstead) {
                    if (returnType != this.semanticInfoChain.voidTypeSymbol) {
                        context.postError(callEx.minChar, callEx.getLength(), this.unitPath, "Call signatures used in a 'new' expression must have a return type of 'void'", enclosingDecl);
                        return this.semanticInfoChain.anyTypeSymbol;                        
                    }
                }

                if (!returnType) {
                    returnType = signature.getReturnType();

                    if (!returnType) {
                        returnType = targetTypeSymbol;
                    }
                }

                // contextually type arguments
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    var params = signature.getParameters();
                    var contextualType: PullTypeSymbol = null;
                    var signatureDecl = signature.getDeclarations()[0];

                    for (i = 0; i < len; i++) {

                        if (params.length && i < params.length) {
                            if (typeReplacementMap) {
                                context.pushTypeSpecializationCache(typeReplacementMap);
                            }
                            this.resolveDeclaredSymbol(params[i], signatureDecl, context);
                            if (typeReplacementMap) {
                                context.popTypeSpecializationCache();
                            }
                            contextualType = params[i].getType();
                        }
                        else if (params.length) {
                            contextualType = params[params.length - 1].getType();
                            if (contextualType.isArray()) {
                                contextualType = contextualType.getElementType();
                            }
                        }

                        if (contextualType) {
                            context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                        }

                        this.resolveStatementOrExpression(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                        if (contextualType) {
                            context.popContextualType();
                            contextualType = null;
                        }
                    }
                }

                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                // Store any additional resolution results if needed
                if (additionalResults) {
                    additionalResults.targetSymbol = targetTypeSymbol;
                    additionalResults.resolvedSignatures = constructSignatures;
                    additionalResults.candidateSignature = signature;
                }

                return returnType;
            }
            else if (targetTypeSymbol.isClass()) {

                // implicit constructor
                return returnType;
            }

            context.postError(callEx.minChar, callEx.getLength(), this.unitPath, "Invalid 'new' expression", enclosingDecl);

            return this.semanticInfoChain.anyTypeSymbol;

        }

        public resolveTypeAssertionExpression(expressionAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            var assertionExpression = <UnaryExpression>expressionAST;
            var typeReference = this.resolveTypeReference(<TypeReference>assertionExpression.castTerm, enclosingDecl, context);

            // PULLTODO: We don't technically need to resolve the operand, since the type of the
            // expression is the type of the cast term.  Still, it makes life a bit easier for the LS
            if (context.resolveAggressively && !assertionExpression.operand.isParenthesized) {
                context.pushContextualType(typeReference, context.inProvisionalResolution(), null);
                this.resolveStatementOrExpression(assertionExpression.operand, true, enclosingDecl, context);
                context.popContextualType();
            }

            return typeReference;
        }

        public resolveAssignmentStatement(statementAST: AST, isTypedAssignment: bool, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSymbol {

            var binex = <BinaryExpression>statementAST;

            var leftType = this.resolveStatementOrExpression(binex.operand1, isTypedAssignment, enclosingDecl, context).getType();

            context.pushContextualType(leftType, context.inProvisionalResolution(), null);
            this.resolveStatementOrExpression(binex.operand2, true, enclosingDecl, context);
            context.popContextualType();

            return leftType;
        }

        public resolveBoundDecls(decl: PullDecl, context: PullTypeResolutionContext): void {

            if (!decl) {
                return;
            }
            
            switch (decl.getKind()) {
                case PullElementKind.Script:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.resolveBoundDecls(childDecls[i], context);
                    }
                    break;
                case PullElementKind.DynamicModule:
                case PullElementKind.Container:
                    var moduleDecl = <ModuleDeclaration>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveModuleDeclaration(moduleDecl, context);
                    break;
                case PullElementKind.Interface:
                    var interfaceDecl = <TypeDeclaration>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveInterfaceDeclaration(interfaceDecl, context);
                    break;
                case PullElementKind.Class:
                    var classDecl = <ClassDeclaration>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveClassDeclaration(classDecl, context);
                    break;
                case PullElementKind.Method:
                case PullElementKind.Function:
                    var funcDecl = <FuncDecl>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveFunctionDeclaration(funcDecl, context);
                    break;
                case PullElementKind.GetAccessor:
                    funcDecl = <FuncDecl>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveGetAccessorDeclaration(funcDecl, context);
                    break;
                case PullElementKind.SetAccessor:
                    funcDecl = <FuncDecl>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);
                    this.resolveSetAccessorDeclaration(funcDecl, context);
                    break;
                case PullElementKind.Property:
                case PullElementKind.Variable:
                case PullElementKind.Parameter:
                    var varDecl = <BoundDecl>this.semanticInfoChain.getASTForDecl(decl, this.unitPath);

                    // varDecl may be null if we're dealing with an implicit variable created for a class,
                    // module or enum
                    if (varDecl) {
                        this.resolveVariableDeclaration(varDecl, context);
                    }
                    break;
            }
        }

        // type relationships

        public mergeOrdered(a: PullTypeSymbol, b: PullTypeSymbol, acceptVoid: bool, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): PullTypeSymbol {
            if ((a == this.semanticInfoChain.anyTypeSymbol) || (b == this.semanticInfoChain.anyTypeSymbol)) {
                return this.semanticInfoChain.anyTypeSymbol;
            }
            else if (a == b) {
                return a;
            }
            else if ((b == this.semanticInfoChain.nullTypeSymbol) && a != this.semanticInfoChain.nullTypeSymbol) {
                return a;
            }
            else if ((a == this.semanticInfoChain.nullTypeSymbol) && (b != this.semanticInfoChain.nullTypeSymbol)) {
                return b;
            }
            else if (acceptVoid && (b == this.semanticInfoChain.voidTypeSymbol) && a != this.semanticInfoChain.voidTypeSymbol) {
                return a;
            }
            else if (acceptVoid && (a == this.semanticInfoChain.voidTypeSymbol) && (b != this.semanticInfoChain.voidTypeSymbol)) {
                return b;
            }
            else if ((b == this.semanticInfoChain.undefinedTypeSymbol) && a != this.semanticInfoChain.voidTypeSymbol) {
                return a;
            }
            else if ((a == this.semanticInfoChain.undefinedTypeSymbol) && (b != this.semanticInfoChain.undefinedTypeSymbol)) {
                return b;
            }
            else if (a.isTypeParameter() && !b.isTypeParameter()) {
                return b;
            }
            else if (!a.isTypeParameter() && b.isTypeParameter()) {
                return a;
            }
            else if (a.isArray() && b.isArray()) {
                if (a.getElementType() == b.getElementType()) {
                    return a;
                }
                else {
                    var mergedET = this.mergeOrdered(a.getElementType(), b.getElementType(), acceptVoid, context, comparisonInfo);
                    var mergedArrayType = mergedET.getArrayType();

                    if (!mergedArrayType) {
                        mergedArrayType = specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, mergedET, this, context);
                    }

                    return mergedArrayType;
                }
            }
            else if (this.sourceIsSubtypeOfTarget(a, b, context, comparisonInfo)) {
                return b;
            }
            else if (this.sourceIsSubtypeOfTarget(b, a, context, comparisonInfo)) {
                return a;
            }
            else {
                return this.semanticInfoChain.anyTypeSymbol;
            }
        }

        public widenType(type: PullTypeSymbol): PullTypeSymbol {
            if (type == this.semanticInfoChain.undefinedTypeSymbol ||
                type == this.semanticInfoChain.nullTypeSymbol) {

                return this.semanticInfoChain.anyTypeSymbol;
            }

            return type;
        }

        public isNullOrUndefinedType(type: PullTypeSymbol) {
            return type == this.semanticInfoChain.nullTypeSymbol ||
                    type == this.semanticInfoChain.undefinedTypeSymbol;
        }

        public findBestCommonType(initialType: PullTypeSymbol, targetType: PullTypeSymbol, collection: IPullTypeCollection, acceptVoid: bool, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) {
            var i = 0;
            var len = collection.getLength();
            var nlastChecked = 0;
            var bestCommonType = initialType;

            if (targetType) {
                bestCommonType = bestCommonType ? this.mergeOrdered(bestCommonType, targetType, acceptVoid, context) : targetType;
            }

            // it's important that we set the convergence type here, and not in the loop,
            // since the first element considered may be the contextual type
            var convergenceType: PullTypeSymbol = bestCommonType;

            while (nlastChecked < len) {

                for (i = 0; i < len; i++) {

                    // no use in comparing a type against itself
                    if (i == nlastChecked) {
                        continue;
                    }

                    if (convergenceType && (bestCommonType = this.mergeOrdered(convergenceType, collection.getTypeAtIndex(i), acceptVoid, context, comparisonInfo))) {
                        convergenceType = bestCommonType;
                    }

                    if (bestCommonType == this.semanticInfoChain.anyTypeSymbol || bestCommonType == null) {
                        break;
                    }
                    else if (targetType) { // set the element type to the target type
                        collection.setTypeAtIndex(i, targetType);
                    }
                }

                // use the type if we've agreed upon it
                if (convergenceType && bestCommonType) {
                    break;
                }

                nlastChecked++;
                if (nlastChecked < len) {
                    convergenceType = collection.getTypeAtIndex(nlastChecked);
                }
            }

            return acceptVoid ? bestCommonType : (bestCommonType == this.semanticInfoChain.voidTypeSymbol ? null : bestCommonType);
        }

        // Type Identity

        public typesAreIdentical(t1: PullTypeSymbol, t2: PullTypeSymbol) {

            // This clause will cover both primitive types (since the type objects are shared),
            // as well as shared brands
            if (t1 == t2) {
                return true;
            }

            if (!t1 || !t2) {
                return false;
            }

            if (t1.isPrimitive() || t2.isPrimitive()) {
                return false;
            }

            if (t1.isClass()) {
                return false;
            }

            var comboId = (t2.getSymbolID() << 16) | t1.getSymbolID();

            if (this.identicalCache[comboId]) {
                return true;
            }

            // If one is an enum, and they're not the same type, they're not identical
            if ((t1.getKind() & PullElementKind.Enum) || (t2.getKind() & PullElementKind.Enum)) {
                return false;
            }

            if (t1.isArray() || t2.isArray()) {
                if (!(t1.isArray() && t2.isArray())) {
                    return false;
                }
                this.identicalCache[comboId] = false;
                var ret = this.typesAreIdentical(t1.getElementType(), t2.getElementType());
                if (ret) {
                    this.subtypeCache[comboId] = true;
                }
                else {
                    this.subtypeCache[comboId] = undefined;
                }

                return ret;
            }

            if (t1.isPrimitive() != t2.isPrimitive()) {
                return false;
            }

            this.identicalCache[comboId] = false;

            // properties are identical in name, optionality, and type
            if (t1.hasMembers() && t2.hasMembers()) {
                var t1Members = t1.getMembers();
                var t2Members = t2.getMembers();

                if (t1Members.length != t2Members.length) {
                    this.identicalCache[comboId] = undefined;
                    return false;
                }

                var t1MemberSymbol: PullSymbol = null;
                var t2MemberSymbol: PullSymbol = null;

                var t1MemberType: PullTypeSymbol = null;
                var t2MemberType: PullTypeSymbol = null;

                for (var iMember = 0; iMember < t1Members.length; iMember++) {

                    t1MemberSymbol = t1Members[iMember];
                    t2MemberSymbol = t2.findMember(t1MemberSymbol.getName());

                    if (!t2MemberSymbol || (t1MemberSymbol.getIsOptional() != t2MemberSymbol.getIsOptional())) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }

                    t1MemberType = t1MemberSymbol.getType();
                    t2MemberType = t2MemberSymbol.getType();

                    // catch the mutually recursive or cached cases
                    if (t1MemberType && t2MemberType && (this.identicalCache[(t2MemberType.getSymbolID() << 16) | t1MemberType.getSymbolID()] != undefined)) {
                        continue;
                    }

                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                }
            }
            else if (t1.hasMembers() || t2.hasMembers()) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            var t1CallSigs = t1.getCallSignatures();
            var t2CallSigs = t2.getCallSignatures();

            var t1ConstructSigs = t1.getConstructSignatures();
            var t2ConstructSigs = t2.getConstructSignatures();

            var t1IndexSigs = t1.getIndexSignatures();
            var t2IndexSigs = t2.getIndexSignatures();

            if (!this.signatureGroupsAreIdentical(t1CallSigs, t2CallSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1ConstructSigs, t2ConstructSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1IndexSigs, t2IndexSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            this.identicalCache[comboId] = true;
            return true;
        }

        public signatureGroupsAreIdentical(sg1: PullSignatureSymbol[], sg2: PullSignatureSymbol[]) {

            // covers the null case
            if (sg1 == sg2) {
                return true;
            }

            // covers the mixed-null case
            if (!sg1 || !sg2) {
                return false;
            }

            if (sg1.length != sg2.length) {
                return false;
            }

            var sig1: PullSignatureSymbol = null;
            var sig2: PullSignatureSymbol = null;
            var sigsMatch = false;

            // The signatures in the signature group may not be ordered...
            // REVIEW: Should definition signatures be required to be identical as well?
            for (var iSig1 = 0; iSig1 < sg1.length; iSig1++) {
                sig1 = sg1[iSig1];

                for (var iSig2 = 0; iSig2 < sg2.length; iSig2++) {
                    sig2 = sg2[iSig2];

                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }

                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }

                // no match found for a specific signature
                return false;
            }

            return true;
        }

        public signaturesAreIdentical(s1: PullSignatureSymbol, s2: PullSignatureSymbol) {

            if (s1.hasVariableParamList() != s2.hasVariableParamList()) {
                return false;
            }

            if (s1.getNonOptionalParameterCount() != s2.getNonOptionalParameterCount()) {
                return false;
            }

            var s1Params = s1.getParameters();
            var s2Params = s2.getParameters();

            if (s1Params.length != s2Params.length) {
                return false;
            }

            if (!this.typesAreIdentical(s1.getReturnType(), s2.getReturnType())) {
                return false;
            }

            for (var iParam = 0; iParam < s1Params.length; iParam++) {
                if (!this.typesAreIdentical(s1Params[iParam].getType(), s2Params[iParam].getType())) {
                    return false;
                }
            }

            return true;
        }

        // Assignment Compatibility and Subtyping

        public sourceIsSubtypeOfTarget(source: PullTypeSymbol, target: PullTypeSymbol, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, context, comparisonInfo);
        }

        public signatureGroupIsSubtypeOfTarget(sg1: PullSignatureSymbol[], sg2: PullSignatureSymbol[], context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, context, comparisonInfo);
        }

        public signatureIsSubtypeOfTarget(s1: PullSignatureSymbol, s2: PullSignatureSymbol, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, context, comparisonInfo);
        }

        public sourceIsAssignableToTarget(source: PullTypeSymbol, target: PullTypeSymbol, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): bool {
            return this.sourceIsRelatableToTarget(source, target, true, this.assignableCache, context, comparisonInfo);
        }

        public signatureGroupIsAssignableToTarget(sg1: PullSignatureSymbol[], sg2: PullSignatureSymbol[], context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): bool {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, context, comparisonInfo);
        }

        public signatureIsAssignableToTarget(s1: PullSignatureSymbol, s2: PullSignatureSymbol, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): bool {
            return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, context, comparisonInfo);
        }

        public sourceIsRelatableToTarget(source: PullTypeSymbol, target: PullTypeSymbol, assignableTo: bool, comparisonCache: any, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo): bool {

            // REVIEW: Does this check even matter?
            //if (this.typesAreIdentical(source, target)) {
            //    return true;
            //}
            if (source == target) {
                return true;
            }

            // An error has already been reported in this case
            if (!(source && target)) {
                return true;
            }

            var comboId = (source.getSymbolID() << 16) | target.getSymbolID();

            // In the case of a 'false', we want to short-circuit a recursive typecheck
            if (comparisonCache[comboId] != undefined) {
                return true;
            }

            // this is one difference between subtyping and assignment compatibility
            if (assignableTo) {
                if (source == this.semanticInfoChain.anyTypeSymbol || target == this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }
            }
            else {
                // This is one difference between assignment compatibility and subtyping
                if (target == this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }
            }

            if (source == this.semanticInfoChain.undefinedTypeSymbol) {
                return true;
            }

            if ((source == this.semanticInfoChain.nullTypeSymbol) && (target != this.semanticInfoChain.undefinedTypeSymbol && target != this.semanticInfoChain.voidTypeSymbol)) {
                return true;
            }

            // REVIEW: enum types aren't explicitly covered in the spec
            if (target == this.semanticInfoChain.numberTypeSymbol && (source.getKind() & PullElementKind.Enum)) {
                return true;
            }
            if (source == this.semanticInfoChain.numberTypeSymbol && (target.getKind() & PullElementKind.Enum)) {
                return true;
            }
            if ((source.getKind() & PullElementKind.Enum) || (target.getKind() & PullElementKind.Enum)) {
                return false;
            }

            if (source.isArray() || target.isArray()) {
                if (!(source.isArray() && target.isArray())) {
                    return false;
                }
                comparisonCache[comboId] = false;
                var ret = this.sourceIsRelatableToTarget(source.getElementType(), target.getElementType(), assignableTo, comparisonCache, context, comparisonInfo);
                if (ret) {
                    comparisonCache[comboId] = true;
                }
                else {
                    comparisonCache[comboId] = undefined;
                }

                return ret;
            }

            if (target.isTypeParameter()) {
                return true;
            }            

            // this check ensures that we only operate on object types from this point forward,
            // since the checks involving primitives occurred above
            if (source.isPrimitive() && target.isPrimitive()) {

                // we already know that they're not the same, and that neither is 'any'
                return false;
            }
            else if (source.isPrimitive() != target.isPrimitive()) {

                if (!target.isPrimitive()) {
                    if (source == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType) {

                        if (!this.cachedNumberInterfaceType.isResolved()) {
                            this.resolveDeclaredSymbol(this.cachedNumberInterfaceType, null, context);
                        }

                        source = this.cachedNumberInterfaceType;
                    }
                    else if (source == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType) {

                        if (!this.cachedStringInterfaceType.isResolved()) {
                            this.resolveDeclaredSymbol(this.cachedStringInterfaceType, null, context);
                        }

                        source = this.cachedStringInterfaceType;
                    }
                    else if (source == this.semanticInfoChain.boolTypeSymbol && this.cachedBooleanInterfaceType) {

                        if (!this.cachedBooleanInterfaceType.isResolved()) {
                            this.resolveDeclaredSymbol(this.cachedBooleanInterfaceType, null, context);
                        }

                        source = this.cachedBooleanInterfaceType;
                    }
                    else {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }

            comparisonCache[comboId] = false;

            if (source.hasBase(target)) {
                comparisonCache[comboId] = true;
                return true;
            }

            if (this.cachedObjectInterfaceType && target == this.cachedObjectInterfaceType) {
                return true;
            }

            if (this.cachedFunctionInterfaceType && (source.getCallSignatures().length || source.getConstructSignatures().length) && target == this.cachedFunctionInterfaceType) {
                return true;
            }

            if (target.hasMembers()) {
                var mProps = target.getMembers();
                var mProp: PullSymbol = null;
                var nProp: PullSymbol = null;
                var mPropType: PullTypeSymbol = null;
                var nPropType: PullTypeSymbol = null;

                for (var iMProp = 0; iMProp < mProps.length; iMProp++) {

                    mProp = mProps[iMProp];
                    nProp = source.findMember(mProp.getName());

                    // PULLTODO:
                    // methods do not have the "arguments" field
                    //if (mProp.getName() == "arguments" &&
                    //    this.cachedIArgumentsInterfaceType &&
                    //    (this.typeFlow.iargumentsInterfaceType.symbol.flags & SymbolFlags.CompilerGenerated) &&
                    //    mProp.kind() == SymbolKind.Variable &&
                    //    (<VariableSymbol>mProp).variable.typeLink.type == this.typeFlow.iargumentsInterfaceType) {
                    //    continue;
                    //}

                    if (!mProp.isResolved()) {
                        this.resolveDeclaredSymbol(mProp, null, context);
                    }

                    mPropType = mProp.getType();

                    if (!nProp) {
                        // If it's not present on the type in question, look for the property on 'Object'
                        if (this.cachedObjectInterfaceType) {
                            nProp = this.cachedObjectInterfaceType.findMember(mProp.getName());
                        }

                        if (!nProp) {
                            // Now, the property was not found on Object, but the type in question is a function, look
                            // for it on function
                            if (this.cachedFunctionInterfaceType && (mPropType.getCallSignatures().length || mPropType.getConstructSignatures().length)) {
                                nProp = this.cachedFunctionInterfaceType.findMember(mProp.getName());
                            }

                            // finally, check to see if the property is optional
                            if (!nProp) {
                                if (!(mProp.getIsOptional())) {
                                    comparisonCache[comboId] = undefined;
                                    if (comparisonInfo) { // only surface the first error
                                        comparisonInfo.flags |= TypeRelationshipFlags.RequiredPropertyIsMissing;
                                        comparisonInfo.addMessageToFront("Type '" + source.toString() + "' is missing property '" + mProp.getScopedNameEx().toString() + "' from type '" + target.toString() + "'");
                                    }
                                    return false;
                                }
                                else {
                                    continue;
                                }
                            }
                        }
                    }

                    // if both are private members, test to ensure that they share a declaration
                    if (nProp.hasFlag(PullElementFlags.Private) && mProp.hasFlag(PullElementFlags.Private)) {
                        var mDecl = mProp.getDeclarations()[0];
                        var nDecl = nProp.getDeclarations()[0];

                        if (mDecl != nDecl) {
                            return false;
                        }
                    }

                    if (!nProp.isResolved()) {
                        this.resolveDeclaredSymbol(nProp, null, context);
                    }


                    nPropType = nProp.getType();

                    // catch the mutually recursive or cached cases
                    if (mPropType && nPropType && (comparisonCache[(nPropType.getSymbolID() << 16) | mPropType.getSymbolID()] != undefined)) {
                        continue;
                    }

                    if (!this.sourceIsRelatableToTarget(nPropType, mPropType, assignableTo, comparisonCache, context, comparisonInfo)) {
                        comparisonCache[comboId] = undefined;
                        if (comparisonInfo) { // only surface the first error
                            comparisonInfo.flags |= TypeRelationshipFlags.IncompatiblePropertyTypes;
                            comparisonInfo.addMessageToFront("Types of property '" + mProp.getScopedNameEx().toString() + "' of types '" + source.toString() + "' and '" + target.toString() + "' are incompatible");
                        }
                        return false;
                    }
                }
            }

            var sourceCallSigs = source.getCallSignatures();
            var targetCallSigs = target.getCallSignatures();

            var sourceConstructSigs = source.getConstructSignatures();
            var targetConstructSigs = target.getConstructSignatures();

            var sourceIndexSigs = source.getIndexSignatures();
            var targetIndexSigs = target.getIndexSignatures();
            
            var hasSig: string;
            var lacksSig: string;

            // check signature groups
            if (targetCallSigs.length) {
                if (!this.signatureGroupIsRelatableToTarget(sourceCallSigs, targetCallSigs, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (sourceCallSigs.length && targetCallSigs.length) {
                            comparisonInfo.addMessageToFront("Call signatures of types '" + source.toString() + "' and '" + target.toString() + "' are incompatible");
                        }
                        else {
                            hasSig = targetCallSigs.length ? target.toString() : source.toString();
                            lacksSig = !targetCallSigs.length ? target.toString() : source.toString();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a call signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            if (targetConstructSigs.length) {
                if (!this.signatureGroupIsRelatableToTarget(sourceConstructSigs, targetConstructSigs, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        if (sourceConstructSigs.length && targetConstructSigs.length) {
                            comparisonInfo.addMessageToFront("Construct signatures of types '" + source.toString() + "' and '" + target.toString() + "' are incompatible");
                        }
                        else {
                            hasSig = targetConstructSigs.length ? target.toString() : source.toString();
                            lacksSig = !targetConstructSigs.length ? target.toString() : source.toString();
                            comparisonInfo.setMessage("Type '" + hasSig + "' requires a construct signature, but Type '" + lacksSig + "' lacks one");
                        }
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            if (targetIndexSigs.length) {
                var targetIndex = !targetIndexSigs.length && this.cachedObjectInterfaceType ? this.cachedObjectInterfaceType.getIndexSignatures() : targetIndexSigs;
                var sourceIndex = !sourceIndexSigs.length && this.cachedObjectInterfaceType ? this.cachedObjectInterfaceType.getIndexSignatures() : sourceIndexSigs;

                if (!this.signatureGroupIsRelatableToTarget(sourceIndex, targetIndex, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.addMessageToFront("Index signatures of types '" + source.toString() + "' and '" + target.toString() + "' are incompatible");
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleSignatures;
                    }
                    comparisonCache[comboId] = undefined;
                    return false;
                }
            }

            comparisonCache[comboId] = true;
            return true;
        }

        // REVIEW: TypeChanges: Return an error context object so the user can get better diagnostic info
        public signatureGroupIsRelatableToTarget(sourceSG: PullSignatureSymbol[], targetSG: PullSignatureSymbol[], assignableTo: bool, comparisonCache: any, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) {
            if (sourceSG == targetSG) {
                return true;
            }

            if (!(sourceSG.length && targetSG.length)) {
                return false;
            }

            var mSig: PullSignatureSymbol = null;
            var nSig: PullSignatureSymbol = null;
            var foundMatch = false;

            for (var iMSig = 0; iMSig < targetSG.length; iMSig++) {
                mSig = targetSG[iMSig];

                for (var iNSig = 0; iNSig < sourceSG.length; iNSig++) {
                    nSig = sourceSG[iNSig];
                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, context, comparisonInfo)) {
                        foundMatch = true;
                        break;
                    }
                }

                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }

            return true;
        }

        public signatureIsRelatableToTarget(sourceSig: PullSignatureSymbol, targetSig: PullSignatureSymbol, assignableTo: bool, comparisonCache: any, context: PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo) {

            var sourceParameters = sourceSig.getParameters();
            var targetParameters = targetSig.getParameters();

            if (!sourceParameters || !targetParameters) {
                return false;
            }

            var targetVarArgCount = /*targetSig.hasVariableParamList() ? targetSig.getNonOptionalParameterCount() - 1 :*/ targetSig.getNonOptionalParameterCount();
            var sourceVarArgCount = /*sourceSig.hasVariableParamList() ? sourceSig.getNonOptionalParameterCount() - 1 :*/ sourceSig.getNonOptionalParameterCount();

            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableParamList()) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= TypeRelationshipFlags.SourceSignatureHasTooManyParameters;
                    comparisonInfo.addMessageToFront("Call signature expects " + targetVarArgCount + " or fewer parameters");
                }
                return false;
            }

            var sourceReturnType = sourceSig.getReturnType();
            var targetReturnType = targetSig.getReturnType();

            if (targetReturnType != this.semanticInfoChain.voidTypeSymbol) {
                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleReturnTypes;
                        // No need to print this one here - it's printed as part of the signature error in sourceIsRelatableToTarget
                        //comparisonInfo.addMessageToFront("Incompatible return types: '" + sourceReturnType.getTypeName() + "' and '" + targetReturnType.getTypeName() + "'");
                    }
                    return false;
                }
            }

            var len = (sourceVarArgCount < targetVarArgCount && sourceSig.hasVariableParamList()) ? targetVarArgCount : sourceVarArgCount;
            var sourceParamType: PullTypeSymbol = null;
            var targetParamType: PullTypeSymbol = null;
            var sourceParamName = "";
            var targetParamName = "";

            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {

                if (!sourceSig.hasVariableParamList || iSource < sourceVarArgCount) {
                    sourceParamType = sourceParameters[iSource].getType();
                    sourceParamName = sourceParameters[iSource].getName();
                }
                else if (iSource == sourceVarArgCount) {
                    sourceParamType = sourceParameters[iSource].getType();
                    if (sourceParamType.isArray()) {
                        sourceParamType = sourceParamType.getElementType();
                    }
                    sourceParamName = sourceParameters[iSource].getName();
                }

                if (iTarget < targetParameters.length && iTarget < targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].getType();
                    targetParamName = targetParameters[iTarget].getName();
                }
                else if (targetSig.hasVariableParamList && iTarget == targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].getType();
                    if (targetParamType.isArray()) {
                        targetParamType = targetParamType.getElementType();
                    }
                    targetParamName = targetParameters[iTarget].getName();
                }

                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, context, comparisonInfo) ||
                        this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, context, comparisonInfo))) {

                    if (comparisonInfo) {
                        comparisonInfo.flags |= TypeRelationshipFlags.IncompatibleParameterTypes;
                    }
                    return false;
                }
            }
            return true;
        }

        // Overload resolution

        public resolveOverloads(application: AST, group: PullSignatureSymbol[], enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSignatureSymbol {
            var rd = this.resolutionDataCache.getResolutionData();
            var actuals = rd.actuals;
            var exactCandidates = rd.exactCandidates;
            var conversionCandidates = rd.conversionCandidates;
            var candidate: PullSignatureSymbol = null;
            var hasOverloads = group.length > 1;
            var comparisonInfo = new TypeComparisonInfo();
            var args: ASTList = null;
            var target: AST = null;
            var argSym: PullSymbol;
            var i = 0;

            if (application.nodeType == NodeType.Call || application.nodeType == NodeType.New) {
                var callEx = <CallExpression>application;

                args = callEx.arguments;
                target = callEx.target;

                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    
                    for (i = 0; i < len; i++) {
                        argSym = this.resolveStatementOrExpression(callEx.arguments.members[i], false, enclosingDecl, context);
                        actuals[i] = argSym.getType();
                    }
                }
            }
            else if (application.nodeType == NodeType.Index) {
                var binExp = <BinaryExpression>application;
                target = binExp.operand1;
                args = new ASTList();
                args.members[0] = binExp.operand2;
                argSym = this.resolveStatementOrExpression(args.members[0], false, enclosingDecl, context);
                actuals[0] = argSym.getType();
            }

            var signature: PullSignatureSymbol;
            var returnType: PullTypeSymbol;
            var candidateInfo: { sig: PullSignatureSymbol; ambiguous: bool; };

            for (var j = 0, groupLen = group.length; j < groupLen; j++) {
                signature = group[j];
                if (hasOverloads && signature.isDefinition()) {
                    continue;
                }

                returnType = signature.getReturnType();

                this.getCandidateSignatures(signature, actuals, exactCandidates, conversionCandidates, enclosingDecl, context, comparisonInfo);
            }
            if (exactCandidates.length == 0) {

                var applicableCandidates = this.getApplicableSignaturesFromCandidates(conversionCandidates, args, comparisonInfo, enclosingDecl, context);
                if (applicableCandidates.length > 0) {
                    candidateInfo = this.findMostApplicableSignature(applicableCandidates, args, enclosingDecl, context);
                    if (candidateInfo.ambiguous) {
                        //this.errorReporter.simpleError(target, "Ambiguous call expression - could not choose overload");
                        context.postError(application.minChar, application.getLength(), this.unitPath, "Ambiguous call expression - could not choose overload", enclosingDecl);
                    }
                    candidate = candidateInfo.sig;
                }
                else {
                    var emsg = "Supplied parameters do not match any signature of call target";
                    if (comparisonInfo.message) {
                        //this.checker.errorReporter.simpleError(target, emsg + ":\n\t" + comparisonInfo.message);
                        context.postError(application.minChar, application.getLength(), this.unitPath, emsg + ":\n\t" + comparisonInfo.message, enclosingDecl);
                    }
                    else {
                        context.postError(application.minChar, application.getLength(), this.unitPath, emsg, enclosingDecl);
                        //this.checker.errorReporter.simpleError(target, emsg);
                    }
                }
            }
            else {
                if (exactCandidates.length > 1) {
                    var applicableSigs: PullApplicableSignature[] = [];
                    for (i = 0; i < exactCandidates.length; i++) {
                        applicableSigs[i] = { signature: exactCandidates[i], hadProvisionalErrors: false };
                    }
                    candidateInfo = this.findMostApplicableSignature(applicableSigs, args, enclosingDecl, context);
                    if (candidateInfo.ambiguous) {
                        //this.checker.errorReporter.simpleError(target, "Ambiguous call expression - could not choose overload");
                        context.postError(application.minChar, application.getLength(), this.unitPath, "Ambiguous call expression - could not choose overload", enclosingDecl);
                    }
                    candidate = candidateInfo.sig;
                }
                else {
                    candidate = exactCandidates[0];
                }
            }

            this.resolutionDataCache.returnResolutionData(rd);
            return candidate;
        }

        public getCandidateSignatures(signature: PullSignatureSymbol, actuals: PullTypeSymbol[], exactCandidates: PullSignatureSymbol[], conversionCandidates: PullSignatureSymbol[], enclosingDecl: PullDecl, context: PullTypeResolutionContext, comparisonInfo: TypeComparisonInfo): void {
            var parameters = signature.getParameters();
            var lowerBound = signature.getNonOptionalParameterCount(); // required parameters
            var upperBound = parameters.length; // required and optional parameters
            var formalLen = lowerBound;
            var acceptable = false;

            if ((actuals.length >= lowerBound) && (signature.hasVariableParamList() || actuals.length <= upperBound)) {
                formalLen = (signature.hasVariableParamList() ? parameters.length : actuals.length);
                acceptable = true;
            }

            var repeatType: PullTypeSymbol = null;

            if (acceptable || signature.hasVariableParamList()) {
                // assumed structure here is checked when signature is formed
                if (signature.hasVariableParamList()) {
                    formalLen -= 1;
                    repeatType = parameters[formalLen].getType();
                    repeatType = repeatType.getElementType();
                    acceptable = actuals.length >= formalLen;
                }
                var len = actuals.length;

                var exact = acceptable;
                var convert = acceptable;

                var typeA: PullTypeSymbol;
                var typeB: PullTypeSymbol;

                for (var i = 0; i < len; i++) {

                    if (i < formalLen) {
                        typeA = parameters[i].getType();
                    }
                    else {
                        typeA = repeatType;
                    }

                    typeB = actuals[i];

                    if (typeA && !typeA.isResolved()) {
                        this.resolveDeclaredSymbol(typeA, enclosingDecl, context);
                    }

                    if (typeB && !typeB.isResolved()) {
                        this.resolveDeclaredSymbol(typeB, enclosingDecl, context);
                    }

                    if (!typeA || !typeB || !(this.typesAreIdentical(typeA, typeB))) {
                        exact = false;
                    }
                    // is the argument assignable to the parameter?
                    if (!this.sourceIsAssignableToTarget(typeB, typeA, context, comparisonInfo)) {
                        convert = false;
                    }
                    if (!(exact || convert)) {
                        break;
                    }
                }
                if (exact) {
                    exactCandidates[exactCandidates.length] = signature;
                }
                else if (convert && (exactCandidates.length == 0)) {
                    conversionCandidates[conversionCandidates.length] = signature;
                }
            }
        }

        public getApplicableSignaturesFromCandidates(candidateSignatures: PullSignatureSymbol[],
                                                     args: ASTList,
                                                     comparisonInfo: TypeComparisonInfo,
                                                     enclosingDecl: PullDecl,
                                                     context: PullTypeResolutionContext): PullApplicableSignature[] {

            var applicableSigs: PullApplicableSignature[] = [];
            var memberType: PullTypeSymbol = null;
            var miss = false;
            var cxt: PullContextualTypeContext = null;
            var hadProvisionalErrors = false;

            var parameters: PullSymbol[];
            var signature: PullSignatureSymbol;
            var argSym: PullSymbol;

            for (var i = 0; i < candidateSignatures.length; i++) {
                miss = false;

                signature = candidateSignatures[i];
                parameters = signature.getParameters();

                for (var j = 0; j < args.members.length; j++) {

                    if (j >= parameters.length) {
                        continue;
                    }

                    if (!parameters[j].isResolved()) {
                        this.resolveDeclaredSymbol(parameters[j], enclosingDecl, context);
                    }

                    memberType = parameters[j].getType();

                    // account for varargs
                    if (signature.hasVariableParamList() && (j >= signature.getNonOptionalParameterCount() - 1) && memberType.isArray()) {
                        memberType = memberType.getElementType();
                    }

                    if (memberType == this.semanticInfoChain.anyTypeSymbol) {
                        continue;
                    }
                    else if (args.members[j].nodeType == NodeType.FuncDecl) {

                        if (this.cachedFunctionInterfaceType && memberType == this.cachedFunctionInterfaceType) {
                            continue;
                        }

                        argSym = this.resolveFunctionExpression(<FuncDecl>args.members[j], false, enclosingDecl, context);

                        if (!this.canApplyContextualTypeToFunction(memberType, <FuncDecl>args.members[j], true)) {
                            // if it's just annotations that are blocking us, typecheck the function and add it to the list
                            if (this.canApplyContextualTypeToFunction(memberType, <FuncDecl>args.members[j], false)) {
                                if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                                    break;
                                }
                            }
                            else {
                                break;
                            }
                        }
                        else { // if it can be contextually typed, try it out...
                            //argSym.invalidate();
                            context.pushContextualType(memberType, true, null);

                            argSym = this.resolveFunctionExpression(<FuncDecl>args.members[j], true, enclosingDecl, context);

                            if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                                if (comparisonInfo) {
                                    comparisonInfo.setMessage("Could not apply type '" + memberType.toString() + "' to argument " + (j + 1) + ", which is of type '" + argSym.getTypeName() + "'");
                                }
                                miss = true;
                            }
                            argSym.invalidate();
                            cxt = context.popContextualType();
                            hadProvisionalErrors = cxt.hadProvisionalErrors();

                            //argSym.invalidate();

                            //this.resetProvisionalErrors();
                            if (miss) {
                                break;
                            }
                        }
                    }
                    else if (args.members[j].nodeType == NodeType.ObjectLit) {
                        // now actually attempt to typecheck as the contextual type
                        if (this.cachedObjectInterfaceType && memberType == this.cachedObjectInterfaceType) {
                            continue;
                        }
                        context.pushContextualType(memberType, true, null);
                        argSym = this.resolveObjectLiteralExpression(args.members[j], true, enclosingDecl, context);


                        if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.toString() + "' to argument " + (j + 1) + ", which is of type '" + argSym.getTypeName() + "'");
                            }
                            miss = true;
                        }
                        argSym.invalidate();
                        cxt = context.popContextualType();
                        hadProvisionalErrors = cxt.hadProvisionalErrors();

                        //argSym.invalidate();

                        //this.resetProvisionalErrors();
                        if (miss) {
                            break;
                        }
                    }
                    else if (args.members[j].nodeType == NodeType.ArrayLit) {
                        // attempt to contextually type the array literal
                        if (this.cachedArrayInterfaceType && memberType == this.cachedArrayInterfaceType) {
                            continue;
                        }

                        context.pushContextualType(memberType, true, null);
                        argSym = this.resolveArrayLiteralExpression(args.members[j], true, enclosingDecl, context);

                        if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage("Could not apply type '" + memberType.toString() + "' to argument " + (j + 1) + ", which is of type '" + argSym.getTypeName() + "'");
                            }
                            break;
                        }
                        argSym.invalidate();
                        cxt = context.popContextualType();

                        hadProvisionalErrors = cxt.hadProvisionalErrors();

                        //argSym.invalidate();

                        if (miss) {
                            break;
                        }
                    }
                }

                if (j == args.members.length) {
                    applicableSigs[applicableSigs.length] = { signature: candidateSignatures[i], hadProvisionalErrors: hadProvisionalErrors };
                }
                hadProvisionalErrors = false;
            }

            return applicableSigs;
        }

        public findMostApplicableSignature(signatures: PullApplicableSignature[], args: ASTList, enclosingDecl: PullDecl, context: PullTypeResolutionContext): { sig: PullSignatureSymbol; ambiguous: bool; } {

            if (signatures.length == 1) {
                return { sig: signatures[0].signature, ambiguous: false };
            }

            var best: PullApplicableSignature = signatures[0];
            var Q: PullApplicableSignature = null;

            var AType: PullTypeSymbol = null;
            var PType: PullTypeSymbol = null;
            var QType: PullTypeSymbol = null;

            var ambiguous = false;

            var argSym: PullSymbol;

            var bestParams: PullSymbol[];
            var qParams: PullSymbol[];

            for (var qSig = 1; qSig < signatures.length; qSig++) {
                Q = signatures[qSig];
                var i = 0;

                // find the better conversion
                for (i = 0; args && i < args.members.length; i++) {

                    argSym = this.resolveStatementOrExpression(args.members[i], false, enclosingDecl, context);

                    AType = argSym.getType();

                    // invalidate the argument so that we may correctly resolve it later as part of the call expression
                    argSym.invalidate();

                    bestParams = best.signature.getParameters();
                    qParams = Q.signature.getParameters();

                    PType = i < bestParams.length ? bestParams[i].getType() : bestParams[bestParams.length - 1].getType().getElementType();
                    QType = i < qParams.length ? qParams[i].getType() : qParams[qParams.length - 1].getType().getElementType();

                    if (this.typesAreIdentical(PType, QType)) {
                        continue;
                    }
                    else if (this.typesAreIdentical(AType, PType)) {
                        break;
                    }
                    else if (this.typesAreIdentical(AType, QType)) {
                        best = Q;
                        break;
                    }
                    else if (this.sourceIsSubtypeOfTarget(PType, QType, context)) {
                        break;
                    }
                    else if (this.sourceIsSubtypeOfTarget(QType, PType, context)) {
                        best = Q;
                        break;
                    }
                    else if (Q.hadProvisionalErrors) {
                        break;
                    }
                    else if (best.hadProvisionalErrors) {
                        best = Q;
                        break;
                    }
                }

                if (!args || i == args.members.length) {
                    var collection: IPullTypeCollection = {
                        getLength: () => { return 2; },
                        setTypeAtIndex: (index: number, type: PullTypeSymbol) => { }, // no contextual typing here, so no need to do anything
                        getTypeAtIndex: (index: number) => { return index ? Q.signature.getReturnType() : best.signature.getReturnType(); } // we only want the "second" type - the "first" is skipped
                    }
                    var bct = this.findBestCommonType(best.signature.getReturnType(), null, collection, false, context);
                    ambiguous = !bct;
                }
                else {
                    ambiguous = false;
                }
            }

            return { sig: best.signature, ambiguous: ambiguous };
        }

        public canApplyContextualTypeToFunction(candidateType: PullTypeSymbol, funcDecl: FuncDecl, beStringent: bool): bool {

            // in these cases, we do not attempt to apply a contextual type
            //  RE: isInlineCallLiteral - if the call target is a function literal, we don't want to apply the target type
            //  to its body - instead, it should be applied to its return type
            if (funcDecl.isParenthesized ||
                funcDecl.isMethod() ||
                beStringent && funcDecl.returnTypeAnnotation ||
                funcDecl.isInlineCallLiteral) {
                return false;
            }

            beStringent = beStringent || (this.cachedFunctionInterfaceType == candidateType);

            // At this point, if we're not being stringent, there's no need to check for multiple call sigs
            // or count parameters - we just want to unblock typecheck
            if (!beStringent) {
                return true;
            }

            var signature = this.getSymbolForAST(funcDecl).getType().getCallSignatures()[0];
            var parameters = signature.getParameters();
            var paramLen = parameters.length;

            // Check that the argument declarations have no type annotations
            for (var i = 0; i < paramLen; i++) {
                var param = parameters[i];
                var argDecl = <ArgDecl>this.getASTForSymbol(param);

                // REVIEW: a valid typeExpr is a requirement for varargs,
                // so we may want to revise our invariant
                if (beStringent && argDecl.typeExpr) {
                    return false;
                }
            }

            if (candidateType.getConstructSignatures().length && candidateType.getCallSignatures().length) {
                return false;
            }

            var candidateSigs = candidateType.getConstructSignatures().length ? candidateType.getConstructSignatures() : candidateType.getCallSignatures();

            if (!candidateSigs || candidateSigs.length > 1) {
                return false;
            }

            // if we're here, the contextual type can be applied to the function
            return true;
        }

        public inferArgumentTypesForSignature(signature: PullSignatureSymbol,
                                              args: ASTList,
                                              comparisonInfo: TypeComparisonInfo,
                                              enclosingDecl: PullDecl,
                                              context: PullTypeResolutionContext): PullTypeSymbol[] {

            var cxt: PullContextualTypeContext = null;
            var hadProvisionalErrors = false;

            var argSym: PullSymbol;

            var parameters = signature.getParameters();
            var typeParameters = signature.getTypeParameters();
            var argContext = new ArgumentInferenceContext();

            var parameterType: PullTypeSymbol = null;

            var i = 0;

            // seed each type parameter with the undefined type, so that we can widen it to 'any'
            // if no inferences can be made
            for (i = 0; i < typeParameters.length; i++) {
                argContext.addCandidateForInference(typeParameters[i], null, false);
            }

            var substitutions: any;
            var inferenceCandidates: PullTypeSymbol[];
            var inferenceCandidate: PullTypeSymbol;

            for (i = 0; i < args.members.length; i++) {

                if (i >= parameters.length) {
                    break;
                }

                parameterType = parameters[i].getType();

                // account for varargs
                if (signature.hasVariableParamList() && (i >= signature.getNonOptionalParameterCount() - 1) && parameterType.isArray()) {
                    parameterType = parameterType.getElementType();
                }

                inferenceCandidates = argContext.getInferenceCandidates();
                substitutions = {};

                if (inferenceCandidates.length) {
                    for (var j = 0; j < inferenceCandidates.length; j++) {

                        inferenceCandidate = inferenceCandidates[j];

                        substitutions = inferenceCandidates[j];

                        context.pushContextualType(parameterType, true, substitutions);
                        argSym = this.resolveStatementOrExpression(args.members[i], true, enclosingDecl, context);

                        this.relateTypeToTypeParameters(argSym.getType(), parameterType, false, argContext, enclosingDecl, context);

                        cxt = context.popContextualType();

                        argSym.invalidate();

                        hadProvisionalErrors = cxt.hadProvisionalErrors();
                    }
                }
                else {
                    context.pushContextualType(parameterType, true, {});
                    argSym = this.resolveStatementOrExpression(args.members[i], true, enclosingDecl, context);

                    this.relateTypeToTypeParameters(argSym.getType(), parameterType, false, argContext, enclosingDecl, context);

                    cxt = context.popContextualType();

                    argSym.invalidate();

                    hadProvisionalErrors = cxt.hadProvisionalErrors();
                }
            }

            hadProvisionalErrors = false;

            var inferenceResults = argContext.inferArgumentTypes(this, context);


            if (inferenceResults.unfit) {
                return null;
            }

            var resultTypes: PullTypeSymbol[] = [];

            for (i = 0; i < inferenceResults.results.length; i++) {
                resultTypes[resultTypes.length] = inferenceResults.results[i].type;
            }

            return resultTypes;
        }

        public relateTypeToTypeParameters(expressionType: PullTypeSymbol,
                                          parameterType: PullTypeSymbol,
                                          shouldFix: bool,
                                          argContext: ArgumentInferenceContext,
                                          enclosingDecl: PullDecl,
                                          context: PullTypeResolutionContext): void {

            if (parameterType == expressionType) {
                return;
            }

            if (parameterType.isTypeParameter()) {
                argContext.addCandidateForInference(<PullTypeParameterSymbol>parameterType, expressionType, shouldFix);
                return;
            }

            // if the expression and parameter type, with type arguments of 'any', are not assignment compatible, ignore
            var anyExpressionType = this.specializeTypeToAny(expressionType, enclosingDecl, context);
            var anyParameterType = this.specializeTypeToAny(parameterType, enclosingDecl, context);

            if (!this.sourceIsAssignableToTarget(anyExpressionType, anyParameterType, context)) {
                return;
            }

            if (expressionType.isArray() && parameterType.isArray()) {
                this.relateArrayTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);

                return;
            }

            this.relateObjectTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);
        }

        public relateFunctionSignatureToTypeParameters(expressionSignature: PullSignatureSymbol,
                                                       parameterSignature: PullSignatureSymbol,
                                                       argContext: ArgumentInferenceContext,
                                                       enclosingDecl: PullDecl,
                                                       context: PullTypeResolutionContext): void {
            // Sub in 'any' for type parameters

            var anyExpressionSignature = this.specializeSignatureToAny(expressionSignature, enclosingDecl, context);
            var anyParamExpressionSignature = this.specializeSignatureToAny(parameterSignature, enclosingDecl, context);

            if (!this.signatureIsAssignableToTarget(anyExpressionSignature, anyParamExpressionSignature, context)) {
                return;
            }

            var expressionParams = expressionSignature.getParameters();
            var expressionReturnType = expressionSignature.getReturnType();

            var parameterParams = parameterSignature.getParameters();
            var parameterReturnType = parameterSignature.getReturnType();

            var len = parameterParams.length < expressionParams.length ? parameterParams.length : expressionParams.length;

            for (var i = 0; i < len; i++) {
                this.relateTypeToTypeParameters(expressionParams[i].getType(), parameterParams[i].getType(), true, argContext, enclosingDecl, context);
            }

            this.relateTypeToTypeParameters(expressionReturnType, parameterReturnType, true, argContext, enclosingDecl, context);
        }

        public relateObjectTypeToTypeParameters(objectType: PullTypeSymbol,
                                                parameterType: PullTypeSymbol,
                                                shouldFix: bool,
                                                argContext: ArgumentInferenceContext,
                                                enclosingDecl: PullDecl,
                                                context: PullTypeResolutionContext): void {

            var parameterTypeMembers = parameterType.getMembers();
            var parameterSignatures: PullSignatureSymbol[];
            var parameterSignature: PullSignatureSymbol;

            var objectMember: PullSymbol;
            var objectSignatures: PullSignatureSymbol[];


            if (argContext.alreadyRelatingTypes(objectType, parameterType)) {
                return;
            }

            var i = 0;
            var j = 0;

            var objectTypeArguments = objectType.getTypeArguments();
            var parameterTypeParameters = parameterType.getTypeParameters();

            if (objectTypeArguments && (objectTypeArguments.length == parameterTypeParameters.length)) {
                for (i = 0; i < objectTypeArguments.length; i++) {
                    argContext.addCandidateForInference(parameterTypeParameters[i], objectTypeArguments[i], shouldFix);
                }
            }

            for (i = 0; i < parameterTypeMembers.length; i++) {
                objectMember = objectType.findMember(parameterTypeMembers[i].getName());

                if (objectMember) {
                    this.relateTypeToTypeParameters(objectMember.getType(), parameterTypeMembers[i].getType(), shouldFix, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getCallSignatures();
            objectSignatures = objectType.getCallSignatures();

            for (i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getConstructSignatures();
            objectSignatures = objectType.getConstructSignatures();

            for (i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getIndexSignatures();
            objectSignatures = objectType.getIndexSignatures();

            for (i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }
        }

        public relateArrayTypeToTypeParameters(argArrayType: PullTypeSymbol,
                                               parameterArrayType: PullTypeSymbol,
                                               shouldFix: bool,
                                               argContext: ArgumentInferenceContext,
                                               enclosingDecl: PullDecl,
                                               context: PullTypeResolutionContext): void {

            var argElement = argArrayType.getElementType();
            var paramElement = parameterArrayType.getElementType();

            this.relateTypeToTypeParameters(argElement, paramElement, shouldFix, argContext, enclosingDecl, context);
        }

        public specializeTypeToAny(typeToSpecialize: PullTypeSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullTypeSymbol {
            var prevSpecialize = context.specializingToAny;

            context.specializingToAny = true;
            var type = specializeType(typeToSpecialize, [], this, enclosingDecl, context);
            context.specializingToAny = prevSpecialize;

            return type;
        }

        public specializeSignatureToAny(signatureToSpecialize: PullSignatureSymbol, enclosingDecl: PullDecl, context: PullTypeResolutionContext): PullSignatureSymbol {
            var typeParameters = signatureToSpecialize.getTypeParameters();
            var typeReplacementMap: any = {};
            var typeArguments: PullTypeSymbol[] = []; // PULLTODO - may be expensive, but easy to cache

            for (var i = 0; i < typeParameters.length; i++) {
                typeArguments[i] = this.semanticInfoChain.anyTypeSymbol;
                typeReplacementMap[typeParameters[i].getSymbolID().toString()] = typeArguments[i];
            }
            if (!typeArguments.length) {
                typeArguments[0] = this.semanticInfoChain.anyTypeSymbol;
            }

            // no need to worry about returning 'null', since 'any' satisfies all constraints
            return specializeSignature(signatureToSpecialize, false, typeReplacementMap, typeArguments, this, enclosingDecl, context);
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {

    export class PullTypeCheckContext {
        public enclosingDeclStack: PullDecl[] = [];
        public enclosingDeclReturnStack: bool[] = [];
        public semanticInfo: SemanticInfo = null;

        constructor(public compiler: TypeScriptCompiler, public script: Script, public scriptName: string) { }

        public pushEnclosingDecl(decl: PullDecl) {
            this.enclosingDeclStack[this.enclosingDeclStack.length] = decl;
            this.enclosingDeclReturnStack[this.enclosingDeclReturnStack.length] = false;
        }

        public popEnclosingDecl() {
            this.enclosingDeclStack.length--;
            this.enclosingDeclReturnStack.length--;
        }

        public getEnclosingDecl() {
            if (this.enclosingDeclStack.length) {
                return this.enclosingDeclStack[this.enclosingDeclStack.length - 1];
            }

            return null;
        }

        public getEnclosingDeclHasReturn() {
            return this.enclosingDeclReturnStack[this.enclosingDeclReturnStack.length - 1];
        }
        public setEnclosingDeclHasReturn() {
            return this.enclosingDeclReturnStack[this.enclosingDeclReturnStack.length - 1] = true;
        }        
    }

    export class PullTypeChecker {

        static globalPullTypeCheckPhase = 0;
        
        public resolver: PullTypeResolver = null;

        public context: PullTypeResolutionContext = new PullTypeResolutionContext();

        constructor(private compilationSettings: CompilationSettings,
                    public semanticInfoChain: SemanticInfoChain) { }

        public setUnit(unitPath: string) {
            this.resolver = new PullTypeResolver(this.compilationSettings, this.semanticInfoChain, unitPath);
        }

        public getScriptDecl(fileName: string): PullDecl {
            return this.semanticInfoChain.getUnit(fileName).getTopLevelDecls()[0];
        }

        // declarations

        public typeCheckAST(ast: AST, typeCheckContext: PullTypeCheckContext, inTypedAssignment=false): PullTypeSymbol {

            if (!ast) {
                return null;
            }

            if (ast.typeCheckPhase >= PullTypeChecker.globalPullTypeCheckPhase) {
                return null;
            }
            else {
                ast.typeCheckPhase = PullTypeChecker.globalPullTypeCheckPhase;
            }
           
            switch (ast.nodeType) {

                // lists
                case NodeType.List:
                    return this.typeCheckList(ast, typeCheckContext);

                // decarations

                case NodeType.VarDecl:
                case NodeType.ArgDecl:
                    return this.typeCheckBoundDecl(ast, typeCheckContext);

                case NodeType.FuncDecl:
                    return this.typeCheckFunction(ast, typeCheckContext, inTypedAssignment);

                case NodeType.ClassDeclaration:
                    return this.typeCheckClass(ast, typeCheckContext);

                case NodeType.InterfaceDeclaration:
                    return this.typeCheckInterface(ast, typeCheckContext);

                case NodeType.ModuleDeclaration:
                    return this.typeCheckModule(ast, typeCheckContext);

                // expressions

                // assignment
                case NodeType.Asg:
                    return this.typeCheckAssignment(ast, typeCheckContext);

                case GenericType:
                    return this.typeCheckGenericType(ast, typeCheckContext);

                case NodeType.ObjectLit:
                    return this.typeCheckObjectLiteral(ast, typeCheckContext, inTypedAssignment);

                case NodeType.ArrayLit:
                    return this.typeCheckArrayLiteral(ast, typeCheckContext, inTypedAssignment);

                case NodeType.This:
                    return this.typeCheckThis(ast, typeCheckContext);

                case NodeType.Super:
                    return this.typeCheckSuper(ast, typeCheckContext);

                case NodeType.Call:
                    return this.typeCheckCall(ast, typeCheckContext);

                case NodeType.New:
                    return this.typeCheckNew(ast, typeCheckContext);

                case NodeType.TypeAssertion:
                    return this.typeCheckTypeAssertion(ast, typeCheckContext);

                case NodeType.TypeRef:
                    return this.typeCheckTypeReference(ast, typeCheckContext);

                // boolean operations
                case NodeType.Ne:
                case NodeType.Eq:
                case NodeType.Eqv:
                case NodeType.NEqv:
                case NodeType.Lt:
                case NodeType.Le:
                case NodeType.Ge:
                case NodeType.Gt:
                    return this.typeCheckLogicalOperation(ast, typeCheckContext);

                case NodeType.Add:
                case NodeType.Sub:
                case NodeType.Mul:
                case NodeType.Div:
                case NodeType.Mod:
                case NodeType.Or:
                case NodeType.And:
                case NodeType.AsgAdd:
                case NodeType.AsgSub:
                case NodeType.AsgMul:
                case NodeType.AsgDiv:
                case NodeType.AsgMod:
                case NodeType.AsgOr:
                case NodeType.AsgAnd:
                    return this.typeCheckBinaryArithmeticOperation(ast, typeCheckContext);

                case NodeType.Not:
                case NodeType.LogNot:
                case NodeType.Pos:
                case NodeType.Neg:
                case NodeType.IncPost:
                case NodeType.IncPre:
                case NodeType.DecPost:
                case NodeType.DecPre:
                    return this.typeCheckUnaryArithmeticOperation(ast, typeCheckContext);

                case NodeType.Lsh:
                case NodeType.Rsh:
                case NodeType.Rs2:
                case NodeType.AsgLsh:
                case NodeType.AsgRsh:
                case NodeType.AsgRs2:
                    return this.typeCheckBitwiseOperation(ast, typeCheckContext);

                case NodeType.Index:
                    return this.typeCheckIndex(ast, typeCheckContext);

                case NodeType.LogOr:
                case NodeType.LogAnd:
                    return this.typeCheckLogicalAndOrExpression(ast, typeCheckContext);

                case NodeType.Typeof:
                    return this.typeCheckTypeOf(ast, typeCheckContext);

                case NodeType.ConditionalExpression:
                    return this.typeCheckConditionalExpression(ast, typeCheckContext);

                case NodeType.Void:
                    return this.typeCheckVoidExpression(ast, typeCheckContext);

                case NodeType.Throw:
                    return this.typeCheckThrowExpression(ast, typeCheckContext);

                case NodeType.Delete:
                    return this.typeCheckDeleteExpression(ast, typeCheckContext);

                case NodeType.Regex:
                    return this.typeCheckRegExpExpression(ast, typeCheckContext);

                // statements
                case NodeType.For:
                    return this.typeCheckForStatement(ast, typeCheckContext);

                case NodeType.ForIn:
                    return this.typeCheckForInStatement(ast, typeCheckContext);

                case NodeType.While:
                    return this.typeCheckWhileStatement(ast, typeCheckContext);

                case NodeType.DoWhile:
                    return this.typeCheckDoWhileStatement(ast, typeCheckContext);

                case NodeType.If:
                    return this.typeCheckIfStatement(ast, typeCheckContext);

                case NodeType.Block:
                    return this.typeCheckBlockStatement(ast, typeCheckContext);

                case NodeType.With:
                    return this.typeCheckWithStatement(ast, typeCheckContext);

                case NodeType.TryFinally:
                    return this.typeCheckTryFinallyStatement(ast, typeCheckContext);

                case NodeType.TryCatch:
                    return this.typeCheckTryCatchStatement(ast, typeCheckContext);

                case NodeType.Try:
                    return this.typeCheckTryBlock(ast, typeCheckContext);

                case NodeType.Catch:
                    return this.typeCheckCatchBlock(ast, typeCheckContext);

                case NodeType.Finally:
                    return this.typeCheckFinallyBlock(ast, typeCheckContext);

                case NodeType.Return:
                    return this.typeCheckReturnExpression(ast, typeCheckContext);

                case NodeType.Name:
                    return this.typeCheckNameExpression(ast, typeCheckContext);

                case NodeType.Dot:
                    return this.typeCheckDottedNameExpression(ast, typeCheckContext);

                case NodeType.Switch:
                    return this.typeCheckSwitchStatement(ast, typeCheckContext);

                case NodeType.Case:
                    return this.typeCheckCaseStatement(ast, typeCheckContext);

                // primitives
                case NodeType.NumberLit:
                    return this.semanticInfoChain.numberTypeSymbol;
                case NodeType.QString:
                    return this.semanticInfoChain.stringTypeSymbol;
                case NodeType.Null:
                    return this.semanticInfoChain.nullTypeSymbol;
                case NodeType.True:
                case NodeType.False:
                    return this.semanticInfoChain.boolTypeSymbol;
                case NodeType.Void:
                    return this.semanticInfoChain.voidTypeSymbol;

                default:
                    break;
            }

            return null;
        }

        //
        // Validation
        //

        // scripts
        public typeCheckScript(script: Script, scriptName: string, compiler: TypeScriptCompiler) {
            var typeCheckContext = new PullTypeCheckContext(compiler, script, scriptName);

            this.setUnit(scriptName);
            
            typeCheckContext.semanticInfo = typeCheckContext.compiler.semanticInfoChain.getUnit(typeCheckContext.scriptName);
            var scriptDecl = typeCheckContext.semanticInfo.getTopLevelDecls()[0];
            typeCheckContext.pushEnclosingDecl(scriptDecl);

            PullTypeChecker.globalPullTypeCheckPhase++;

            if (script.bod.members) {
                for (var i = 0; i < script.bod.members.length; i++) {
                    this.typeCheckAST(script.bod.members[i], typeCheckContext);
                }
            }

            typeCheckContext.popEnclosingDecl();
        }

        // lists
        public typeCheckList(ast: AST, typeCheckContext: PullTypeCheckContext) {
            var list = <ASTList>ast;

            if (!list) {
                return null;
            }

            for (var i = 0; i < list.members.length; i++) {
                this.typeCheckAST(list.members[i], typeCheckContext);
            }
        }

        // variable and argument declarations
        // validate:
        //  - lhs and rhs types agree (if lhs has no type annotation)
        public typeCheckBoundDecl(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var boundDeclAST = <BoundDecl>ast;

            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var varTypeSymbol = this.resolver.resolveAST(boundDeclAST, false, enclosingDecl, this.context).getType();

            // if there's a type expr and an initializer, resolve the initializer
            if (boundDeclAST.init) {
                this.context.pushContextualType(varTypeSymbol, this.context.inProvisionalResolution(), null);
                //var initTypeSymbol = this.resolver.resolveAST(boundDeclAST.init, true, enclosingDecl, this.context).getType();
                var initTypeSymbol = this.typeCheckAST(boundDeclAST.init, typeCheckContext, true);
                this.context.popContextualType();
                
                //getAstWalkerFactory().walk(boundDeclAST.init, prePullTypeCheck, postPullTypeCheck, null, typeCheckContext);

                var comparisonInfo = new TypeComparisonInfo();

                var isAssignable = this.resolver.sourceIsAssignableToTarget(initTypeSymbol, varTypeSymbol, this.context, comparisonInfo);

                if (!isAssignable) {
                    var errorMessage = comparisonInfo.message;

                    // ignore comparison info for now
                    var message = getDiagnosticMessage(PullDiagnosticMessages.incompatibleTypes_2, [initTypeSymbol.toString(), varTypeSymbol.toString()]);

                    this.context.postError(boundDeclAST.minChar, boundDeclAST.getLength(), typeCheckContext.scriptName, message, enclosingDecl);
                }
            }

            return varTypeSymbol;
        }         

        // functions 
        // validate:
        //  - use of super calls 
        //  - signatures agree in optionality
        //  - getter/setter type agreement
        //  - body members expr
        //  - getter/setter flags agree
        //  - getters have no parameters 
        //  - getters return a value
        //  - setters return no value
        // PULLTODO: split up into separate functions for constructors, indexers, expressions, signatures, etc.
        public typeCheckFunction(ast: AST, typeCheckContext: PullTypeCheckContext, inTypedAssignment = false): PullTypeSymbol {

            var funcDeclAST = <FuncDecl>ast;

            if (funcDeclAST.isConstructor || hasFlag(funcDeclAST.fncFlags, FncFlags.ConstructMember)) {
                return this.typeCheckConstructor(ast, typeCheckContext, inTypedAssignment);
            }
            else if (hasFlag(funcDeclAST.fncFlags, FncFlags.IndexerMember)) {
                return this.typeCheckIndexer(ast, typeCheckContext, inTypedAssignment);
            }
            else if (funcDeclAST.isAccessor()) {
                return this.typeCheckAccessor(ast, typeCheckContext, inTypedAssignment);
            }

            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var functionSymbol = this.resolver.resolveAST(ast, inTypedAssignment, enclosingDecl, this.context);

            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);

            typeCheckContext.pushEnclosingDecl(functionDecl);

            this.typeCheckAST(funcDeclAST.bod, typeCheckContext);
            var hasReturn = typeCheckContext.getEnclosingDeclHasReturn();
            typeCheckContext.popEnclosingDecl();

            var functionSignature = functionDecl.getSignatureSymbol();

            // check for optionality
            var parameters = functionSignature.getParameters();

            if (parameters.length) {
                var lastWasOptional = false;

                for (var i = 0; i < parameters.length; i++) {

                    if (parameters[i].getIsOptional()) {
                        lastWasOptional = true;
                    }
                    else if (lastWasOptional) {
                        this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Optional parameters may only be followed by other optional parameters", typeCheckContext.getEnclosingDecl());
                    }

                }
            } 

            if (funcDeclAST.bod && funcDeclAST.returnTypeAnnotation != null && !hasReturn) {
                var returnType = functionSignature.getReturnType();
                var isVoidOrAny = returnType == this.semanticInfoChain.anyTypeSymbol || returnType == this.semanticInfoChain.voidTypeSymbol;
                
                if (!isVoidOrAny && !(funcDeclAST.bod.members.length > 0 && funcDeclAST.bod.members[0].nodeType === NodeType.Throw)) {
                    var funcName = functionDecl.getName();
                    funcName = funcName ? "'" + funcName + "'" : "expression";
                    this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Function "+ funcName +" declared a non-void return type, but has no return expression", typeCheckContext.getEnclosingDecl());
                }
            }            

            return functionSymbol ? functionSymbol.getType() : null;
        }

        public typeCheckAccessor(ast: AST, typeCheckContext: PullTypeCheckContext, inTypedAssignment = false): PullTypeSymbol {
            var funcDeclAST = <FuncDecl>ast;            

            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var accessorSymbol = <PullAccessorSymbol>this.resolver.resolveAST(ast, inTypedAssignment, enclosingDecl, this.context);

            var isGetter = hasFlag(funcDeclAST.fncFlags, FncFlags.GetAccessor);
            var isSetter = !isGetter;

            var getter = accessorSymbol.getGetter();
            var setter = accessorSymbol.getSetter();

            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);

            typeCheckContext.pushEnclosingDecl(functionDecl);

            this.typeCheckAST(funcDeclAST.bod, typeCheckContext);
            var hasReturn = typeCheckContext.getEnclosingDeclHasReturn();
            typeCheckContext.popEnclosingDecl();

            var functionSignature = functionDecl.getSignatureSymbol();

            // check for optionality
            var parameters = functionSignature.getParameters();

            if (parameters.length) {

                if (isGetter) {
                    this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Getters may not take arguments", typeCheckContext.getEnclosingDecl());''
                }
                else {
                    
                    if (parameters.length > 1) {
                        this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Setters may have one and only one argument", typeCheckContext.getEnclosingDecl());''
                    }

                    for (var i = 0; i < parameters.length; i++) {
                        if (parameters[i].getIsOptional()) {
                            this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Setters may not take optional parameters", typeCheckContext.getEnclosingDecl());
                            break;
                        }
                    }
                }
            }

            // PULLREVIEW: Should we also raise an error if the setter returns a value?
            if (isGetter && !hasReturn) {
                if (!(funcDeclAST.bod.members.length > 0 && funcDeclAST.bod.members[0].nodeType === NodeType.Throw)) {
                    this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Getters must return a value", typeCheckContext.getEnclosingDecl());
                }
            }
            else if (isSetter && hasReturn) {
                this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Setters may not return a value", typeCheckContext.getEnclosingDecl());
            }

            if (getter && setter) {
                var getterDecl = getter.getDeclarations()[0];
                var setterDecl = setter.getDeclarations()[0];

                var getterIsPrivate = getterDecl.getFlags() & PullElementFlags.Private;
                var setterIsPrivate = setterDecl.getFlags() & PullElementFlags.Private;

                if (getterIsPrivate != setterIsPrivate) {
                    this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Getter and setter accessors do not agree in visibility", typeCheckContext.getEnclosingDecl());
                }
            }

            return accessorSymbol;
        }

        public typeCheckConstructor(ast: AST, typeCheckContext: PullTypeCheckContext, inTypedAssignment = false): PullTypeSymbol {

            // PULLTODOERROR: "Calls to 'super' constructor are not allowed in classes that either inherit directly from 'Object' or have no base class"
            // PULLTODOERROR: "If a derived class contains initialized properties or constructor parameter properties, the first statement in the constructor body must be a call to the super constructor"
            // PULLTODOERROR: "Constructors for derived classes must contain a call to the class's 'super' constructor"            

            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var functionSymbol = this.resolver.resolveAST(ast, inTypedAssignment, enclosingDecl, this.context);

            var funcDeclAST = <FuncDecl>ast;

            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);

            typeCheckContext.pushEnclosingDecl(functionDecl);

            this.typeCheckAST(funcDeclAST.bod, typeCheckContext);

            typeCheckContext.popEnclosingDecl();

            var constructorSignature = functionDecl.getSignatureSymbol();

            // check for optionality
            var parameters = constructorSignature.getParameters();

            if (parameters.length) {
                var lastWasOptional = false;

                for (var i = 0; i < parameters.length; i++) {

                    if (parameters[i].getIsOptional()) {
                        lastWasOptional = true;
                    }
                    else if (lastWasOptional) {
                        this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Optional parameters may only be followed by other optional parameters", typeCheckContext.getEnclosingDecl());
                    }

                }
            } 

            return functionSymbol ? functionSymbol.getType() : null;
        }

        public typeCheckIndexer(ast: AST, typeCheckContext: PullTypeCheckContext, inTypedAssignment = false): PullTypeSymbol {
        
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            // resolve the index signature, even though we won't be needing its type
            this.resolver.resolveAST(ast, inTypedAssignment, enclosingDecl, this.context);

            var funcDeclAST = <FuncDecl>ast;

            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);

            typeCheckContext.pushEnclosingDecl(functionDecl);

            this.typeCheckAST(funcDeclAST.bod, typeCheckContext);

            typeCheckContext.popEnclosingDecl();

            var indexSignature = functionDecl.getSignatureSymbol();
            var parameters = indexSignature.getParameters();

            if (parameters.length) {

                if (parameters.length > 1) {
                    this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Index signatures may take one and only one parameter", typeCheckContext.getEnclosingDecl());
                }

                var parameterType: PullTypeSymbol = null;

                for (var i = 0; i < parameters.length; i++) {

                    if (parameters[i].getIsOptional() || parameters[i].getIsVarArg()) {
                        this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Index signatures may not have optional parameters", typeCheckContext.getEnclosingDecl());
                    }

                    parameterType = parameters[i].getType();

                    if (parameterType != this.semanticInfoChain.stringTypeSymbol && parameterType != this.semanticInfoChain.numberTypeSymbol) {
                        this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Index signatures may not have optional parameters", typeCheckContext.getEnclosingDecl());
                    }
                }
            }
            else {
                this.context.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, "Index signatures may take one and only one parameter", typeCheckContext.getEnclosingDecl());
            }

            return null;
        }

        // Classes
        // validate:
        //  - mutually recursive base classes
        //  - duplicate implemented interfaces
        //  - mutually recursive type parameters
        //  - bases are interfaces or classes
        //  - properties satisfy implemented interfaces
        //  - properties of base class and implemented interfaces agree
        //  - type of overridden member is subtype of original
        //  - method does not overrided field, or vice-versa
        //  - body members
        public typeCheckClass(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var classAST = <ClassDeclaration>ast;
            // resolving the class also resolves its members...
            var classSymbol = <PullClassTypeSymbol>this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
            
            if (classAST.members) {
                for (var i = 0; i < classAST.members.members.length; i++) {
                    this.typeCheckAST(classAST.members.members[i], typeCheckContext);
                }
            }
            
            return classSymbol;
        }

        // Interfaces
        // validate:
        //  - mutually recursive bases
        //  - duplicate implemented or extended interfaces
        //  - mutually recursive type parameters
        //  - properties of extended interfaces do not conflict
        //  - bases are interfaces or classes
        //  - declarations agree in generic parameters 
        public typeCheckInterface(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var interfaceAST = <InterfaceDeclaration>ast;
            // resolving the interface also resolves its members...
            var interfaceType = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();

            if (interfaceAST.members) {
                for (var i = 0; i < interfaceAST.members.members.length; i++) {
                    this.typeCheckAST(interfaceAST.members.members[i], typeCheckContext);
                }
            }

            return interfaceType;
        }

        // Modules
        // validate:
        //  - No type parameters?
        public typeCheckModule(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {

            // we resolve here because resolving a module *does not* resolve its MemberScopeContext
            // PULLREVIEW: Perhaps it should?
            var moduleDeclAST = <ModuleDeclaration>ast;
            this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context);

            var moduleDecl = typeCheckContext.semanticInfo.getDeclForAST(moduleDeclAST);
            typeCheckContext.pushEnclosingDecl(moduleDecl);

            if (moduleDeclAST.members) {
                this.typeCheckAST(moduleDeclAST.members, typeCheckContext);
            }

            typeCheckContext.popEnclosingDecl();

            return moduleDecl.getSymbol().getType();
        }

        // expressions

        // Assignment
        // validate:
        //  - lhs and rhs types agree
        //  - lhs is a valid value type
        public typeCheckAssignment(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var assignmentAST = <BinaryExpression>ast;

            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var leftType = this.typeCheckAST(assignmentAST.operand1, typeCheckContext);

            this.context.pushContextualType(leftType, this.context.inProvisionalResolution(), null);
            var rightType = this.typeCheckAST(assignmentAST.operand2, typeCheckContext, true);
            this.context.popContextualType();

            var comparisonInfo = new TypeComparisonInfo();

            var isAssignable = this.resolver.sourceIsAssignableToTarget(rightType, leftType, this.context, comparisonInfo);

            if (!isAssignable) {
                var errorMessage = comparisonInfo.message;
                var span = enclosingDecl.getSpan();

                // ignore comparison info for now
                var message = getDiagnosticMessage(PullDiagnosticMessages.incompatibleTypes_2, [rightType.toString(), leftType.toString()]);

                this.context.postError(assignmentAST.operand1.minChar, span.length(), typeCheckContext.scriptName, message, enclosingDecl);
            }

            return leftType;
        }

        // Generic Type references
        // validate:
        //
        public typeCheckGenericType(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            // validate:
            //  - mutually recursive type parameters and constraints
            return this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
        }

        // Object literals
        // validate:
        //
        public typeCheckObjectLiteral(ast: AST, typeCheckContext: PullTypeCheckContext, inTypedAssignment = false): PullTypeSymbol {
            var objectLitAST = <UnaryExpression>ast;

            // PULLTODO: We're really resolving these expressions twice - need a better way...
            var objectLitType = this.resolver.resolveAST(ast, inTypedAssignment, typeCheckContext.getEnclosingDecl(), this.context).getType();
            var memberDecls = <ASTList>objectLitAST.operand;

            var contextualType = this.context.getContextualType();

            // PULLTODO: Contextually type the members
            if (memberDecls) {
                var binex: BinaryExpression;
                var text: string;
                var member: PullSymbol = null;

                for (var i = 0; i < memberDecls.members.length; i++) {
                    binex = <BinaryExpression>memberDecls.members[i];

                    if (contextualType) {
                        if (binex.operand1.nodeType == NodeType.Name) {
                            text = (<Identifier>binex.operand1).text;
                        }
                        else if (binex.operand1.nodeType == NodeType.QString) {
                            text = (<StringLiteral>binex.operand1).text;
                            text = text.substring(1, text.length - 1);
                        }

                        member = contextualType.findMember(text);

                        if (member) {
                            this.context.pushContextualType(member.getType(), this.context.inProvisionalResolution(), null);
                        }
                    }

                    this.typeCheckAST(binex.operand2, typeCheckContext, member != null);

                    if (member) {
                        this.context.popContextualType();
                        member = null;
                    }
                }
            }


            return objectLitType;
        }

        // Array literals
        // validate:
        //  - incompatible types in expression
        public typeCheckArrayLiteral(ast: AST, typeCheckContext: PullTypeCheckContext, inTypedAssignment = false): PullTypeSymbol {
            return this.resolver.resolveAST(ast, inTypedAssignment, typeCheckContext.getEnclosingDecl(), this.context).getType();
        }

        // 'This' expressions 
        // validate:
        //
        public typeCheckThis(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            return this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
        }

        // 'Super' expressions 
        // validate:
        //
        public typeCheckSuper(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            return this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
        }

        // Call expressions 
        // validate:
        //
        public typeCheckCall(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            // "use of new expression as a statement"
            var callEx = <CallExpression>ast;
            var resultType = this.resolver.resolveAST(callEx, false, typeCheckContext.getEnclosingDecl(), this.context).getType();


            var args = callEx.arguments;

            if (args) {
                for (var i = 0; i < args.members.length; i++) {
                    this.typeCheckAST(args.members[i], typeCheckContext);
                }
            }

            return resultType;
        }

        // 'New' expressions 
        // validate:
        //
        public typeCheckNew(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var callEx = <CallExpression>ast;
            var resultType = this.resolver.resolveAST(callEx, false, typeCheckContext.getEnclosingDecl(), this.context).getType();

            var args = callEx.arguments;

            if (args) {
                for (var i = 0; i < args.members.length; i++) {
                    this.typeCheckAST(args.members[i], typeCheckContext);
                }
            }

            return resultType;
        }

        // Type assertion expressions 
        // validate:
        //  - the type assertion and the expression it's applied to are assignment compatible
        public typeCheckTypeAssertion(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var returnType = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
            this.typeCheckAST((<UnaryExpression>ast).operand, typeCheckContext);

            return returnType;
        }

        // Logical operations
        // validate:
        //  - lhs and rhs are compatible
        public typeCheckLogicalOperation(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var binex = <BinaryExpression>ast;
            var type = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();

            this.typeCheckAST(binex.operand1, typeCheckContext);
            this.typeCheckAST(binex.operand2, typeCheckContext);

            return type;
        }

        // Logical 'And' and 'Or' expressions 
        // validate:
        // - lhs and rhs are compatible
        public typeCheckLogicalAndOrExpression(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var binex = <BinaryExpression>ast;
            var type = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();

            this.typeCheckAST(binex.operand1, typeCheckContext);
            this.typeCheckAST(binex.operand2, typeCheckContext);

            return type;
        }

        // Binary arithmetic expressions 
        // validate:
        //  - lhs and rhs are compatible
        public typeCheckBinaryArithmeticOperation(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var binex = <BinaryExpression>ast;
            var type = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();

            this.typeCheckAST(binex.operand1, typeCheckContext);
            this.typeCheckAST(binex.operand2, typeCheckContext);

            return type;
        }

        // Unary arithmetic expressions 
        // validate:
        //  -
        public typeCheckUnaryArithmeticOperation(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var unex = <UnaryExpression>ast;
            var type = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();

            this.typeCheckAST(unex.operand, typeCheckContext);

            return type;
        }

        // Bitwise operations 
        // validate:
        //  -
        public typeCheckBitwiseOperation(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var binex = <BinaryExpression>ast;
            var type = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();

            this.typeCheckAST(binex.operand1, typeCheckContext);
            this.typeCheckAST(binex.operand2, typeCheckContext);

            return type;
        }

        // Index expression 
        // validate:
        //  -
        public typeCheckIndex(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            return this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
        }

        // 'typeof' expression 
        // validate:
        //  -
        public typeCheckTypeOf(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            return this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
        }

        // Type reference expression
        // validate:
        //  -
        public typeCheckTypeReference(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            return this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
        }

        // Conditional expressions
        // validate:
        //  -
        public typeCheckConditionalExpression(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            
            var condAST = <ConditionalExpression>ast;
            var type = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();

            this.typeCheckAST(condAST.operand1, typeCheckContext);
            this.typeCheckAST(condAST.operand2, typeCheckContext);
            this.typeCheckAST(condAST.operand3, typeCheckContext);

            return type;
        }

        // new expression types
        public typeCheckThrowExpression(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            this.resolver.resolveAST((<UnaryExpression>ast).operand, false, typeCheckContext.getEnclosingDecl(), this.context);
            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckDeleteExpression(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var unex = <UnaryExpression>ast;
            var type = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();

            this.typeCheckAST(unex.operand, typeCheckContext);

            return type;
        }

        public typeCheckVoidExpression(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var unex = <UnaryExpression>ast;
            var type = this.resolver.resolveAST(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();

            this.typeCheckAST(unex.operand, typeCheckContext);

            return type;
        }

        public typeCheckRegExpExpression(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            return this.resolver.resolveStatementOrExpression(ast, false, typeCheckContext.getEnclosingDecl(), this.context).getType();
        }

        // statements

        public typeCheckForStatement(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var forStatementAST = <ForStatement>ast;

            this.typeCheckAST(forStatementAST.init, typeCheckContext);
            this.typeCheckAST(forStatementAST.cond, typeCheckContext);
            this.typeCheckAST(forStatementAST.body, typeCheckContext);            

            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckForInStatement(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {

            var forInStatement = <ForInStatement>ast;


            this.typeCheckAST(forInStatement.obj, typeCheckContext);
            
            var varDecl = <VarDecl>forInStatement.lval;

            if (varDecl.typeExpr) {
                this.context.postError(varDecl.minChar, varDecl.getLength(), typeCheckContext.scriptName, "Variable declarations for for/in expressions may not contain a type annotation", typeCheckContext.getEnclosingDecl());
            }

            var varSym = this.resolver.resolveAST(varDecl, false, typeCheckContext.getEnclosingDecl(), this.context);

            varSym.unsetType();

            varSym.setType(this.semanticInfoChain.stringTypeSymbol);
            varSym.setResolved();            

            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckWhileStatement(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var whileStatementAST = <WhileStatement>ast;

            this.typeCheckAST(whileStatementAST.cond, typeCheckContext);
            this.typeCheckAST(whileStatementAST.body, typeCheckContext);

            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckDoWhileStatement(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var whileStatementAST = <DoWhileStatement>ast;

            this.typeCheckAST(whileStatementAST.cond, typeCheckContext);
            this.typeCheckAST(whileStatementAST.body, typeCheckContext);

            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckIfStatement(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {

            var ifStatementAST = <IfStatement>ast;

            this.typeCheckAST(ifStatementAST.cond, typeCheckContext);
            this.typeCheckAST(ifStatementAST.thenBod, typeCheckContext);
            this.typeCheckAST(ifStatementAST.elseBod, typeCheckContext);
                
            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckBlockStatement(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var blockStatement = <Block>ast;

            this.typeCheckAST(blockStatement.statements, typeCheckContext);

            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckWithStatement(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            // PULLTODO: "With" statements
            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckTryFinallyStatement(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var tryFinallyAST = <TryFinally>ast;

            this.typeCheckAST(tryFinallyAST.tryNode, typeCheckContext);
            this.typeCheckAST(tryFinallyAST.finallyNode, typeCheckContext);

            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckTryCatchStatement(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var tryCatchAST = <TryCatch>ast;

            this.typeCheckAST(tryCatchAST.tryNode, typeCheckContext);
            this.typeCheckAST(tryCatchAST.catchNode, typeCheckContext);

            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckTryBlock(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var tryAST = <Try>ast;

            this.typeCheckAST(tryAST.body, typeCheckContext);

            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckCatchBlock(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var catchAST = <Catch>ast;

            this.typeCheckAST(catchAST.body, typeCheckContext);

            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckFinallyBlock(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var finallyAST = <Finally>ast;

            this.typeCheckAST(finallyAST.body, typeCheckContext);

            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckReturnExpression(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var returnAST = <ReturnStatement>ast;
            typeCheckContext.setEnclosingDeclHasReturn();
            return this.typeCheckAST(returnAST.returnExpression, typeCheckContext);
        }

        public typeCheckNameExpression(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            return this.resolver.resolveNameExpression(<Identifier>ast, typeCheckContext.getEnclosingDecl(), this.context).getType();
        }

        public typeCheckDottedNameExpression(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            return this.resolver.resolveDottedNameExpression(<BinaryExpression>ast, typeCheckContext.getEnclosingDecl(), this.context).getType();
        }

        public typeCheckSwitchStatement(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var switchAST = <SwitchStatement>ast;

            this.typeCheckAST(switchAST.val, typeCheckContext);
            this.typeCheckAST(switchAST.caseList, typeCheckContext);
            this.typeCheckAST(switchAST.defaultCase, typeCheckContext);

            return this.semanticInfoChain.voidTypeSymbol;
        }

        public typeCheckCaseStatement(ast: AST, typeCheckContext: PullTypeCheckContext): PullTypeSymbol {
            var caseAST = <CaseStatement>ast;

            this.typeCheckAST(caseAST.expr, typeCheckContext);
            this.typeCheckAST(caseAST.body, typeCheckContext);

            return this.semanticInfoChain.voidTypeSymbol;
        }

    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {
    export enum PullDeclEdit {
        NoChanges,
        DeclAdded,
        DeclRemoved,
        DeclChanged,
    }

    export class PullDeclDiff {
        constructor(public oldDecl: PullDecl, public newDecl: PullDecl, public kind: PullDeclEdit) {
        }
    }

    export class PullDeclDiffer {

        /*
        What can change?

        - decl name
        - decl type
        - decl span
        - decl flags

        */

        // For now, just check for there/not there - we'll invalidate the inference symbols anyway
        // next up, we'll want to use this data to find the decl that changed
        public diffDecls(oldDecl: PullDecl, newDecl: PullDecl, diffs: PullDeclDiff[]): bool {
            // check the children
            var oldDeclChildren = oldDecl.getChildDecls();
            var newDeclChildren = newDecl.getChildDecls();
            var foundDecls: PullDecl[];
            var foundDiff = false;
            var childFoundDiff = true;
            var i = 0;

            for (i = 0; i < oldDeclChildren.length; i++) {
                foundDecls = newDecl.findChildDecls(oldDeclChildren[i].getName(), oldDeclChildren[i].getKind());

                if (!foundDecls.length) {
                    diffs[diffs.length] = new PullDeclDiff(oldDeclChildren[i], null, PullDeclEdit.DeclRemoved);
                    foundDiff = true;
                }
                else if (foundDecls.length == 1) { // just care about non-split entities for now
                    childFoundDiff = this.diffDecls(oldDeclChildren[i], foundDecls[0], diffs);

                    if (childFoundDiff) {
                        foundDiff = true;
                    }
                }
            }

            for (i = 0; i < newDeclChildren.length; i++) {
                foundDecls = oldDecl.findChildDecls(newDeclChildren[i].getName(), newDeclChildren[i].getKind());

                if (!foundDecls.length) {
                    diffs[diffs.length] = new PullDeclDiff(oldDecl, newDeclChildren[i], PullDeclEdit.DeclAdded);
                    foundDiff = true;
                }
            }

            //if (!foundDiff) {
            //    newDecl.setErrors(oldDecl.getErrors());
            //}

            return foundDiff;
        }
    }
}
///<reference path='References.ts' />

module TypeScript.Collections {
    export var DefaultHashTableCapacity = 256;

    class HashTableEntry {
        constructor(public Key: any,
                    public Value: any,
                    public HashCode: number,
                    public Next: HashTableEntry) {
        }
    }

    export class HashTable {
        // TODO: figure out why the type checker dosn't like "HashTableEntry[]" here.
        private entries /*: HashTableEntry[]*/ = [];
        private count: number = 0;

        constructor(capacity: number,
                    private hash: (k: any) => number,
                    private equals: (k1: any, k2: any) => bool) {
            var size = Hash.getPrime(capacity);
            this.hash = hash;
            this.equals = equals;
            this.entries = ArrayUtilities.createArray(size, null);
        }

        // Maps 'key' to 'value' in this table.  Does not throw if 'key' is already in the table.
        public set (key: any, value: any) {
            this.addOrSet(key, value, /*throwOnExistingEntry:*/ false);
        }

        // Maps 'key' to 'value' in this table.  Throws if 'key' is already in the table.
        public add(key: any, value: any) {
            this.addOrSet(key, value, /*throwOnExistingEntry:*/ true);
        }

        public containsKey(key: any): bool {
            var hashCode = this.computeHashCode(key);
            var entry = this.findEntry(key, hashCode);
            return entry !== null;
        }

        public get (key: any): any {
            var hashCode = this.computeHashCode(key);
            var entry = this.findEntry(key, hashCode);

            return entry === null ? null : entry.Value;
        }

        private computeHashCode(key: any): number {
            var hashCode = this.hash === null
                ? key.hashCode()
                : this.hash(key);

            hashCode = hashCode & 0x7FFFFFFF;
            Debug.assert(hashCode > 0);

            return hashCode;
        }

        private addOrSet(key: any, value: any, throwOnExistingEntry: bool) {
            // Compute the hash for this key.  Also ensure that it's non negative.
            var hashCode = this.computeHashCode(key);

            var entry = this.findEntry(key, hashCode);
            if (entry !== null) {
                if (throwOnExistingEntry) {
                    throw Errors.argument('key', 'Key was already in table.');
                }

                entry.Key = key;
                entry.Value = value;
                return;
            }

            return this.addEntry(key, value, hashCode);
        }

        private findEntry(key: any, hashCode: number) /*: HashTableEntry*/ {
            for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                if (e.HashCode === hashCode) {
                    var equals = this.equals === null
                        ? key === e.Key
                        : this.equals(key, e.Key);

                    if (equals) {
                        return e;
                    }
                }
            }

            return null;
        }

        private addEntry(key: any, value: any, hashCode: number): any {
            var index = hashCode % this.entries.length;

            var e = new HashTableEntry(key, value, hashCode, this.entries[index]);

            this.entries[index] = e;

            // Right now we grow when we get a load factor of 1.  We're basically guaranteed to have had
            // a collision at that point.  Should we potentially change this to a lower load factor?  It
            // will require more space, but provide us with faster lookup.  We could potentially make this
            // configurable as well.
            if (this.count === this.entries.length) {
                this.grow();
            }

            this.count++;
            return e.Key;
        }

        //private dumpStats() {
        //    var standardOut = Environment.standardOut;

        //    standardOut.WriteLine("----------------------")
        //    standardOut.WriteLine("Hash table stats");
        //    standardOut.WriteLine("Count            : " + this.count);
        //    standardOut.WriteLine("Entries Length   : " + this.entries.length);

        //    var occupiedSlots = 0;
        //    for (var i = 0; i < this.entries.length; i++) {
        //        if (this.entries[i] !== null) {
        //            occupiedSlots++;
        //        }
        //    }

        //    standardOut.WriteLine("Occupied slots   : " + occupiedSlots);
        //    standardOut.WriteLine("Avg Length/Slot  : " + (this.count / occupiedSlots));
        //    standardOut.WriteLine("----------------------");
        //}

        private grow(): void {
            // this.dumpStats();

            var newSize = Hash.expandPrime(this.entries.length);

            var oldEntries = this.entries;
            var newEntries: HashTableEntry[] = ArrayUtilities.createArray(newSize, null);

            this.entries = newEntries;

            for (var i = 0; i < oldEntries.length; i++) {
                var e = oldEntries[i];

                while (e !== null) {
                    var newIndex = e.HashCode % newSize;
                    var tmp = e.Next;
                    e.Next = newEntries[newIndex];
                    newEntries[newIndex] = e;
                    e = tmp;
                }
            }

            // this.dumpStats();
        }
    }

    export function createHashTable(capacity: number = DefaultHashTableCapacity,
        hash: (k: any) => number = null,
        equals: (k1: any, k2: any) => bool = null): HashTable {
        return new HashTable(capacity, hash, equals);
    }

    var currentHashCode = 1;
    export function identityHashCode(value: any): number {
        if (value.__hash === undefined) {
            value.__hash = currentHashCode;
            currentHashCode++;
        }

        return value.__hash;
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />
///<reference path='..\Core\HashTable.ts' />
///<reference path='..\Syntax\ISyntaxElement.ts' />

module TypeScript {

    // per-file info on 
    //  decls
    //  bindings
    //  scopes

    // PULLTODO: Get rid of these
    export var declCacheHit = 0;
    export var declCacheMiss = 0;
    export var symbolCacheHit = 0;
    export var symbolCacheMiss = 0;

    export class SemanticInfo {
        private compilationUnitPath: string;  // the "file" this is associated with

        private topLevelDecls: PullDecl[] = [];

        private astDeclMap: DataMap = new DataMap();
        private declASTMap: DataMap = new DataMap();

        private syntaxElementDeclMap: DataMap = new DataMap();
        private declSyntaxElementMap: DataMap = new DataMap();

        private declSymbolMap: DataMap = new DataMap();

        private astSymbolMap: DataMap = new DataMap();
        private symbolASTMap: DataMap = new DataMap();

        private syntaxElementSymbolMap: DataMap = new DataMap();
        private symbolSyntaxElementMap: DataMap = new DataMap();

        private dynamicModuleImports: PullTypeAliasSymbol[] = [];

        constructor(compilationUnitPath: string, public locationInfo: LocationInfo = null) {
            this.compilationUnitPath = compilationUnitPath;
        }

        public addTopLevelDecl(decl: PullDecl) {
            this.topLevelDecls[this.topLevelDecls.length] = decl;
        }

        public getTopLevelDecls() { return this.topLevelDecls; }

        public getPath(): string {
            return this.compilationUnitPath;
        }

        public getDeclForAST(ast: AST): PullDecl {
            return <PullDecl>this.astDeclMap.read(ast.getID().toString());
        }

        public setDeclForAST(ast: AST, decl: PullDecl): void {
            this.astDeclMap.link(ast.getID().toString(), decl);
        }

        public getASTForDecl(decl: PullDecl): AST {
            return <AST>this.declASTMap.read(decl.getDeclID().toString() + decl.getKind().toString());
        }

        public setASTForDecl(decl: PullDecl, ast: AST): void {
            this.declASTMap.link(decl.getDeclID().toString() + decl.getKind().toString(), ast);
        }

        public setSymbolForAST(ast: AST, symbol: PullSymbol): void {
            this.astSymbolMap.link(ast.getID().toString(), symbol);
            this.symbolASTMap.link(symbol.getSymbolID().toString(), ast)
        }

        public getSymbolForAST(ast: AST): PullSymbol {
            return <PullSymbol>this.astSymbolMap.read(ast.getID().toString());
        }

        public getASTForSymbol(symbol: PullSymbol): AST {
            return <AST>this.symbolASTMap.read(symbol.getSymbolID().toString());
        }

        public getSyntaxElementForDecl(decl: PullDecl): ISyntaxElement {
            return <ISyntaxElement>this.declSyntaxElementMap.read(decl.getDeclID().toString() + decl.getKind().toString());
        }

        public setSyntaxElementForDecl(decl: PullDecl, syntaxElement: ISyntaxElement): void {
            this.declSyntaxElementMap.link(decl.getDeclID().toString() + decl.getKind().toString(), syntaxElement);
        }

        public getDeclForSyntaxElement(syntaxElement: ISyntaxElement): PullDecl {
            return <PullDecl>this.syntaxElementDeclMap.read(Collections.identityHashCode(syntaxElement).toString());
        }

        public setDeclForSyntaxElement(syntaxElement: ISyntaxElement, decl: PullDecl): void {
            this.syntaxElementDeclMap.link(Collections.identityHashCode(syntaxElement).toString(), decl);
        }

        public getSyntaxElementForSymbol(symbol: PullSymbol): ISyntaxElement {
            return <ISyntaxElement> this.symbolSyntaxElementMap.read(symbol.getSymbolID().toString());
        }

        public getSymbolForSyntaxElement(syntaxElement: ISyntaxElement): PullSymbol {
            return <PullSymbol>this.syntaxElementSymbolMap.read(Collections.identityHashCode(syntaxElement).toString());
        }

        public setSymbolForSyntaxElement(syntaxElement: ISyntaxElement, symbol: PullSymbol) {
            this.syntaxElementSymbolMap.link(Collections.identityHashCode(syntaxElement).toString(), symbol);
            this.symbolSyntaxElementMap.link(symbol.getSymbolID().toString(), syntaxElement);
        }

        public addDynamicModuleImport(importSymbol: PullTypeAliasSymbol) {
            this.dynamicModuleImports[this.dynamicModuleImports.length] = importSymbol;
        }

        public getDynamicModuleImports() {
            return this.dynamicModuleImports;
        }

        public getDiagnostics(semanticErrors: IDiagnostic[]) {

            for (var i = 0; i < this.topLevelDecls.length; i++) {
                getDiagnosticsFromEnclosingDecl(this.topLevelDecls[i], semanticErrors);
            }
        }
    }

    export class SemanticInfoChain {
        public units: SemanticInfo[] = [new SemanticInfo("")];
        private declCache = <any>new BlockIntrinsics();
        private symbolCache = <any>new BlockIntrinsics();
        private unitCache = <any>new BlockIntrinsics();

        public anyTypeSymbol: PullTypeSymbol = null;
        public boolTypeSymbol: PullTypeSymbol = null;
        public numberTypeSymbol: PullTypeSymbol = null;
        public stringTypeSymbol: PullTypeSymbol = null;
        public nullTypeSymbol: PullTypeSymbol = null;
        public undefinedTypeSymbol: PullTypeSymbol = null;
        public elementTypeSymbol: PullTypeSymbol = null;
        public voidTypeSymbol: PullTypeSymbol = null;

        public addPrimitive(name: string, globalDecl: PullDecl) {
            var span = new TextSpan(0, 0);
            var decl = new PullDecl(name, PullElementKind.Primitive, PullElementFlags.None, span, "");
            var symbol = new PullPrimitiveTypeSymbol(name);

            symbol.addDeclaration(decl);
            decl.setSymbol(symbol);

            symbol.setResolved();

            globalDecl.addChildDecl(decl);

            return symbol;
        }

        constructor() {
            var span = new TextSpan(0, 0);
            var globalDecl = new PullDecl("", PullElementKind.Global, PullElementFlags.None, span, "");
            var globalInfo = this.units[0];
            globalInfo.addTopLevelDecl(globalDecl);

            // add primitive types
            this.anyTypeSymbol = this.addPrimitive("any", globalDecl);
            this.boolTypeSymbol = this.addPrimitive("bool", globalDecl);
            this.numberTypeSymbol = this.addPrimitive("number", globalDecl);
            this.stringTypeSymbol = this.addPrimitive("string", globalDecl);
            this.nullTypeSymbol = this.addPrimitive("null", globalDecl);
            this.undefinedTypeSymbol = this.addPrimitive("undefined", globalDecl);
            this.voidTypeSymbol = this.addPrimitive("void", globalDecl);
            this.elementTypeSymbol = this.addPrimitive("_element", globalDecl);
        }

        public addUnit(unit: SemanticInfo) {
            this.units[this.units.length] = unit;
            this.unitCache[unit.getPath()] = unit;
        }

        public getUnit(compilationUnitPath: string) {
            // PULLTODO: Replace this with a hash so we don't have a linear walk going on here.
            for (var i = 0; i < this.units.length; i++) {
                if (this.units[i].getPath() == compilationUnitPath) {
                    return this.units[i];
                }
            }

            return null;
        }

        // PULLTODO: compilationUnitPath is only really there for debug purposes
        public updateUnit(oldUnit: SemanticInfo, newUnit: SemanticInfo) {
            for (var i = 0; i < this.units.length; i++) {
                if (this.units[i] == oldUnit) {
                    this.units[i] = newUnit;
                    this.unitCache[oldUnit.getPath()] = newUnit;
                    return;
                }
            }
        }

        private collectAllTopLevelDecls() {
            var decls: PullDecl[] = [];
            var unitDecls: PullDecl[];

            for (var i = 0; i < this.units.length; i++) {
                unitDecls = this.units[i].getTopLevelDecls();
                for (var j = 0; j < unitDecls.length; j++) {
                    decls[decls.length] = unitDecls[j];
                }
            }

            return decls;
        }

        private getDeclPathCacheID(declPath: string[], declKind: PullElementKind) {
            var cacheID = "";

            for (var i = 0; i < declPath.length; i++) {
                cacheID += "#" + declPath[i];
            }

            return cacheID + "#" + declKind.toString();
        }

        // a decl path is a list of decls that reference the components of a declaration from the global scope down
        // E.g., string would be "['string']" and "A.B.C" would be "['A','B','C']"
        public findDecls(declPath: string[], declKind: PullElementKind): PullDecl[] {

            var cacheID = this.getDeclPathCacheID(declPath, declKind);

            if (declPath.length) {
                var cachedDecls = this.declCache[cacheID];

                if (cachedDecls && cachedDecls.length) {
                    declCacheHit++;
                    return <PullDecl[]> cachedDecls;
                }
            }

            declCacheMiss++;

            var declsToSearch = this.collectAllTopLevelDecls();

            var decls: PullDecl[] = [];
            var path: string;
            var foundDecls: PullDecl[] = [];
            var keepSearching = (declKind & PullElementKind.Container) || (declKind & PullElementKind.Interface);

            for (var i = 0; i < declPath.length; i++) {
                path = declPath[i];
                decls = [];

                for (var j = 0; j < declsToSearch.length; j++) {
                    foundDecls = declsToSearch[j].findChildDecls(path, (i == declPath.length - 1) ? declKind : PullElementKind.SomeType);

                    for (var k = 0; k < foundDecls.length; k++) {
                        decls[decls.length] = foundDecls[k];
                    }

                    // Unless we're searching for an interface or module, we've found the one true
                    // decl, so don't bother searching the rest of the top-level decls
                    if (foundDecls.length && !keepSearching) {
                        break;
                    }
                }

                declsToSearch = decls;

                if (!declsToSearch) {
                    break;
                }
            }

            if (decls.length) {
                this.declCache[cacheID] = decls;
            }

            return decls;
        }

        public findSymbol(declPath: string[], declType: PullElementKind): PullSymbol {

            var cacheID = this.getDeclPathCacheID(declPath, declType);

            if (declPath.length) {

                var cachedSymbol = this.symbolCache[cacheID];

                if (cachedSymbol) {
                    symbolCacheHit++;
                    return cachedSymbol;
                }
            }

            symbolCacheMiss++;

            // symbol wasn't cached, so get the decl
            var decls: PullDecl[] = this.findDecls(declPath, declType);
            var symbol: PullSymbol = null;

            if (decls.length) {
                symbol = decls[0].getSymbol();

                if (symbol) {
                    this.symbolCache[cacheID] = symbol;

                    symbol.addCacheID(cacheID);
                }
            }

            return symbol;
        }

        public update(compilationUnitPath: string) {

            // PULLTODO: Be less aggressive about clearing the cache
            this.declCache = <any>new BlockIntrinsics();
            //this.symbolCache = <any>{};
            //this.unitCache[compilationUnitPath] = undefined;
        }

        public getDeclForAST(ast: AST, unitPath: string): PullDecl {
            var unit = <SemanticInfo>this.unitCache[unitPath];

            if (unit) {
                return unit.getDeclForAST(ast);
            }

            return null;
        }

        public getASTForDecl(decl: PullDecl, unitPath: string): AST {
            var unit = <SemanticInfo>this.unitCache[unitPath];

            if (unit) {
                return unit.getASTForDecl(decl);
            }

            return null;
        }

        public getSymbolForAST(ast: AST, unitPath: string) {
            var unit = <SemanticInfo>this.unitCache[unitPath];

            if (unit) {
                return unit.getSymbolForAST(ast);
            }

            return null;
        }

        public getASTForSymbol(symbol: PullSymbol, unitPath: string) {
            var unit = <SemanticInfo>this.unitCache[unitPath];

            if (unit) {
                return unit.getASTForSymbol(symbol);
            }

            return null;
        }

        public setSymbolForAST(ast: AST, typeSymbol: PullSymbol, unitPath: string) {
            var unit = <SemanticInfo>this.unitCache[unitPath];

            if (unit) {
                unit.setSymbolForAST(ast, typeSymbol);
            }
        }

        public removeSymbolFromCache(symbol: PullSymbol) {

            var path = [symbol.getName()];
            var kind = (symbol.getKind() & PullElementKind.SomeType) != 0 ? PullElementKind.SomeType : PullElementKind.SomeValue;

            var kindID = this.getDeclPathCacheID(path, kind);
            var symID = this.getDeclPathCacheID(path, symbol.getKind());

            symbol.addCacheID(kindID);
            symbol.addCacheID(symID);

            symbol.invalidateCachedIDs(this.symbolCache);
        }

        public postDiagnostics(): IDiagnostic[] {
            var errors: IDiagnostic[] = [];

            // PULLTODO: Why are we indexing from 1?
            for (var i = 1; i < this.units.length; i++) {
                this.units[i].getDiagnostics(errors);
            }

            return errors;
        }
    }
}
﻿///<reference path='References.ts' />

module TypeScript {
    export class SyntaxWalker implements ISyntaxVisitor {
        public visitToken(token: ISyntaxToken): void {
        }

        public visitNode(node: SyntaxNode): void {
            node.accept(this);
        }

        public visitNodeOrToken(nodeOrToken: ISyntaxNodeOrToken): void {
            if (nodeOrToken.isToken()) { 
                this.visitToken(<ISyntaxToken>nodeOrToken);
            }
            else {
                this.visitNode(<SyntaxNode>nodeOrToken);
            }
        }

        private visitOptionalToken(token: ISyntaxToken): void {
            if (token === null) {
                return;
            }

            this.visitToken(token);
        }

        public visitOptionalNode(node: SyntaxNode): void {
            if (node === null) {
                return;
            }

            this.visitNode(node);
        }

        public visitOptionalNodeOrToken(nodeOrToken: ISyntaxNodeOrToken): void {
            if (nodeOrToken === null) {
                return;
            }

            this.visitNodeOrToken(nodeOrToken);
        }

        public visitList(list: ISyntaxList): void {
            for (var i = 0, n = list.childCount(); i < n; i++) {
               this.visitNodeOrToken(list.childAt(i));
            }
        }

        public visitSeparatedList(list: ISeparatedSyntaxList): void {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                this.visitNodeOrToken(item);
            }
        }

        public visitSourceUnit(node: SourceUnitSyntax): void {
            this.visitList(node.moduleElements);
            this.visitToken(node.endOfFileToken);
        }

        public visitExternalModuleReference(node: ExternalModuleReferenceSyntax): void {
            this.visitToken(node.moduleKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.stringLiteral);
            this.visitToken(node.closeParenToken);
        }

        public visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): void {
            this.visitNodeOrToken(node.moduleName);
        }

        public visitImportDeclaration(node: ImportDeclarationSyntax): void {
            this.visitToken(node.importKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.equalsToken);
            this.visitNode(node.moduleReference);
            this.visitToken(node.semicolonToken);
        }

        public visitExportAssignment(node: ExportAssignmentSyntax): void {
            this.visitToken(node.exportKeyword);
            this.visitToken(node.equalsToken);
            this.visitToken(node.identifier);
            this.visitToken(node.semicolonToken);
        }

        public visitClassDeclaration(node: ClassDeclarationSyntax): void {
            this.visitOptionalToken(node.exportKeyword);
            this.visitOptionalToken(node.declareKeyword);
            this.visitToken(node.classKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitOptionalNode(node.extendsClause);
            this.visitOptionalNode(node.implementsClause);
            this.visitToken(node.openBraceToken);
            this.visitList(node.classElements);
            this.visitToken(node.closeBraceToken);
        }

        public visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): void {
            this.visitOptionalToken(node.exportKeyword);
            this.visitToken(node.interfaceKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitOptionalNode(node.extendsClause);
            this.visitNode(node.body);
        }

        public visitExtendsClause(node: ExtendsClauseSyntax): void {
            this.visitToken(node.extendsKeyword);
            this.visitSeparatedList(node.typeNames);
        }

        public visitImplementsClause(node: ImplementsClauseSyntax): void {
            this.visitToken(node.implementsKeyword);
            this.visitSeparatedList(node.typeNames);
        }

        public visitModuleDeclaration(node: ModuleDeclarationSyntax): void {
            this.visitOptionalToken(node.exportKeyword);
            this.visitOptionalToken(node.declareKeyword);
            this.visitToken(node.moduleKeyword);
            this.visitOptionalNodeOrToken(node.moduleName);
            this.visitOptionalToken(node.stringLiteral);
            this.visitToken(node.openBraceToken);
            this.visitList(node.moduleElements);
            this.visitToken(node.closeBraceToken);
        }

        public visitFunctionDeclaration(node: FunctionDeclarationSyntax): void {
            this.visitOptionalToken(node.exportKeyword);
            this.visitOptionalToken(node.declareKeyword);
            this.visitToken(node.functionKeyword);
            this.visitToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitVariableStatement(node: VariableStatementSyntax): void {
            this.visitOptionalToken(node.exportKeyword);
            this.visitOptionalToken(node.declareKeyword);
            this.visitNode(node.variableDeclaration);
            this.visitToken(node.semicolonToken);
        }

        public visitVariableDeclaration(node: VariableDeclarationSyntax): void {
            this.visitToken(node.varKeyword);
            this.visitSeparatedList(node.variableDeclarators);
        }

        public visitVariableDeclarator(node: VariableDeclaratorSyntax): void {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        }

        public visitEqualsValueClause(node: EqualsValueClauseSyntax): void {
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.value);
        }

        public visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): void {
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.operand);
        }

        public visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): void {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.expressions);
            this.visitToken(node.closeBracketToken);
        }

        public visitOmittedExpression(node: OmittedExpressionSyntax): void {
        }

        public visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): void {
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
        }

        public visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): void {
            this.visitToken(node.identifier);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.body);
        }

        public visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): void {
            this.visitNode(node.callSignature);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.body);
        }

        public visitQualifiedName(node: QualifiedNameSyntax): void {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.dotToken);
            this.visitToken(node.right);
        }

        public visitTypeArgumentList(node: TypeArgumentListSyntax): void {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeArguments);
            this.visitToken(node.greaterThanToken);
        }

        public visitConstructorType(node: ConstructorTypeSyntax): void {
            this.visitToken(node.newKeyword);
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        }

        public visitFunctionType(node: FunctionTypeSyntax): void {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        }

        public visitObjectType(node: ObjectTypeSyntax): void {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.typeMembers);
            this.visitToken(node.closeBraceToken);
        }

        public visitArrayType(node: ArrayTypeSyntax): void {
            this.visitNodeOrToken(node.type);
            this.visitToken(node.openBracketToken);
            this.visitToken(node.closeBracketToken);
        }

        public visitGenericType(node: GenericTypeSyntax): void {
            this.visitNodeOrToken(node.name);
            this.visitNode(node.typeArgumentList);
        }

        public visitTypeAnnotation(node: TypeAnnotationSyntax): void {
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.type);
        }

        public visitBlock(node: BlockSyntax): void {
            this.visitToken(node.openBraceToken);
            this.visitList(node.statements);
            this.visitToken(node.closeBraceToken);
        }

        public visitParameter(node: ParameterSyntax): void {
            this.visitOptionalToken(node.dotDotDotToken);
            this.visitOptionalToken(node.publicOrPrivateKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        }

        public visitMemberAccessExpression(node: MemberAccessExpressionSyntax): void {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.dotToken);
            this.visitToken(node.name);
        }

        public visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): void {
            this.visitNodeOrToken(node.operand);
            this.visitToken(node.operatorToken);
        }

        public visitElementAccessExpression(node: ElementAccessExpressionSyntax): void {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.openBracketToken);
            this.visitNodeOrToken(node.argumentExpression);
            this.visitToken(node.closeBracketToken);
        }

        public visitInvocationExpression(node: InvocationExpressionSyntax): void {
            this.visitNodeOrToken(node.expression);
            this.visitNode(node.argumentList);
        }

        public visitArgumentList(node: ArgumentListSyntax): void {
            this.visitOptionalNode(node.typeArgumentList);
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.arguments);
            this.visitToken(node.closeParenToken);
        }

        public visitBinaryExpression(node: BinaryExpressionSyntax): void {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.right);
        }

        public visitConditionalExpression(node: ConditionalExpressionSyntax): void {
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.questionToken);
            this.visitNodeOrToken(node.whenTrue);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.whenFalse);
        }

        public visitConstructSignature(node: ConstructSignatureSyntax): void {
            this.visitToken(node.newKeyword);
            this.visitNode(node.callSignature);
        }

        public visitMethodSignature(node: MethodSignatureSyntax): void {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitNode(node.callSignature);
        }

        public visitIndexSignature(node: IndexSignatureSyntax): void {
            this.visitToken(node.openBracketToken);
            this.visitToken(node.identifier);
            this.visitNode(node.parameterTypeAnnotation);
            this.visitToken(node.closeBracketToken);
            this.visitOptionalNode(node.typeAnnotation);
        }

        public visitPropertySignature(node: PropertySignatureSyntax): void {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
        }

        public visitCallSignature(node: CallSignatureSyntax): void {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
        }

        public visitParameterList(node: ParameterListSyntax): void {
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.parameters);
            this.visitToken(node.closeParenToken);
        }

        public visitTypeParameterList(node: TypeParameterListSyntax): void {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeParameters);
            this.visitToken(node.greaterThanToken);
        }

        public visitTypeParameter(node: TypeParameterSyntax): void {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.constraint);
        }

        public visitConstraint(node: ConstraintSyntax): void {
            this.visitToken(node.extendsKeyword);
            this.visitNodeOrToken(node.type);
        }

        public visitElseClause(node: ElseClauseSyntax): void {
            this.visitToken(node.elseKeyword);
            this.visitNodeOrToken(node.statement);
        }

        public visitIfStatement(node: IfStatementSyntax): void {
            this.visitToken(node.ifKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
            this.visitOptionalNode(node.elseClause);
        }

        public visitExpressionStatement(node: ExpressionStatementSyntax): void {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        }

        public visitConstructorDeclaration(node: ConstructorDeclarationSyntax): void {
            this.visitToken(node.constructorKeyword);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): void {
            this.visitOptionalToken(node.publicOrPrivateKeyword);
            this.visitOptionalToken(node.staticKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        }

        public visitGetMemberAccessorDeclaration(node: GetMemberAccessorDeclarationSyntax): void {
            this.visitOptionalToken(node.publicOrPrivateKeyword);
            this.visitOptionalToken(node.staticKeyword);
            this.visitToken(node.getKeyword);
            this.visitToken(node.identifier);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        }

        public visitSetMemberAccessorDeclaration(node: SetMemberAccessorDeclarationSyntax): void {
            this.visitOptionalToken(node.publicOrPrivateKeyword);
            this.visitOptionalToken(node.staticKeyword);
            this.visitToken(node.setKeyword);
            this.visitToken(node.identifier);
            this.visitNode(node.parameterList);
            this.visitNode(node.block);
        }

        public visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): void {
            this.visitOptionalToken(node.publicOrPrivateKeyword);
            this.visitOptionalToken(node.staticKeyword);
            this.visitNode(node.variableDeclarator);
            this.visitToken(node.semicolonToken);
        }

        public visitThrowStatement(node: ThrowStatementSyntax): void {
            this.visitToken(node.throwKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        }

        public visitReturnStatement(node: ReturnStatementSyntax): void {
            this.visitToken(node.returnKeyword);
            this.visitOptionalNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        }

        public visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): void {
            this.visitToken(node.newKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalNode(node.argumentList);
        }

        public visitSwitchStatement(node: SwitchStatementSyntax): void {
            this.visitToken(node.switchKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.openBraceToken);
            this.visitList(node.switchClauses);
            this.visitToken(node.closeBraceToken);
        }

        public visitCaseSwitchClause(node: CaseSwitchClauseSyntax): void {
            this.visitToken(node.caseKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        }

        public visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): void {
            this.visitToken(node.defaultKeyword);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        }

        public visitBreakStatement(node: BreakStatementSyntax): void {
            this.visitToken(node.breakKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        }

        public visitContinueStatement(node: ContinueStatementSyntax): void {
            this.visitToken(node.continueKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        }

        public visitForStatement(node: ForStatementSyntax): void {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.initializer);
            this.visitToken(node.firstSemicolonToken);
            this.visitOptionalNodeOrToken(node.condition);
            this.visitToken(node.secondSemicolonToken);
            this.visitOptionalNodeOrToken(node.incrementor);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        }

        public visitForInStatement(node: ForInStatementSyntax): void {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.left);
            this.visitToken(node.inKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        }

        public visitWhileStatement(node: WhileStatementSyntax): void {
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        }

        public visitWithStatement(node: WithStatementSyntax): void {
            this.visitToken(node.withKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        }

        public visitEnumDeclaration(node: EnumDeclarationSyntax): void {
            this.visitOptionalToken(node.exportKeyword);
            this.visitToken(node.enumKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.enumElements);
            this.visitToken(node.closeBraceToken);
        }

        public visitEnumElement(node: EnumElementSyntax): void {
            this.visitOptionalToken(node.identifier);
            this.visitOptionalToken(node.stringLiteral);
            this.visitOptionalNode(node.equalsValueClause);
        }

        public visitCastExpression(node: CastExpressionSyntax): void {
            this.visitToken(node.lessThanToken);
            this.visitNodeOrToken(node.type);
            this.visitToken(node.greaterThanToken);
            this.visitNodeOrToken(node.expression);
        }

        public visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): void {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.propertyAssignments);
            this.visitToken(node.closeBraceToken);
        }

        public visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): void {
            this.visitToken(node.propertyName);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.expression);
        }

        public visitGetAccessorPropertyAssignment(node: GetAccessorPropertyAssignmentSyntax): void {
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitToken(node.openParenToken);
            this.visitToken(node.closeParenToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        }

        public visitSetAccessorPropertyAssignment(node: SetAccessorPropertyAssignmentSyntax): void {
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitToken(node.openParenToken);
            this.visitNode(node.parameter);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        }

        public visitFunctionExpression(node: FunctionExpressionSyntax): void {
            this.visitToken(node.functionKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        }

        public visitEmptyStatement(node: EmptyStatementSyntax): void {
            this.visitToken(node.semicolonToken);
        }

        public visitTryStatement(node: TryStatementSyntax): void {
            this.visitToken(node.tryKeyword);
            this.visitNode(node.block);
            this.visitOptionalNode(node.catchClause);
            this.visitOptionalNode(node.finallyClause);
        }

        public visitCatchClause(node: CatchClauseSyntax): void {
            this.visitToken(node.catchKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        }

        public visitFinallyClause(node: FinallyClauseSyntax): void {
            this.visitToken(node.finallyKeyword);
            this.visitNode(node.block);
        }

        public visitLabeledStatement(node: LabeledStatementSyntax): void {
            this.visitToken(node.identifier);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.statement);
        }

        public visitDoStatement(node: DoStatementSyntax): void {
            this.visitToken(node.doKeyword);
            this.visitNodeOrToken(node.statement);
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.semicolonToken);
        }

        public visitTypeOfExpression(node: TypeOfExpressionSyntax): void {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.expression);
        }

        public visitDeleteExpression(node: DeleteExpressionSyntax): void {
            this.visitToken(node.deleteKeyword);
            this.visitNodeOrToken(node.expression);
        }

        public visitVoidExpression(node: VoidExpressionSyntax): void {
            this.visitToken(node.voidKeyword);
            this.visitNodeOrToken(node.expression);
        }

        public visitDebuggerStatement(node: DebuggerStatementSyntax): void {
            this.visitToken(node.debuggerKeyword);
            this.visitToken(node.semicolonToken);
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />
///<reference path='..\Syntax\SyntaxWalker.generated.ts' />
///<reference path='..\Text\TextSpan.ts' />

module TypeScript {
    export class DeclCollectionContext {
        public parentChain: PullDecl[] = [];

        constructor(public semanticInfo: SemanticInfo, public scriptName = "") {
        }

        public getParent() { return this.parentChain ? this.parentChain[this.parentChain.length - 1] : null; }

        public pushParent(parentDecl: PullDecl) { if (parentDecl) { this.parentChain[this.parentChain.length] = parentDecl; } }

        public popParent() { this.parentChain.length--; }

        public foundValueDecl = false;
    }

    export function preCollectImportDecls(ast: AST, parentAST: AST, context: DeclCollectionContext) {
        var importDecl = <ImportDeclaration>ast;
        var declFlags = PullElementFlags.None;
        var span = TextSpan.fromBounds(importDecl.minChar, importDecl.limChar);

        var decl = new PullDecl(importDecl.id.actualText, PullElementKind.TypeAlias, declFlags, span, context.scriptName);

        var parent = context.getParent();

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        context.semanticInfo.setDeclForAST(ast, decl);

        context.semanticInfo.setASTForDecl(decl, ast);

        return false;
    }

    export function preCollectModuleDecls(ast: AST, parentAST: AST, context: DeclCollectionContext) {
        var moduleDecl: ModuleDeclaration = <ModuleDeclaration>ast;
        var declFlags = PullElementFlags.None;
        var modName = (<Identifier>moduleDecl.name).text;
        var isDynamic = isQuoted(modName) || hasFlag(moduleDecl.modFlags, ModuleFlags.IsDynamic);
        var kind: PullElementKind = PullElementKind.Container;

        if (hasFlag(moduleDecl.modFlags, ModuleFlags.Ambient)) {
            declFlags |= PullElementFlags.Ambient;
        }

        if (hasFlag(moduleDecl.modFlags, ModuleFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }

        if (hasFlag(moduleDecl.modFlags, ModuleFlags.IsEnum)) {
            declFlags |= PullElementFlags.Enum;
            kind = PullElementKind.Enum;
        }
        else {
            kind = isDynamic ? PullElementKind.DynamicModule : PullElementKind.Container;
        }

        var span = TextSpan.fromBounds(moduleDecl.minChar, moduleDecl.limChar);

        var decl = new PullDecl(modName, kind, declFlags, span, context.scriptName);
        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(ast, decl);

        context.semanticInfo.setASTForDecl(decl, ast);

        return true;
    }

    export function preCollectClassDecls(ast: AST, parenAST: AST, context: DeclCollectionContext) {
        var classDecl = <ClassDeclaration>ast;
        var declFlags = PullElementFlags.None;
        var constructorDeclKind = PullElementKind.Variable;

        if (hasFlag(classDecl.varFlags, VarFlags.Ambient)) {
            declFlags |= PullElementFlags.Ambient;
        }

        if (hasFlag(classDecl.varFlags, VarFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
            constructorDeclKind = PullElementKind.Property;
        }

        var span = TextSpan.fromBounds(classDecl.minChar, classDecl.limChar);

        var decl = new PullDecl(classDecl.name.text, PullElementKind.Class, declFlags, span, context.scriptName);

        var constructorDecl = new PullDecl(classDecl.name.text, constructorDeclKind, declFlags | PullElementFlags.ClassConstructorVariable, span, context.scriptName);

        decl.setValueDecl(constructorDecl);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        parent.addChildDecl(constructorDecl);
        decl.setParentDecl(parent);
        constructorDecl.setParentDecl(parent);

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(ast, decl);

        context.semanticInfo.setASTForDecl(decl, ast);
        context.semanticInfo.setASTForDecl(constructorDecl, ast);

        return true;
    }

    export function createInferfaceDeclaration(interfaceDecl: InterfaceDeclaration, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;

        if (hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }

        var span = TextSpan.fromBounds(interfaceDecl.minChar, interfaceDecl.limChar);

        var decl = new PullDecl(interfaceDecl.name.text, PullElementKind.Interface, declFlags, span, context.scriptName);

        var parent = context.getParent();

        // if we're collecting a decl for a type annotation, we don't want to add the decl to the parent scope
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);

        return true;
    }

    export function createObjectTypeDeclaration(interfaceDecl: InterfaceDeclaration, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;

        if (hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }

        var span = TextSpan.fromBounds(interfaceDecl.minChar, interfaceDecl.limChar);

        var decl = new PullDecl("", PullElementKind.ObjectType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        // if we're collecting a decl for a type annotation, we don't want to add the decl to the parent scope
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);

        return true;
    }

    export function preCollectInterfaceDecls(ast: AST, parentAST: AST, context: DeclCollectionContext) {

        var interfaceDecl = <InterfaceDeclaration>ast;
        var declFlags = PullElementFlags.None;

        // PULLTODO
        //if (ast.flags & ASTFlags.TypeReference) {
        //    return createObjectTypeDeclaration(interfaceDecl, context);
        //}

        if (hasFlag(interfaceDecl.varFlags, VarFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }

        var span = TextSpan.fromBounds(interfaceDecl.minChar, interfaceDecl.limChar);

        var decl = new PullDecl(interfaceDecl.name.text, PullElementKind.Interface, declFlags, span, context.scriptName);

        var parent = context.getParent();

        // if we're collecting a decl for a type annotation, we don't want to add the decl to the parent scope
        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        return true;
    }

    export function preCollectParameterDecl(ast: AST, parentAST: AST, context: DeclCollectionContext) {
        var argDecl = <BoundDecl>ast;
        var declFlags = PullElementFlags.None;

        if (hasFlag(argDecl.varFlags, VarFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }
        else {
            declFlags |= PullElementFlags.Public;
        }

        if (hasFlag(argDecl.flags, ASTFlags.OptionalName) || hasFlag(argDecl.id.flags, ASTFlags.OptionalName)) {
            declFlags |= PullElementFlags.Optional;
        }

        var span = TextSpan.fromBounds(argDecl.minChar, argDecl.limChar);

        var decl = new PullDecl(argDecl.id.text, PullElementKind.Parameter, declFlags, span, context.scriptName);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        // if it's a property type, we'll need to add it to the parent's parent as well
        if (hasFlag(argDecl.varFlags, VarFlags.Property)) {
            var propDecl = new PullDecl(argDecl.id.text, PullElementKind.Property, declFlags, span, context.scriptName);
            propDecl.setValueDecl(decl);
            context.parentChain[context.parentChain.length - 2].addChildDecl(propDecl);
            propDecl.setParentDecl(context.parentChain[context.parentChain.length - 2]);
            context.semanticInfo.setASTForDecl(propDecl, ast);
            context.semanticInfo.setDeclForAST(ast, propDecl);
        }
        else {
            context.semanticInfo.setASTForDecl(decl, ast);
            context.semanticInfo.setDeclForAST(ast, decl);
        }

        if (argDecl.typeExpr &&
            ((<TypeReference>argDecl.typeExpr).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>argDecl.typeExpr).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>argDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    export function preCollectTypeParameterDecl(ast: AST, parentAST: AST, context: DeclCollectionContext) {
        var typeParameterDecl = <TypeParameter>ast;
        var declFlags = PullElementFlags.None;

        var span = TextSpan.fromBounds(typeParameterDecl.minChar, typeParameterDecl.limChar);

        var decl = new PullDecl(typeParameterDecl.name.actualText, PullElementKind.TypeParameter, declFlags, span, context.scriptName);

        context.semanticInfo.setASTForDecl(decl, ast);
        context.semanticInfo.setDeclForAST(ast, decl);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (typeParameterDecl.constraint &&
            ((<TypeReference>typeParameterDecl.constraint).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>typeParameterDecl.constraint).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>typeParameterDecl.constraint).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // interface properties
    export function createPropertySignature(propertyDecl: VarDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Public;
        var declType = PullElementKind.Property;

        if (hasFlag(propertyDecl.id.flags, ASTFlags.OptionalName)) {
            declFlags |= PullElementFlags.Optional;
        }

        if (hasFlag(propertyDecl.varFlags, VarFlags.Constant)) {
            declFlags |= PullElementFlags.Constant;
        }

        var span = TextSpan.fromBounds(propertyDecl.minChar, propertyDecl.limChar);

        var decl = new PullDecl(propertyDecl.id.text, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        context.semanticInfo.setDeclForAST(propertyDecl, decl);

        context.semanticInfo.setASTForDecl(decl, propertyDecl);

        if (propertyDecl.typeExpr &&
            ((<TypeReference>propertyDecl.typeExpr).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>propertyDecl.typeExpr).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>propertyDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    // class member variables
    export function createMemberVariableDeclaration(memberDecl: VarDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Property;

        if (hasFlag(memberDecl.varFlags, VarFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }
        else {
            declFlags |= PullElementFlags.Public;
        }

        if (hasFlag(memberDecl.varFlags, VarFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        var span = TextSpan.fromBounds(memberDecl.minChar, memberDecl.limChar);

        var decl = new PullDecl(memberDecl.id.text, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        context.semanticInfo.setDeclForAST(memberDecl, decl);

        context.semanticInfo.setASTForDecl(decl, memberDecl);

        if (memberDecl.typeExpr &&
            ((<TypeReference>memberDecl.typeExpr).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>memberDecl.typeExpr).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>memberDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    export function createVariableDeclaration(varDecl: VarDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Variable;

        if (hasFlag(varDecl.varFlags, VarFlags.Ambient)) {
            declFlags |= PullElementFlags.Ambient;
        }

        if (hasFlag(varDecl.varFlags, VarFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }

        var span = TextSpan.fromBounds(varDecl.minChar, varDecl.limChar);

        var decl = new PullDecl(varDecl.id.text, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        context.semanticInfo.setDeclForAST(varDecl, decl);

        context.semanticInfo.setASTForDecl(decl, varDecl);

        if (varDecl.typeExpr &&
            ((<TypeReference>varDecl.typeExpr).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>varDecl.typeExpr).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>varDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    export function preCollectVarDecls(ast: AST, parentAST: AST, context: DeclCollectionContext) {
        var varDecl = <VarDecl>ast;
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Variable;
        var isProperty = false;
        var isStatic = false;

        if (hasFlag(varDecl.varFlags, VarFlags.ClassProperty)) {
            return createMemberVariableDeclaration(varDecl, context);
        }
        else if (hasFlag(varDecl.varFlags, VarFlags.Property)) {
            return createPropertySignature(varDecl, context);
        }

        return createVariableDeclaration(varDecl, context);
    }

    // function type expressions
    export function createFunctionTypeDeclaration(functionTypeDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.FunctionType;

        var span = TextSpan.fromBounds(functionTypeDeclAST.minChar, functionTypeDeclAST.limChar);

        var decl = new PullDecl("", declType, declFlags, span, context.semanticInfo.getPath());

        // parent could be null if we're collecting decls for a lambda expression
        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(functionTypeDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, functionTypeDeclAST);

        if (functionTypeDeclAST.returnTypeAnnotation &&
            ((<TypeReference>functionTypeDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>functionTypeDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>functionTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // constructor types
    export function createConstructorTypeDeclaration(constructorTypeDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.ConstructorType;

        var span = TextSpan.fromBounds(constructorTypeDeclAST.minChar, constructorTypeDeclAST.limChar);

        var decl = new PullDecl("{new}", declType, declFlags, span, context.semanticInfo.getPath());

        // parent could be null if we're collecting decls for a lambda expression
        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(constructorTypeDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, constructorTypeDeclAST);

        if (constructorTypeDeclAST.returnTypeAnnotation &&
            ((<TypeReference>constructorTypeDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>constructorTypeDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>constructorTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // function declaration
    export function createFunctionDeclaration(funcDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Function;

        if (hasFlag(funcDeclAST.fncFlags, FncFlags.Ambient)) {
            declFlags |= PullElementFlags.Ambient;
        }

        if (hasFlag(funcDeclAST.fncFlags, FncFlags.Exported)) {
            declFlags |= PullElementFlags.Exported;
        }

        if (!funcDeclAST.bod) {
            declFlags |= PullElementFlags.Signature;
        }

        var span = TextSpan.fromBounds(funcDeclAST.minChar, funcDeclAST.limChar);

        var decl = new PullDecl(funcDeclAST.name.actualText, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(funcDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, funcDeclAST);

        if (funcDeclAST.returnTypeAnnotation &&
            ((<TypeReference>funcDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>funcDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>funcDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // function expression
    export function createFunctionExpressionDeclaration(functionExpressionDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.FunctionExpression;

        if (hasFlag(functionExpressionDeclAST.fncFlags, FncFlags.IsFatArrowFunction)) {
            declFlags |= PullElementFlags.FatArrow;
        }

        var span = TextSpan.fromBounds(functionExpressionDeclAST.minChar, functionExpressionDeclAST.limChar);

        var decl = new PullDecl("", declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(functionExpressionDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, functionExpressionDeclAST);

        if (functionExpressionDeclAST.returnTypeAnnotation &&
            ((<TypeReference>functionExpressionDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>functionExpressionDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>functionExpressionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // methods
    export function createMemberFunctionDeclaration(memberFunctionDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.None;
        var declType = PullElementKind.Method;

        if (hasFlag(memberFunctionDeclAST.fncFlags, FncFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        if (hasFlag(memberFunctionDeclAST.fncFlags, FncFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }
        else {
            declFlags |= PullElementFlags.Public;
        }

        if (!memberFunctionDeclAST.bod || !memberFunctionDeclAST.bod.members.length) {
            declFlags |= PullElementFlags.Signature;
        }

        if (hasFlag(memberFunctionDeclAST.name.flags, ASTFlags.OptionalName)) {
            declFlags |= PullElementFlags.Optional;
        }

        var span = TextSpan.fromBounds(memberFunctionDeclAST.minChar, memberFunctionDeclAST.limChar);

        var decl = new PullDecl(memberFunctionDeclAST.name.actualText, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(memberFunctionDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, memberFunctionDeclAST);

        if (memberFunctionDeclAST.returnTypeAnnotation &&
            ((<TypeReference>memberFunctionDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>memberFunctionDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>memberFunctionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // index signatures
    export function createIndexSignatureDeclaration(indexSignatureDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Signature | PullElementFlags.Index;
        var declType = PullElementKind.IndexSignature;

        var span = TextSpan.fromBounds(indexSignatureDeclAST.minChar, indexSignatureDeclAST.limChar);

        var decl = new PullDecl("[]", declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(indexSignatureDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, indexSignatureDeclAST);

        if (indexSignatureDeclAST.returnTypeAnnotation &&
            ((<TypeReference>indexSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>indexSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>indexSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // call signatures
    export function createCallSignatureDeclaration(callSignatureDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Signature | PullElementFlags.Call;
        var declType = PullElementKind.CallSignature;

        var span = TextSpan.fromBounds(callSignatureDeclAST.minChar, callSignatureDeclAST.limChar);

        var decl = new PullDecl("()", declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(callSignatureDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, callSignatureDeclAST);

        if (callSignatureDeclAST.returnTypeAnnotation &&
            ((<TypeReference>callSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>callSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>callSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // construct signatures
    export function createConstructSignatureDeclaration(constructSignatureDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Signature | PullElementFlags.Call;
        var declType = PullElementKind.ConstructSignature;

        var span = TextSpan.fromBounds(constructSignatureDeclAST.minChar, constructSignatureDeclAST.limChar);

        var decl = new PullDecl("new", declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(constructSignatureDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, constructSignatureDeclAST);

        if (constructSignatureDeclAST.returnTypeAnnotation &&
            ((<TypeReference>constructSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>constructSignatureDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>constructSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // class constructors
    export function createClassConstructorDeclaration(constructorDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Constructor;
        var declType = PullElementKind.ConstructorMethod;

        if (!constructorDeclAST.bod) {
            declFlags |= PullElementFlags.Signature;
        }

        var span = TextSpan.fromBounds(constructorDeclAST.minChar, constructorDeclAST.limChar);

        var parent = context.getParent();

        if (parent) {
            // if the parent is exported, the constructor decl must be as well
            var parentFlags = parent.getFlags();

            if (parentFlags & PullElementFlags.Exported) {
                declFlags |= PullElementFlags.Exported;
            }
        }

        var decl = new PullDecl(constructorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);        

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(constructorDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, constructorDeclAST);

        if (constructorDeclAST.returnTypeAnnotation &&
            ((<TypeReference>constructorDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>constructorDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>constructorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    export function createGetAccessorDeclaration(getAccessorDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Public;
        var declType = PullElementKind.GetAccessor;

        if (hasFlag(getAccessorDeclAST.fncFlags, FncFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        if (hasFlag(getAccessorDeclAST.name.flags, ASTFlags.OptionalName)) {
            declFlags |= PullElementFlags.Optional;
        }

        if (hasFlag(getAccessorDeclAST.fncFlags, FncFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }
        else {
            declFlags |= PullElementFlags.Public;
        }        

        var span = TextSpan.fromBounds(getAccessorDeclAST.minChar, getAccessorDeclAST.limChar);

        var decl = new PullDecl(getAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(getAccessorDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, getAccessorDeclAST);

        if (getAccessorDeclAST.returnTypeAnnotation &&
            ((<TypeReference>getAccessorDeclAST.returnTypeAnnotation).term.nodeType == NodeType.InterfaceDeclaration ||
            (<TypeReference>getAccessorDeclAST.returnTypeAnnotation).term.nodeType == NodeType.FuncDecl)) {

            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            getAstWalkerFactory().walk((<TypeReference>getAccessorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    // set accessors
    export function createSetAccessorDeclaration(setAccessorDeclAST: FuncDecl, context: DeclCollectionContext) {
        var declFlags = PullElementFlags.Public;
        var declType = PullElementKind.SetAccessor;

        if (hasFlag(setAccessorDeclAST.fncFlags, FncFlags.Static)) {
            declFlags |= PullElementFlags.Static;
        }

        if (hasFlag(setAccessorDeclAST.name.flags, ASTFlags.OptionalName)) {
            declFlags |= PullElementFlags.Optional;
        }

        if (hasFlag(setAccessorDeclAST.fncFlags, FncFlags.Private)) {
            declFlags |= PullElementFlags.Private;
        }
        else {
            declFlags |= PullElementFlags.Public;
        }         

        var span = TextSpan.fromBounds(setAccessorDeclAST.minChar, setAccessorDeclAST.limChar);

        var decl = new PullDecl(setAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(setAccessorDeclAST, decl);

        context.semanticInfo.setASTForDecl(decl, setAccessorDeclAST);

        return true;
    }

    export function preCollectFuncDecls(ast: AST, parentAST: AST, context: DeclCollectionContext) {

        var funcDecl = <FuncDecl>ast;

        if (hasFlag(funcDecl.fncFlags, (FncFlags.IsFunctionExpression | FncFlags.IsFatArrowFunction))) {
            return createFunctionExpressionDeclaration(funcDecl, context);
        }
        else if (funcDecl.isConstructor) {
            return createClassConstructorDeclaration(funcDecl, context);
        }
        else if (funcDecl.isGetAccessor()) {
            return createGetAccessorDeclaration(funcDecl, context);
        }
        else if (funcDecl.isSetAccessor()) {
            return createSetAccessorDeclaration(funcDecl, context);
        }
        else if (hasFlag(funcDecl.fncFlags, FncFlags.ConstructMember)) {
            return hasFlag(funcDecl.flags, ASTFlags.TypeReference) ?
                createConstructorTypeDeclaration(funcDecl, context) :
                createConstructSignatureDeclaration(funcDecl, context);
        }
        else if (hasFlag(funcDecl.fncFlags, FncFlags.CallMember)) {
            return createCallSignatureDeclaration(funcDecl, context);
        }
        else if (hasFlag(funcDecl.fncFlags, FncFlags.IndexerMember)) {
            return createIndexSignatureDeclaration(funcDecl, context);
        }
        else if (hasFlag(funcDecl.flags, ASTFlags.TypeReference)) {
            return createFunctionTypeDeclaration(funcDecl, context);
        }
        else if (hasFlag(funcDecl.fncFlags, FncFlags.Method) ||
                 hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod)) {
            return createMemberFunctionDeclaration(funcDecl, context);
        }

        return createFunctionDeclaration(funcDecl, context);
    }

    export function preCollectDecls(ast: AST, parentAST: AST, walker: IAstWalker) {
        var context: DeclCollectionContext = walker.state;
        var go = false;

        if (ast.nodeType == NodeType.Script) {
            var script: Script = <Script>ast;
            var span = TextSpan.fromBounds(script.minChar, script.limChar);

            var decl = new PullDecl(context.scriptName, PullElementKind.Script, PullElementFlags.None, span, context.scriptName);

            context.pushParent(decl);

            go = true;
        }
        else if (ast.nodeType == NodeType.List) {
            go = true;
        }
        else if (ast.nodeType == NodeType.Block) {
            go = true;
        }
        else if (ast.nodeType == NodeType.ModuleDeclaration) {
            go = preCollectModuleDecls(ast, parentAST, context);
        }
        else if (ast.nodeType == NodeType.ClassDeclaration) {
            go = preCollectClassDecls(ast, parentAST, context);
        }
        else if (ast.nodeType == NodeType.InterfaceDeclaration) {
            go = preCollectInterfaceDecls(ast, parentAST, context);
        }
        else if (ast.nodeType == NodeType.ArgDecl) {
            go = preCollectParameterDecl(ast, parentAST, context);
        }
        else if (ast.nodeType == NodeType.VarDecl) {
            go = preCollectVarDecls(ast, parentAST, context);
        }
        else if (ast.nodeType == NodeType.FuncDecl) {
            go = preCollectFuncDecls(ast, parentAST, context);
        }
        else if (ast.nodeType == NodeType.ImportDeclaration) {
            go = preCollectImportDecls(ast, parentAST, context);
        }
        else if (ast.nodeType == NodeType.TypeParameter) {
            go = preCollectTypeParameterDecl(ast, parentAST, context);
        }
        else if (ast.nodeType == NodeType.If) {
            go = true;
        }
        else if (ast.nodeType == NodeType.For) {
            go = true;
        }
        else if (ast.nodeType == NodeType.ForIn) {
            go = true;
        }
        else if (ast.nodeType == NodeType.While) {
            go = true;
        }
        else if (ast.nodeType == NodeType.DoWhile) {
            go = true;
        }
        else if (ast.nodeType == NodeType.Comma) {
            go = true;
        }
        else if (ast.nodeType == NodeType.Return) {
            // want to be able to bind lambdas in return positions
            go = true;
        }
        else if (ast.nodeType == NodeType.Switch || ast.nodeType == NodeType.Case) {
            go = true;
        }

            // call and 'new' expressions may contain lambdas with bindings...
        else if (ast.nodeType == NodeType.Call) {
            // want to be able to bind lambdas in return positions
            go = true;
        }
        else if (ast.nodeType == NodeType.New) {
            // want to be able to bind lambdas in return positions
            go = true;
        }
        else if (ast.nodeType == NodeType.TryCatch) {
            go = true;
        }
        else if (ast.nodeType == NodeType.TryFinally) {
            go = true;
        }
        else if (ast.nodeType == NodeType.Try) {
            go = true;
        }
        else if (ast.nodeType == NodeType.Catch) {
            go = true;
        }
        else if (ast.nodeType == NodeType.Finally) {
            go = true;
        }

        walker.options.goChildren = go;

        return ast;
    }

    function isContainer(decl: PullDecl): bool {
        return decl.getKind() == PullElementKind.Container || decl.getKind() == PullElementKind.DynamicModule;
    }

    function getInitializationFlag(decl: PullDecl): PullElementFlags {
        if (decl.getKind() & PullElementKind.Container) {
            return PullElementFlags.InitializedModule;
        }
        else if (decl.getKind() & PullElementKind.DynamicModule) {
            return PullElementFlags.InitializedDynamicModule;
        }

        return PullElementFlags.None;
    }

    function hasInitializationFlag(decl: PullDecl): bool {
        if (decl.getKind() & PullElementKind.Container) {
            return (decl.getFlags() & PullElementFlags.InitializedModule) !== 0;
        }
        else if (decl.getKind() & PullElementKind.DynamicModule) {
            return (decl.getFlags() & PullElementFlags.InitializedDynamicModule) !== 0;
        }

        return false;
    }

    export function postCollectDecls(ast: AST, parentAST: AST, walker: IAstWalker) {
        var context: DeclCollectionContext = walker.state;
        var parentDecl: PullDecl;
        var initFlag = PullElementFlags.None;

        // Note that we never pop the Script - after the traversal, it should be the
        // one parent left in the context


        if (ast.nodeType == NodeType.ModuleDeclaration) {
            var thisModule = context.getParent();
            context.popParent();
            parentDecl = context.getParent();

            if (hasInitializationFlag(thisModule)) {

                if (parentDecl && isContainer(parentDecl)) {
                    initFlag = getInitializationFlag(parentDecl);
                    parentDecl.setFlags(parentDecl.getFlags() | initFlag);
                }

                // create the value decl
                var valueDecl = new PullDecl(thisModule.getName(), PullElementKind.Variable, thisModule.getFlags(), thisModule.getSpan(), context.scriptName);

                thisModule.setValueDecl(valueDecl);

                context.semanticInfo.setASTForDecl(valueDecl, ast);

                if (parentDecl) {
                    parentDecl.addChildDecl(valueDecl);
                    valueDecl.setParentDecl(parentDecl);
                }
            }
        }
        else if (ast.nodeType == NodeType.ClassDeclaration) {
            context.popParent();

            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }
        }
        else if (ast.nodeType == NodeType.InterfaceDeclaration) {
            context.popParent();
        }
        else if (ast.nodeType == NodeType.FuncDecl) {
            context.popParent();

            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }
        }
        else if (ast.nodeType == NodeType.VarDecl) { // PULLREVIEW: What if we just have a for loop in a module body?
            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }
        }

        return ast;
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {
    export var globalBindingPhase = 0;

    export class PullSymbolBinder {
        private parentChain: PullTypeSymbol[] = [];
        private parentDeclChain: PullDecl[] = [];
        private declPath: string[] = [];

        private bindingPhase = globalBindingPhase++;

        private staticClassMembers: PullSymbol[] = [];

        public semanticInfo: SemanticInfo;

        public reBindingAfterChange = false;
        public startingDeclForRebind = pullDeclID; // note that this gets set on creation
        public startingSymbolForRebind = pullSymbolID; // note that this gets set on creation

        constructor(private compilationSettings: CompilationSettings,
                    public semanticInfoChain: SemanticInfoChain) {
        }

        public setUnit(fileName: string) {
            this.semanticInfo = this.semanticInfoChain.getUnit(fileName);
        }

        public getParent(returnInstanceType = false): PullTypeSymbol {
            var parent = this.parentChain ? this.parentChain[this.parentChain.length - 1] : null;

            if (parent && parent.isContainer() && returnInstanceType) {
                var instanceSymbol = (<PullContainerTypeSymbol>parent).getInstanceSymbol();

                if (instanceSymbol) {
                    parent = instanceSymbol.getType();
                }
            }

            return parent;
        }

        public getParentDecl(): PullDecl {
            return this.parentDeclChain.length ? this.parentDeclChain[this.parentDeclChain.length - 1] : null;
        }

        public getDeclPath() { return this.declPath; }

        public pushParent(parentType: PullTypeSymbol, parentDecl: PullDecl) {
            if (parentType) {
                this.parentChain[this.parentChain.length] = parentType;
                this.parentDeclChain[this.parentDeclChain.length] = parentDecl;
                this.declPath[this.declPath.length] = parentType.getName();
            }
        }

        public popParent() {
            if (this.parentChain.length) {
                this.parentChain.length--;
                this.parentDeclChain.length--;
                this.declPath.length--;
            }
        }

        public findSymbolInContext(name: string, declKind: PullElementKind, typeLookupPath: string[]): PullSymbol {
            var startTime = new Date().getTime();
            var contextSymbolPath: string[] = this.getDeclPath();
            var nestedSymbolPath: string[] = [];
            var copyOfContextSymbolPath = [];
            var symbol: PullSymbol = null;

            var i = 0;
            var endTime = 0;


            // first, search within the given symbol path
            if (typeLookupPath.length) {

                for (i = 0; i < typeLookupPath.length; i++) {
                    nestedSymbolPath[nestedSymbolPath.length] = typeLookupPath[i];
                }

                nestedSymbolPath[nestedSymbolPath.length] = name;

                while (nestedSymbolPath.length >= 2) {
                    symbol = this.semanticInfoChain.findSymbol(nestedSymbolPath, declKind);

                    if (symbol) {
                        endTime = new Date().getTime();
                        time_in_findSymbol += endTime - startTime;

                        return symbol;
                    }
                    nestedSymbolPath.length -= 2;
                    nestedSymbolPath[nestedSymbolPath.length] = name;
                }
            }

            // next, link back up to the enclosing context
            if (contextSymbolPath.length) {

                for (i = 0; i < contextSymbolPath.length; i++) {
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i];
                }

                for (i = 0; i < typeLookupPath.length; i++) {
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = typeLookupPath[i];
                }

                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;

                while (copyOfContextSymbolPath.length >= 2) {
                    symbol = this.semanticInfoChain.findSymbol(copyOfContextSymbolPath, declKind);

                    if (symbol) {
                        endTime = new Date().getTime();
                        time_in_findSymbol += endTime - startTime;

                        return symbol;
                    }
                    copyOfContextSymbolPath.length -= 2;
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
                }
            }

            // finally, try searching globally
            symbol = this.semanticInfoChain.findSymbol([name], declKind);

            endTime = new Date().getTime();
            time_in_findSymbol += endTime - startTime;

            return symbol;
        }

        private recordNonInterfaceParentModule() {
            var parent = this.getParent();
            if (parent) {
                var ast = this.semanticInfo.getASTForSymbol(parent);
                if (ast && ast.nodeType == NodeType.ModuleDeclaration) {
                    (<ModuleDeclaration>ast).recordNonInterface();
                }
            }
        }

        public symbolIsRedeclaration(sym: PullSymbol): bool {
            var symID = sym.getSymbolID();
            return (symID > this.startingSymbolForRebind) ||
                    ((sym.getRebindingID() == this.bindingPhase) && (symID != this.startingSymbolForRebind));
        }

        //
        // decl binding
        //

        public bindModuleDeclarationToPullSymbol(moduleContainerDecl: PullDecl) {

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var modName = moduleContainerDecl.getName();

            var moduleContainerTypeSymbol: PullContainerTypeSymbol = null;
            var moduleInstanceSymbol: PullSymbol = null;
            var moduleInstanceTypeSymbol: PullTypeSymbol = null;

            var moduleInstanceDecl: PullDecl = moduleContainerDecl.getValueDecl();

            var moduleKind = moduleContainerDecl.getKind();

            var parent = this.getParent();
            var parentInstanceSymbol = this.getParent(true);
            var moduleAST = <ModuleDeclaration>this.semanticInfo.getASTForDecl(moduleContainerDecl);

            var createdNewSymbol = false;
            var i = 0;

            if (parent) {
                moduleContainerTypeSymbol = <PullContainerTypeSymbol>parent.findNestedType(modName);
            }
            else if (!(moduleContainerDecl.getFlags() & PullElementFlags.Exported)) {
                moduleContainerTypeSymbol = <PullContainerTypeSymbol>this.findSymbolInContext(modName, PullElementKind.SomeType, []);
            }

            if (moduleContainerTypeSymbol && moduleContainerTypeSymbol.getKind() != moduleKind) {
                // duplicate symbol error
                moduleContainerDecl.addDiagnostic(new PullDiagnostic(
                    moduleAST.minChar, moduleAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [modName])));

                moduleContainerTypeSymbol = null;
            }

            if (moduleContainerTypeSymbol) {
                moduleInstanceSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
            }
            else { 
                moduleContainerTypeSymbol = new PullContainerTypeSymbol(modName, moduleKind);
                createdNewSymbol = true;
            }

            if (!moduleInstanceSymbol && (moduleContainerDecl.getFlags() & PullElementFlags.SomeInitializedModule)) {
                moduleInstanceTypeSymbol = new PullTypeSymbol(modName, PullElementKind.ObjectType);
                moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);

                moduleInstanceTypeSymbol.setAssociatedContainerType(moduleContainerTypeSymbol);

                // The instance symbol is further set up in bindVariableDeclaration
                moduleInstanceSymbol = new PullSymbol(modName, PullElementKind.Variable);
                moduleInstanceSymbol.setType(moduleInstanceTypeSymbol);
                moduleInstanceSymbol.addDeclaration(moduleContainerDecl);

                moduleContainerTypeSymbol.setInstanceSymbol(moduleInstanceSymbol);
            }

            moduleContainerTypeSymbol.addDeclaration(moduleContainerDecl);
            moduleContainerDecl.setSymbol(moduleContainerTypeSymbol);

            this.semanticInfo.setSymbolForAST(moduleAST.name, moduleContainerTypeSymbol);
            this.semanticInfo.setSymbolForAST(moduleAST, moduleContainerTypeSymbol);

            if (createdNewSymbol) {

                if (parent) {
                    var linkKind = moduleContainerDecl.getFlags() & PullElementFlags.Exported ? SymbolLinkKind.PublicMember : SymbolLinkKind.PrivateMember;

                    if (linkKind == SymbolLinkKind.PublicMember) {
                        parent.addMember(moduleContainerTypeSymbol, linkKind);

                        if (moduleInstanceSymbol && parentInstanceSymbol && (parentInstanceSymbol != moduleInstanceSymbol)) {
                            parentInstanceSymbol.addMember(moduleInstanceSymbol, linkKind);
                        }
                    }
                    else {
                        moduleContainerTypeSymbol.setContainer(parent);

                        if (moduleInstanceSymbol && parentInstanceSymbol && (parentInstanceSymbol != moduleInstanceSymbol)) {
                            moduleInstanceSymbol.setContainer(parentInstanceSymbol);
                        }
                    }
                }
            }
            else if (this.reBindingAfterChange) {
                // clear out the old decls...
                var decls = moduleContainerTypeSymbol.getDeclarations();
                var scriptName = moduleContainerDecl.getScriptName();

                for (i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        moduleContainerTypeSymbol.removeDeclaration(decls[i]);
                    }
                }

                if (moduleInstanceSymbol) {
                    decls = moduleInstanceSymbol.getDeclarations();

                    for (i = 0; i < decls.length; i++) {
                        if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                            moduleInstanceSymbol.removeDeclaration(decls[i]);
                        }
                    }

                    moduleInstanceTypeSymbol = moduleInstanceSymbol.getType();

                    decls = moduleInstanceTypeSymbol.getDeclarations();

                    for (i = 0; i < decls.length; i++) {
                        if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                            moduleInstanceTypeSymbol.removeDeclaration(decls[i]);
                        }
                    }

                    // add the current module decl to the declaration list, to make up for the ones we just deleted
                    moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);

                    moduleInstanceSymbol.invalidate();
                }

                moduleContainerTypeSymbol.invalidate();
            }
            this.recordNonInterfaceParentModule();

            this.pushParent(moduleContainerTypeSymbol, moduleContainerDecl);

            var childDecls = moduleContainerDecl.getChildDecls();

            for (i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();
        }

        // aliases
        public bindImportDeclaration(importDeclaration: PullDecl) {
            var declFlags = importDeclaration.getFlags();
            var declKind = importDeclaration.getKind();
            var importDeclAST = <VarDecl>this.semanticInfo.getASTForDecl(importDeclaration);

            var isExported = false;
            var linkKind = SymbolLinkKind.PrivateMember;
            var importSymbol: PullTypeAliasSymbol = null;
            var declName = importDeclaration.getName();
            var parentHadSymbol = false;
            var parent = this.getParent();

            if (parent) {
                importSymbol = <PullTypeAliasSymbol>parent.findMember(declName);

                if (!importSymbol) {
                    importSymbol = <PullTypeAliasSymbol>parent.findContainedMember(declName);
                }
            }
            else if (!(importDeclaration.getFlags() & PullElementFlags.Exported)) {
                importSymbol = <PullTypeAliasSymbol>this.findSymbolInContext(declName, PullElementKind.SomeType, []);
            }

            if (importSymbol) {
                parentHadSymbol = true;
            }

            if (importSymbol && this.symbolIsRedeclaration(importSymbol)) {
                importDeclaration.addDiagnostic(new PullDiagnostic(importDeclAST.minChar, importDeclAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [declName])));
                importSymbol = null;
            }

            if (this.reBindingAfterChange && importSymbol) {

                // prune out-of-date decls...
                var decls = importSymbol.getDeclarations();
                var scriptName = importDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        importSymbol.removeDeclaration(decls[j]);
                    }
                }

                importSymbol.setUnresolved();
            }

            if (!importSymbol) {
                importSymbol = new PullTypeAliasSymbol(declName);
            }

            importSymbol.addDeclaration(importDeclaration);
            importDeclaration.setSymbol(importSymbol);

            this.semanticInfo.setSymbolForAST(importDeclAST, importSymbol);

            if (parent && !parentHadSymbol) {

                if (declFlags & PullElementFlags.Exported) {
                    parent.addMember(importSymbol, SymbolLinkKind.PublicMember);
                }
                else {
                    importSymbol.setContainer(parent);
                }
            }
            this.recordNonInterfaceParentModule();

            importSymbol.setIsBound(this.bindingPhase);
        }

        // enums
        public bindEnumDeclarationToPullSymbol(enumDeclaration: PullDecl) {
            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one
            var enumName = enumDeclaration.getName();
            var enumSymbol = <PullTypeSymbol>this.findSymbolInContext(enumName, PullElementKind.Enum, []);

            var enumAST = <ModuleDeclaration>this.semanticInfo.getASTForDecl(enumDeclaration);
            var createdNewSymbol = false;
            var parent = this.getParent();

            var i = 0;

            if (parent) {
                enumSymbol = parent.findNestedType(enumName);
            }
            else if (!(enumDeclaration.getFlags() & PullElementFlags.Exported)) {
                enumSymbol = <PullTypeSymbol>this.findSymbolInContext(enumName, PullElementKind.SomeType, []);
            }

            if (enumSymbol && (enumSymbol.getKind() != PullElementKind.Enum || !this.reBindingAfterChange || this.symbolIsRedeclaration(enumSymbol))) {
                enumDeclaration.addDiagnostic(new PullDiagnostic(enumAST.minChar, enumAST.getLength(), this.semanticInfo.getPath(),
                    getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [enumName])));
                enumSymbol = null;
            }

            if (!enumSymbol) {
                enumSymbol = new PullTypeSymbol(enumName, PullElementKind.Enum);

                enumSymbol.addDeclaration(enumDeclaration);
                enumDeclaration.setSymbol(enumSymbol);

                createdNewSymbol = true;
            }

            enumSymbol.addDeclaration(enumDeclaration);
            enumDeclaration.setSymbol(enumSymbol);

            this.semanticInfo.setSymbolForAST(enumAST.name, enumSymbol);
            this.semanticInfo.setSymbolForAST(enumAST, enumSymbol);

            if (createdNewSymbol) {

                if (parent) {
                    var linkKind = enumDeclaration.getFlags() & PullElementFlags.Exported ? SymbolLinkKind.PublicMember : SymbolLinkKind.PrivateMember;

                    if (linkKind == SymbolLinkKind.PublicMember) {
                        parent.addMember(enumSymbol, linkKind);
                    }
                    else {
                        enumSymbol.setContainer(parent);
                    }
                }
            }
            else if (this.reBindingAfterChange) {
                // clear out the old decls...
                var decls = enumSymbol.getDeclarations();
                var scriptName = enumDeclaration.getScriptName();

                for (i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        enumSymbol.removeDeclaration(decls[i]);
                    }
                }

                enumSymbol.invalidate();
            }
            this.recordNonInterfaceParentModule();

            this.pushParent(enumSymbol, enumDeclaration);

            var childDecls = enumDeclaration.getChildDecls();

            for (i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();

            enumSymbol.setIsBound(this.bindingPhase);
        }

        // classes
        public bindClassDeclarationToPullSymbol(classDecl: PullDecl) {

            var className = classDecl.getName();
            var classSymbol: PullClassTypeSymbol = null;

            var constructorSymbol: PullSymbol = null;
            var constructorTypeSymbol: PullConstructorTypeSymbol = null;

            var classAST = <ClassDeclaration>this.semanticInfo.getASTForDecl(classDecl);
            var parentHadSymbol = false;

            var parent = this.getParent();
            var cleanedPreviousDecls = false;
            var isExported = classDecl.getFlags() & PullElementFlags.Exported;

            var i = 0;
            var j = 0;

            if (parent) {
                if (isExported) {
                    classSymbol = <PullClassTypeSymbol>parent.findMember(className);
                }
                else {
                    classSymbol = <PullClassTypeSymbol>parent.findContainedMember(className);
                }
            }
            else {
                classSymbol = <PullClassTypeSymbol>this.findSymbolInContext(className, PullElementKind.SomeType, []);
            }

            if (classSymbol && (classSymbol.getKind() != PullElementKind.Class || !this.reBindingAfterChange || this.symbolIsRedeclaration(classSymbol))) {
                classDecl.addDiagnostic(new PullDiagnostic(classAST.minChar, classAST.getLength(), this.semanticInfo.getPath(),
                    getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [className])));
                classSymbol = null;
            }
            else if (classSymbol) {
                parentHadSymbol = true;
            }

            var decls: PullDecl[];

            if (this.reBindingAfterChange && classSymbol) {

                // prune out-of-date decls
                decls = classSymbol.getDeclarations();
                var scriptName = classDecl.getScriptName();

                for (j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        classSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                constructorSymbol = classSymbol.getConstructorMethod();
                constructorTypeSymbol = <PullConstructorTypeSymbol>constructorSymbol.getType();

                decls = constructorSymbol.getDeclarations();

                for (j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        constructorSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                if (constructorSymbol.getIsSynthesized()) {
                    constructorSymbol.addDeclaration(classDecl);
                }

                if (classSymbol.isGeneric()) {
                    //classSymbol.invalidateSpecializations();

                    var specializations = classSymbol.getKnownSpecializations();
                    var specialization: PullTypeSymbol = null;

                    for (i = 0; i < specializations.length; i++) {
                        specialization = specializations[i];

                        decls = specialization.getDeclarations();

                        for (j = 0; j < decls.length; j++) {
                            if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                                specialization.removeDeclaration(decls[j]);

                                cleanedPreviousDecls = true;
                            }
                        }

                        specialization.addDeclaration(classDecl);
                    }

                    classSymbol.cleanTypeParameters();
                    constructorTypeSymbol.cleanTypeParameters();
                }

                classSymbol.setUnresolved();
                constructorSymbol.setUnresolved();
                constructorTypeSymbol.setUnresolved();
            }

            if (!parentHadSymbol) {
                classSymbol = new PullClassTypeSymbol(className);
            }

            classSymbol.addDeclaration(classDecl);

            classDecl.setSymbol(classSymbol);

            this.semanticInfo.setSymbolForAST(classAST.name, classSymbol);
            this.semanticInfo.setSymbolForAST(classAST, classSymbol);

            if (parent && !parentHadSymbol) {
                var linkKind = classDecl.getFlags() & PullElementFlags.Exported ? SymbolLinkKind.PublicMember : SymbolLinkKind.PrivateMember;

                if (linkKind == SymbolLinkKind.PublicMember) {
                    parent.addMember(classSymbol, linkKind);
                }
                else {
                    classSymbol.setContainer(parent);
                }
            }
            this.recordNonInterfaceParentModule();

            // PULLTODO: For now, remove stale signatures from the function type, but we want to be smarter about this when
            // incremental parsing comes online
            // PULLTODO: For now, classes should have none of these, though a pre-existing constructor might
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = classSymbol.getCallSignatures();
                var constructSigs = classSymbol.getConstructSignatures();
                var indexSigs = classSymbol.getIndexSignatures();

                for (i = 0; i < callSigs.length; i++) {
                    classSymbol.removeCallSignature(callSigs[i], false);
                }
                for (i = 0; i < constructSigs.length; i++) {
                    classSymbol.removeConstructSignature(constructSigs[i], false);
                }
                for (i = 0; i < indexSigs.length; i++) {
                    classSymbol.removeIndexSignature(indexSigs[i], false);
                }

                constructorSymbol = classSymbol.getConstructorMethod();
                constructorTypeSymbol = <PullConstructorTypeSymbol>(constructorSymbol ? constructorSymbol.getType() : null);

                if (constructorTypeSymbol) {
                    constructSigs = constructorTypeSymbol.getConstructSignatures();

                    for (i = 0; i < constructSigs.length; i++) {
                        constructorTypeSymbol.removeConstructSignature(constructSigs[i], false);
                    }
                }

                // just invalidate this once, so we don't pay the cost of rebuilding caches
                // for each signature removed
                classSymbol.invalidate();
            }

            this.pushParent(classSymbol, classDecl);

            var childDecls = classDecl.getChildDecls();

            for (i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();

            // create the default constructor symbol, if necessary

            // even if we've already tried to set these, we want to try again after we've walked the class members
            constructorSymbol = classSymbol.getConstructorMethod();
            constructorTypeSymbol = <PullConstructorTypeSymbol>(constructorSymbol ? constructorSymbol.getType() : null);

            if (!constructorSymbol) {
                constructorSymbol = new PullSymbol(className, PullElementKind.ConstructorMethod);
                constructorTypeSymbol = new PullConstructorTypeSymbol();

                constructorSymbol.setIsSynthesized();

                constructorSymbol.setType(constructorTypeSymbol);
                constructorSymbol.addDeclaration(classDecl);
                classSymbol.setConstructorMethod(constructorSymbol);

                constructorTypeSymbol.addDeclaration(classDecl);

                classSymbol.setHasDefaultConstructor();

                if (!classAST.extendsList || !classAST.extendsList.members.length) {
                    var constructorSignature = new PullSignatureSymbol(PullElementKind.ConstructSignature);
                    constructorSignature.setReturnType(classSymbol);
                    constructorTypeSymbol.addConstructSignature(constructorSignature);
                    constructorSignature.addDeclaration(classDecl);
                }

                // set the class decl's AST to the class declaration
                this.semanticInfo.setASTForDecl(classDecl, classAST);
            }

            constructorTypeSymbol.setAssociatedContainerType(classSymbol);

            // bind statics to the constructor symbol
            if (this.staticClassMembers.length) {
                var member: PullSymbol;
                var isPrivate = false;
                var memberMap: any = {};
                var memberDecl: PullDecl;
                var memberAST: AST;

                for (i = 0; i < this.staticClassMembers.length; i++) {

                    member = this.staticClassMembers[i];

                    if (memberMap[member.getName()]) {
                        memberDecl = member.getDeclarations()[0];
                        memberAST = this.semanticInfo.getASTForDecl(memberDecl);
                        memberDecl.addDiagnostic(new PullDiagnostic(memberAST.minChar, memberAST.getLength(), this.semanticInfo.getPath(),
                            getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [member.getName()])));
                    }
                    else {
                        memberMap[member.getName()] = true;
                    }

                    isPrivate = member.hasFlag(PullElementFlags.Private);

                    constructorTypeSymbol.addMember(member, isPrivate ? SymbolLinkKind.PrivateMember : SymbolLinkKind.PublicMember);
                }

                this.staticClassMembers.length = 0;
            }

            var typeParameters = classDecl.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            // PULLREVIEW: Now that we clean type paramters, searching is redundant
            for (i = 0; i < typeParameters.length; i++) {

                typeParameter = classSymbol.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());

                    classSymbol.addMember(typeParameter, SymbolLinkKind.TypeParameter);
                    constructorTypeSymbol.addTypeParameter(typeParameter);
                }
                else {
                    // clean the decls
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            classSymbol.setIsBound(this.bindingPhase);
        }

        // interfaces
        public bindInterfaceDeclarationToPullSymbol(interfaceDecl: PullDecl) {

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one
            var interfaceName = interfaceDecl.getName();
            var interfaceSymbol: PullTypeSymbol = <PullTypeSymbol>this.findSymbolInContext(interfaceName, PullElementKind.SomeType, []);

            var interfaceAST = <TypeDeclaration>this.semanticInfo.getASTForDecl(interfaceDecl);
            var createdNewSymbol = false;
            var parent = this.getParent();

            var i = 0;
            var j = 0;

            if (parent) {
                interfaceSymbol = parent.findNestedType(interfaceName);
            }
            else if (!(interfaceDecl.getFlags() & PullElementFlags.Exported)) {
                interfaceSymbol = <PullClassTypeSymbol>this.findSymbolInContext(interfaceName, PullElementKind.SomeType, []);
            }

            if (interfaceSymbol && (interfaceSymbol.getKind() != PullElementKind.Interface)) {
                interfaceDecl.addDiagnostic(new PullDiagnostic(interfaceAST.minChar, interfaceAST.getLength(), this.semanticInfo.getPath(),
                    getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [interfaceName])));
                interfaceSymbol = null;
            }

            if (!interfaceSymbol) {
                interfaceSymbol = new PullTypeSymbol(interfaceName, PullElementKind.Interface);
                createdNewSymbol = true;
            }

            interfaceSymbol.addDeclaration(interfaceDecl);
            interfaceDecl.setSymbol(interfaceSymbol);

            this.semanticInfo.setSymbolForAST(interfaceAST.name, interfaceSymbol);
            this.semanticInfo.setSymbolForAST(interfaceAST, interfaceSymbol);

            if (createdNewSymbol) {

                if (parent) {
                    var linkKind = interfaceDecl.getFlags() & PullElementFlags.Exported ? SymbolLinkKind.PublicMember : SymbolLinkKind.PrivateMember;

                    if (linkKind == SymbolLinkKind.PublicMember) {
                        parent.addMember(interfaceSymbol, linkKind);
                    }
                    else {
                        interfaceSymbol.setContainer(parent);
                    }
                }
            }
            else if (this.reBindingAfterChange) {
                // clear out the old decls...
                var decls = interfaceSymbol.getDeclarations();
                var scriptName = interfaceDecl.getScriptName();

                for (i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() == scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        interfaceSymbol.removeDeclaration(decls[i]);
                    }
                }

                if (interfaceSymbol.isGeneric()) {

                    //interfaceSymbol.invalidateSpecializations();

                    var specializations = interfaceSymbol.getKnownSpecializations();
                    var specialization: PullTypeSymbol = null;

                    for (i = 0; i < specializations.length; i++) {
                        specialization = specializations[i];

                        decls = specialization.getDeclarations();

                        for (j = 0; j < decls.length; j++) {
                            if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                                specialization.removeDeclaration(decls[j]);
                            }
                        }

                        specialization.addDeclaration(interfaceDecl);
                    }

                    interfaceSymbol.cleanTypeParameters();

                    interfaceSymbol.setUnresolved();
                }
            }

            this.pushParent(interfaceSymbol, interfaceDecl);

            var childDecls = interfaceDecl.getChildDecls();

            for (i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();

            var typeParameters = interfaceDecl.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            // PULLREVIEW: Now that we clean type paramters, searching is redundant
            for (i = 0; i < typeParameters.length; i++) {

                typeParameter = interfaceSymbol.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());

                    interfaceSymbol.addMember(typeParameter, SymbolLinkKind.TypeParameter);
                }
                else {
                    // clean the decls
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        }

        public bindObjectTypeDeclarationToPullSymbol(objectDecl: PullDecl) {
            var objectSymbolAST: AST = this.semanticInfo.getASTForDecl(objectDecl);

            var objectSymbol = new PullTypeSymbol("", PullElementKind.ObjectType);

            objectSymbol.addDeclaration(objectDecl);
            objectDecl.setSymbol(objectSymbol);

            this.semanticInfo.setSymbolForAST(objectSymbolAST, objectSymbol);

            this.pushParent(objectSymbol, objectDecl);

            var childDecls = objectDecl.getChildDecls();

            var i = 0;

            for (i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();

            var typeParameters = objectDecl.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            for (i = 0; i < typeParameters.length; i++) {

                typeParameter = objectSymbol.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());

                    objectSymbol.addMember(typeParameter, SymbolLinkKind.TypeParameter);
                }
                else {
                    // clean the decls
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

        }

        public bindConstructorTypeDeclarationToPullSymbol(constructorTypeDeclaration: PullDecl) {
            var declKind = constructorTypeDeclaration.getKind();
            var declFlags = constructorTypeDeclaration.getFlags();
            var constructorTypeAST = this.semanticInfo.getASTForDecl(constructorTypeDeclaration);

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var constructorTypeSymbol = new PullConstructorTypeSymbol();

            constructorTypeDeclaration.setSymbol(constructorTypeSymbol);
            constructorTypeSymbol.addDeclaration(constructorTypeDeclaration);
            this.semanticInfo.setSymbolForAST(constructorTypeAST, constructorTypeSymbol);

            var signature = new PullDefinitionSignatureSymbol(PullElementKind.ConstructSignature);

            signature.addDeclaration(constructorTypeDeclaration);
            constructorTypeDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(constructorTypeDeclaration), constructorTypeSymbol, signature);

            // add the implicit construct member for this function type
            constructorTypeSymbol.addSignature(signature);

            var typeParameters = constructorTypeDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            for (var i = 0; i < typeParameters.length; i++) {

                typeParameter = constructorTypeSymbol.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());

                    constructorTypeSymbol.addTypeParameter(typeParameter);
                }
                else {
                    // clean the decls
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        }

        // variables
        public bindVariableDeclarationToPullSymbol(variableDeclaration: PullDecl) {
            var declFlags = variableDeclaration.getFlags();
            var declKind = variableDeclaration.getKind();
            var varDeclAST = <VarDecl>this.semanticInfo.getASTForDecl(variableDeclaration);

            var isExported = false;

            var linkKind = SymbolLinkKind.PrivateMember;

            var variableSymbol: PullSymbol = null;

            var declName = variableDeclaration.getName();

            var parentHadSymbol = false;

            var parent = this.getParent(true);

            var i = 0;

            // The code below accounts for the variable symbol being a type because
            // modules may create instance variables

            if (parent) {
                variableSymbol = parent.findMember(declName);

                if (!variableSymbol) {
                    variableSymbol = parent.findContainedMember(declName);
                    var parentDecl = this.getParentDecl();

                    if (variableSymbol && (parentDecl != variableSymbol.getDeclarations()[0].getParentDecl())) {
                        variableSymbol = null;
                    }
                }

            }
            else if (!(variableDeclaration.getFlags() & PullElementFlags.Exported)) {
                variableSymbol = this.findSymbolInContext(declName, PullElementKind.SomeValue, []);
            }

            if (variableSymbol && !variableSymbol.isType()) {
                parentHadSymbol = true;
            }

            var span: TextSpan;
            var decl: PullDecl;
            var decls: PullDecl[];
            var ast: AST;
            var members: PullSymbol[];

            // PULLTODO: Keeping these two error clauses separate for now, so that we can add a better error message later
            if (variableSymbol && this.symbolIsRedeclaration(variableSymbol)) {
                // if it's an implicit variable, then this variable symbol will actually be a class constructor
                // or container type that was just defined, so we don't want to raise an error
                if ((declFlags & PullElementFlags.ImplicitVariable) == 0) {
                    span = variableDeclaration.getSpan();

                    variableDeclaration.addDiagnostic(new PullDiagnostic(span.start(), span.length(), this.semanticInfo.getPath(),
                        getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [declName])));
                    variableSymbol = null;
                    parentHadSymbol = false;
                }
            }
            else if (variableSymbol && (variableSymbol.getKind() != PullElementKind.Variable) && ((declFlags & PullElementFlags.ImplicitVariable) == 0)) {
                span = variableDeclaration.getSpan();

                variableDeclaration.addDiagnostic(new PullDiagnostic(span.start(), span.length(), this.semanticInfo.getPath(),
                    getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [declName])));
                variableSymbol = null;
                parentHadSymbol = false;
            }

            if (this.reBindingAfterChange && variableSymbol && !variableSymbol.isType()) {

                // prune out-of-date decls...
                decls = variableSymbol.getDeclarations();
                var scriptName = variableDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        variableSymbol.removeDeclaration(decls[j]);
                    }
                }

                variableSymbol.invalidate();
            }

            if ((declFlags & PullElementFlags.ImplicitVariable) == 0) {
                if (!variableSymbol) {
                    variableSymbol = new PullSymbol(declName, declKind);
                }

                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);

                this.semanticInfo.setSymbolForAST(varDeclAST.id, variableSymbol);
                this.semanticInfo.setSymbolForAST(varDeclAST, variableSymbol);
            }
            else if (!parentHadSymbol) {

                if ((declFlags & PullElementFlags.ClassConstructorVariable)) {
                    // it's really an implicit class decl, so we need to set the type of the symbol to
                    // the constructor type
                    // Note that we would have already found the class symbol in the search above
                    var classTypeSymbol: PullClassTypeSymbol = <PullClassTypeSymbol>variableSymbol;

                    // PULLTODO: In both this case and the case below, we should have already received the
                    // class or module symbol as the variableSymbol found above
                    if (parent) {
                        members = parent.getMembers();

                        for (i = 0; i < members.length; i++) {
                            if ((members[i].getName() == declName) && (members[i].getKind() == PullElementKind.Class)) {
                                classTypeSymbol = <PullClassTypeSymbol>members[i];
                                break;
                            }
                        }
                    }

                    if (!classTypeSymbol) {
                        classTypeSymbol = <PullClassTypeSymbol>this.findSymbolInContext(declName, PullElementKind.SomeType, []);

                        if (classTypeSymbol && (classTypeSymbol.getKind() != PullElementKind.Class)) {
                            classTypeSymbol = null;
                        }
                    }

                    if (classTypeSymbol && classTypeSymbol.isClass()) { // protect against duplicate declarations
                        variableSymbol = classTypeSymbol.getConstructorMethod();
                        variableDeclaration.setSymbol(variableSymbol);

                        // set the AST to the constructor method's if possible
                        decls = classTypeSymbol.getDeclarations();

                        if (decls.length) {

                            decl = decls[decls.length - 1];
                            ast = this.semanticInfo.getASTForDecl(decl);

                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }
                    }
                    else {
                        // PULLTODO: Clodules/Interfaces on classes
                        if (!variableSymbol) {
                            variableSymbol = new PullSymbol(declName, declKind);
                        }

                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);

                        variableSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }
                }
                else if (declFlags & PullElementFlags.SomeInitializedModule) {
                    var moduleContainerTypeSymbol: PullContainerTypeSymbol = null;
                    var moduleParent = this.getParent(false);

                    if (moduleParent) {
                        members = moduleParent.getMembers();

                        for (i = 0; i < members.length; i++) {
                            if ((members[i].getName() == declName) && (members[i].isContainer())) {
                                moduleContainerTypeSymbol = <PullContainerTypeSymbol>members[i];
                                break;
                            }
                        }
                    }

                    if (!moduleContainerTypeSymbol) {
                        moduleContainerTypeSymbol = <PullContainerTypeSymbol>this.findSymbolInContext(declName, PullElementKind.SomeType, []);

                        if (moduleContainerTypeSymbol && (!moduleContainerTypeSymbol.isContainer())) {
                            moduleContainerTypeSymbol = null;
                        }
                    }

                    if (moduleContainerTypeSymbol) {
                        variableSymbol = moduleContainerTypeSymbol.getInstanceSymbol();

                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);

                        // set the AST to the constructor method's if possible
                        decls = moduleContainerTypeSymbol.getDeclarations();

                        if (decls.length) {

                            decl = decls[decls.length - 1];
                            ast = this.semanticInfo.getASTForDecl(decl);

                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }

                        // we added the variable to the parent when binding the module
                        parentHadSymbol = true;
                    }
                    else {
                        // PULLTODO: Raise an Error here
                        variableSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }
                }
            }
            else {
                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);
            }

            if (parent && !parentHadSymbol) {

                if (declFlags & PullElementFlags.Exported) {
                    parent.addMember(variableSymbol, SymbolLinkKind.PublicMember);
                }
                else {
                    variableSymbol.setContainer(parent);
                }
            }
            this.recordNonInterfaceParentModule();

            variableSymbol.setIsBound(this.bindingPhase);
        }

        // properties
        public bindPropertyDeclarationToPullSymbol(propertyDeclaration: PullDecl) {
            var declFlags = propertyDeclaration.getFlags();
            var declKind = propertyDeclaration.getKind();
            var propDeclAST = <VarDecl>this.semanticInfo.getASTForDecl(propertyDeclaration);

            var isStatic = false;
            var isOptional = false;
            var isImplicit = (declFlags & PullElementFlags.ImplicitVariable) != 0;

            var linkKind = SymbolLinkKind.PublicMember;

            var propertySymbol: PullSymbol = null;

            if (hasFlag(declFlags, PullElementFlags.Static)) {
                isStatic = true;
            }

            if (hasFlag(declFlags, PullElementFlags.Private)) {
                linkKind = SymbolLinkKind.PrivateMember;
            }

            if (hasFlag(declFlags, PullElementFlags.Optional)) {
                isOptional = true;
            }

            var declName = propertyDeclaration.getName();

            var parentHadSymbol = false;

            var parent = this.getParent(true);

            if (parent.isClass() && isStatic) {

                for (i = 0; i < this.staticClassMembers.length; i++) {
                    if (this.staticClassMembers[i].getName() == declName) {
                        propertySymbol = this.staticClassMembers[i];
                        break;
                    }
                }
            }
            else {
                propertySymbol = parent.findMember(declName);
            }

            if (propertySymbol && (!this.reBindingAfterChange || this.symbolIsRedeclaration(propertySymbol))) {

                if (!propertySymbol.isType() || 
                    !isImplicit ||
                    (!(<PullTypeSymbol>propertySymbol).isClass() && isImplicit)) {

                    // use the span, since we may not have an AST if this is a class constructor property for a class
                    // with an implicit constructor...
                    var span = propertyDeclaration.getSpan();

                    propertyDeclaration.addDiagnostic(new PullDiagnostic(span.start(), span.length(), this.semanticInfo.getPath(), getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [declName])));
                }
                
                propertySymbol = null;
            }

            if (propertySymbol) {
                parentHadSymbol = true;
            }

            if (this.reBindingAfterChange && propertySymbol) {

                // prune out-of-date decls...
                var decls = propertySymbol.getDeclarations();
                var scriptName = propertyDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        propertySymbol.removeDeclaration(decls[j]);
                    }
                }

                propertySymbol.setUnresolved();
            }

            var classTypeSymbol: PullClassTypeSymbol;

            if ((declFlags & PullElementFlags.ImplicitVariable) == 0) {
                if (!parentHadSymbol) {
                    propertySymbol = new PullSymbol(declName, declKind);
                }

                propertySymbol.addDeclaration(propertyDeclaration);
                propertyDeclaration.setSymbol(propertySymbol);

                this.semanticInfo.setSymbolForAST(propDeclAST.id, propertySymbol);
                this.semanticInfo.setSymbolForAST(propDeclAST, propertySymbol);
            }
            else {
                // it's really an implicit class decl, so we need to set the type of the symbol to
                // the constructor type

                if (parent) {
                    var members = parent.getMembers();

                    for (var i = 0; i < members.length; i++) {
                        if ((members[i].getName() == declName) && (members[i].getKind() == PullElementKind.Class)) {
                            classTypeSymbol = <PullClassTypeSymbol>members[i];
                            break;
                        }
                    }
                }

                if (!classTypeSymbol) {
                    classTypeSymbol = <PullClassTypeSymbol>this.findSymbolInContext(declName, PullElementKind.SomeType, []);

                    if (classTypeSymbol && (classTypeSymbol.getKind() != PullElementKind.Class)) {
                        classTypeSymbol = null;
                    }
                }

                if (classTypeSymbol) {
                    propertySymbol = classTypeSymbol.getConstructorMethod();
                    propertyDeclaration.setSymbol(propertySymbol);
                }
                else {
                    propertySymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                }

                propertySymbol.setResolved();
            }

            if (isOptional) {
                propertySymbol.setIsOptional();
            }

            if (parent && !parentHadSymbol) {
                if (parent.isClass()) {
                    classTypeSymbol = <PullClassTypeSymbol>parent;

                    if (isStatic) {
                        this.staticClassMembers[this.staticClassMembers.length] = propertySymbol;
                    }
                    else {
                        classTypeSymbol.addMember(propertySymbol, linkKind);
                    }
                }
                else {
                    parent.addMember(propertySymbol, linkKind);
                }
            }

            propertySymbol.setIsBound(this.bindingPhase);
        }

        // parameters
        public bindParameterSymbols(funcDecl: FuncDecl, funcType: PullTypeSymbol, signatureSymbol: PullSignatureSymbol) {
            // create a symbol for each ast
            // if it's a property, add the symbol to the enclosing type's member list
            var parameters: PullSymbol[] = [];
            var decl: PullDecl = null;
            var argDecl: BoundDecl = null;
            var parameterSymbol: PullSymbol = null;
            var isProperty = false;
            var params: any = new BlockIntrinsics();

            if (funcDecl.arguments) {

                for (var i = 0; i < funcDecl.arguments.members.length; i++) {
                    argDecl = <BoundDecl>funcDecl.arguments.members[i];
                    decl = this.semanticInfo.getDeclForAST(argDecl);
                    isProperty = hasFlag(argDecl.varFlags, VarFlags.Property);
                    parameterSymbol = new PullSymbol(argDecl.id.actualText, PullElementKind.Parameter);

                    if (funcDecl.variableArgList && i == funcDecl.arguments.members.length - 1) {
                        parameterSymbol.setIsVarArg();

                        if (argDecl.init || hasFlag(argDecl.id.flags, ASTFlags.OptionalName)) {
                            decl.addDiagnostic(new PullDiagnostic(argDecl.minChar, argDecl.getLength(), this.semanticInfo.getPath(), "Varargs may not be optional or have default parameters"));
                        }
                    }

                    if (decl.getFlags() & PullElementFlags.Optional) {
                        parameterSymbol.setIsOptional();
                    }

                    if (params[argDecl.id.actualText]) {
                        decl.addDiagnostic(new PullDiagnostic(argDecl.minChar, argDecl.getLength(), this.semanticInfo.getPath(),
                            getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [argDecl.id.actualText])));
                    }
                    else {
                        params[argDecl.id.actualText] = true;
                    }
                    if (decl) {
                        parameterSymbol.addDeclaration(decl);
                        decl.setSymbol(parameterSymbol);

                        var valDecl = decl.getValueDecl();

                        // if this is a parameter property, we still need to set the value decl
                        // for the function parameter
                        if (valDecl) {
                            valDecl.setSymbol(parameterSymbol);
                            parameterSymbol.addDeclaration(valDecl);
                        }
                    }
                    this.semanticInfo.setSymbolForAST(argDecl.id, parameterSymbol);
                    this.semanticInfo.setSymbolForAST(argDecl, parameterSymbol);

                    signatureSymbol.addParameter(parameterSymbol, parameterSymbol.getIsOptional());

                    if (signatureSymbol.isDefinition()) {
                        parameterSymbol.setContainer(funcType);
                    }

                    // PULLREVIEW: Shouldn't need this, since parameters are created off of decl collection
                    // add a member to the parent type
                    //if (decl && isProperty) {
                    //    parameterSymbol = new PullSymbol(argDecl.id.actualText, PullElementKind.Field);

                    //    parameterSymbol.addDeclaration(decl);
                    //    decl.setPropertySymbol(parameterSymbol);

                    //    var linkKind = (decl.getDeclFlags() & PullElementFlags.Private) ? SymbolLinkKind.PrivateProperty : SymbolLinkKind.PublicProperty;
                    //    var parent = context.getParent(1);
                    //    if (parent.hasBrand()) {
                    //        (<PullClassSymbol>parent).getInstanceType().addMember(parameterSymbol, linkKind);
                    //    }
                    //    else {
                    //        // PULLTODO: I don't think we ever even take this branch...
                    //        parent.addMember(parameterSymbol, linkKind);
                    //    }
                    //}
                }
            }
        }

        // function declarations
        public bindFunctionDeclarationToPullSymbol(functionDeclaration: PullDecl) {
            var declKind = functionDeclaration.getKind();
            var declFlags = functionDeclaration.getFlags();
            var funcDeclAST = <FuncDecl>this.semanticInfo.getASTForDecl(functionDeclaration);

            var isExported = (declFlags & PullElementFlags.Exported) != 0;

            var funcName = functionDeclaration.getName();

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var isSignature: bool = (declFlags & PullElementFlags.Signature) != 0;

            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;

            // PULLREVIEW: On a re-bind, there's no need to search far-and-wide: just look in the parent's member list
            var functionSymbol: PullSymbol = null;
            var functionTypeSymbol: PullFunctionTypeSymbol = null;

            var i = 0;
            var j = 0;

            if (parent) {
                functionSymbol = parent.findMember(funcName);

                if (!functionSymbol) {
                    functionSymbol = parent.findContainedMember(funcName);
                    var parentDecl = this.getParentDecl();

                    if (functionSymbol && (parentDecl != functionSymbol.getDeclarations()[0].getParentDecl())) {
                        functionSymbol = null;
                    }
                }
            }
            else if (!(functionDeclaration.getFlags() & PullElementFlags.Exported)) {
                functionSymbol = this.findSymbolInContext(funcName, PullElementKind.SomeValue, []);
            }

            if (functionSymbol && 
                (functionSymbol.getKind() != PullElementKind.Function ||
                    !isSignature && !functionSymbol.allDeclsHaveFlag(PullElementFlags.Signature))) {
                functionDeclaration.addDiagnostic(new PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(),
                    getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [funcName])));
                functionSymbol = null;
            }

            if (functionSymbol) {
                functionTypeSymbol = <PullFunctionTypeSymbol>functionSymbol.getType();
                parentHadSymbol = true;
            }

            if (this.reBindingAfterChange && functionSymbol) {

                // prune out-of-date decls...
                var decls = functionSymbol.getDeclarations();
                var scriptName = functionDeclaration.getScriptName();

                for (j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        functionSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                functionSymbol.invalidate();
            }

            if (!functionSymbol) {
                // PULLTODO: Make sure that we properly flag signature decl types when collecting decls
                functionSymbol = new PullSymbol(funcName, PullElementKind.Function);
                functionTypeSymbol = new PullFunctionTypeSymbol();

                functionSymbol.setType(functionTypeSymbol);
            }

            functionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionDeclaration);
            functionTypeSymbol.addDeclaration(functionDeclaration);

            this.semanticInfo.setSymbolForAST(funcDeclAST.name, functionSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, functionSymbol);


            if (parent && !parentHadSymbol) {
                if (isExported) {
                    parent.addMember(functionSymbol, SymbolLinkKind.PublicMember);
                }
                else {
                    functionSymbol.setContainer(parent);
                }
            }
            this.recordNonInterfaceParentModule();

            if (!isSignature) {
                this.pushParent(functionTypeSymbol, functionDeclaration);
            }

            // PULLTODO: For now, remove stale signatures from the function type, but we want to be smarter about this when
            // incremental parsing comes online
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = functionTypeSymbol.getCallSignatures();

                for (i = 0; i < callSigs.length; i++) {
                    functionTypeSymbol.removeCallSignature(callSigs[i], false);
                }

                // just invalidate this once, so we don't pay the cost of rebuilding caches
                // for each signature removed
                functionSymbol.invalidate();
                functionTypeSymbol.invalidate();
            }

            var signature = isSignature ? new PullSignatureSymbol(PullElementKind.CallSignature) : new PullDefinitionSignatureSymbol(PullElementKind.CallSignature);

            signature.addDeclaration(functionDeclaration);
            functionDeclaration.setSignatureSymbol(signature);

            if (funcDeclAST.variableArgList) {
                signature.setHasVariableParamList();
            }

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(functionDeclaration), functionTypeSymbol, signature);

            var typeParameters = functionDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            for (i = 0; i < typeParameters.length; i++) {

                typeParameter = signature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());

                    signature.addTypeParameter(typeParameter);
                }
                else {
                    // clean the decls
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            // add the implicit call member for this function type
            functionTypeSymbol.addSignature(signature);

            if (!isSignature) {
                var childDecls = functionDeclaration.getChildDecls();

                for (i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }

                this.popParent();
            }
        }

        public bindFunctionExpressionToPullSymbol(functionExpressionDeclaration: PullDecl) {
            var declKind = functionExpressionDeclaration.getKind();
            var declFlags = functionExpressionDeclaration.getFlags();
            var funcExpAST = <FuncDecl>this.semanticInfo.getASTForDecl(functionExpressionDeclaration);

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var functionSymbol: PullSymbol = new PullSymbol(functionExpressionDeclaration.getName(), PullElementKind.Function);
            var functionTypeSymbol = new PullFunctionTypeSymbol();

            functionSymbol.setType(functionTypeSymbol);

            functionExpressionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionExpressionDeclaration);

            if (funcExpAST.name) {
                this.semanticInfo.setSymbolForAST(funcExpAST.name, functionSymbol);
            }
            this.semanticInfo.setSymbolForAST(funcExpAST, functionSymbol);

            this.pushParent(functionTypeSymbol, functionExpressionDeclaration);

            var signature = new PullDefinitionSignatureSymbol(PullElementKind.CallSignature);

            if (funcExpAST.variableArgList) {
                signature.setHasVariableParamList();
            }

            var typeParameters = functionExpressionDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            for (var i = 0; i < typeParameters.length; i++) {

                typeParameter = signature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());

                    signature.addTypeParameter(typeParameter);
                }
                else {
                    // clean the decls
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(functionExpressionDeclaration);
            functionExpressionDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(functionExpressionDeclaration), functionTypeSymbol, signature);

            // add the implicit call member for this function type
            functionTypeSymbol.addSignature(signature);

            var childDecls = functionExpressionDeclaration.getChildDecls();

            for (i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            this.popParent();
        }

        public bindFunctionTypeDeclarationToPullSymbol(functionTypeDeclaration: PullDecl) {
            var declKind = functionTypeDeclaration.getKind();
            var declFlags = functionTypeDeclaration.getFlags();
            var funcTypeAST = <FuncDecl>this.semanticInfo.getASTForDecl(functionTypeDeclaration);

            // 1. Test for existing decl - if it exists, use its symbol
            // 2. If no other decl exists, create a new symbol and use that one

            var functionTypeSymbol = new PullFunctionTypeSymbol();

            functionTypeDeclaration.setSymbol(functionTypeSymbol);
            functionTypeSymbol.addDeclaration(functionTypeDeclaration);
            this.semanticInfo.setSymbolForAST(funcTypeAST, functionTypeSymbol);

            this.pushParent(functionTypeSymbol, functionTypeDeclaration);

            var signature = new PullDefinitionSignatureSymbol(PullElementKind.CallSignature);

            if (funcTypeAST.variableArgList) {
                signature.setHasVariableParamList();
            }

            var typeParameters = functionTypeDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            for (var i = 0; i < typeParameters.length; i++) {

                typeParameter = signature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());

                    signature.addTypeParameter(typeParameter);
                }
                else {
                    // clean the decls
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(functionTypeDeclaration);
            functionTypeDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(functionTypeDeclaration), functionTypeSymbol, signature);

            // add the implicit call member for this function type
            functionTypeSymbol.addSignature(signature);

            this.popParent();
        }

        // method declarations
        public bindMethodDeclarationToPullSymbol(methodDeclaration: PullDecl) {
            var declKind = methodDeclaration.getKind();
            var declFlags = methodDeclaration.getFlags();
            var methodAST = <FuncDecl>this.semanticInfo.getASTForDecl(methodDeclaration);

            var isPrivate = (declFlags & PullElementFlags.Private) != 0;
            var isStatic = (declFlags & PullElementFlags.Static) != 0;

            var methodName = methodDeclaration.getName();

            var isSignature: bool = (declFlags & PullElementFlags.Signature) != 0;

            var parent = this.getParent(true);
            var parentHadSymbol = false;

            var cleanedPreviousDecls = false;

            var methodSymbol: PullSymbol = null;
            var methodTypeSymbol: PullFunctionTypeSymbol = null;

            var linkKind = isPrivate ? SymbolLinkKind.PrivateMember : SymbolLinkKind.PublicMember;

            var i = 0;
            var j = 0;

            if (parent.isClass() && isStatic) {

                for (i = 0; i < this.staticClassMembers.length; i++) {
                    if (this.staticClassMembers[i].getName() == methodName) {
                        methodSymbol = this.staticClassMembers[i];
                        break;
                    }
                }
            }
            else {
                methodSymbol = parent.findMember(methodName);
            }

            if (methodSymbol && 
                (methodSymbol.getKind() != PullElementKind.Method ||
                    (!isSignature && !methodSymbol.allDeclsHaveFlag(PullElementFlags.Signature)))) {
                methodDeclaration.addDiagnostic(new PullDiagnostic(methodAST.minChar, methodAST.getLength(), this.semanticInfo.getPath(), getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [methodName])));
                methodSymbol = null;
            }

            if (methodSymbol) {
                methodTypeSymbol = <PullFunctionTypeSymbol>methodSymbol.getType();
                parentHadSymbol = true;
            }

            if (this.reBindingAfterChange && methodSymbol) {

                // prune out-of-date decls...
                var decls = methodSymbol.getDeclarations();
                var scriptName = methodDeclaration.getScriptName();

                for (j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        methodSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                methodSymbol.invalidate();
            }

            if (!methodSymbol) {
                // PULLTODO: Make sure that we properly flag signature decl types when collecting decls
                methodSymbol = new PullSymbol(methodName, PullElementKind.Method);
                methodTypeSymbol = new PullFunctionTypeSymbol();

                methodSymbol.setType(methodTypeSymbol);
            }

            methodDeclaration.setSymbol(methodSymbol);
            methodSymbol.addDeclaration(methodDeclaration);
            methodTypeSymbol.addDeclaration(methodDeclaration);
            this.semanticInfo.setSymbolForAST(methodAST.name, methodSymbol);
            this.semanticInfo.setSymbolForAST(methodAST, methodSymbol);

            if (!parentHadSymbol) {

                if (isStatic) {
                    this.staticClassMembers[this.staticClassMembers.length] = methodSymbol;
                }
                else {
                    parent.addMember(methodSymbol, linkKind);
                }
            }

            if (!isSignature) {
                this.pushParent(methodTypeSymbol, methodDeclaration);
            }

            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = methodTypeSymbol.getCallSignatures();
                var constructSigs = methodTypeSymbol.getConstructSignatures();
                var indexSigs = methodTypeSymbol.getIndexSignatures();

                for (i = 0; i < callSigs.length; i++) {
                    methodTypeSymbol.removeCallSignature(callSigs[i], false);
                }
                for (i = 0; i < constructSigs.length; i++) {
                    methodTypeSymbol.removeConstructSignature(constructSigs[i], false);
                }
                for (i = 0; i < indexSigs.length; i++) {
                    methodTypeSymbol.removeIndexSignature(indexSigs[i], false);
                }

                methodSymbol.invalidate();
                methodTypeSymbol.invalidate();
            }

            var sigKind = PullElementKind.CallSignature;

            var signature = isSignature ? new PullSignatureSymbol(sigKind) : new PullDefinitionSignatureSymbol(sigKind);

            if (methodAST.variableArgList) {
                signature.setHasVariableParamList();
            }

            var typeParameters = methodDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            for (i = 0; i < typeParameters.length; i++) {

                typeParameter = signature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());

                    signature.addTypeParameter(typeParameter);
                }
                else {
                    // clean the decls
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(methodDeclaration);
            methodDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(methodDeclaration), methodTypeSymbol, signature);

            // add the implicit call member for this function type
            methodTypeSymbol.addSignature(signature);

            if (!isSignature) {
                var childDecls = methodDeclaration.getChildDecls();

                for (i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }

                this.popParent();
            }
        }

        // class constructor declarations
        public bindConstructorDeclarationToPullSymbol(constructorDeclaration: PullDecl) {
            var declKind = constructorDeclaration.getKind();
            var declFlags = constructorDeclaration.getFlags();
            var constructorAST = <FuncDecl>this.semanticInfo.getASTForDecl(constructorDeclaration);

            var constructorName = constructorDeclaration.getName();

            var isSignature: bool = (declFlags & PullElementFlags.Signature) != 0;

            var parent = <PullClassTypeSymbol>this.getParent(true);

            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;

            var constructorSymbol: PullSymbol = parent.getConstructorMethod();
            var constructorTypeSymbol: PullConstructorTypeSymbol = null;

            var linkKind = SymbolLinkKind.ConstructorMethod;

            if (constructorSymbol && 
                (constructorSymbol.getKind() != PullElementKind.ConstructorMethod ||
                    !isSignature && !constructorSymbol.allDeclsHaveFlag(PullElementFlags.Signature))) {
                constructorDeclaration.addDiagnostic(new PullDiagnostic(constructorAST.minChar, constructorAST.getLength(), this.semanticInfo.getPath(),
                    "Duplicate constructor definition"));
                constructorSymbol = null;
            }            

            if (constructorSymbol) {

                constructorTypeSymbol = <PullConstructorTypeSymbol>constructorSymbol.getType();

                if (this.reBindingAfterChange) {
                    // prune out-of-date decls...
                    var decls = constructorSymbol.getDeclarations();
                    var scriptName = constructorDeclaration.getScriptName();

                    for (var j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            constructorSymbol.removeDeclaration(decls[j]);

                            cleanedPreviousDecls = true;
                        }
                    }

                    constructorSymbol.invalidate();
                    constructorTypeSymbol.invalidate();
                }
            }

            if (!constructorSymbol) {
                constructorSymbol = new PullSymbol(constructorName, PullElementKind.ConstructorMethod);
                constructorTypeSymbol = new PullConstructorTypeSymbol();
            }

            // Even if we're reusing the symbol, it would have been cleared by the call to invalidate above
            parent.setConstructorMethod(constructorSymbol);
            constructorSymbol.setType(constructorTypeSymbol);

            constructorDeclaration.setSymbol(constructorSymbol);
            constructorSymbol.addDeclaration(constructorDeclaration);
            this.semanticInfo.setSymbolForAST(constructorAST, constructorSymbol);

            var i = 0;

            if (!isSignature) {
                this.pushParent(constructorTypeSymbol, constructorDeclaration);
            }

            if (parentHadSymbol && cleanedPreviousDecls) {
                var constructSigs = constructorTypeSymbol.getConstructSignatures();

                for (i = 0; i < constructSigs.length; i++) {
                    constructorTypeSymbol.removeConstructSignature(constructSigs[i]);
                }

                constructorSymbol.invalidate();
                constructorTypeSymbol.invalidate();
            }

            // add a call signature to the constructor method, and a construct signature to the parent class type
            var constructSignature = isSignature ? new PullSignatureSymbol(PullElementKind.ConstructSignature) : new PullDefinitionSignatureSymbol(PullElementKind.ConstructSignature);

            constructSignature.setReturnType(parent);

            constructSignature.addDeclaration(constructorDeclaration);
            constructorDeclaration.setSignatureSymbol(constructSignature);

            this.bindParameterSymbols(constructorAST, constructorTypeSymbol, constructSignature);

            if (constructorAST.variableArgList) {
                constructSignature.setHasVariableParamList();
            }

            constructorTypeSymbol.addSignature(constructSignature);

            if (!isSignature) {
                var childDecls = constructorDeclaration.getChildDecls();

                for (i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }

                this.popParent();
            }
        }

        public bindConstructSignatureDeclarationToPullSymbol(constructSignatureDeclaration: PullDecl) {
            var parent = this.getParent(true);
            var constructorAST = <FuncDecl>this.semanticInfo.getASTForDecl(constructSignatureDeclaration);

            var constructSigs = parent.getConstructSignatures();

            var i = 0;

            for (i = 0; i < constructSigs.length; i++) {
                if (constructSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeConstructSignature(constructSigs[i], false);
                }
            }

            // update the construct signature list
            parent.recomputeConstructSignatures();
            var constructSignature = new PullSignatureSymbol(PullElementKind.ConstructSignature);

            if (constructorAST.variableArgList) {
                constructSignature.setHasVariableParamList();
            }

            var typeParameters = constructSignatureDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            for (i = 0; i < typeParameters.length; i++) {

                typeParameter = constructSignature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());

                    constructSignature.addTypeParameter(typeParameter);
                }
                else {
                    // clean the decls
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            constructSignature.addDeclaration(constructSignatureDeclaration);
            constructSignatureDeclaration.setSignatureSymbol(constructSignature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(constructSignatureDeclaration), null, constructSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), constructSignature);

            parent.addConstructSignature(constructSignature);
        }

        public bindCallSignatureDeclarationToPullSymbol(callSignatureDeclaration: PullDecl) {
            var parent = this.getParent(true);
            var callSignatureAST = <FuncDecl>this.semanticInfo.getASTForDecl(callSignatureDeclaration);

            // PULLTODO: For now, remove stale signatures from the function type, but we want to be smarter about this when
            // incremental parsing comes online
            var callSigs = parent.getCallSignatures();

            var i = 0;

            for (i = 0; i < callSigs.length; i++) {
                if (callSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeCallSignature(callSigs[i], false);
                }
            }

            // update the call signature list
            parent.recomputeCallSignatures();

            var callSignature = new PullSignatureSymbol(PullElementKind.CallSignature);

            if (callSignatureAST.variableArgList) {
                callSignature.setHasVariableParamList();
            }

            var typeParameters = callSignatureDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            for (i = 0; i < typeParameters.length; i++) {

                typeParameter = callSignature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());

                    callSignature.addTypeParameter(typeParameter);
                }
                else {
                    // clean the decls
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            callSignature.addDeclaration(callSignatureDeclaration);
            callSignatureDeclaration.setSignatureSymbol(callSignature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(callSignatureDeclaration), null, callSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(callSignatureDeclaration), callSignature);

            parent.addCallSignature(callSignature);
        }

        public bindIndexSignatureDeclarationToPullSymbol(indexSignatureDeclaration: PullDecl) {
            var parent = this.getParent(true);

            var indexSigs = parent.getIndexSignatures();

            var i = 0;

            for (i = 0; i < indexSigs.length; i++) {
                if (indexSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeIndexSignature(indexSigs[i], false);
                }
            }

            // update the index signature list
            parent.recomputeIndexSignatures();

            var indexSignature = new PullSignatureSymbol(PullElementKind.IndexSignature);

            var typeParameters = indexSignatureDeclaration.getTypeParameters();
            var typeParameter: PullTypeParameterSymbol;
            var typeParameterDecls: PullDecl[] = null;

            for (i = 0; i < typeParameters.length; i++) {

                typeParameter = indexSignature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new PullTypeParameterSymbol(typeParameters[i].getName());

                    indexSignature.addTypeParameter(typeParameter);
                }
                else {
                    // clean the decls
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            indexSignature.addDeclaration(indexSignatureDeclaration);
            indexSignatureDeclaration.setSignatureSymbol(indexSignature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(indexSignatureDeclaration), null, indexSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), indexSignature);

            parent.addIndexSignature(indexSignature);
        }

        // getters and setters

        public bindGetAccessorDeclarationToPullSymbol(getAccessorDeclaration: PullDecl) {
            var declKind = getAccessorDeclaration.getKind();
            var declFlags = getAccessorDeclaration.getFlags();
            var funcDeclAST = <FuncDecl>this.semanticInfo.getASTForDecl(getAccessorDeclaration);

            var isExported = (declFlags & PullElementFlags.Exported) != 0;

            var funcName = getAccessorDeclaration.getName();

            var isSignature: bool = (declFlags & PullElementFlags.Signature) != 0;
            var isStatic = false;
            var linkKind = SymbolLinkKind.PublicMember;

            if (hasFlag(declFlags, PullElementFlags.Static)) {
                isStatic = true;
            }

            if (hasFlag(declFlags, PullElementFlags.Private)) {
                linkKind = SymbolLinkKind.PrivateMember;
            }

            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var hadOtherAccessor = false;
            var cleanedPreviousDecls = false;

            var accessorSymbol: PullAccessorSymbol = null;
            var getterSymbol: PullSymbol = null;
            var getterTypeSymbol: PullFunctionTypeSymbol = null;

            var i = 0;
            var j = 0;

            if (!isStatic) {
                accessorSymbol = <PullAccessorSymbol>parent.findMember(funcName);
            }
            else {
                var candidate: PullSymbol;

                for (var m = 0; m < this.staticClassMembers.length; m++) {
                    candidate = this.staticClassMembers[m];

                    if (candidate.getName() == funcName) {
                        accessorSymbol = <PullAccessorSymbol>candidate;
                        hadOtherAccessor = accessorSymbol.isAccessor();
                        break;
                    }
                }
            }

            if (this.compilationSettings.codeGenTarget < LanguageVersion.EcmaScript5) {
                getAccessorDeclaration.addDiagnostic(new PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(),
                    "Property accessors are only available when targeting ES5 or greater"));
            }

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    getAccessorDeclaration.addDiagnostic(new PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(),
                        getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [funcName])));
                    accessorSymbol = null;
                }
                else {
                    getterSymbol = accessorSymbol.getGetter();

                    if (getterSymbol && (!this.reBindingAfterChange || this.symbolIsRedeclaration(getterSymbol))) {
                        getAccessorDeclaration.addDiagnostic(new PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(),
                            getDiagnosticMessage(PullDiagnosticMessages.duplicateGetter_1, [funcName])));
                        accessorSymbol = null;
                        getterSymbol = null;
                    }
                }
            }

            // we have an accessor we can use...
            if (accessorSymbol && getterSymbol) {
                getterTypeSymbol = <PullFunctionTypeSymbol>getterSymbol.getType();
                parentHadSymbol = true;
            }

            if (this.reBindingAfterChange && accessorSymbol) {

                // prune out-of-date decls...
                var decls = accessorSymbol.getDeclarations();
                var scriptName = getAccessorDeclaration.getScriptName();

                for (j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        accessorSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                if (getterSymbol) {
                    decls = getterSymbol.getDeclarations();

                    for (j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            getterSymbol.removeDeclaration(decls[j]);

                            cleanedPreviousDecls = true;
                        }
                    }
                }

                accessorSymbol.invalidate();
            }

            if (!accessorSymbol) {
                accessorSymbol = new PullAccessorSymbol(funcName);
            }

            if (!getterSymbol) {
                getterSymbol = new PullSymbol(funcName, PullElementKind.Function);
                getterTypeSymbol = new PullFunctionTypeSymbol();

                getterSymbol.setType(getterTypeSymbol);

                accessorSymbol.setGetter(getterSymbol);
            }

            getAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(getAccessorDeclaration);
            getterSymbol.addDeclaration(getAccessorDeclaration);

            this.semanticInfo.setSymbolForAST(funcDeclAST.name, getterSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, getterSymbol);

            // PULLTODO: Verify parent is a class or object literal
            // PULLTODO: Verify static/non-static between getter and setter

            if (!parentHadSymbol && !hadOtherAccessor) {

                if (isStatic) {
                    this.staticClassMembers[this.staticClassMembers.length] = accessorSymbol;
                }
                else {
                    parent.addMember(accessorSymbol, linkKind);
                }
            }

            if (!isSignature) {
                this.pushParent(getterTypeSymbol, getAccessorDeclaration);
            }

            // PULLTODO: For now, remove stale signatures from the function type, but we want to be smarter about this when
            // incremental parsing comes online
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = getterTypeSymbol.getCallSignatures();

                for (i = 0; i < callSigs.length; i++) {
                    getterTypeSymbol.removeCallSignature(callSigs[i], false);
                }

                // just invalidate this once, so we don't pay the cost of rebuilding caches
                // for each signature removed
                getterSymbol.invalidate();
                getterTypeSymbol.invalidate();
            }

            var signature = isSignature ? new PullSignatureSymbol(PullElementKind.CallSignature) : new PullDefinitionSignatureSymbol(PullElementKind.CallSignature);

            signature.addDeclaration(getAccessorDeclaration);
            getAccessorDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(getAccessorDeclaration), getterTypeSymbol, signature);

            var typeParameters = getAccessorDeclaration.getTypeParameters();

            if (typeParameters.length) {
                getAccessorDeclaration.addDiagnostic(new PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(),
                    getDiagnosticMessage(PullDiagnosticMessages.accessorsMayNotBeGeneric, null)));
            }

            // add the implicit call member for this function type
            getterTypeSymbol.addSignature(signature);

            if (!isSignature) {
                var childDecls = getAccessorDeclaration.getChildDecls();

                for (i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }

                this.popParent();
            }

            getterSymbol.setIsBound(this.bindingPhase);
        }

        public bindSetAccessorDeclarationToPullSymbol(setAccessorDeclaration: PullDecl) {
            var declKind = setAccessorDeclaration.getKind();
            var declFlags = setAccessorDeclaration.getFlags();
            var funcDeclAST = <FuncDecl>this.semanticInfo.getASTForDecl(setAccessorDeclaration);

            var isExported = (declFlags & PullElementFlags.Exported) != 0;

            var funcName = setAccessorDeclaration.getName();

            var isSignature: bool = (declFlags & PullElementFlags.Signature) != 0;
            var isStatic = false;
            var linkKind = SymbolLinkKind.PublicMember;

            if (hasFlag(declFlags, PullElementFlags.Static)) {
                isStatic = true;
            }

            if (hasFlag(declFlags, PullElementFlags.Private)) {
                linkKind = SymbolLinkKind.PrivateMember;
            }

            var parent = this.getParent(true);
            var parentHadSymbol = false;
            var hadOtherAccessor = false;
            var cleanedPreviousDecls = false;

            var accessorSymbol: PullAccessorSymbol = null;
            var setterSymbol: PullSymbol = null;
            var setterTypeSymbol: PullFunctionTypeSymbol = null;

            var i = 0;
            var j = 0;

            if (!isStatic) {
                accessorSymbol = <PullAccessorSymbol>parent.findMember(funcName);
            }
            else {
                var candidate: PullSymbol;

                for (var m = 0; m < this.staticClassMembers.length; m++) {
                    candidate = this.staticClassMembers[m];

                    if (candidate.getName() == funcName) {
                        accessorSymbol = <PullAccessorSymbol>candidate;
                        hadOtherAccessor = accessorSymbol.isAccessor();
                        break;
                    }
                }
            }

            if (this.compilationSettings.codeGenTarget < LanguageVersion.EcmaScript5) {
                setAccessorDeclaration.addDiagnostic(new PullDiagnostic(
                    funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(), "Property accessors are only available when targeting ES5 or greater"));
            }

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    setAccessorDeclaration.addDiagnostic(new PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(),
                        getDiagnosticMessage(PullDiagnosticMessages.duplicateIdentifier_1, [funcName])));
                    accessorSymbol = null;
                }
                else {
                    setterSymbol = accessorSymbol.getSetter();

                    if (setterSymbol && (!this.reBindingAfterChange || this.symbolIsRedeclaration(setterSymbol))) {
                        setAccessorDeclaration.addDiagnostic(new PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(),
                            getDiagnosticMessage(PullDiagnosticMessages.duplicateSetter_1, [funcName])));
                        accessorSymbol = null;
                        setterSymbol = null;
                    }
                }
            }

            // we have an accessor we can use...
            if (accessorSymbol && setterSymbol) {
                setterTypeSymbol = <PullFunctionTypeSymbol>setterSymbol.getType();
                parentHadSymbol = true;
            }

            if (this.reBindingAfterChange && accessorSymbol) {

                // prune out-of-date decls...
                var decls = accessorSymbol.getDeclarations();
                var scriptName = setAccessorDeclaration.getScriptName();

                for (j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        accessorSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                if (setterSymbol) {
                    decls = setterSymbol.getDeclarations();

                    for (j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() == scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            setterSymbol.removeDeclaration(decls[j]);

                            cleanedPreviousDecls = true;
                        }
                    }
                }

                accessorSymbol.invalidate();
            }

            if (!accessorSymbol) {
                // PULLTODO: Make sure that we properly flag signature decl types when collecting decls
                accessorSymbol = new PullAccessorSymbol(funcName);
            }

            if (!setterSymbol) {
                setterSymbol = new PullSymbol(funcName, PullElementKind.Function);
                setterTypeSymbol = new PullFunctionTypeSymbol();

                setterSymbol.setType(setterTypeSymbol);

                accessorSymbol.setSetter(setterSymbol);
            }

            setAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(setAccessorDeclaration);
            setterSymbol.addDeclaration(setAccessorDeclaration);

            this.semanticInfo.setSymbolForAST(funcDeclAST.name, setterSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, setterSymbol);

            // PULLTODO: Verify parent is a class or object literal
            // PULLTODO: Verify static/non-static between getter and setter

            if (!parentHadSymbol && !hadOtherAccessor) {

                if (isStatic) {
                    this.staticClassMembers[this.staticClassMembers.length] = accessorSymbol;
                }
                else {
                    parent.addMember(accessorSymbol, linkKind);
                }
            }

            if (!isSignature) {
                this.pushParent(setterTypeSymbol, setAccessorDeclaration);
            }

            // PULLTODO: For now, remove stale signatures from the function type, but we want to be smarter about this when
            // incremental parsing comes online
            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = setterTypeSymbol.getCallSignatures();

                for (i = 0; i < callSigs.length; i++) {
                    setterTypeSymbol.removeCallSignature(callSigs[i], false);
                }

                // just invalidate this once, so we don't pay the cost of rebuilding caches
                // for each signature removed
                setterSymbol.invalidate();
                setterTypeSymbol.invalidate();
            }

            var signature = isSignature ? new PullSignatureSymbol(PullElementKind.CallSignature) : new PullDefinitionSignatureSymbol(PullElementKind.CallSignature);

            signature.addDeclaration(setAccessorDeclaration);
            setAccessorDeclaration.setSignatureSymbol(signature);

            // PULLTODO: setter should not have a parameters
            this.bindParameterSymbols(<FuncDecl>this.semanticInfo.getASTForDecl(setAccessorDeclaration), setterTypeSymbol, signature);

            var typeParameters = setAccessorDeclaration.getTypeParameters();

            if (typeParameters.length) {
                setAccessorDeclaration.addDiagnostic(new PullDiagnostic(funcDeclAST.minChar, funcDeclAST.getLength(), this.semanticInfo.getPath(),
                    getDiagnosticMessage(PullDiagnosticMessages.accessorsMayNotBeGeneric, null)));
            }

            // add the implicit call member for this function type
            setterTypeSymbol.addSignature(signature);

            if (!isSignature) {
                var childDecls = setAccessorDeclaration.getChildDecls();

                for (i = 0; i < childDecls.length; i++) {
                    this.bindDeclToPullSymbol(childDecls[i]);
                }

                this.popParent();
            }

            setterSymbol.setIsBound(this.bindingPhase);
        }

        // binding
        public bindDeclToPullSymbol(decl: PullDecl, rebind = false) {

            if (rebind) {
                this.startingDeclForRebind = lastBoundPullDeclId;
                this.startingSymbolForRebind = lastBoundPullSymbolID;
                this.reBindingAfterChange = true;
            }

            switch (decl.getKind()) {

                case PullElementKind.Script:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.bindDeclToPullSymbol(childDecls[i]);
                    }
                    break;

                case PullElementKind.DynamicModule:
                case PullElementKind.Container:
                    this.bindModuleDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Interface:
                    this.bindInterfaceDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Class:
                    this.bindClassDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Function:
                    this.bindFunctionDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Variable:
                    this.bindVariableDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Property:
                    this.bindPropertyDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Method:
                    this.bindMethodDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ConstructorMethod:
                    this.bindConstructorDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.CallSignature:
                    this.bindCallSignatureDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ConstructSignature:
                    this.bindConstructSignatureDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.IndexSignature:
                    this.bindIndexSignatureDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.Enum:
                    this.bindEnumDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.GetAccessor:
                    this.bindGetAccessorDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.SetAccessor:
                    this.bindSetAccessorDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ObjectType:
                    this.bindObjectTypeDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.FunctionType:
                    this.bindFunctionTypeDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.ConstructorType:
                    this.bindConstructorTypeDeclarationToPullSymbol(decl);
                    break;

                case PullElementKind.FunctionExpression:
                    this.bindFunctionExpressionToPullSymbol(decl);
                    break;

                case PullElementKind.TypeAlias:
                    this.bindImportDeclaration(decl);
                    break;

                case PullElementKind.Parameter:
                    // parameters are bound by their enclosing function
                    break;

                default:
                    throw new Error("Unrecognized type declaration");
            }
        }

        public bindDeclsForUnit(filePath: string, rebind = false) {
            this.setUnit(filePath);

            var topLevelDecls = this.semanticInfo.getTopLevelDecls();

            for (var i = 0; i < topLevelDecls.length; i++) {
                this.bindDeclToPullSymbol(topLevelDecls[i], rebind);
            }
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />

module TypeScript {
    export var linkID = 0; // PULLTODO: Prune these if not in use

    export class IListItem {
        public next: IListItem = null;
        public prev: IListItem = null;

        constructor(public value: any) { }
    }

    export class LinkList {
        public head: IListItem = null;
        public last: IListItem = null;
        public length = 0;

        public addItem(item: any) {
            if (!this.head) {
                this.head = new IListItem(item);
                this.last = this.head;
            }
            else {
                this.last.next = new IListItem(item);
                this.last.next.prev = this.last;
                this.last = this.last.next;
            }

            this.length++;
        }

        // PULLTODO: Register callbacks for caching
        public find(p: (rn: any) => bool) {
            var node = this.head;
            var vals: any[] = [];

            while (node) {

                if (p(node.value)) {
                    vals[vals.length] = node.value;
                }
                node = node.next;
            }

            return vals;
        }

        public remove(p: (item: any) => bool) {
            var node = this.head;
            var prev: IListItem = null;
            var next: IListItem = null;

            while (node) {

                if (p(node.value)) {

                    if (node == this.head) {

                        if (this.last == this.head) {
                            this.last = null;
                        }

                        this.head = this.head.next;

                        if (this.head) {
                            this.head.prev = null;
                        }
                    }
                    else {
                        prev = node.prev;
                        next = node.next;

                        if (prev) {
                            prev.next = next;
                        }
                        if (next) {
                            next.prev = prev;
                        }

                        if (node == this.last) {
                            this.last = prev;
                        }
                    }

                    this.length--;
                }
                node = node.next;
            }
        }

        public update(map: (item: any, context: any) => void , context: any) {
            var node = this.head;

            while (node) {
                map(node.value, context);

                node = node.next;
            }
        }
    }

    export class PullSymbolLink {
        public id = linkID++;
        public data: any;
        constructor(public start: PullSymbol, public end: PullSymbol, public kind: SymbolLinkKind) { }
    }

    export enum GraphUpdateKind {
        NoUpdate,

        SymbolRemoved,
        SymbolAdded,

        TypeChanged,
    }

    export class PullSymbolUpdate {

        constructor(public updateKind: GraphUpdateKind, public symbolToUpdate: PullSymbol, public updater: PullSymbolGraphUpdater) { }

    }

    export var updateVersion = 0;

    export class PullSymbolGraphUpdater {

        constructor(public semanticInfoChain: SemanticInfoChain) { }

        public removeDecl(declToRemove: PullDecl) {
            var declSymbol = declToRemove.getSymbol();

            if (declSymbol) {
                declSymbol.removeDeclaration(declToRemove);

                var decls = declSymbol.getDeclarations();

                if (!decls.length) {
                    this.removeSymbol(declSymbol);
                }
                else {
                    var childDecls = declToRemove.getChildDecls();

                    for (var i = 0; i < childDecls.length; i++) {
                        this.removeDecl(childDecls[i]);
                    }
                }

                this.semanticInfoChain.removeSymbolFromCache(declSymbol);
            }

            // if we're removing a class, enum, etc., remove the implicit
            // value decl as well
            var valDecl = declToRemove.getValueDecl();

            if (valDecl) {
                this.removeDecl(valDecl);
            }

            updateVersion++;
        }

        public addDecl(declToAdd: PullDecl) {
            // the decl has been bound to a symbol already, so we just need to trigger an update

            var symbolToAdd = declToAdd.getSymbol();

            this.addSymbol(symbolToAdd);

            updateVersion++;
        }

        // for now, remove all links - later on, see what happens if we leave stuff 'dangling'
        public removeSymbol(symbolToRemove: PullSymbol) {

            if (symbolToRemove.removeUpdateVersion == updateVersion) {
                return;
            }

            symbolToRemove.removeUpdateVersion = updateVersion;

            symbolToRemove.updateOutgoingLinks(propagateRemovalToOutgoingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolRemoved, symbolToRemove, this));

            symbolToRemove.updateIncomingLinks(propagateRemovalToIncomingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolRemoved, symbolToRemove, this));

            symbolToRemove.unsetContainer();

            this.semanticInfoChain.removeSymbolFromCache(symbolToRemove);

            var container = symbolToRemove.getContainer();

            if (container) {
                container.removeMember(symbolToRemove);
                this.semanticInfoChain.removeSymbolFromCache(symbolToRemove);
            }
        }

        public addSymbol(symbolToAdd: PullSymbol) {

            if (symbolToAdd.addUpdateVersion == updateVersion) {
                return;
            }

            symbolToAdd.addUpdateVersion = updateVersion;

            symbolToAdd.updateOutgoingLinks(propagateAdditionToOutgoingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolAdded, symbolToAdd, this));

            symbolToAdd.updateIncomingLinks(propagateAdditionToIncomingLinks, new PullSymbolUpdate(GraphUpdateKind.SymbolAdded, symbolToAdd, this));

        }

        public invalidateType(symbolWhoseTypeChanged: PullSymbol) {
            if (!symbolWhoseTypeChanged) {
                return;
            }

            if (symbolWhoseTypeChanged.isPrimitive()) {
                return;
            }

            if (symbolWhoseTypeChanged.typeChangeUpdateVersion == updateVersion) {
                return;
            }

            symbolWhoseTypeChanged.typeChangeUpdateVersion = updateVersion;

            symbolWhoseTypeChanged.updateOutgoingLinks(propagateChangedTypeToOutgoingLinks, new PullSymbolUpdate(GraphUpdateKind.TypeChanged, symbolWhoseTypeChanged, this));

            symbolWhoseTypeChanged.updateIncomingLinks(propagateChangedTypeToIncomingLinks, new PullSymbolUpdate(GraphUpdateKind.TypeChanged, symbolWhoseTypeChanged, this));

            symbolWhoseTypeChanged.invalidate();

        }
    }

    export function propagateRemovalToOutgoingLinks(link: PullSymbolLink, update: PullSymbolUpdate) {

        var symbolToRemove = update.symbolToUpdate;
        var affectedSymbol = link.end;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {

            // if another type infers its type from this one, unset the link
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            update.updater.removeSymbol(affectedSymbol);
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {

            // shouldn't affect the other type - we'd remove the parent type as an
            // incoming link
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            update.updater.removeSymbol(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            update.updater.removeSymbol(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            //update.updater.removeSymbol(affectedSymbol);
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            (<PullTypeSymbol>affectedSymbol).removeMember(symbolToRemove);
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            update.updater.removeSymbol(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            update.updater.invalidateType(affectedSymbol);
        }

        symbolToRemove.removeOutgoingLink(link);
    }

    export function propagateRemovalToIncomingLinks(link: PullSymbolLink, update: PullSymbolUpdate) {
        var symbolToRemove = update.symbolToUpdate;
        var affectedSymbol = link.start;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {
            // no action...
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayType) {
            update.updater.removeSymbol(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {
            update.updater.removeSymbol(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            (<PullTypeSymbol>affectedSymbol).removeMember(symbolToRemove);
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            (<PullTypeSymbol>affectedSymbol).removeMember(symbolToRemove);
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
    }

    export function propagateAdditionToOutgoingLinks(link: PullSymbolLink, update: PullSymbolUpdate) {

        var symbolToAdd = update.symbolToUpdate;
        var affectedSymbol = link.end;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            //update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            //update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {
            // how could this happen?
            //update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            // Don't invalidate the type in this case - we only care about
            // public properties
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            // Don't invalidate the type in this case - we only care about
            // public properties
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
    }

    export function propagateAdditionToIncomingLinks(link: PullSymbolLink, update: PullSymbolUpdate) {
        var symbolToAdd = update.symbolToUpdate;
        var affectedSymbol = link.start;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {
            //update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {
            // shouldn't change anything...
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            // do nothing...
        }
    }

    export function propagateChangedTypeToOutgoingLinks(link: PullSymbolLink, update: PullSymbolUpdate) {
        var symbolWhoseTypeChanged = update.symbolToUpdate;
        var affectedSymbol = link.end;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            //update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            //update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            update.updater.invalidateType(affectedSymbol);
        }
    }

    export function propagateChangedTypeToIncomingLinks(link: PullSymbolLink, update: PullSymbolUpdate) {
        var symbolWhoseTypeChanged = update.symbolToUpdate;
        var affectedSymbol = link.start;

        // carry out the update based on the update kind, the affected symbol kind and the relationship
        if (link.kind == SymbolLinkKind.TypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ContextuallyTypedAs) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ProvidesInferredType) {
            //update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameter) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeArgument) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeParameterSpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.SpecializedTo) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.TypeConstraint) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.ArrayOf) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.PublicMember) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.PrivateMember) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructorMethod) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Aliases) {
            // PULLTODO
        }
        else if (link.kind == SymbolLinkKind.ContainedBy) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.Extends) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Implements) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.Parameter) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ReturnType) {
            update.updater.invalidateType(affectedSymbol);
        }
        else if (link.kind == SymbolLinkKind.CallSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.ConstructSignature) {
            // do nothing...
        }
        else if (link.kind == SymbolLinkKind.IndexSignature) {
            // do nothing...
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='..\typescript.ts' />

module TypeScript {
    export class PullEmitter extends Emitter {
        public locationInfo: LocationInfo = null;
        private pullTypeChecker: PullTypeChecker = null;
        private declStack: PullDecl[] = [];

        constructor(emittingFileName: string,
                    outfile: ITextWriter,
                    emitOptions: EmitOptions,
                    private semanticInfoChain: SemanticInfoChain) {
            super(null, emittingFileName, outfile, emitOptions);

            this.pullTypeChecker = new PullTypeChecker(emitOptions.compilationSettings, semanticInfoChain);
        }

        public isPull() { return true; }

        public diagnostics(): IDiagnostic[] { return []; }

        public importStatementShouldBeEmitted(importDeclAST: ImportDeclaration, unitPath?: string): bool {

            if (!importDeclAST.isDynamicImport) {
                return true;
            }

            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST, this.locationInfo.fileName);

            var pullSymbol = <PullTypeAliasSymbol>importDecl.getSymbol();

            return pullSymbol.isUsedAsValue;
        }

        private pushDecl(decl: PullDecl) {
            if (decl) {
                this.declStack[this.declStack.length] = decl;
            }
        }

        private popDecl(decl: PullDecl) {
            if (decl) {
                this.declStack.length--;
            }
        }

        private setTypeCheckerUnit(fileName: string) {
            if (!this.pullTypeChecker.resolver) {
                this.pullTypeChecker.setUnit(fileName);
                return;
            }

            this.pullTypeChecker.resolver.setUnitPath(fileName);
        }

        public setUnit(locationInfo: LocationInfo) {
            this.locationInfo = locationInfo;
        }

        private getEnclosingDecl() {
            var declStackLen = this.declStack.length;
            var enclosingDecl = declStackLen > 0 ? this.declStack[declStackLen - 1] : null;
            return enclosingDecl;
        }

        private symbolIsUsedInItsEnclosingContainer(symbol: PullSymbol, dynamic=false) {            

            var symDecls = symbol.getDeclarations();

            if (symDecls.length) {

                var enclosingDecl = this.getEnclosingDecl();

                if (enclosingDecl) {

                    var parentDecl = symDecls[0].getParentDecl();

                    if (parentDecl) {

                        var symbolDeclarationEnclosingContainer = parentDecl;
                        var enclosingContainer = enclosingDecl;

                        // compute the closing container of the symbol's declaration
                        while (symbolDeclarationEnclosingContainer) {

                            if (symbolDeclarationEnclosingContainer.getKind() == (dynamic ? PullElementKind.DynamicModule : PullElementKind.Container)) {
                                break;
                            }

                            symbolDeclarationEnclosingContainer = symbolDeclarationEnclosingContainer.getParentDecl();
                        }

                        // if the symbol in question is not a global, compute the nearest
                        // enclosing declaration from the point of usage
                        if (symbolDeclarationEnclosingContainer) {

                            while(enclosingContainer) {
                                if (enclosingContainer.getKind() == (dynamic ? PullElementKind.DynamicModule : PullElementKind.Container)) {
                                    break;
                                }

                                enclosingContainer = enclosingContainer.getParentDecl();
                            }
                        }

                        if (symbolDeclarationEnclosingContainer && enclosingContainer) {
                            var same = symbolDeclarationEnclosingContainer == enclosingContainer;

                            // initialized module object variables are bound to their parent's decls
                            if (!same && symbol.hasFlag(PullElementFlags.InitializedModule)) {
                                same = symbolDeclarationEnclosingContainer == enclosingContainer.getParentDecl();
                            }

                            return same;
                        }
                    }
                }
            }

            return false;
        }

        public getVarDeclFromIdentifier(boundDeclInfo: BoundDeclInfo): BoundDeclInfo {
            CompilerDiagnostics.assert(boundDeclInfo.boundDecl && boundDeclInfo.boundDecl.init &&
                boundDeclInfo.boundDecl.init.nodeType == NodeType.Name, 
                "The init expression of bound declaration when emitting as constant has to be indentifier");

            var init = boundDeclInfo.boundDecl.init;
            var ident = <Identifier>init;

            var resolvingContext = new PullTypeResolutionContext();
            this.setTypeCheckerUnit(this.locationInfo.fileName);
            var pullSymbol = this.pullTypeChecker.resolver.resolveNameExpression(ident, boundDeclInfo.pullDecl.getParentDecl(), resolvingContext);
            if (pullSymbol) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length == 1) {
                    var pullDecl = pullDecls[0];
                    var ast = this.semanticInfoChain.getASTForDecl(pullDecl, pullDecl.getScriptName());
                    if (ast && ast.nodeType == NodeType.VarDecl) {
                        return { boundDecl: <VarDecl>ast, pullDecl: pullDecl };
                    }
                }
            }

            return null;
        }

        public getConstantDecl(dotExpr: BinaryExpression): BoundDeclInfo {
            var resolvingContext = new PullTypeResolutionContext();
            this.setTypeCheckerUnit(this.locationInfo.fileName);
            var pullSymbol = this.pullTypeChecker.resolver.resolveDottedNameExpression(dotExpr, this.getEnclosingDecl(), resolvingContext);
            if (pullSymbol && pullSymbol.hasFlag(PullElementFlags.Constant)) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length == 1) {
                    var pullDecl = pullDecls[0];
                    var ast = this.semanticInfoChain.getASTForDecl(pullDecl, pullDecl.getScriptName());
                    if (ast && ast.nodeType == NodeType.VarDecl) {
                        return { boundDecl: <VarDecl>ast, pullDecl: pullDecl };
                    }
                }
            }

            return null;
        }

        public getClassPropertiesMustComeAfterSuperCall(funcDecl: FuncDecl, classDecl: TypeDeclaration) {
            var isClassConstructor = funcDecl.isConstructor && hasFlag(funcDecl.fncFlags, FncFlags.ClassMethod);
            var hasNonObjectBaseType = isClassConstructor && classDecl.extendsList && classDecl.extendsList.members.length > 0;
            var classPropertiesMustComeAfterSuperCall = hasNonObjectBaseType;
            return classPropertiesMustComeAfterSuperCall;
        }

        public emitInnerFunction(funcDecl: FuncDecl, printName: bool, isMember: bool,
            hasSelfRef: bool, classDecl: TypeDeclaration) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl, this.locationInfo.fileName);
            this.pushDecl(pullDecl);
            super.emitInnerFunction(funcDecl, printName, isMember, hasSelfRef, classDecl);
            this.popDecl(pullDecl);
        }

        // PULLTODO
        public getModuleImportAndDepencyList(moduleDecl: ModuleDeclaration) {
            var importList = "";
            var dependencyList = "";
            var i = 0;

            var semanticInfo = this.semanticInfoChain.getUnit(this.locationInfo.fileName);
            var imports = semanticInfo.getDynamicModuleImports();

            // all dependencies are quoted
            if (imports.length) {
                for (i = 0; i < imports.length; i++) {
                    var importStatement = imports[i];
                    var importStatementAST = <ImportDeclaration>semanticInfo.getASTForDecl(importStatement.getDeclarations()[0]);

                    if (importStatement.getIsUsedAsValue()) {
                        if (i <= imports.length - 1) {
                            dependencyList += ", ";
                            importList += ", ";
                        }

                        importList += "__" + importStatement.getName() + "__";
                        dependencyList += importStatementAST.firstAliasedModToString();
                    }
                }
            }

            // emit any potential amd dependencies
            for (i = 0; i < moduleDecl.amdDependencies.length; i++) {
                dependencyList += ", \"" + moduleDecl.amdDependencies[i] + "\"";
            }

            return {
                importList: importList,
                dependencyList: dependencyList
            };
        }

        public isParentDynamicModule(moduleDecl: ModuleDeclaration) {
            var symbol = this.semanticInfoChain.getSymbolForAST(moduleDecl, this.locationInfo.fileName);
            var parentSymbol = symbol.getContainer();

            parentSymbol = parentSymbol ? parentSymbol.getAssociatedContainerType() : null;

            if (parentSymbol && parentSymbol.getKind() == PullElementKind.DynamicModule) {
                return true;
            }

            return false;
        }

        public shouldCaptureThis(ast: AST) {
            if (ast == null) {
                var scriptDecl = this.semanticInfoChain.getUnit(this.locationInfo.fileName).getTopLevelDecls()[0];
                return (scriptDecl.getFlags() & PullElementFlags.MustCaptureThis) == PullElementFlags.MustCaptureThis;
            }

            var decl = this.semanticInfoChain.getDeclForAST(ast, this.locationInfo.fileName);
            if (decl) {
                return (decl.getFlags() & PullElementFlags.MustCaptureThis) == PullElementFlags.MustCaptureThis;
            }

            return false;
        }

        public emitJavascriptModule(moduleDecl: ModuleDeclaration) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(moduleDecl, this.locationInfo.fileName);
            this.pushDecl(pullDecl);
            super.emitJavascriptModule(moduleDecl);
            this.popDecl(pullDecl);
        }

        public isContainedInClassDeclaration(varDecl: VarDecl) {
            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl, this.locationInfo.fileName);
            if (symbol) {
                var parentSymbol = symbol.getContainer();
                if (parentSymbol) {
                    var parentKind = parentSymbol.getKind();
                    if (parentKind == PullElementKind.Class) {
                        return true;
                    }
                }
            }

            return false;
        }

        public isContainedInModuleOrEnumDeclaration(varDecl: VarDecl) {
            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl, this.locationInfo.fileName);
            var parentSymbol: PullTypeSymbol;

            if (symbol) {
                parentSymbol = symbol.getContainer();
                if (parentSymbol && (parentSymbol.getKind() == PullElementKind.Enum || parentSymbol.getKind() == PullElementKind.DynamicModule)) {
                    return true;
                }

                parentSymbol = parentSymbol ? parentSymbol.getAssociatedContainerType() : null;

                if (parentSymbol) {
                    var parentKind = parentSymbol.getKind();
                    if (parentKind == PullElementKind.Container || parentKind == PullElementKind.DynamicModule || parentKind == PullElementKind.Enum) {
                        return true;
                    }
                }
            }

            return false;
        }

        public getContainedSymbolName(varDecl: VarDecl) {
            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl, this.locationInfo.fileName);
            var parentSymbol = symbol.getContainer();
            return parentSymbol.getName();
        }

        public emitJavascriptVarDecl(varDecl: VarDecl, tokenId: TokenID) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl, this.locationInfo.fileName);
            this.pushDecl(pullDecl);
            super.emitJavascriptVarDecl(varDecl, tokenId);
            this.popDecl(pullDecl);
        }

        public emitJavascriptName(name: Identifier, addThis: bool) {
            this.emitParensAndCommentsInPlace(name, true);
            this.recordSourceMappingStart(name);
            if (!name.isMissing()) {
                var resolvingContext = new PullTypeResolutionContext();
                this.setTypeCheckerUnit(this.locationInfo.fileName);
                var pullSymbol = this.pullTypeChecker.resolver.resolveNameExpression(name,
                    this.getEnclosingDecl(), resolvingContext);
                var pullSymbolKind = pullSymbol.getKind();
                if (addThis && (this.emitState.container != EmitContainer.Args) && pullSymbol) {
                    var pullSymbolContainer = pullSymbol.getContainer();
                    if (pullSymbolContainer) {
                        var pullSymbolContainerKind = pullSymbolContainer.getKind();

                        if (pullSymbolContainerKind == PullElementKind.Class) {
                            if (pullSymbol.hasFlag(PullElementFlags.Static)) {
                                // This is static symbol
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            }
                            else if (pullSymbolKind == PullElementKind.Property) {
                                this.emitThis();
                                this.writeToOutput(".");
                            }
                        }
                        else if (pullSymbolContainerKind == PullElementKind.Container || pullSymbolContainerKind == PullElementKind.Enum || 
                                    pullSymbolContainer.hasFlag(PullElementFlags.InitializedModule)) {
                            // If property or, say, a constructor being invoked locally within the module of its definition
                            if (pullSymbolKind == PullElementKind.Property) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            }
                            else if (pullSymbol.hasFlag(PullElementFlags.Exported) && 
                                pullSymbolKind == PullElementKind.Variable && 
                                !pullSymbol.hasFlag(PullElementFlags.InitializedModule))  {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            }
                            else if (pullSymbol.hasFlag(PullElementFlags.Exported) &&
                                !this.symbolIsUsedInItsEnclosingContainer(pullSymbol)) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            }
                            // else if (pullSymbol.hasFlag(PullElementFlags.Exported) && 
                            //             pullSymbolKind != PullElementKind.Class && 
                            //             pullSymbolKind != PullElementKind.ConstructorMethod && 
                            //             !pullSymbol.hasFlag(PullElementFlags.ClassConstructorVariable)) {
                            //         this.writeToOutput(pullSymbolContainer.getName() + ".");
                            // }
                        }
                        else if (pullSymbolContainerKind == PullElementKind.DynamicModule) {
                            if (pullSymbolKind == PullElementKind.Property || pullSymbol.hasFlag(PullElementFlags.Exported)) {
                                // If dynamic module
                                if (pullSymbolKind == PullElementKind.Property) {
                                    this.writeToOutput("exports.");
                                }
                                else if (pullSymbol.hasFlag(PullElementFlags.Exported) &&
                                    !this.symbolIsUsedInItsEnclosingContainer(pullSymbol, true)) {
                                    this.writeToOutput("exports.");
                                }
                            }
                        }
                        else if (pullSymbolKind == PullElementKind.Property) {
                            if (pullSymbolContainer.getKind() == PullElementKind.Class) {
                                this.emitThis();
                                this.writeToOutput(".");
                            }
                        }
                        else {
                            var pullDecls = pullSymbol.getDeclarations();
                            var emitContainerName = true;
                            for (var i = 0 ; i < pullDecls.length; i++) {
                                if (pullDecls[i].getScriptName() == this.locationInfo.fileName) {
                                    emitContainerName = false;
                                }
                            }
                            if (emitContainerName) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            }
                        }
                    }
                }

                // If it's a dynamic module, we need to print the "require" invocation
                if (pullSymbol && pullSymbolKind == PullElementKind.DynamicModule) {
                    if (this.emitOptions.compilationSettings.moduleGenTarget == ModuleGenTarget.Asynchronous) {
                        this.writeLineToOutput("__" + this.modAliasId + "__;");
                    }
                    else {
                        var moduleDecl: ModuleDeclaration = <ModuleDeclaration>this.semanticInfoChain.getASTForSymbol(pullSymbol, this.locationInfo.fileName);
                        var modPath = name.actualText;
                        var isAmbient = pullSymbol.hasFlag(PullElementFlags.Ambient);
                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : quoteBaseName(modPath);
                        modPath = isAmbient ? modPath : (!isRelative(stripQuotes(modPath)) ? quoteStr("./" + stripQuotes(modPath)) : modPath);
                        this.writeToOutput("require(" + modPath + ")");
                    }
                }
                else {
                    this.writeToOutput(name.actualText);
                }
            }

            this.recordSourceMappingEnd(name);
            this.emitParensAndCommentsInPlace(name, false);
        }

        public getLineMap(): LineMap {
            return this.locationInfo.lineMap;
        }

        public isAccessorEmitted(funcDecl: FuncDecl) {
            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                return false;
            }

            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.locationInfo.fileName);
            if (accessorSymbol.getGetter()) {
                return true;
            }

            return false;
        }

        public getGetterAndSetterFunction(funcDecl: FuncDecl): { getter: FuncDecl; setter: FuncDecl; } {
            var result = PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain, this.locationInfo.fileName);
            return result;
        }

        public isAccessorInObjectLiteral(funcDecl: FuncDecl) {
            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.locationInfo.fileName);
            var container = accessorSymbol.getContainer();
            var containerKind = container.getKind();
            return containerKind != PullElementKind.Class && containerKind != PullElementKind.ConstructorType;
        }

        public emitJavascriptClass(classDecl: ClassDeclaration) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(classDecl, this.locationInfo.fileName);
            this.pushDecl(pullDecl);
            super.emitJavascriptClass(classDecl);
            this.popDecl(pullDecl);
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />
///<reference path='..\Core\IDiagnostic.ts' />

module TypeScript {

    // pull errors are declared at a specific offset from a given decl
    // adjustedOffset is set when the error is added to a decl

    export class PullDiagnostic implements IDiagnostic {
        private _originalStart: number;
        private _fileName: string;
        private _start: number;
        private _length: number;
        private _message: string;

        constructor(start: number, length: number, fileName: string, message: string) {
            this._originalStart = start;
            this._fileName = fileName;
            this._start = start;
            this._length = length;
            this._message = message;
        }

        public fileName(): string {
            return this._fileName;
        }

        public start(): number {
            return this._start;
        }

        public length(): number {
            return this._length;
        }

        public message(): string {
            return this._message;
        }

        public adjustOffset(pos: number) {
            this._start = this._originalStart + pos;
        }
    }

    export function getDiagnosticsFromEnclosingDecl(enclosingDecl: PullDecl, errors: IDiagnostic[]) {
        var declErrors = enclosingDecl.getDiagnostics();
        var i = 0;

        if (declErrors) {
            for (i = 0; i < declErrors.length; i++) {
                errors[errors.length] = declErrors[i];
            }
        }

        var childDecls = enclosingDecl.getChildDecls();

        for (i = 0; i < childDecls.length; i++) {
            getDiagnosticsFromEnclosingDecl(childDecls[i], errors);
        }
    }

    export class PullErrorReporter {
        public lineCol = { line: 0, character: 0 };
        public locationInfoCache: any = {};
        public hasErrors = false;

        constructor(public textWriter: ITextWriter) {
        }

        public setUnits(fileNameToLocationInfo: TypeScript.StringHashTable) {
            this.locationInfoCache = {};

            var fileNames = fileNameToLocationInfo.getAllKeys();
            for (var i = 0; i < fileNames.length; i++) {
                var fileName = fileNames[i];
                this.locationInfoCache[fileName] = fileNameToLocationInfo.lookup(fileName);
            }
        }

        public reportDiagnostic(error: IDiagnostic, lineMap: LineMap = null) {
            this.hasErrors = true;

            if (lineMap === null) {
                var locationInfo = this.locationInfoCache[error.fileName()];
                if (locationInfo && locationInfo.lineMap) {
                    lineMap = locationInfo.lineMap;
                }
            }

            if (error.fileName()) {
                if (lineMap) {
                    lineMap.fillLineAndCharacterFromPosition(error.start(), this.lineCol);

                    this.textWriter.Write(error.fileName() + "(" + (this.lineCol.line + 1) + "," + this.lineCol.character + "): ");
                }
                else {
                    this.textWriter.Write(error.fileName() + "(0,0): ");
                }
            }

            this.textWriter.WriteLine(error.message());
        }

        public reportDiagnostics(errors: IDiagnostic[], lineMap: LineMap = null) {
            for (var i = 0; i < errors.length; i++) {
                this.reportDiagnostic(errors[i], lineMap);
            }
        }
    }
}
// Copyright (c) Microsoft. All rights reserved. Licensed under the Apache License, Version 2.0. 
// See LICENSE.txt in the project root for complete license information.

///<reference path='..\typescript.ts' />
///<reference path='..\Core\HashTable.ts' />
///<reference path='..\Syntax\ISyntaxElement.ts' />

module TypeScript {

    export module PullHelpers {
        export interface SignatureInfoForFuncDecl {
            signature: PullSignatureSymbol;
            allSignatures: PullSignatureSymbol[];
        }

        export function getSignatureForFuncDecl(funcDecl: FuncDecl, semanticInfoChain: SemanticInfoChain, unitPath: string) {
            var funcSymbol = semanticInfoChain.getSymbolForAST(funcDecl, unitPath);
            var result: SignatureInfoForFuncDecl = { signature: null, allSignatures: null };
            if (funcSymbol.isSignature()) {
                result.signature = <PullSignatureSymbol>funcSymbol;
                result.allSignatures = [<PullSignatureSymbol>funcSymbol];
                return result;
            }
            var funcTypeSymbol = funcSymbol.getType();
            var signatures: PullSignatureSymbol[];
            if (funcDecl.isConstructor || funcDecl.isConstructMember()) {
                signatures = funcTypeSymbol.getConstructSignatures();
            } else if (funcDecl.isIndexerMember()) {
                signatures = funcTypeSymbol.getIndexSignatures();
            } else {
                signatures = funcTypeSymbol.getCallSignatures();
            }
            for (var i = 0; i < signatures.length; i++) {
                var signatureDecl = signatures[i].getDeclarations()[0];
                var signatureAST = semanticInfoChain.getASTForDecl(signatureDecl, signatureDecl.getScriptName());
                if (signatureAST == funcDecl) {
                    result.signature = signatures[i];
                    result.allSignatures = signatures;
                    return result;
                }
            }

            return null;
        }

        export function getAccessorSymbol(getterOrSetter: FuncDecl, semanticInfoChain: SemanticInfoChain, unitPath: string) {
            var getterOrSetterSymbol = semanticInfoChain.getSymbolForAST(getterOrSetter, unitPath);
            var linkKind: SymbolLinkKind;
            if (hasFlag(getterOrSetter.fncFlags, FncFlags.GetAccessor)) {
                linkKind = SymbolLinkKind.GetterFunction;
            } else {
                linkKind = SymbolLinkKind.SetterFunction;
            }

            var accessorSymbolLinks = getterOrSetterSymbol.findIncomingLinks((psl) => psl.kind == linkKind);
            if (accessorSymbolLinks.length) {
                return <PullAccessorSymbol>accessorSymbolLinks[0].start;
            }

            return null;
        }

        export function getASTForDecl(decl: PullDecl, semanticInfoChain: SemanticInfoChain) {
            return semanticInfoChain.getASTForDecl(decl, decl.getScriptName());
        }
        
        export function getGetterAndSetterFunction(funcDecl: FuncDecl, semanticInfoChain: SemanticInfoChain, unitPath: string): { getter: FuncDecl; setter: FuncDecl; } {
            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, semanticInfoChain, unitPath);
            var result: { getter: FuncDecl; setter: FuncDecl; } = {
                getter: null,
                setter: null
            };
            var getter = accessorSymbol.getGetter();
            if (getter) {
                var getterDecl = getter.getDeclarations()[0];
                result.getter = <FuncDecl>PullHelpers.getASTForDecl(getterDecl, semanticInfoChain);
            }
            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterDecl = setter.getDeclarations()[0];
                result.setter = <FuncDecl>PullHelpers.getASTForDecl(setterDecl, semanticInfoChain);
            }

            return result;
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='..\typescript.ts' />

module TypeScript {
    export class PullDeclarationEmitter extends DeclarationEmitter {
        private locationInfo: LocationInfo = null;

        constructor(emittingFileName: string,
                    isUTF8: bool,
                    private semanticInfoChain: SemanticInfoChain,
                    emitOptions: EmitOptions) {
            super(emittingFileName, isUTF8, null, emitOptions);
        }

        private emitTypeSignature(type: PullTypeSymbol) {
            var declarationContainerAst = this.getAstDeclarationContainer();
            var declarationPullSymbol = this.semanticInfoChain.getSymbolForAST(declarationContainerAst, this.locationInfo.fileName);
            var typeNameMembers = type.getScopedNameEx(declarationPullSymbol);
            this.emitTypeNamesMember(typeNameMembers);
        }

        public emitTypeOfBoundDecl(boundDecl: BoundDecl) {
            var pullSymbol = this.semanticInfoChain.getSymbolForAST(boundDecl, this.locationInfo.fileName);
            var type = pullSymbol.getType();
            if (!type) {
                // PULLTODO
                return;
            }
            if (boundDecl.typeExpr || // Specified type expression
                (boundDecl.init && type != this.semanticInfoChain.anyTypeSymbol)) { // Not infered any
                this.declFile.Write(": ");
                this.emitTypeSignature(type);
            }
        }

        public isOverloadedConstructorSignature(funcDecl: FuncDecl) {
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl, this.locationInfo.fileName);
            var funcTypeSymbol = funcSymbol.getType();
            var signatures = funcTypeSymbol.getConstructSignatures();
            return signatures && signatures.length > 1;
        }

        public isOverloadedCallSignature(funcDecl: FuncDecl) {
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl, this.locationInfo.fileName);
            var funcTypeSymbol = funcSymbol.getType();
            var signatures = funcTypeSymbol.getCallSignatures();
            return signatures && signatures.length > 1;
        }

        public getFirstCallOverloadFuncDecl(funcDecl: FuncDecl) {
            var funcSymbol = this.semanticInfoChain.getSymbolForAST(funcDecl, this.locationInfo.fileName);
            var funcTypeSymbol = funcSymbol.getType();
            var signatures = funcTypeSymbol.getCallSignatures();
            Debug.assert(signatures && signatures.length > 1);
            var firstSignature = signatures[0].isDefinition() ? signatures[1] : signatures[0];
            var firstSignatureDecl = firstSignature.getDeclarations()[0];
            var firstFuncDecl = <FuncDecl>PullHelpers.getASTForDecl(firstSignatureDecl, this.semanticInfoChain);
            return firstFuncDecl;
        }

        public emitReturnTypeOfFuncDecl(funcDecl: FuncDecl) {
            var funcSignature = PullHelpers.getSignatureForFuncDecl(funcDecl, this.semanticInfoChain, this.locationInfo.fileName).signature;
            var returnType = funcSignature.getReturnType();
            if (funcDecl.returnTypeAnnotation ||
                (returnType && returnType != this.semanticInfoChain.anyTypeSymbol)) {
                this.declFile.Write(": ");
                this.emitTypeSignature(returnType);
            }
        }

        public hasGetterAndIsNotGetter(funcDecl: FuncDecl) {
            if (hasFlag(funcDecl.fncFlags, FncFlags.GetAccessor)) {
                return false;
            }

            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.locationInfo.fileName);
            if (accessorSymbol.getGetter()) {
                return true;
            }

            return false;
        }

        public emitAccessorDeclarationComments(funcDecl: FuncDecl) {
            if (!this.emitOptions.compilationSettings.emitComments) {
                return;
            }

            var accessors = PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain, this.locationInfo.fileName);
            var comments: Comment[] = [];
            if (accessors.getter) {
                comments = comments.concat(accessors.getter.getDocComments());
            }
            if (accessors.setter) {
                comments = comments.concat(accessors.setter.getDocComments());
            }
            this.writeDeclarationComments(comments);
        }

        public emitPropertyTypeOfProperty(funcDecl: FuncDecl) {
            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.locationInfo.fileName);
            var type = accessorSymbol.getType();
            this.emitTypeSignature(type);
        }

        public emitBaseExpression(bases: ASTList, index: number, useExtendsList: bool) {
            var containerAst = this.getAstDeclarationContainer();
            var containerSymbol = <PullTypeSymbol>this.semanticInfoChain.getSymbolForAST(containerAst, this.locationInfo.fileName);
            var baseType: PullTypeSymbol
            if (useExtendsList) {
                baseType = containerSymbol.getExtendedTypes()[index];
            } else {
                baseType = containerSymbol.getImplementedTypes()[index];
            }
            this.emitTypeSignature(baseType);
        }

        // PULLTODO
        //public ImportDeclarationCallback(pre: bool, importDecl: ImportDeclaration): bool {
        //    if (pre) {
        //        if ((<Script>this.declarationContainerStack[0]).isExternallyVisibleSymbol(importDecl.id.sym)) {
        //            this.emitDeclarationComments(importDecl);
        //            this.emitIndent();
        //            this.declFile.Write("import ");

        //            this.declFile.Write(importDecl.id.text + " = ");
        //            if (importDecl.isDynamicImport) {
        //                this.declFile.WriteLine("module (" + importDecl.getAliasName() + ");");
        //            } else {
        //                this.declFile.WriteLine(importDecl.getAliasName() + ";");
        //            }
        //        }
        //    }

        //    return false;
        //}

        public ScriptCallback(pre: bool, script: Script): bool {
            if (pre) {
                this.locationInfo = script.locationInfo;
            }
            else {
                this.locationInfo = null;
            }
            return super.ScriptCallback(pre, script);
        }
    }
}
///<reference path='References.ts' />

module TypeScript {
    export interface ITokenInformation {
        previousToken: ISyntaxToken;
        nextToken: ISyntaxToken;
    }

    export class SyntaxInformationMap extends SyntaxWalker {
        private tokenToInformation = Collections.createHashTable(Collections.DefaultHashTableCapacity, Collections.identityHashCode);
        private elementToPosition = Collections.createHashTable(Collections.DefaultHashTableCapacity, Collections.identityHashCode);

        private _previousToken = null;
        private _previousTokenInformation: ITokenInformation = null;
        private _currentPosition = 0;
        private _elementToParent = Collections.createHashTable(Collections.DefaultHashTableCapacity, Collections.identityHashCode);

        private _parentStack: SyntaxNode[] = [];

        constructor(private trackParents: bool, private trackPreviousToken: bool) {
            super();
            this._parentStack.push(null);
        }

        public static create(node: SyntaxNode, trackParents: bool, trackPreviousToken: bool): SyntaxInformationMap {
            var map = new SyntaxInformationMap(trackParents, trackPreviousToken);
            map.visitNode(node);
            return map;
        }

        private visitNode(node: SyntaxNode): void {
            this.trackParents && this._elementToParent.add(node, ArrayUtilities.last(this._parentStack));
            this.elementToPosition.add(node, this._currentPosition);

            this.trackParents && this._parentStack.push(node);
            super.visitNode(node);
            this.trackParents && this._parentStack.pop();
        }

        private visitToken(token: ISyntaxToken): void {
            this.trackParents && this._elementToParent.add(token, ArrayUtilities.last(this._parentStack));

            if (this.trackPreviousToken) {
                var tokenInformation: ITokenInformation = {
                    previousToken: this._previousToken,
                    nextToken: null
                };

                if (this._previousTokenInformation !== null) {
                    this._previousTokenInformation.nextToken = token;
                }

                this._previousToken = token;
                this._previousTokenInformation = tokenInformation;

                this.tokenToInformation.add(token, tokenInformation);
            }

            this.elementToPosition.add(token, this._currentPosition);
            this._currentPosition += token.fullWidth();
        }

        public parent(element: ISyntaxElement): SyntaxNode {
            return this._elementToParent.get(element);
        }

        public fullStart(element: ISyntaxElement): number {
            return this.elementToPosition.get(element);
        }

        public start(element: ISyntaxElement): number {
            return this.fullStart(element) + element.leadingTriviaWidth();
        }

        public end(element: ISyntaxElement): number {
            return this.start(element) + element.width();
        }

        public previousToken(token: ISyntaxToken): ISyntaxToken {
            return this.tokenInformation(token).previousToken;
        }

        public tokenInformation(token: ISyntaxToken): ITokenInformation {
            return this.tokenToInformation.get(token);
        }

        public firstTokenInLineContainingToken(token: ISyntaxToken): ISyntaxToken {
            var current = token;
            while (true) {
                var information = this.tokenInformation(current);
                if (this.isFirstTokenInLineWorker(information)) {
                    break;
                }

                current = information.previousToken;
            }

            return current;
        }

        public isFirstTokenInLine(token: ISyntaxToken): bool {
            var information = this.tokenInformation(token);
            return this.isFirstTokenInLineWorker(information);

        }

        private isFirstTokenInLineWorker(information: ITokenInformation): bool {
            return information.previousToken === null || information.previousToken.hasTrailingNewLine();
        }
    }
}
/// <reference path='Syntax\SyntaxVisitor.generated.ts' />
/// <reference path='Syntax\SyntaxWalker.generated.ts' />
/// <reference path='Syntax\SyntaxInformationMap.ts' />
/// <reference path='ast.ts' />

module TypeScript {
    export class SyntaxPositionMap {
        private position = 0;
        private elementToPosition = Collections.createHashTable(2048, Collections.identityHashCode);

        constructor(node: SyntaxNode) {
            this.process(node);
        }

        private process(element: ISyntaxElement) {
            if (element !== null) {
                if (element.isToken()) {
                    this.elementToPosition.add(element, this.position);
                    this.position += element.fullWidth();
                }
                else {
                    if (element.isNode()) {
                        this.elementToPosition.add(element, this.position);
                    }

                    for (var i = 0, n = element.childCount(); i < n; i++) {
                        this.process(element.childAt(i));
                    }
                }
            }
        }

        public static create(node: SyntaxNode): SyntaxPositionMap {
            var map = new SyntaxPositionMap(node);
            return map;
        }

        public fullStart(element: ISyntaxElement): number {
            return this.elementToPosition.get(element);
        }

        public start(element: ISyntaxElement): number {
            return this.fullStart(element) + element.leadingTriviaWidth();
        }

        public end(element: ISyntaxElement): number {
            return this.start(element) + element.width();
        }

        public fullEnd(element: ISyntaxElement): number {
            return this.fullStart(element) + element.fullWidth();
        }
    }

    export class SyntaxTreeToAstVisitor implements ISyntaxVisitor {
        public static checkPositions = false;

        private nestingLevel = 0;
        private position = 0;

        private varLists: ASTList[] = [];
        private scopeLists: ASTList[] = [];
        private staticsLists: ASTList[] = [];

        private requiresExtendsBlock: bool = false;
        private previousTokenTrailingComments: Comment[] = null;

        private isParsingDeclareFile: bool;
        private isParsingAmbientModule = false;

        constructor(private syntaxPositionMap: SyntaxPositionMap,
                    private fileName: string,
                    private lineMap: LineMap,
                    private compilationSettings: CompilationSettings) {
            this.isParsingDeclareFile = isDTSFile(fileName);
        }

        public static visit(syntaxTree: SyntaxTree, fileName: string, compilationSettings: CompilationSettings): Script {
            var map = SyntaxTreeToAstVisitor.checkPositions ? SyntaxPositionMap.create(syntaxTree.sourceUnit()) : null;
            var visitor = new SyntaxTreeToAstVisitor(map, fileName, syntaxTree.lineMap(), compilationSettings);
            return syntaxTree.sourceUnit().accept(visitor);
        }

        private assertElementAtPosition(element: ISyntaxElement) {
            if (SyntaxTreeToAstVisitor.checkPositions) {
                Debug.assert(this.position === this.syntaxPositionMap.fullStart(element));
            }
        }

        private movePast(element: ISyntaxToken): void {
            if (element !== null) {
                this.assertElementAtPosition(element);
                this.position += element.fullWidth();
            }
        }

        private moveTo2(element1: ISyntaxNodeOrToken, element2: ISyntaxElement): void {
            if (element2 !== null) {
                this.position += Syntax.childOffset(element1, element2);
            }
        }

        private moveTo3(element1: ISyntaxNodeOrToken, element2: ISyntaxNodeOrToken, element3: ISyntaxNodeOrToken): void {
            this.moveTo2(element1, element2);
            this.moveTo2(element2, element3);
        }

        private setSpan(span: IASTSpan, start: number, end: number): void {
            span.minChar = start;
            span.limChar = end;
        }

        private hasEscapeSequence(token: ISyntaxToken): bool {
            // TODO: implement this.
            return false;
        }

        private valueText(token: ISyntaxToken): string {
            // TODO: handle unicode escapes here.
            return token.text();
        }

        private identifierFromToken(token: ISyntaxToken, isOptional: bool): Identifier {
            this.assertElementAtPosition(token);

            var result: Identifier = null;
            if (token.fullWidth() === 0) {
                result = new MissingIdentifier();
                result.flags |= ASTFlags.Error;
            }
            else {
                result = new Identifier(this.valueText(token), this.hasEscapeSequence(token));
            }

            if (isOptional) {
                result.flags |= ASTFlags.OptionalName;
            }

            this.setSpan(result, this.position, this.position + token.width());
            return result;
        }

        private visitSyntaxList(list: ISyntaxList): ASTList {
            var result = new ASTList();
            var start = this.position;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                result.append(list.childAt(i).accept(this));
            }

            this.setSpan(result, start, this.position);
            return result;
        }

        private visitSeparatedSyntaxList(list: ISeparatedSyntaxList): ASTList {
            var result = new ASTList();
            var start = this.position;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                if (i % 2 === 0) {
                    result.append(list.childAt(i).accept(this));
                    this.previousTokenTrailingComments = null;
                }
                else {
                    var separatorToken = <ISyntaxToken>list.childAt(i);
                    this.previousTokenTrailingComments = this.convertTokenTrailingComments(
                        separatorToken, this.position + separatorToken.leadingTriviaWidth() + separatorToken.width());
                    this.movePast(separatorToken);
                }
            }

            this.previousTokenTrailingComments = null;

            this.setSpan(result, start, this.position);
            return result;
        }

        private createRef(text: string, hasEscapeSequence: bool, minChar: number): Identifier {
            var id = new Identifier(text, hasEscapeSequence);
            id.minChar = minChar;
            return id;
        }

        private pushDeclLists() {
            this.staticsLists.push(new ASTList());
            this.varLists.push(new ASTList());
            this.scopeLists.push(new ASTList());
        }

        private popDeclLists() {
            this.staticsLists.pop();
            this.varLists.pop();
            this.scopeLists.pop();
        }

        private topVarList() {
            return this.varLists[this.varLists.length - 1];
        }

        private topScopeList() {
            return this.scopeLists[this.scopeLists.length - 1];
        }

        private topStaticsList() {
            return this.staticsLists[this.staticsLists.length - 1];
        }

        private convertComment(trivia: ISyntaxTrivia, commentStartPosition: number, hasTrailingNewLine: bool): Comment {
            var comment = new Comment(trivia.fullText(), trivia.kind() === SyntaxKind.MultiLineCommentTrivia, hasTrailingNewLine);

            comment.minChar = commentStartPosition;
            comment.limChar = commentStartPosition + trivia.fullWidth();
            comment.minLine = this.lineMap.getLineNumberFromPosition(comment.minChar);
            comment.limLine = this.lineMap.getLineNumberFromPosition(comment.limChar);

            return comment;
        }

        private convertComments(triviaList: ISyntaxTriviaList, commentStartPosition: number): Comment[] {
            var result: Comment[] = [];

            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                if (trivia.isComment()) {
                    var hasTrailingNewLine = ((i + 1) < n) && triviaList.syntaxTriviaAt(i + 1).isNewLine();
                    result.push(this.convertComment(trivia, commentStartPosition, hasTrailingNewLine));
                }

                commentStartPosition += trivia.fullWidth();
            }

            return result;
        }

        private mergeComments(comments1: Comment[], comments2: Comment[]): Comment[]{
            if (comments1 === null) {
                return comments2;
            }

            if (comments2 === null) {
                return comments1;
            }

            return comments1.concat(comments2);

        }

        private convertTokenLeadingComments(token: ISyntaxToken, commentStartPosition: number): Comment[] {
            if (token === null) {
                return null;
            }

            var preComments = token.hasLeadingComment()
                ? this.convertComments(token.leadingTrivia(), commentStartPosition)
                : null;

            var previousTokenTrailingComments = this.previousTokenTrailingComments;
            this.previousTokenTrailingComments = null;

            return this.mergeComments(previousTokenTrailingComments, preComments);
        }

        private convertTokenTrailingComments(token: ISyntaxToken, commentStartPosition: number): Comment[] {
            if (token === null || !token.hasTrailingComment() || token.hasTrailingNewLine()) {
                return null;
            }

            return this.convertComments(token.trailingTrivia(), commentStartPosition);
        }

        private convertNodeLeadingComments(node: SyntaxNode, nodeStart: number): Comment[] {
            return this.convertTokenLeadingComments(node.firstToken(), nodeStart);
        }

        private convertNodeTrailingComments(node: SyntaxNode, nodeStart: number): Comment[] {
            return this.convertTokenTrailingComments(node.lastToken(), nodeStart + node.leadingTriviaWidth() + node.width());
        }

        private visitToken(token: ISyntaxToken): AST {
            this.assertElementAtPosition(token);

            var result: AST = null;
            var start = this.position;
            
            if (token.kind() === SyntaxKind.ThisKeyword) {
                result = new AST(NodeType.This);
            }
            else if (token.kind() === SyntaxKind.SuperKeyword) {
                result = new AST(NodeType.Super);
            }
            else if (token.kind() === SyntaxKind.TrueKeyword) {
                result = new AST(NodeType.True);
            }
            else if (token.kind() === SyntaxKind.FalseKeyword) {
                result = new AST(NodeType.False);
            }
            else if (token.kind() === SyntaxKind.NullKeyword) {
                result = new AST(NodeType.Null);
            }
            else if (token.kind() === SyntaxKind.StringLiteral) {
                result = new StringLiteral(token.text());
            }
            else if (token.kind() === SyntaxKind.RegularExpressionLiteral) {
                result = new RegexLiteral(token.text());
            }
            else if (token.kind() === SyntaxKind.NumericLiteral) {
                var preComments = this.convertTokenLeadingComments(token, start);

                var value = token.text().indexOf(".") > 0 ? parseFloat(token.text()) : parseInt(token.text());
                result = new NumberLiteral(value, token.text());

                result.preComments = preComments;
            }
            else {
                result = this.identifierFromToken(token, /*isOptional:*/ false);
            }

            start = this.position + token.leadingTriviaWidth();
            this.setSpan(result, start, start + token.width());
            this.movePast(token);
            return result;
        }

        private hasTopLevelImportOrExport(node: SourceUnitSyntax): bool {
            // TODO: implement this.

            var firstToken: ISyntaxToken;
            var i = 0;
            var n = 0;

            for (i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var moduleElement = node.moduleElements.childAt(i);

                firstToken = moduleElement.firstToken();
                if (firstToken !== null && firstToken.kind() === SyntaxKind.ExportKeyword) {
                    return true;
                }

                if (moduleElement.kind() === SyntaxKind.ImportDeclaration) {
                    var importDecl = <ImportDeclarationSyntax>moduleElement;
                    if (importDecl.moduleReference.kind() === SyntaxKind.ExternalModuleReference) {
                        return true;
                    }
                }
            }

            firstToken = node.firstToken();

            if (firstToken.hasLeadingComment()) {
                var leadingTrivia = firstToken.leadingTrivia();

                for (i = 0, n = leadingTrivia.count(); i < n; i++) {
                    var trivia = leadingTrivia.syntaxTriviaAt(i);

                    if (trivia.isComment()) {
                        // var dependencyPath = getAdditionalDependencyPath(trivia.text());

                        //if (dependencyPath) {
                        //    this.amdDependencies.push(dependencyPath);
                        //}

                        if (getImplicitImport(trivia.fullText())) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        private hasUseStrictDirective(list: ISyntaxList): bool {
            // Check if all the items are directive prologue elements.
            for (var i = 0; i < list.childCount(); i++) {
                var item = list.childAt(i);
                if (!SyntaxFacts.isDirectivePrologueElement(item)) {
                    return false;
                }

                if (SyntaxFacts.isUseStrictDirective(item)) {
                    return true;
                }
            }

            return false;
        }

        private visitSourceUnit(node: SourceUnitSyntax): Script {
            this.assertElementAtPosition(node);

            var start = this.position;
            var members;
            this.pushDeclLists();

            var bod = this.visitSyntaxList(node.moduleElements);

            if (this.hasUseStrictDirective(node.moduleElements)) {
                bod.flags |= ASTFlags.StrictMode;
            }

            var topLevelMod: ModuleDeclaration = null;
            if (this.compilationSettings.moduleGenTarget != ModuleGenTarget.Local && this.hasTopLevelImportOrExport(node)) {
                var correctedFileName = switchToForwardSlashes(this.fileName);
                var id: Identifier = new Identifier(correctedFileName);
                topLevelMod = new ModuleDeclaration(id, bod, this.topVarList(), null);
                this.setSpan(topLevelMod, start, this.position);

                topLevelMod.modFlags |= ModuleFlags.IsDynamic;
                topLevelMod.modFlags |= ModuleFlags.IsWholeFile;
                topLevelMod.modFlags |= ModuleFlags.Exported;

                if (this.isParsingDeclareFile) {
                    topLevelMod.modFlags |= ModuleFlags.Ambient;
                }

                topLevelMod.prettyName = getPrettyName(correctedFileName);
                //topLevelMod.containsUnicodeChar = this.scanner.seenUnicodeChar;
                //topLevelMod.containsUnicodeCharInComment = this.scanner.seenUnicodeCharInComment;

                // topLevelMod.amdDependencies = this.amdDependencies;

                bod = new ASTList();
                this.setSpan(bod, start, this.position);
                bod.append(topLevelMod);
            }

            var result = new Script(this.topVarList(), this.topScopeList());
            this.setSpan(result, start, this.position);

            this.popDeclLists();

            result.bod = bod;
            result.locationInfo = new LocationInfo(this.fileName, this.lineMap);
            result.topLevelMod = topLevelMod;
            result.isDeclareFile = this.isParsingDeclareFile;
            result.requiresExtendsBlock = this.requiresExtendsBlock;

            return result;
        }

        private visitExternalModuleReference(node: ExternalModuleReferenceSyntax): any {
            this.assertElementAtPosition(node);
            this.moveTo2(node, node.stringLiteral);
            var result = this.identifierFromToken(node.stringLiteral, /*isOptional:*/ false);
            this.movePast(node.stringLiteral);
            this.movePast(node.closeParenToken);

            return result;
        }

        private visitModuleNameModuleReference(node: ModuleNameModuleReferenceSyntax): any {
            this.assertElementAtPosition(node);
            return node.moduleName.accept(this);
        }

        private visitClassDeclaration(node: ClassDeclarationSyntax): ClassDeclaration {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);
            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);

            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var extendsList = node.extendsClause ? node.extendsClause.accept(this) : new ASTList();
            var implementsList = node.implementsClause ? node.implementsClause.accept(this) : new ASTList();
            this.movePast(node.openBraceToken);
            var members = this.visitSyntaxList(node.classElements);
            this.movePast(node.closeBraceToken);

            this.requiresExtendsBlock = this.requiresExtendsBlock || !!node.extendsClause;

            var result = new ClassDeclaration(name, typeParameters, members, extendsList, implementsList);
            this.setSpan(result, start, this.position);

            result.preComments = preComments;
            result.postComments = postComments;

            if (node.exportKeyword || this.isParsingAmbientModule) {
                result.varFlags |= VarFlags.Exported;
            }

            if (node.declareKeyword || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                result.varFlags |= VarFlags.Ambient;
            }

            result.varFlags |= VarFlags.Class;

            var i = 0;
            var n = 0;

            for (i = 0; i < members.members.length; i++) {
                var member = members.members[i];
                if (member.nodeType === NodeType.FuncDecl) {
                    var funcDecl = <FuncDecl>member;

                    if (funcDecl.isConstructor) {
                        funcDecl.name = name;
                        funcDecl.classDecl = result;

                        result.constructorDecl = funcDecl;
                    }
                }
            }

            var knownMemberNames: any = {};

            for (i = 0, n = node.classElements.childCount(); i < n; i++) {
                var classElement = <IClassElementSyntax>node.classElements.childAt(i);

                if (classElement.kind() === SyntaxKind.MemberVariableDeclaration) {
                    var variableDeclaration = <MemberVariableDeclarationSyntax>classElement;
                    knownMemberNames[this.valueText(variableDeclaration.variableDeclarator.identifier)] = true;
                }
                else if (classElement.kind() === SyntaxKind.MemberFunctionDeclaration) {
                    var functionDeclaration = <MemberFunctionDeclarationSyntax>classElement;
                    knownMemberNames[this.valueText(functionDeclaration.propertyName)] = true;
                }
            }

            result.knownMemberNames = knownMemberNames;

            return result;
        }

        private visitInterfaceDeclaration(node: InterfaceDeclarationSyntax): InterfaceDeclaration {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);
            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var extendsList = node.extendsClause ? node.extendsClause.accept(this) : null;
            this.movePast(node.body.openBraceToken);
            var members = this.visitSeparatedSyntaxList(node.body.typeMembers);

            // Fix up interface method flags
            if (members.members) {
                for (var i = 0; i < members.members.length; i++) {
                    if (members.members[i].nodeType === NodeType.FuncDecl) {
                        (<FuncDecl>members.members[i]).fncFlags |= FncFlags.Method;
                        (<FuncDecl>members.members[i]).fncFlags |= FncFlags.Signature;
                    }
                }
            }

            this.movePast(node.body.closeBraceToken);

            var result = new InterfaceDeclaration(name, typeParameters, members, extendsList, null);
            this.setSpan(result, start, this.position);

            result.preComments = preComments;
            result.postComments = postComments;

            //if (node.publicOrPrivateKeyword) {
            //    result.varFlags |= VarFlags.Private;
            //}
            //if (hasFlag(modifiers, Modifiers.Public)) {
            //    result.varFlags |= VarFlags.Public;
            //}

            if (node.exportKeyword || this.isParsingAmbientModule) {
                result.varFlags |= VarFlags.Exported;
            }

            return result;
        }

        private visitExtendsClause(node: ExtendsClauseSyntax): ASTList {
            this.assertElementAtPosition(node);

            var result = new ASTList();

            this.movePast(node.extendsKeyword);
            for (var i = 0, n = node.typeNames.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(<ISyntaxToken>node.typeNames.childAt(i));
                }
                else {
                    var type = this.visitType(node.typeNames.childAt(i));
                    if (type.nodeType === NodeType.TypeRef) {
                        type = (<TypeReference>type).term;
                    }

                    result.append(type);
                }
            }

            return result;
        }

        private visitImplementsClause(node: ImplementsClauseSyntax): ASTList {
            this.assertElementAtPosition(node);

            var result = new ASTList();

            this.movePast(node.implementsKeyword);
            for (var i = 0, n = node.typeNames.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(<ISyntaxToken>node.typeNames.childAt(i));
                }
                else {
                    var type = this.visitType(node.typeNames.childAt(i));
                    if (type.nodeType === NodeType.TypeRef) {
                        type = (<TypeReference>type).term;
                    }

                    result.append(type);
                }
            }

            return result;
        }

        private getModuleNames(node: ModuleDeclarationSyntax): Identifier[] {
            var result: Identifier[] = [];

            if (node.stringLiteral !== null) {
                result.push(this.identifierFromToken(node.stringLiteral, /*isOptional:*/false));
                this.movePast(node.stringLiteral);
            }
            else {
                this.getModuleNamesHelper(node.moduleName, result);
            }

            return result;
        }

        private getModuleNamesHelper(name: INameSyntax, result: Identifier[]): void {
            this.assertElementAtPosition(name);

            if (name.kind() === SyntaxKind.QualifiedName) {
                var qualifiedName = <QualifiedNameSyntax>name;
                this.getModuleNamesHelper(qualifiedName.left, result);
                this.movePast(qualifiedName.dotToken);
                result.push(this.identifierFromToken(qualifiedName.right, /*isOptional:*/ false));
                this.movePast(qualifiedName.right);
            }
            else {
                result.push(this.identifierFromToken(<ISyntaxToken>name, /*isOptional:*/ false));
                this.movePast(<ISyntaxToken>name);
            }
        }

        private visitModuleDeclaration(node: ModuleDeclarationSyntax): ModuleDeclaration {
            this.assertElementAtPosition(node);

            this.pushDeclLists();

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.movePast(node.exportKeyword);
            this.movePast(node.declareKeyword);
            this.movePast(node.moduleKeyword);
            var names = this.getModuleNames(node);
            this.movePast(node.openBraceToken);
            var svIsParsingAmbientModule = this.isParsingAmbientModule;
            if (node.declareKeyword|| this.isParsingDeclareFile) {
                this.isParsingAmbientModule = true;
            }
            var members = this.visitSyntaxList(node.moduleElements);
            this.isParsingAmbientModule = svIsParsingAmbientModule;
            var closeBracePosition = this.position;
            this.movePast(node.closeBraceToken);

            var moduleDecl: ModuleDeclaration = null;

            for (var i = names.length - 1; i >= 0; i--) {
                var innerName = names[i];

                var closeBraceSpan = new ASTSpan();
                closeBraceSpan.minChar = closeBracePosition;
                closeBraceSpan.limChar = this.position;

                moduleDecl = new ModuleDeclaration(innerName, members, this.topVarList(), closeBraceSpan);
                this.setSpan(moduleDecl, start, this.position);

                moduleDecl.preComments = preComments;
                moduleDecl.postComments = postComments;

                preComments = null;
                postComments = null;

                // mark the inner module declarations as exported
                if (i) {
                    moduleDecl.modFlags |= ModuleFlags.Exported;
                } else if (node.exportKeyword || this.isParsingAmbientModule) {
                    // outer module is exported if export key word or parsing ambient module
                    moduleDecl.modFlags |= ModuleFlags.Exported;
                }

                // mark ambient if declare keyword or parsing ambient module or parsing declare file
                if (node.declareKeyword || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                    moduleDecl.modFlags |= ModuleFlags.Ambient;
                }

                // REVIEW: will also possibly need to re-parent comments as well

                if (i === 0) {
                    this.popDeclLists();
                }

                members = new ASTList();
                members.append(moduleDecl);
            }

            //if (isDynamicMod) {
            //    moduleDecl.modFlags |= ModuleFlags.IsDynamic;
            //}

            //this.ambientModule = svAmbient;

            //this.topLevel = svTopLevel;
            //moduleDecl.leftCurlyCount = this.scanner.leftCurlyCount - leftCurlyCount;
            //moduleDecl.rightCurlyCount = this.scanner.rightCurlyCount - rightCurlyCount;
            //moduleDecl.limChar = moduleBody.limChar;

            return moduleDecl;
        }

        private hasDotDotDotParameter(parameters: ISeparatedSyntaxList): bool {
            for (var i = 0, n = parameters.nonSeparatorCount(); i < n; i++) {
                if ((<ParameterSyntax>parameters.nonSeparatorAt(i)).dotDotDotToken) {
                    return true;
                }
            }

            return false;
        }

        private convertBlock(node: BlockSyntax): ASTList {
            if (!node) {
                return null;
            }

            this.movePast(node.openBraceToken);
            var statements = this.visitSyntaxList(node.statements);
            this.movePast(node.closeBraceToken);

            return statements;
        }

        private visitFunctionDeclaration(node: FunctionDeclarationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);

            this.movePast(node.identifier);

            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);

            var returnType = node.callSignature.typeAnnotation
                ? node.callSignature.typeAnnotation.accept(this)
                : null;

            this.pushDeclLists();

            var bod = this.convertBlock(node.block);
            if (bod) {
                bod.append(new EndCode());
            }

            if (node.block) {
                if (this.hasUseStrictDirective(node.block.statements)) {
                    bod.flags |= ASTFlags.StrictMode;
                }
            }

            this.movePast(node.semicolonToken);

            var funcDecl = new FuncDecl(name, bod, false, typeParameters, parameters, this.topVarList(),
                this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(funcDecl, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);

            funcDecl.preComments = preComments;
            funcDecl.postComments = postComments;
            funcDecl.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            funcDecl.returnTypeAnnotation = returnType;

            if (node.exportKeyword || this.isParsingAmbientModule) {
                funcDecl.fncFlags |= FncFlags.Exported;
            }

            if (node.declareKeyword || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                funcDecl.fncFlags |= FncFlags.Ambient;
            }

            if (node.semicolonToken) {
                funcDecl.fncFlags |= FncFlags.Signature;
            }

            return funcDecl;
        }

        private visitEnumDeclaration(node: EnumDeclarationSyntax): ModuleDeclaration {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);

            this.pushDeclLists();

            this.movePast(node.openBraceToken);
            var members = new ASTList();

            var mapDecl = new VarDecl(new Identifier("_map"), 0);

            mapDecl.varFlags |= VarFlags.Exported;
            mapDecl.varFlags |= VarFlags.Private;

            // REVIEW: Is this still necessary?
            mapDecl.varFlags |= (VarFlags.Property | VarFlags.Public);
            mapDecl.init = new UnaryExpression(NodeType.ArrayLit, null);
            members.append(mapDecl);
            var lastValue: NumberLiteral = null;
            var memberNames: Identifier[] = [];
            var memberName: Identifier;

            for (var i = 0, n = node.enumElements.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(<ISyntaxToken>node.enumElements.childAt(i));
                }
                else {
                    var enumElement = <EnumElementSyntax>node.enumElements.childAt(i);

                    var memberValue: AST = null;

                    memberName = this.identifierFromToken(enumElement.identifier || enumElement.stringLiteral, /*isOptional:*/ false);
                    this.movePast(enumElement.identifier);
                    this.movePast(enumElement.stringLiteral);

                    if (enumElement.equalsValueClause !== null) {
                        memberValue = enumElement.equalsValueClause.accept(this);
                        lastValue = <NumberLiteral>memberValue;
                    }

                    var memberStart = this.position;

                    if (memberValue === null) {
                        if (lastValue === null) {
                            memberValue = new NumberLiteral(0, "0");
                            lastValue = <NumberLiteral>memberValue;
                        }
                        else {
                            var nextValue = lastValue.value + 1;
                            memberValue = new NumberLiteral(nextValue, nextValue.toString());
                            lastValue = <NumberLiteral>memberValue;
                        }
                        var map: BinaryExpression =
                            new BinaryExpression(NodeType.Asg,
                                                 new BinaryExpression(NodeType.Index,
                                                                      new Identifier("_map"),
                                                                      memberValue),
                                                 new StringLiteral('"' + memberName.actualText + '"'));
                        members.append(map);
                    }

                    var member = new VarDecl(memberName, this.nestingLevel);
                    member.init = memberValue;
                    // Note: Leave minChar, limChar as "-1" on typeExpr as this is a parsing artifact.
                    member.typeExpr = new TypeReference(this.createRef(name.actualText, name.hasEscapeSequence, -1), 0);
                    member.varFlags |= (VarFlags.Readonly | VarFlags.Property);
                    this.setSpan(member, memberStart, this.position);

                    if (memberValue.nodeType === NodeType.NumberLit) {
                        member.varFlags |= VarFlags.Constant;
                    }
                    else if (memberValue.nodeType === NodeType.Lsh) {
                        // If the initializer is of the form "value << value" then treat it as a constant
                        // as well.
                        var binop = <BinaryExpression>memberValue;
                        if (binop.operand1.nodeType === NodeType.NumberLit && binop.operand2.nodeType === NodeType.NumberLit) {
                            member.varFlags |= VarFlags.Constant;
                        }
                    }
                    else if (memberValue.nodeType === NodeType.Name) {
                        // If the initializer refers to an earlier enum value, then treat it as a constant
                        // as well.
                        var nameNode = <Identifier>memberValue;
                        for (var j = 0; j < memberNames.length; j++) {
                            memberName = memberNames[j];
                            if (memberName.text === nameNode.text) {
                                member.varFlags |= VarFlags.Constant;
                                break;
                            }
                        }
                    }

                    members.append(member);
                    memberNames.push(memberName);
                    // all enum members are exported
                    member.varFlags |= VarFlags.Exported;
                }
            }

            this.movePast(node.closeBraceToken);

            var endingToken = new ASTSpan();
            var modDecl = new ModuleDeclaration(name, members, this.topVarList(), endingToken);
            this.setSpan(modDecl, start, this.position);
            this.setSpan(mapDecl, start, this.position);

            modDecl.preComments = preComments;
            modDecl.postComments = postComments;
            modDecl.modFlags |= ModuleFlags.IsEnum;
            modDecl.recordNonInterface();

            if (node.exportKeyword || this.isParsingAmbientModule) {
                modDecl.modFlags |= ModuleFlags.Exported;
            }

            this.popDeclLists();

            return modDecl;
        }

        private visitEnumElement(node: EnumElementSyntax): void {
            // Processing enum elements should be handled from inside visitEnumDeclaration.
            throw Errors.invalidOperation();
        }

        private visitImportDeclaration(node: ImportDeclarationSyntax): ImportDeclaration {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            this.movePast(node.equalsToken);
            var alias = node.moduleReference.accept(this);
            this.movePast(node.semicolonToken);

            var importDecl = new ImportDeclaration(name, alias);
            this.setSpan(importDecl, start, this.position);

            importDecl.preComments = preComments;
            importDecl.postComments = postComments;
            importDecl.isDynamicImport = node.moduleReference.kind() === SyntaxKind.ExternalModuleReference;

            return importDecl;
        }

        private visitExportAssignment(node: ExportAssignmentSyntax): ExportAssignment {
            this.assertElementAtPosition(node);
            var start = this.position;

            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);

            var result = new ExportAssignment(name);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitVariableStatement(node: VariableStatementSyntax): AST {
            this.assertElementAtPosition(node);
            var start = this.position;

            var preComments: Comment[] = null;

            if (node.exportKeyword) {
                preComments = this.convertTokenLeadingComments(node.exportKeyword, start);
                this.movePast(node.exportKeyword);
            }

            if (node.declareKeyword) {
                preComments = this.convertTokenLeadingComments(node.declareKeyword, this.position);
                this.movePast(node.declareKeyword);
            }

            var varList = node.variableDeclaration.accept(this);
            this.movePast(node.semicolonToken);

            if (varList.nodeType === NodeType.VarDecl) {
                varDecl = <VarDecl>varList;
                varList = new ASTList();
                varList.append(varDecl);
            }

            for (var i = 0, n = varList.members.length; i < n; i++) {
                var varDecl = <VarDecl>varList.members[i];

                if (i === 0) {
                    varDecl.preComments = this.mergeComments(preComments, varDecl.preComments);
                }

                if (node.exportKeyword || this.isParsingAmbientModule) {
                    varDecl.varFlags |= VarFlags.Exported;
                }

                if (node.declareKeyword || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                    varDecl.varFlags |= VarFlags.Ambient;
                }
            }

            if (node.variableDeclaration.variableDeclarators.nonSeparatorCount() === 1) {
                return varList.members[0];
            }
            else {
                var result = new Block(varList, /*isStatementBlock:*/ false);
                this.setSpan(result, start, this.position);

                return result;
            }
        }

        private visitVariableDeclaration(node: VariableDeclarationSyntax): AST {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.moveTo2(node, node.variableDeclarators);
            var variableDecls = this.visitSeparatedSyntaxList(node.variableDeclarators);

            for (var i = 0; i < variableDecls.members.length; i++) {
                (<BoundDecl>variableDecls.members[i]).nestingLevel = i;

                if (i === 0) {
                    variableDecls.members[i].preComments = preComments;
                    variableDecls.members[i].postComments = postComments;
                }
            }

            if (variableDecls.members.length === 1) {
                return variableDecls.members[0];
            }

            return variableDecls;
        }

        private visitVariableDeclarator(node: VariableDeclaratorSyntax): VarDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;

            var result = new VarDecl(name, 0);
            this.setSpan(result, start, this.position);

            this.topVarList().append(result);

            result.typeExpr = typeExpr;
            result.init = init;
            if (init && init.nodeType === NodeType.FuncDecl) {
                var funcDecl = <FuncDecl>init;
                funcDecl.hint = name.actualText;
            }

            // TODO: more flags

            return result;
        }

        private visitEqualsValueClause(node: EqualsValueClauseSyntax): AST {
            this.assertElementAtPosition(node);

            this.previousTokenTrailingComments = this.convertTokenTrailingComments(node.equalsToken,
                this.position + node.equalsToken.leadingTriviaWidth() + node.equalsToken.width());

            this.movePast(node.equalsToken);
            var result = node.value.accept(this);

            this.previousTokenTrailingComments = null;
            return result;
        }

        private getUnaryExpressionNodeType(kind: SyntaxKind): NodeType {
            switch (kind) {
                case SyntaxKind.PlusExpression: return NodeType.Pos;
                case SyntaxKind.NegateExpression: return NodeType.Neg;
                case SyntaxKind.BitwiseNotExpression: return NodeType.Not;
                case SyntaxKind.LogicalNotExpression: return NodeType.LogNot;
                case SyntaxKind.PreIncrementExpression: return NodeType.IncPre;
                case SyntaxKind.PreDecrementExpression: return NodeType.DecPre;
                default:
                    throw Errors.invalidOperation();
            }
        }

        private visitPrefixUnaryExpression(node: PrefixUnaryExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.operatorToken);
            var operand = node.operand.accept(this);

            var result = new UnaryExpression(this.getUnaryExpressionNodeType(node.kind()), operand);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitArrayLiteralExpression(node: ArrayLiteralExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.openBracketToken);
            var expressions = this.visitSeparatedSyntaxList(node.expressions);
            this.movePast(node.closeBracketToken);

            if (node.expressions.childCount() > 0 && node.expressions.childAt(node.expressions.childCount() - 1).kind() === SyntaxKind.CommaToken) {
                expressions.append(new AST(NodeType.EmptyExpr));
            }

            var result = new UnaryExpression(NodeType.ArrayLit, expressions);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitOmittedExpression(node: OmittedExpressionSyntax): any {
            this.assertElementAtPosition(node);

            var start = this.position;

            var result = new AST(NodeType.EmptyExpr);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitParenthesizedExpression(node: ParenthesizedExpressionSyntax): AST {
            this.assertElementAtPosition(node);

            this.movePast(node.openParenToken);
            var result = node.expression.accept(this);
            this.movePast(node.closeParenToken);

            result.isParenthesized = true;

            return result;
        }

        private getArrowFunctionStatements(body: ISyntaxNodeOrToken): ASTList {
            var statements: ASTList = null;

            if (body.kind() === SyntaxKind.Block) {
                var block = <BlockSyntax>body;

                statements = this.convertBlock(block);
            }
            else {
                statements = new ASTList();

                var expr = body.accept(this);
                var retStmt = new ReturnStatement();
                retStmt.returnExpression = expr;

                statements.append(retStmt);
            }

            statements.append(new EndCode());

            return statements;
        }

        private visitSimpleArrowFunctionExpression(node: SimpleArrowFunctionExpressionSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;
            var identifier = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            this.movePast(node.equalsGreaterThanToken);

            var parameters = new ASTList();

            var parameter = new ArgDecl(identifier);
            this.setSpan(parameter, identifier.minChar, identifier.limChar);

            parameters.append(parameter);

            this.pushDeclLists();

            var statements = this.getArrowFunctionStatements(node.body);

            var result = new FuncDecl(null, statements, /*isConstructor:*/ false, null, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(result);

            result.returnTypeAnnotation = null;
            result.fncFlags |= FncFlags.IsFunctionExpression;
            result.fncFlags |= FncFlags.IsFatArrowFunction;

            return result;
        }

        private visitParenthesizedArrowFunctionExpression(node: ParenthesizedArrowFunctionExpressionSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);

            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
            this.movePast(node.equalsGreaterThanToken);

            this.pushDeclLists();

            var statements = this.getArrowFunctionStatements(node.body);

            var result = new FuncDecl(null, statements, /*isConstructor:*/ false, typeParameters, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            this.popDeclLists();
            var scopeList = this.topScopeList();
            scopeList.append(result);

            result.preComments = preComments;
            result.returnTypeAnnotation = returnType;
            result.fncFlags |= FncFlags.IsFunctionExpression;
            result.fncFlags |= FncFlags.IsFatArrowFunction;
            result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);

            return result;
        }

        private visitType(type: ITypeSyntax): AST {
            this.assertElementAtPosition(type);

            if (type.isToken()) {
                var start = this.position;
                var result = new TypeReference(type.accept(this), 0);
                this.setSpan(result, start, this.position);

                return result;
            }
            else {
                return type.accept(this);
            }
        }

        private visitQualifiedName(node: QualifiedNameSyntax): TypeReference {
            this.assertElementAtPosition(node);

            var start = this.position;
            var left = this.visitType(node.left);
            this.movePast(node.dotToken);
            var right = this.identifierFromToken(node.right, /*isOptional:*/ false);
            this.movePast(node.right);

            if (left.nodeType === NodeType.TypeRef) {
                left = (<TypeReference>left).term;
            }

            var term = new BinaryExpression(NodeType.Dot, left, right);
            this.setSpan(term, start, this.position);

            var result = new TypeReference(term, 0);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitTypeArgumentList(node: TypeArgumentListSyntax): ASTList {
            this.assertElementAtPosition(node);

            var result = new ASTList();

            this.movePast(node.lessThanToken);
            for (var i = 0, n = node.typeArguments.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(<ISyntaxToken>node.typeArguments.childAt(i));
                }
                else {
                    result.append(this.visitType(node.typeArguments.childAt(i)));
                }
            }
            this.movePast(node.greaterThanToken);

            return result;
        }

        private visitConstructorType(node: ConstructorTypeSyntax): any {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.newKeyword);
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = node.type ? this.visitType(node.type) : null;

            var result = new FuncDecl(null, null, false, typeParameters, parameters, null, null, null, NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            result.returnTypeAnnotation = returnType;
            // funcDecl.variableArgList = variableArgList;
            result.fncFlags |= FncFlags.Signature;
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);

            result.fncFlags |= FncFlags.ConstructMember;
            result.flags |= ASTFlags.TypeReference;
            result.hint = "_construct";
            result.classDecl = null;

            var typeRef = new TypeReference(result, 0);
            this.setSpan(typeRef, start, this.position);

            return typeRef;
        }

        private visitFunctionType(node: FunctionTypeSyntax): TypeReference {
            this.assertElementAtPosition(node);

            var start = this.position;
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = node.type ? this.visitType(node.type) : null;

            var result = new FuncDecl(null, null, false, typeParameters, parameters, null, null, null, NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            result.returnTypeAnnotation = returnType;
            // funcDecl.variableArgList = variableArgList;
            result.fncFlags |= FncFlags.Signature;
            result.flags |= ASTFlags.TypeReference;
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);

            var typeRef = new TypeReference(result, 0);
            this.setSpan(typeRef, start, this.position);

            return typeRef;
        }

        private visitObjectType(node: ObjectTypeSyntax): TypeReference {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.openBraceToken);
            var typeMembers = this.visitSeparatedSyntaxList(node.typeMembers);

            if (typeMembers.members) {
                for (var i = 0; i < typeMembers.members.length; i++) {
                    if (typeMembers.members[i].nodeType === NodeType.FuncDecl) {
                        (<FuncDecl>typeMembers.members[i]).fncFlags |= FncFlags.Method;
                        (<FuncDecl>typeMembers.members[i]).fncFlags |= FncFlags.Signature;
                    }
                }
            }
            this.movePast(node.closeBraceToken);

            var result = new InterfaceDeclaration(
                new Identifier("_anonymous"),
                null,
                typeMembers,
                null, null);

            result.flags |= ASTFlags.TypeReference;

            this.setSpan(result, start, this.position);

            var typeRef = new TypeReference(result, 0);
            this.setSpan(typeRef, start, this.position);

            return typeRef;
        }

        private visitArrayType(node: ArrayTypeSyntax): TypeReference {
            this.assertElementAtPosition(node);

            var start = this.position;
            var underlying = this.visitType(node.type);
            this.movePast(node.openBracketToken);
            this.movePast(node.closeBracketToken);

            var result: TypeReference = null;
            if (underlying.nodeType === NodeType.TypeRef) {
                result = <TypeReference>underlying;
                result.arrayCount++;
            }
            else {
                result = new TypeReference(underlying, 1);
            }

            result.flags |= ASTFlags.TypeReference;

            this.setSpan(result, start, this.position);

            return result;
        }

        private visitGenericType(node: GenericTypeSyntax): TypeReference {
            this.assertElementAtPosition(node);

            var start = this.position;
            var underlying = this.visitType(node.name);
            var typeArguments = node.typeArgumentList.accept(this);

            if (underlying.nodeType === NodeType.TypeRef) {
                underlying = (<TypeReference>underlying).term;
            }

            var genericType = new GenericType(underlying, typeArguments);

            genericType.flags |= ASTFlags.TypeReference;

            var result = new TypeReference(genericType, 0);
            this.setSpan(result, start, this.position);
            this.setSpan(genericType, start, this.position);

            return result;
        }

        private visitTypeAnnotation(node: TypeAnnotationSyntax): AST {
            this.assertElementAtPosition(node);

            this.movePast(node.colonToken);
            return this.visitType(node.type);
        }

        private visitBlock(node: BlockSyntax): Block {
            this.assertElementAtPosition(node);

            var start = this.position;
            var statements = this.convertBlock(node);

            var result = new Block(statements, /*isStatementBlock:*/ true);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitParameter(node: ParameterSyntax): ArgDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.moveTo2(node, node.identifier);
            var identifier = this.identifierFromToken(node.identifier, !!node.questionToken);
            this.movePast(node.identifier);
            this.movePast(node.questionToken);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;

            var result = new ArgDecl(identifier);
            this.setSpan(result, start, this.position);

            result.preComments = preComments;
            result.postComments = postComments;
            result.isOptional = !!node.questionToken;
            result.init = init;
            result.typeExpr = typeExpr;

            if (node.publicOrPrivateKeyword) {
                result.varFlags |= VarFlags.Property;

                if (node.publicOrPrivateKeyword.kind() === SyntaxKind.PublicKeyword) {
                    result.varFlags |= VarFlags.Public;
                }
                else {
                    result.varFlags |= VarFlags.Private;
                }
            }

            if (node.equalsValueClause || node.dotDotDotToken) {
                result.flags |= ASTFlags.OptionalName;
            }

            return result;
        }

        private visitMemberAccessExpression(node: MemberAccessExpressionSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var expression: AST = node.expression.accept(this);
            this.movePast(node.dotToken);
            var name = this.identifierFromToken(node.name, /*isOptional:*/ false);
            this.movePast(node.name);

            var result = new BinaryExpression(NodeType.Dot, expression, name);
            this.setSpan(result, start, this.position);

            expression.flags |= ASTFlags.DotLHS;

            return result;
        }

        private visitPostfixUnaryExpression(node: PostfixUnaryExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var operand = node.operand.accept(this);
            this.movePast(node.operatorToken);

            var result = new UnaryExpression(node.kind() === SyntaxKind.PostIncrementExpression ? NodeType.IncPost : NodeType.DecPost,
                operand);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitElementAccessExpression(node: ElementAccessExpressionSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var expression = node.expression.accept(this);
            this.movePast(node.openBracketToken);
            var argumentExpression = node.argumentExpression.accept(this);
            this.movePast(node.closeBracketToken);

            var result = new BinaryExpression(NodeType.Index, expression, argumentExpression);
            this.setSpan(result, start, this.position);

            return result;
        }

        private convertArgumentListArguments(node: ArgumentListSyntax): ASTList {
            if (node === null) {
                return null;
            }

            this.movePast(node.openParenToken);
            var result = this.visitSeparatedSyntaxList(node.arguments);
            this.movePast(node.closeParenToken);
            return result;
        }

        private visitInvocationExpression(node: InvocationExpressionSyntax): CallExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var expression = node.expression.accept(this);
            var typeArguments = node.argumentList.typeArgumentList !== null
                ? node.argumentList.typeArgumentList.accept(this)
                : null;
            var argumentList = this.convertArgumentListArguments(node.argumentList);

            var result = new CallExpression(NodeType.Call, expression, typeArguments, argumentList);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitArgumentList(node: ArgumentListSyntax): ASTList {
            // Processing argument lists should be handled from inside visitInvocationExpression or 
            // visitObjectCreationExpression.
            throw Errors.invalidOperation();
        }

        private getBinaryExpressionNodeType(node: BinaryExpressionSyntax): NodeType {
            switch (node.kind()) {
                case SyntaxKind.CommaExpression: return NodeType.Comma;
                case SyntaxKind.AssignmentExpression: return NodeType.Asg;
                case SyntaxKind.AddAssignmentExpression: return NodeType.AsgAdd;
                case SyntaxKind.SubtractAssignmentExpression: return NodeType.AsgSub;
                case SyntaxKind.MultiplyAssignmentExpression: return NodeType.AsgMul;
                case SyntaxKind.DivideAssignmentExpression: return NodeType.AsgDiv;
                case SyntaxKind.ModuloAssignmentExpression: return NodeType.AsgMod;
                case SyntaxKind.AndAssignmentExpression: return NodeType.AsgAnd;
                case SyntaxKind.ExclusiveOrAssignmentExpression: return NodeType.AsgXor;
                case SyntaxKind.OrAssignmentExpression: return NodeType.AsgOr;
                case SyntaxKind.LeftShiftAssignmentExpression: return NodeType.AsgLsh;
                case SyntaxKind.SignedRightShiftAssignmentExpression: return NodeType.AsgRsh;
                case SyntaxKind.UnsignedRightShiftAssignmentExpression: return NodeType.AsgRs2;
                case SyntaxKind.LogicalOrExpression: return NodeType.LogOr;
                case SyntaxKind.LogicalAndExpression: return NodeType.LogAnd;
                case SyntaxKind.BitwiseOrExpression: return NodeType.Or;
                case SyntaxKind.BitwiseExclusiveOrExpression: return NodeType.Xor;
                case SyntaxKind.BitwiseAndExpression: return NodeType.And;
                case SyntaxKind.EqualsWithTypeConversionExpression: return NodeType.Eq;
                case SyntaxKind.NotEqualsWithTypeConversionExpression: return NodeType.Ne;
                case SyntaxKind.EqualsExpression: return NodeType.Eqv;
                case SyntaxKind.NotEqualsExpression: return NodeType.NEqv;
                case SyntaxKind.LessThanExpression: return NodeType.Lt;
                case SyntaxKind.GreaterThanExpression: return NodeType.Gt;
                case SyntaxKind.LessThanOrEqualExpression: return NodeType.Le;
                case SyntaxKind.GreaterThanOrEqualExpression: return NodeType.Ge;
                case SyntaxKind.InstanceOfExpression: return NodeType.InstOf;
                case SyntaxKind.InExpression: return NodeType.In;
                case SyntaxKind.LeftShiftExpression: return NodeType.Lsh;
                case SyntaxKind.SignedRightShiftExpression: return NodeType.Rsh;
                case SyntaxKind.UnsignedRightShiftExpression: return NodeType.Rs2;
                case SyntaxKind.MultiplyExpression: return NodeType.Mul;
                case SyntaxKind.DivideExpression: return NodeType.Div;
                case SyntaxKind.ModuloExpression: return NodeType.Mod;
                case SyntaxKind.AddExpression: return NodeType.Add;
                case SyntaxKind.SubtractExpression: return NodeType.Sub;
            }

            throw Errors.invalidOperation();
        }

        private visitBinaryExpression(node: BinaryExpressionSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var nodeType = this.getBinaryExpressionNodeType(node);
            var left = node.left.accept(this);
            this.movePast(node.operatorToken);
            var right = node.right.accept(this);

            var result = new BinaryExpression(nodeType, left, right);
            this.setSpan(result, start, this.position);

            if (right.nodeType === NodeType.FuncDecl) {
                var id = left.nodeType === NodeType.Dot ? (<BinaryExpression>left).operand2 : left;
                var idHint: string = id.nodeType === NodeType.Name ? id.actualText : null;

                var funcDecl = <FuncDecl>right;
                funcDecl.hint = idHint;
            }

            return result;
        }

        private visitConditionalExpression(node: ConditionalExpressionSyntax): ConditionalExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            var condition = node.condition.accept(this);
            this.movePast(node.questionToken);
            var whenTrue = node.whenTrue.accept(this);
            this.movePast(node.colonToken);
            var whenFalse = node.whenFalse.accept(this)

            var result = new ConditionalExpression(condition, whenTrue, whenFalse);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitConstructSignature(node: ConstructSignatureSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);

            this.movePast(node.newKeyword);
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var result = new FuncDecl(null, null, /*isConstructor:*/ false, typeParameters, parameters, new ASTList(), new ASTList(), new ASTList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            result.preComments = preComments;
            result.returnTypeAnnotation = returnType;

            result.hint = "_construct";
            result.fncFlags |= FncFlags.ConstructMember;
            result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);

            var scopeList = this.topScopeList();
            scopeList.append(result);

            return result;
        }

        private visitMethodSignature(node: MethodSignatureSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);

            var name = this.identifierFromToken(node.propertyName, !!node.questionToken);
            this.movePast(node.propertyName);
            this.movePast(node.questionToken);

            var typeParameters = node.callSignature.typeParameterList ? node.callSignature.typeParameterList.accept(this) : null;
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var funcDecl = new FuncDecl(name, null, false, typeParameters, parameters, new ASTList(), new ASTList(), new ASTList(), NodeType.FuncDecl);
            this.setSpan(funcDecl, start, this.position);

            funcDecl.preComments = preComments;
            funcDecl.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            funcDecl.returnTypeAnnotation = returnType;

            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);

            return funcDecl;
        }

        private visitIndexSignature(node: IndexSignatureSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);

            this.movePast(node.openBracketToken);

            var identifierStart = this.position;
            var identifier = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var parameterType = node.parameterTypeAnnotation.accept(this);

            var parameter = new ArgDecl(identifier);
            parameter.typeExpr = parameterType;
            this.setSpan(parameter, identifierStart, this.position);

            this.movePast(node.closeBracketToken);
            var returnType = node.typeAnnotation.accept(this);

            var name = new Identifier("__item");
            this.setSpan(name, start, start);   // 0 length name.

            var parameters = new ASTList();
            parameters.append(parameter);

            var result = new FuncDecl(name, null, /*isConstructor:*/ false, null, parameters, new ASTList(), new ASTList(), new ASTList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            result.preComments = preComments;
            result.variableArgList = false;
            result.returnTypeAnnotation = returnType;

            result.fncFlags |= FncFlags.IndexerMember;

            var scopeList = this.topScopeList();
            scopeList.append(result);

            return result;
        }

        private visitPropertySignature(node: PropertySignatureSyntax): VarDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);

            var name = this.identifierFromToken(node.propertyName, !!node.questionToken);
            this.movePast(node.propertyName);
            this.movePast(node.questionToken);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var result = new VarDecl(name, 0);
            this.setSpan(result, start, this.position);

            result.preComments = preComments;
            result.typeExpr = typeExpr;
            result.varFlags |= VarFlags.Property;

            return result;
        }

        private visitParameterList(node: ParameterListSyntax): ASTList {
            this.assertElementAtPosition(node);

            var start = this.position;

            var openParenToken = node.openParenToken;
            this.previousTokenTrailingComments = this.convertTokenTrailingComments(
                openParenToken, start + openParenToken.leadingTriviaWidth() + openParenToken.width());

            this.movePast(node.openParenToken);
            var result = this.visitSeparatedSyntaxList(node.parameters);
            this.movePast(node.closeParenToken);

            return result;
        }

        private visitCallSignature(node: CallSignatureSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);

            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var result = new FuncDecl(null, null, /*isConstructor:*/ false, typeParameters, parameters, new ASTList(), new ASTList(), new ASTList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            result.preComments = preComments;
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
            result.returnTypeAnnotation = returnType;

            result.hint = "_call";
            result.fncFlags |= FncFlags.CallMember;

            var scopeList = this.topScopeList();
            scopeList.append(result);

            return result;
        }

        private visitTypeParameterList(node: TypeParameterListSyntax): ASTList {
            this.assertElementAtPosition(node);

            this.movePast(node.lessThanToken);
            var result = this.visitSeparatedSyntaxList(node.typeParameters);
            this.movePast(node.greaterThanToken);

            return result;
        }

        private visitTypeParameter(node: TypeParameterSyntax): TypeParameter {
            this.assertElementAtPosition(node);

            var start = this.position;
            var identifier = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var constraint = node.constraint ? node.constraint.accept(this) : null;

            var result = new TypeParameter(identifier, constraint);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitConstraint(node: ConstraintSyntax): any {
            this.assertElementAtPosition(node);

            this.movePast(node.extendsKeyword);
            return this.visitType(node.type);
        }

        private visitIfStatement(node: IfStatementSyntax): IfStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var thenBod = node.statement.accept(this);
            var elseBod = node.elseClause ? node.elseClause.accept(this) : null;

            var result = new IfStatement(condition);
            this.setSpan(result, start, this.position);

            result.thenBod = thenBod;
            result.elseBod = elseBod;

            return result;
        }

        private visitElseClause(node: ElseClauseSyntax): Statement {
            this.assertElementAtPosition(node);

            this.movePast(node.elseKeyword);
            return node.statement.accept(this);
        }

        private visitExpressionStatement(node: ExpressionStatementSyntax): AST {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            var expression = node.expression.accept(this);
            this.movePast(node.semicolonToken);

            var result = expression;
            this.setSpan(result, start, this.position);

            result.preComments = preComments;
            result.postComments = postComments;

            result.flags |= ASTFlags.IsStatement;

            return result;
        }

        private visitConstructorDeclaration(node: ConstructorDeclarationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.moveTo2(node, node.parameterList);
            var parameters = node.parameterList.accept(this);

            this.pushDeclLists();

            var statements = this.convertBlock(node.block);
            if (statements) {
                statements.append(new EndCode());
            }
            this.movePast(node.semicolonToken);

            var result = new FuncDecl(null, statements, /*isConstructor:*/ true, null, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(result);

            result.preComments = preComments;
            result.postComments = postComments;
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
            // constructorFuncDecl.preComments = preComments;
            //if (requiresSignature && !isAmbient) {
            //    constructorFuncDecl.isOverload = true;
            //}

            // constructorFuncDecl.variableArgList = variableArgList;
            // this.currentClassDecl = null;

            //if (isAmbient) {
            //    constructorFuncDecl.fncFlags |= FncFlags.Ambient;
            //}

            if (node.semicolonToken) {
                result.fncFlags |= FncFlags.Signature;
            }

            //if (this.currentClassDefinition.constructorDecl) {
            //    if (!isAmbient && !this.currentClassDefinition.constructorDecl.isSignature() && !constructorFuncDecl.isSignature()) {
            //        this.reportParseError("Duplicate constructor definition");
            //    }
            //}

            //if (isAmbient || !constructorFuncDecl.isSignature()) {
            //    this.currentClassDefinition.constructorDecl = constructorFuncDecl;
            //}

            // REVIEW: Should we have a separate flag for class constructors?  (Constructors are not methods)
            result.fncFlags |= FncFlags.ClassMethod;

            //this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = constructorFuncDecl;

            //this.parsingClasvisisConstructorDefinition = false;

            return result;
        }

        private visitMemberFunctionDeclaration(node: MemberFunctionDeclarationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.moveTo2(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, /*isOptional:*/ false);

            this.movePast(node.propertyName);

            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation
                ? node.callSignature.typeAnnotation.accept(this)
                : null;

            this.pushDeclLists();

            var statements = this.convertBlock(node.block);
            if (statements) {
                statements.append(new EndCode());
            }
            this.movePast(node.semicolonToken);

            var result = new FuncDecl(name, statements, /*isConstructor:*/ false, typeParameters, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(result);

            result.preComments = preComments;
            result.postComments = postComments;
            result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            result.returnTypeAnnotation = returnType;

            if (node.semicolonToken) {
                result.fncFlags |= FncFlags.Signature;
            }

            if (node.publicOrPrivateKeyword && node.publicOrPrivateKeyword.kind() === SyntaxKind.PrivateKeyword) {
                result.fncFlags |= FncFlags.Private;
            }
            else {
                result.fncFlags |= FncFlags.Public;
            }

            if (node.staticKeyword) {
                result.fncFlags |= FncFlags.Static;
            }

            result.fncFlags |= FncFlags.Method;

            return result;
        }

        private visitMemberAccessorDeclaration(node: MemberAccessorDeclarationSyntax, typeAnnotation: TypeAnnotationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.moveTo2(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var parameters = node.parameterList.accept(this);
            var returnType = typeAnnotation ? typeAnnotation.accept(this) : null;

            this.pushDeclLists();

            var statements = this.convertBlock(node.block);
            if (statements) {
                statements.append(new EndCode());
            }
            var result = new FuncDecl(name, statements, /*isConstructor:*/ false, null, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(result, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(result);

            result.preComments = preComments;
            result.postComments = postComments;
            result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
            result.returnTypeAnnotation = returnType;

            if (node.publicOrPrivateKeyword && node.publicOrPrivateKeyword.kind() === SyntaxKind.PrivateKeyword) {
                result.fncFlags |= FncFlags.Private;
            }
            else {
                result.fncFlags |= FncFlags.Public;
            }

            if (node.staticKeyword) {
                result.fncFlags |= FncFlags.Static;
            }

            result.fncFlags |= FncFlags.Method;

            return result;
        }

        private visitGetMemberAccessorDeclaration(node: GetMemberAccessorDeclarationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var result = this.visitMemberAccessorDeclaration(node, node.typeAnnotation);

            result.fncFlags |= FncFlags.GetAccessor;
            result.hint = "get" + result.name.actualText;

            return result;
        }

        private visitSetMemberAccessorDeclaration(node: SetMemberAccessorDeclarationSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var result = this.visitMemberAccessorDeclaration(node, null);

            result.fncFlags |= FncFlags.SetAccessor;
            result.hint = "set" + result.name.actualText;

            return result;
        }

        private visitMemberVariableDeclaration(node: MemberVariableDeclarationSyntax): VarDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.moveTo3(node, node.variableDeclarator, node.variableDeclarator.identifier);
            var name = this.identifierFromToken(node.variableDeclarator.identifier, /*isOptional:*/ false);
            this.movePast(node.variableDeclarator.identifier);
            var typeExpr = node.variableDeclarator.typeAnnotation ? node.variableDeclarator.typeAnnotation.accept(this) : null;
            var init = node.variableDeclarator.equalsValueClause ? node.variableDeclarator.equalsValueClause.accept(this) : null;
            this.movePast(node.semicolonToken);

            var varDecl = new VarDecl(name, 0);
            this.setSpan(varDecl, name.minChar, name.limChar);

            varDecl.preComments = preComments;
            varDecl.postComments = postComments;
            varDecl.typeExpr = typeExpr;
            varDecl.init = init;

            if (node.staticKeyword) {
                varDecl.varFlags |= VarFlags.Static;
            }

            if (node.publicOrPrivateKeyword && node.publicOrPrivateKeyword.kind() === SyntaxKind.PrivateKeyword) {
                varDecl.varFlags |= VarFlags.Private;
            }
            else {
                varDecl.varFlags |= VarFlags.Public;
            }

            varDecl.varFlags |= VarFlags.ClassProperty;

            // this.currentClassDefinition.knownMemberNames[text.actualText] = true;

            //if (!isDeclaredInConstructor) {
            //    this.currentClassDefinition.members.members[this.currentClassDefinition.members.members.length] = varDecl;
            //}

            // varDecl.postComments = this.parseComments();
            return varDecl;
        }

        private visitThrowStatement(node: ThrowStatementSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.throwKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.semicolonToken);

            var result = new UnaryExpression(NodeType.Throw, expression);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitReturnStatement(node: ReturnStatementSyntax): ReturnStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.returnKeyword);
            var expression = node.expression ? node.expression.accept(this) : null;
            this.movePast(node.semicolonToken);

            var result = new ReturnStatement();
            this.setSpan(result, start, this.position);

            result.returnExpression = expression;

            return result;
        }

        private visitObjectCreationExpression(node: ObjectCreationExpressionSyntax): CallExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.newKeyword);
            var expression = node.expression.accept(this);
            var typeArgumentList = node.argumentList === null || node.argumentList.typeArgumentList === null ? null : node.argumentList.typeArgumentList.accept(this);
            var argumentList = this.convertArgumentListArguments(node.argumentList);

            var result = new CallExpression(NodeType.New, expression, typeArgumentList, argumentList);
            this.setSpan(result, start, this.position);

            if (expression.nodeType === NodeType.TypeRef) {
                var typeRef = <TypeReference>expression;

                if (typeRef.arrayCount === 0) {
                    var term = typeRef.term;
                    if (term.nodeType === NodeType.Dot || term.nodeType === NodeType.Name) {
                        expression = term;
                    }
                }
            }

            return result;
        }

        private visitSwitchStatement(node: SwitchStatementSyntax): SwitchStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.switchKeyword);
            this.movePast(node.openParenToken);
            var expression = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var closeParenPosition = this.position;
            this.movePast(node.openBraceToken);

            var result = new SwitchStatement(expression);
            this.setSpan(result, start, this.position);

            result.statement.minChar = start;
            result.statement.limChar = closeParenPosition;

            result.caseList = new ASTList()

            for (var i = 0, n = node.switchClauses.childCount(); i < n; i++) {
                var switchClause = node.switchClauses.childAt(i);
                var translated = switchClause.accept(this);

                if (switchClause.kind() === SyntaxKind.DefaultSwitchClause) {
                    result.defaultCase = translated;
                }

                result.caseList.append(translated);
            }

            this.movePast(node.closeBraceToken);

            return result;
        }

        private visitCaseSwitchClause(node: CaseSwitchClauseSyntax): CaseStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.caseKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);

            var result = new CaseStatement();
            this.setSpan(result, start, this.position);

            result.expr = expression;
            result.body = statements;

            return result;
        }

        private visitDefaultSwitchClause(node: DefaultSwitchClauseSyntax): CaseStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.defaultKeyword);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);

            var result = new CaseStatement();
            this.setSpan(result, start, this.position);

            result.body = statements;

            return result;
        }

        private visitBreakStatement(node: BreakStatementSyntax): Jump {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.breakKeyword);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);

            var result = new Jump(NodeType.Break);
            this.setSpan(result, start, this.position);

            if (node.identifier !== null) {
                result.target = this.valueText(node.identifier);
            }

            return result;
        }

        private visitContinueStatement(node: ContinueStatementSyntax): Jump {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.continueKeyword);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);

            var result = new Jump(NodeType.Continue);
            this.setSpan(result, start, this.position);

            if (node.identifier !== null) {
                result.target = this.valueText(node.identifier);
            }

            return result;
        }

        private visitForStatement(node: ForStatementSyntax): ForStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var init = node.variableDeclaration
                ? node.variableDeclaration.accept(this)
                : node.initializer
                    ? node.initializer.accept(this)
                    : null;
            this.movePast(node.firstSemicolonToken);
            var cond = node.condition ? node.condition.accept(this) : null;
            this.movePast(node.secondSemicolonToken);
            var incr = node.incrementor ? node.incrementor.accept(this) : null;
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);

            var result = new ForStatement(init);
            this.setSpan(result, start, this.position);

            result.cond = cond;
            result.incr = incr;
            result.body = body;

            return result;
        }

        private visitForInStatement(node: ForInStatementSyntax): ForInStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.left.accept(this);
            this.movePast(node.inKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);

            var result = new ForInStatement(init, expression);
            this.setSpan(result, start, this.position);

            result.body = body;

            return result;
        }

        private visitWhileStatement(node: WhileStatementSyntax): WhileStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);

            var result = new WhileStatement(condition);
            this.setSpan(result, start, this.position);

            result.body = statement;

            return result;
        }

        private visitWithStatement(node: WithStatementSyntax): WithStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);

            var result = new WithStatement(condition);
            this.setSpan(result, start, this.position);

            result.body = statement;

            return result;
        }

        private visitCastExpression(node: CastExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.lessThanToken);
            var castTerm = this.visitType(node.type);
            this.movePast(node.greaterThanToken);
            var expression = node.expression.accept(this);

            var result = new UnaryExpression(NodeType.TypeAssertion, expression);
            this.setSpan(result, start, this.position);

            result.castTerm = castTerm;

            return result;
        }

        private visitObjectLiteralExpression(node: ObjectLiteralExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.openBraceToken);
            var propertyAssignments = this.visitSeparatedSyntaxList(node.propertyAssignments);
            this.movePast(node.closeBraceToken);

            var result = new UnaryExpression(NodeType.ObjectLit, propertyAssignments);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitSimplePropertyAssignment(node: SimplePropertyAssignmentSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);

            var left = node.propertyName.accept(this);

            this.previousTokenTrailingComments = this.convertTokenTrailingComments(
                node.colonToken, this.position + node.colonToken.leadingTriviaWidth() + node.colonToken.width());

            this.movePast(node.colonToken);
            var right = node.expression.accept(this);

            var result = new BinaryExpression(NodeType.Member, left, right);
            this.setSpan(result, start, this.position);

            result.preComments = preComments;

            if (right.nodeType === NodeType.FuncDecl) {
                var funcDecl = <FuncDecl>right;
                funcDecl.hint = left.text;
            }

            return result;
        }

        private visitGetAccessorPropertyAssignment(node: GetAccessorPropertyAssignmentSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, /*isOptional:*/ false);
            this.movePast(node.propertyName);
            this.movePast(node.openParenToken);
            this.movePast(node.closeParenToken);
            var returnType = node.typeAnnotation
                ? node.typeAnnotation.accept(this)
                : null;

            this.pushDeclLists();

            var statements = this.convertBlock(node.block);
            statements.append(new EndCode());

            var funcDecl = new FuncDecl(name, statements, /*isConstructor:*/ false, null, new ASTList(), this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(funcDecl, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);

            funcDecl.fncFlags |= FncFlags.GetAccessor;
            funcDecl.fncFlags |= FncFlags.IsFunctionExpression;
            funcDecl.hint = "get" + node.propertyName.text();
            funcDecl.returnTypeAnnotation = returnType;

            var result = new BinaryExpression(NodeType.Member, name, funcDecl);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitSetAccessorPropertyAssignment(node: SetAccessorPropertyAssignmentSyntax): BinaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.moveTo2(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, /*isOptional:*/ false);
            this.movePast(node.propertyName);
            this.movePast(node.openParenToken);
            var parameter = node.parameter.accept(this);
            this.movePast(node.closeParenToken);

            var parameters = new ASTList();
            parameters.append(parameter);

            this.pushDeclLists();

            var statements = this.convertBlock(node.block);
            statements.append(new EndCode());

            var funcDecl = new FuncDecl(name, statements, /*isConstructor:*/ false, null, parameters, this.topVarList(),
                                        this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(funcDecl, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);

            funcDecl.fncFlags |= FncFlags.SetAccessor;
            funcDecl.fncFlags |= FncFlags.IsFunctionExpression;
            funcDecl.hint = "set" + node.propertyName.text();

            var result = new BinaryExpression(NodeType.Member, name, funcDecl);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitFunctionExpression(node: FunctionExpressionSyntax): FuncDecl {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);

            this.movePast(node.functionKeyword);
            var name = node.identifier === null ? null : this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation
                ? node.callSignature.typeAnnotation.accept(this)
                : null;

            this.pushDeclLists();

            var bod = this.convertBlock(node.block);
            if (bod) {
                bod.append(new EndCode());
            }

            if (node.block) {
                if (this.hasUseStrictDirective(node.block.statements)) {
                    bod.flags |= ASTFlags.StrictMode;
                }
            }

            var funcDecl = new FuncDecl(name, bod, false, typeParameters, parameters, this.topVarList(),
                this.topScopeList(), this.topStaticsList(), NodeType.FuncDecl);
            this.setSpan(funcDecl, start, this.position);

            this.popDeclLists();

            var scopeList = this.topScopeList();
            scopeList.append(funcDecl);

            funcDecl.preComments = preComments;
            funcDecl.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            funcDecl.returnTypeAnnotation = returnType;
            funcDecl.fncFlags |= FncFlags.IsFunctionExpression;

            return funcDecl;
        }

        private visitEmptyStatement(node: EmptyStatementSyntax): AST {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.semicolonToken);

            var result = new AST(NodeType.Empty);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitTryStatement(node: TryStatementSyntax): AST {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.tryKeyword);
            var block = node.block.accept(this);

            var tryPart: AST = new Try(block);
            this.setSpan(tryPart, start, this.position);

            var tryCatch: TryCatch = null;
            if (node.catchClause !== null) {
                var catchBit = node.catchClause.accept(this);

                tryCatch = new TryCatch(<Try>tryPart, catchBit);
                this.setSpan(tryCatch, start, this.position);
            }

            if (node.finallyClause !== null) {
                if (tryCatch !== null) {
                    tryPart = tryCatch;
                }

                var finallyBit = node.finallyClause.accept(this);

                var result = new TryFinally(tryPart, finallyBit);
                this.setSpan(result, start, this.position);

                return result;
            }

            Debug.assert(tryCatch !== null);
            return tryCatch;
        }

        private visitCatchClause(node: CatchClauseSyntax): Catch {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.catchKeyword);
            this.movePast(node.openParenToken);
            var identifier = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            this.movePast(node.closeParenToken);
            var block = node.block.accept(this);

            var varDecl = new VarDecl(identifier, 0);
            this.setSpan(varDecl, identifier.minChar, identifier.limChar);

            varDecl.typeExpr = typeExpr;

            var result = new Catch(varDecl, block);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitFinallyClause(node: FinallyClauseSyntax): Finally {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.finallyKeyword);
            var block = node.block.accept(this);

            var result = new Finally(block);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitLabeledStatement(node: LabeledStatementSyntax): LabeledStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            var identifier = this.identifierFromToken(node.identifier, /*isOptional:*/ false);
            this.movePast(node.identifier);
            this.movePast(node.colonToken);
            var statement = node.statement.accept(this);

            var labelList = new ASTList();
            labelList.append(new Label(identifier));

            var result = new LabeledStatement(labelList, statement);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitDoStatement(node: DoStatementSyntax): DoWhileStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.doKeyword);
            var statement = node.statement.accept(this);
            var whileAst = this.identifierFromToken(node.whileKeyword, /*isOptional:*/ false);
            this.movePast(node.whileKeyword);
            this.movePast(node.openParenToken);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            this.movePast(node.semicolonToken);

            var result = new DoWhileStatement();
            this.setSpan(result, start, this.position);

            result.whileAST = whileAst;
            result.cond = condition;
            result.body = statement;

            return result;
        }

        private visitTypeOfExpression(node: TypeOfExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.typeOfKeyword);
            var expression = node.expression.accept(this);

            var result = new UnaryExpression(NodeType.Typeof, expression);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitDeleteExpression(node: DeleteExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.deleteKeyword);
            var expression = node.expression.accept(this);

            var result = new UnaryExpression(NodeType.Delete, expression);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitVoidExpression(node: VoidExpressionSyntax): UnaryExpression {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.voidKeyword);
            var expression = node.expression.accept(this);

            var result = new UnaryExpression(NodeType.Void, expression);
            this.setSpan(result, start, this.position);

            return result;
        }

        private visitDebuggerStatement(node: DebuggerStatementSyntax): DebuggerStatement {
            this.assertElementAtPosition(node);

            var start = this.position;
            this.movePast(node.debuggerKeyword);
            this.movePast(node.semicolonToken);

            var result = new DebuggerStatement();
            this.setSpan(result, start, this.position);

            return result;
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {

    export enum DiagnosticCategory {
        Warning,
        Error,
    }

    export interface DiagnosticInfo {
        category: DiagnosticCategory;
        message: string;
        code: number;
    }

    export enum PullDiagnosticMessages {
        error_2,
        warning_2,

        duplicateIdentifier_1,
        unresolvedSymbol_1,
        symbolDoesNotReferToAValue_1,
        invalidSuperReference,
        valueCannotBeModified,
        usedCallInsteadOfNew_1,
        valueIsNotCallable_1,
        valueIsNotNewable_1,
        invalidIndexLHS_2,
        incompatibleTypesForOperator_3,
        incompatibleTypesForOperatorWithReason_4,
        incompatibleTypes_2,
        incompatibleTypesWithReason_3,
        expectedClassOrInterface,
        unaryOperatorTypeError_2,
        duplicateGetter_1,
        duplicateSetter_1,
        accessorsMayNotBeGeneric,
    }

    export interface TypeScriptDiagnosticMessages {
        error_2: DiagnosticInfo;
        warning_2: DiagnosticInfo;

        duplicateIdentifier_1: DiagnosticInfo;
        unresolvedSymbol_1: DiagnosticInfo;
        symbolDoesNotReferToAValue_1: DiagnosticInfo;
        invalidSuperReference: DiagnosticInfo;
        valueCannotBeModified: DiagnosticInfo;
        usedCallInsteadOfNew_1: DiagnosticInfo;
        valueIsNotCallable_1: DiagnosticInfo;
        valueIsNotNewable_1: DiagnosticInfo;
        invalidIndexLHS_2: DiagnosticInfo;
        incompatibleTypesForOperator_3: DiagnosticInfo;
        incompatibleTypesForOperatorWithReason_4: DiagnosticInfo;
        incompatibleTypes_2: DiagnosticInfo;
        incompatibleTypesWithReason_3: DiagnosticInfo;
        expectedClassOrInterface: DiagnosticInfo;
        unaryOperatorTypeError_2: DiagnosticInfo;
        duplicateGetter_1: DiagnosticInfo;
        duplicateSetter_1: DiagnosticInfo;
        accessorsMayNotBeGeneric: DiagnosticInfo;
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts' />

module TypeScript {
    export var typescriptDiagnosticMessages: TypeScriptDiagnosticMessages = {
        error_2: {
            category: DiagnosticCategory.Error,
            message: "error TS{0}: {1}",
            code: 0
        },

        warning_2: {
            category: DiagnosticCategory.Warning,
            message: "warning TS{0}: {1}",
            code: 1
        },

        duplicateIdentifier_1: {
            category: DiagnosticCategory.Error,
            message: "Duplicate identifier '{0}'",
            code: 100
        },

        unresolvedSymbol_1: {
            category: DiagnosticCategory.Error,
            message: "The name'{0}' does not exist in the current scope",
            code: 101
        },

        symbolDoesNotReferToAValue_1: {
            category: DiagnosticCategory.Error,
            message: "The name '{0}' does not refer to a value",
            code: 102
        },

        invalidSuperReference: {
            category: DiagnosticCategory.Error,
            message: "Keyword 'super' can only be used inside a class instance method",
            code: 103
        },

        valueCannotBeModified: {
            category: DiagnosticCategory.Error,
            message: "The left-hand side of an assignment expression must be a variable, property or indexer",
            code: 104
        },

        usedCallInsteadOfNew_1: {
            category: DiagnosticCategory.Error,
            message: "Value of type '{0}' is not callable.  Did you mean to include 'new'?",
            code: 105
        },

        valueIsNotCallable_1: {
            category: DiagnosticCategory.Error,
            message: "Value of type '{0}' is not callable",
            code: 106
        },

        valueIsNotNewable_1: {
            category: DiagnosticCategory.Error,
            message: "Value of type '{0}' is not newable",
            code: 107
        },

        invalidIndexLHS_2: {
            category: DiagnosticCategory.Error,
            message: "Value of type '{0}' is not indexable by type '{1}'",
            code: 108
        },

        incompatibleTypesForOperator_3: {
            category: DiagnosticCategory.Error,
            message: "Operator '{0}' cannot be applied to types '{1}' and '{2}'",
            code: 109
        },

        incompatibleTypesForOperatorWithReason_4: {
            category: DiagnosticCategory.Error,
            message: "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}",
            code: 110
        },

        incompatibleTypes_2: {
            category: DiagnosticCategory.Error,
            message: "Cannot convert '{0}' to '{1}'",
            code: 111
        },

        incompatibleTypesWithReason_3: {
            category: DiagnosticCategory.Error,
            message: "Cannot convert '{0}' to '{1}': {2}",
            code: 112
        },

        expectedClassOrInterface: {
            category: DiagnosticCategory.Error,
            message: "Expected var, class, interface, or module",
            code: 113
        },

        unaryOperatorTypeError_2: {
            category: DiagnosticCategory.Error,
            message: "Operator '{0}' cannot be applied to type '{1}'",
            code: 114
        },

        duplicateGetter_1: {
            category: DiagnosticCategory.Error,
            message: "Getter '{0}' already declared",
            code: 115
        },

        duplicateSetter_1: {
            category: DiagnosticCategory.Error,
            message: "Setter '{0}' already declared",
            code: 116
        },

        accessorsMayNotBeGeneric: {
            category: DiagnosticCategory.Error,
            message: "Accessors may not take type parameters",
            code: 117
        },
    };
}
///<reference path='References.ts' />

var global = <any>Function("return this").call(null);

module TypeScript {
    module Clock {
        export var now: () => number;
        export var resolution: number;

        declare module WScript {
            export function InitializeProjection();
        }

        declare module TestUtilities {
            export function QueryPerformanceCounter(): number;
            export function QueryPerformanceFrequency(): number;
        }

        if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
            // Running in JSHost.
            global['WScript'].InitializeProjection();

            now = function () {
                return TestUtilities.QueryPerformanceCounter();
            }

            resolution = TestUtilities.QueryPerformanceFrequency();
        } else {
            now = function () {
                return Date.now();
            }

            resolution = 1000;
        }
    }

    export class Timer {
        public startTime;
        public time = 0;

        public start() {
            this.time = 0;
            this.startTime = Clock.now();
        }

        public end() {
            // Set time to MS.
            this.time = (Clock.now() - this.startTime);
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
 
///<reference path='diagnostics.ts' />
///<reference path='flags.ts' />
///<reference path='nodeTypes.ts' />
///<reference path='hashTable.ts' />
///<reference path='ast.ts' />
///<reference path='astWalker.ts' />
///<reference path='astWalkerCallback.ts' />
///<reference path='astPath.ts' />
///<reference path='binder.ts' />
///<reference path='base64.ts' />
///<reference path='sourceMapping.ts' />
///<reference path='emitter.ts' />
///<reference path='errorReporter.ts' />
///<reference path='printContext.ts' />
///<reference path='scanner.ts' />
///<reference path='scopeAssignment.ts' />
///<reference path='scopeWalk.ts' />
///<reference path='signatures.ts' />
///<reference path='symbols.ts' />
///<reference path='symbolScope.ts' />
///<reference path='tokens.ts' />
///<reference path='typeChecker.ts' />
///<reference path='typeCollection.ts' />
///<reference path='typeFlow.ts' />
///<reference path='types.ts' />
///<reference path='pathUtils.ts' />
///<reference path='referenceResolution.ts' />
///<reference path='precompile.ts' />
///<reference path='declarationEmitter.ts' />
///<reference path='Syntax\ISyntaxNodeOrToken.ts' />
///<reference path='Syntax\Parser.ts' />
///<reference path='Text\TextFactory.ts' />
///<reference path='typecheck\dataMap.ts' />
///<reference path='typecheck\pullFlags.ts' />
///<reference path='typecheck\pullDecls.ts' />
///<reference path='typecheck\pullSymbols.ts' />
///<reference path='typecheck\pullSymbolBindingContext.ts' />
///<reference path='typecheck\pullTypeResolutionContext.ts' />
///<reference path='typecheck\pullTypeResolution.ts' />
///<reference path='typecheck\pullTypeChecker.ts' />
///<reference path='typecheck\pullDeclDiffer.ts' />
///<reference path='typecheck\pullSemanticInfo.ts' />
///<reference path='typecheck\pullDeclCollection.ts' />
///<reference path='typecheck\pullSymbolBinder.ts' />
///<reference path='typecheck\pullSymbolGraph.ts' />
///<reference path='typecheck\pullEmitter.ts' />
///<reference path='typecheck\pullErrors.ts' />
///<reference path='typecheck\pullHelpers.ts' />
///<reference path='typecheck\pullDeclarationEmitter.ts' />
///<reference path='SyntaxTreeToAstVisitor.ts' />
///<reference path='resources.ts' />
///<reference path='resourceStrings.ts' />
///<reference path='Core\Timer.ts' />

module TypeScript {

    declare var IO;

    export interface EmitterIOHost {
        // function that can even create a folder structure if needed
        createFile(path: string, useUTF8?: bool): ITextWriter;

        // function to check if file exists on the disk
        fileExists(path: string): bool;

        // Function to check if the directory exists on the disk
        directoryExists(path: string): bool;

        // Resolves the path
        resolvePath(path: string): string;
    }

    export interface PullTypeInfoAtPositionInfo {
        symbol: PullSymbol;
        ast: AST;
        enclosingScopeSymbol: PullSymbol;
        candidateSignature: PullSignatureSymbol;
        callSignatures: PullSignatureSymbol[];
        isConstructorCall: bool;
    }

    export interface PullVisibleSymbolsInfo {
        symbols: PullSymbol[];
        enclosingScopeSymbol: PullSymbol;
    }

    export class TypeScriptCompiler {
        public pullErrorReporter: PullErrorReporter = null;

        public pullTypeChecker: PullTypeChecker = null;
        public semanticInfoChain: SemanticInfoChain = null;

        public emitOptions: EmitOptions;

        public fileNameToScript = new TypeScript.StringHashTable();
        public fileNameToLocationInfo = new TypeScript.StringHashTable();
        public fileNameToSyntaxTree = new TypeScript.StringHashTable();

        constructor(public errorOutput: ITextWriter,
                    public logger: ILogger = new NullLogger(),
                    public settings: CompilationSettings = new CompilationSettings(),
                    public diagnosticMessages: TypeScriptDiagnosticMessages = null) {
            this.pullErrorReporter = new PullErrorReporter(this.errorOutput);

            this.emitOptions = new EmitOptions(this.settings);

            if (this.diagnosticMessages) {
                typescriptDiagnosticMessages = diagnosticMessages
            }
        }

        public timeFunction(funcDescription: string, func: () => any): any {
            return TypeScript.timeFunction(this.logger, funcDescription, func);
        }

        public addSourceUnit(fileName: string, sourceText: IScriptSnapshot, referencedFiles?: IFileReference[] = []): Script {
            return this.timeFunction("addSourceUnit(" + fileName + ")", () => {
                var syntaxTree = Parser.parse(fileName, SimpleText.fromScriptSnapshot(sourceText), TypeScript.isDTSFile(fileName), LanguageVersion.EcmaScript5);
                var script = SyntaxTreeToAstVisitor.visit(syntaxTree, fileName, this.emitOptions.compilationSettings);
                script.referencedFiles = referencedFiles;

                this.fileNameToSyntaxTree.addOrUpdate(fileName, syntaxTree);
                this.fileNameToLocationInfo.addOrUpdate(fileName, script.locationInfo);
                this.fileNameToScript.addOrUpdate(fileName, script);

                return script;
            });
        }

        public updateSourceUnit(fileName: string, scriptSnapshot: IScriptSnapshot, textChangeRange: TextChangeRange): void {
            this.timeFunction("pullUpdateUnit(" + fileName + ")", () => {
                var oldScript = <Script>this.fileNameToScript.lookup(fileName);
                var oldSyntaxTree = this.fileNameToSyntaxTree.lookup(fileName);

                var text = SimpleText.fromScriptSnapshot(scriptSnapshot);

                var syntaxTree = textChangeRange === null
                    ? TypeScript.Parser.parse(fileName, text, TypeScript.isDTSFile(fileName))
                    : TypeScript.Parser.incrementalParse(oldSyntaxTree, textChangeRange, text);

                var newScript = SyntaxTreeToAstVisitor.visit(syntaxTree, fileName, this.emitOptions.compilationSettings);

                this.fileNameToSyntaxTree.addOrUpdate(fileName, syntaxTree);
                this.fileNameToScript.addOrUpdate(fileName, newScript);
                this.fileNameToLocationInfo.addOrUpdate(fileName, newScript.locationInfo);

                this.pullUpdateScript(oldScript, newScript);
            });
        }

        private isDynamicModuleCompilation() {
            var fileNames = this.fileNameToScript.getAllKeys();
            for (var i = 0, len = fileNames.length; i < len; i++) {
                var script = <Script>this.fileNameToScript.lookup(fileNames[i]);
                if (!script.isDeclareFile && script.topLevelMod != null) {
                    return true;
                }
            }
            return false;
        }

        private updateCommonDirectoryPath(): IDiagnostic {
            var commonComponents: string[] = [];
            var commonComponentsLength = -1;

            var fileNames = this.fileNameToScript.getAllKeys();
            for (var i = 0, len = fileNames.length; i < len; i++) {
                var script = <Script>this.fileNameToScript.lookup(fileNames[i]);

                if (script.emitRequired(this.emitOptions)) {
                    var fileName = script.locationInfo.fileName;
                    var fileComponents = filePathComponents(fileName);
                    if (commonComponentsLength === -1) {
                        // First time at finding common path
                        // So common path = directory of file
                        commonComponents = fileComponents;
                        commonComponentsLength = commonComponents.length;
                    } else {
                        var updatedPath = false;
                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {
                            if (commonComponents[j] != fileComponents[j]) {
                                // The new components = 0 ... j -1
                                commonComponentsLength = j;
                                updatedPath = true;

                                if (j === 0) {
                                    // Its error to not have common path
                                    return new Diagnostic(0, 0, null, "Cannot find the common subdirectory path for the input files");
                                }

                                break;
                            }
                        }

                        // If the fileComponent path completely matched and less than already found update the length
                        if (!updatedPath && fileComponents.length < commonComponentsLength) {
                            commonComponentsLength = fileComponents.length;
                        }
                    }
                }
            }

            this.emitOptions.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";
            if (this.emitOptions.compilationSettings.outputOption.charAt(this.emitOptions.compilationSettings.outputOption.length - 1) != "/") {
                this.emitOptions.compilationSettings.outputOption += "/";
            }

            return null;
        }

        public parseEmitOption(ioHost: EmitterIOHost): IDiagnostic {
            this.emitOptions.ioHost = ioHost;
            if (this.emitOptions.compilationSettings.outputOption === "") {
                this.emitOptions.outputMany = true;
                this.emitOptions.commonDirectoryPath = "";
                return null;
            }

            this.emitOptions.compilationSettings.outputOption = switchToForwardSlashes(this.emitOptions.ioHost.resolvePath(this.emitOptions.compilationSettings.outputOption));

            // Determine if output options is directory or file
            if (this.emitOptions.ioHost.directoryExists(this.emitOptions.compilationSettings.outputOption)) {
                // Existing directory
                this.emitOptions.outputMany = true;
            } else if (this.emitOptions.ioHost.fileExists(this.emitOptions.compilationSettings.outputOption)) {
                // Existing file
                this.emitOptions.outputMany = false;
            }
            else {
                // New File/directory
                this.emitOptions.outputMany = !isJSFile(this.emitOptions.compilationSettings.outputOption);
            }

            // Verify if options are correct
            if (this.isDynamicModuleCompilation() && !this.emitOptions.outputMany) {
                return new Diagnostic(0, 0, null, "Cannot compile dynamic modules when emitting into single file");
            }

            // Parse the directory structure
            if (this.emitOptions.outputMany) {
                return this.updateCommonDirectoryPath();
            }

            return null;
        }

        public getScripts(): Script[] {
            var result: TypeScript.Script[] = [];
            var fileNames = this.fileNameToScript.getAllKeys();

            for (var i = 0; i < fileNames.length; i++) {
                result.push(this.fileNameToScript.lookup(fileNames[i]));
            }

            return result;
        }

        private useUTF8ForFile(script: Script) {
            if (this.emitOptions.outputMany) {
                return this.outputScriptToUTF8(script);
            } else {
                return this.outputScriptsToUTF8(this.getScripts());
            }
        }

        static mapToDTSFileName(fileName: string, wholeFileNameReplaced: bool) {
            return getDeclareFilePath(fileName);
        }

        private canEmitDeclarations(script?: Script) {
            if (!this.settings.generateDeclarationFiles) {
                return false;
            }

            // If its already a declare file or is resident or does not contain body 
            if (!!script && (script.isDeclareFile || script.bod === null)) {
                return false;
            }

            return true;
        }

        // Caller is responsible for closing emitter.
        private emitDeclarationsUnit(script: Script, declarationEmitter?: DeclarationEmitter): DeclarationEmitter {
            if (this.canEmitDeclarations(script)) {
                if (!declarationEmitter) {
                    var declareFileName = this.emitOptions.mapOutputFileName(script.locationInfo.fileName, TypeScriptCompiler.mapToDTSFileName);
                    declarationEmitter = new PullDeclarationEmitter(
                        declareFileName, this.useUTF8ForFile(script), this.semanticInfoChain, this.emitOptions);
                }

                declarationEmitter.emitDeclarations(script);
            }

            return declarationEmitter;
        }

        // Will not throw exceptions.
        public emitDeclarations(): IDiagnostic[] {
            if (this.canEmitDeclarations() &&
                !this.pullErrorReporter.hasErrors) {

                var sharedEmitter: DeclarationEmitter = null;
                var fileNames = this.fileNameToScript.getAllKeys();

                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var fileName = fileNames[i];

                    try {
                        var script = <Script>this.fileNameToScript.lookup(fileNames[i]);

                        if (this.emitOptions.outputMany) {
                            var singleEmitter = this.emitDeclarationsUnit(script);
                            if (singleEmitter) {
                                singleEmitter.close();
                            }
                        }
                        else {
                            // Create or reuse file
                            sharedEmitter = this.emitDeclarationsUnit(script, sharedEmitter);
                        }
                    }
                    catch (ex1) {
                        return Emitter.handleEmitterError(fileName, ex1);
                    }
                }

                if (sharedEmitter) {
                    try {
                        sharedEmitter.close();
                    }
                    catch (ex2) {
                        return Emitter.handleEmitterError(sharedEmitter.locationInfo.fileName, ex2);
                    }
                }
            }

            return [];
        }

        static mapToFileNameExtension(extension: string, fileName: string, wholeFileNameReplaced: bool) {
            if (wholeFileNameReplaced) {
                // The complete output is redirected in this file so do not change extension
                return fileName;
            } else {
                // Change the extension of the file
                var splitFname = fileName.split(".");
                splitFname.pop();
                return splitFname.join(".") + extension;
            }
        }

        static mapToJSFileName(fileName: string, wholeFileNameReplaced: bool) {
            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);
        }

        // Caller is responsible for closing the returned emitter.
        // May throw exceptions.
        private emitUnit(script: Script,
                         inputOutputMapper?: (inputName: string, outputName: string) => void,
                         emitter?: PullEmitter): PullEmitter {

            if (script.emitRequired(this.emitOptions)) {
                var typeScriptFileName = script.locationInfo.fileName;
                if (!emitter) {
                    var javaScriptFileName = this.emitOptions.mapOutputFileName(typeScriptFileName, TypeScriptCompiler.mapToJSFileName);
                    var outFile = this.createFile(javaScriptFileName, this.useUTF8ForFile(script));

                    emitter = new PullEmitter(javaScriptFileName, outFile, this.emitOptions, this.semanticInfoChain);

                    if (this.settings.mapSourceFiles) {
                        var sourceMapFileName = javaScriptFileName + SourceMapper.MapFileExtension;
                        emitter.setSourceMappings(new SourceMapper(typeScriptFileName, javaScriptFileName, sourceMapFileName, outFile,
                            this.createFile(sourceMapFileName, /*isUTF8:*/ false), this.settings.emitFullSourceMapPath));
                    }

                    if (inputOutputMapper) {
                        // Remember the name of the outfile for this source file
                        inputOutputMapper(typeScriptFileName, javaScriptFileName);
                    }
                }
                else if (this.settings.mapSourceFiles) {
                    emitter.setSourceMappings(new SourceMapper(typeScriptFileName, emitter.emittingFileName, emitter.sourceMapper.sourceMapFileName, emitter.outfile,
                        emitter.sourceMapper.sourceMapOut, this.settings.emitFullSourceMapPath));
                }

                // Set location info
                emitter.setUnit(script.locationInfo);
                emitter.emitJavascript(script, TokenID.Comma, false);
            }

            return emitter;
        }

        // Will not throw exceptions.
        public emit(ioHost: EmitterIOHost, inputOutputMapper?: (inputFile: string, outputFile: string) => void ): IDiagnostic[] {
            var optionsDiagnostic = this.parseEmitOption(ioHost);
            if (optionsDiagnostic) {
                return [optionsDiagnostic];
            }

            var startEmitTime = (new Date()).getTime();

            var fileNames = this.fileNameToScript.getAllKeys();
            var sharedEmitter: PullEmitter = null;

            // Iterate through the files, as long as we don't get an error.
            for (var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];

                var script = <Script>this.fileNameToScript.lookup(fileName);

                try {
                    if (this.emitOptions.outputMany) {
                        // We're outputting to mulitple files.  We don't want to reuse an emitter in that case.
                        var singleEmitter = this.emitUnit(script, inputOutputMapper);

                        // Close the emitter after each emitted file.
                        if (singleEmitter) {
                            singleEmitter.emitSourceMapsAndClose();
                        }
                    }
                    else {
                        // We're not outputting to multiple files.  Keep using the same emitter and don't
                        // close until below.
                        sharedEmitter = this.emitUnit(script, inputOutputMapper, sharedEmitter);
                    }
                }
                catch (ex1) {
                    return Emitter.handleEmitterError(fileName, ex1);
                }
            }

            this.logger.log("Emit: " + ((new Date()).getTime() - startEmitTime));

            if (sharedEmitter) {
                try {
                    sharedEmitter.emitSourceMapsAndClose();
                }
                catch (ex2) {
                    return Emitter.handleEmitterError(sharedEmitter.locationInfo.fileName, ex2);
                }
            }

            return [];
        }

        private outputScriptToUTF8(script: Script): bool {
            return script.containsUnicodeChar || (this.emitOptions.compilationSettings.emitComments && script.containsUnicodeCharInComment);
        }

        private outputScriptsToUTF8(scripts: Script[]): bool {
            for (var i = 0, len = scripts.length; i < len; i++) {
                var script = scripts[i];
                if (this.outputScriptToUTF8(script)) {
                    return true;
                }
            }
            return false;
        }

        private createFile(fileName: string, useUTF8: bool): ITextWriter {
            // Creating files can cause exceptions, they will be caught higher up in TypeScriptCompiler.emit
            return this.emitOptions.ioHost.createFile(fileName, useUTF8);
        }

        //
        // Pull typecheck infrastructure
        //

        private pullResolveFile(fileName: string): bool {
            if (!this.pullTypeChecker) {
                return false;
            }

            var unit = this.semanticInfoChain.getUnit(fileName);

            if (!unit) {
                return false;
            }

            this.pullTypeChecker.setUnit(fileName);
            this.pullTypeChecker.resolver.resolveBoundDecls(unit.getTopLevelDecls()[0], new PullTypeResolutionContext());

            return true;
        }

        public getSyntacticDiagnostics(fileName: string): IDiagnostic[]{
            return this.fileNameToSyntaxTree.lookup(fileName).diagnostics();
        }

        public getSemanticDiagnostics(fileName: string): IDiagnostic[] {
            var errors: IDiagnostic[] = [];

            var unit = this.semanticInfoChain.getUnit(fileName);

            if (unit) {
                var script: Script = this.fileNameToScript.lookup(fileName);

                if (script) {
                    this.pullTypeChecker.typeCheckScript(script, fileName, this);

                    unit.getDiagnostics(errors);
                }
            }

            return errors;
        }

        public pullTypeCheck(refresh = false, reportDiagnostics = false) {
            return this.timeFunction("pullTypeCheck()", () => {

                if (!this.pullTypeChecker || refresh) {
                    this.semanticInfoChain = new SemanticInfoChain();
                    this.pullTypeChecker = new PullTypeChecker(this.settings, this.semanticInfoChain);
                }

                this.pullErrorReporter.setUnits(this.fileNameToLocationInfo);

                var declCollectionContext: DeclCollectionContext = null;
                var i: number;

                var createDeclsStartTime = new Date().getTime();

                var fileNames = this.fileNameToScript.getAllKeys();
                for (i = 0; i < fileNames.length; i++) {
                    var fileName = fileNames[i];
                    var semanticInfo = new SemanticInfo(fileName, this.fileNameToLocationInfo.lookup(fileName));

                    declCollectionContext = new DeclCollectionContext(semanticInfo);
                    declCollectionContext.scriptName = fileName;

                    // create decls
                    getAstWalkerFactory().walk(this.fileNameToScript.lookup(fileName), preCollectDecls, postCollectDecls, null, declCollectionContext);

                    semanticInfo.addTopLevelDecl(declCollectionContext.getParent());

                    this.semanticInfoChain.addUnit(semanticInfo);
                }

                var createDeclsEndTime = new Date().getTime();

                // bind declaration symbols
                var bindStartTime = new Date().getTime();

                var binder = new PullSymbolBinder(this.settings, this.semanticInfoChain);

                // start at '1', so as to skip binding for global primitives such as 'any'
                for (i = 1; i < this.semanticInfoChain.units.length; i++) {
                    binder.bindDeclsForUnit(this.semanticInfoChain.units[i].getPath());
                }

                var bindEndTime = new Date().getTime();

                var findErrorsStartTime = new Date().getTime();

                // type check
                fileNames = this.fileNameToScript.getAllKeys();
                for (i = 0; i < fileNames.length; i++) {
                    fileName = fileNames[i];

                    if (reportDiagnostics) {
                        this.logger.log("Type checking " + fileName);
                        this.pullTypeChecker.typeCheckScript(<Script>this.fileNameToScript.lookup(fileName), fileName, this);
                    }
                    else {
                        this.logger.log("Resolving " + fileName);
                        this.pullResolveFile(fileName);
                    }
                }
                var findErrorsEndTime = new Date().getTime();

                this.logger.log("Decl creation: " + (createDeclsEndTime - createDeclsStartTime));
                this.logger.log("Binding: " + (bindEndTime - bindStartTime));
                this.logger.log("    Time in findSymbol: " + time_in_findSymbol);
                this.logger.log("Find errors: " + (findErrorsEndTime - findErrorsStartTime));

                if (reportDiagnostics) {
                    this.pullErrorReporter.reportDiagnostics(this.semanticInfoChain.postDiagnostics());
                }
            });
        }

        // returns 'true' if diffs were detected
        private pullUpdateScript(oldScript: Script, newScript: Script): void {
            this.timeFunction("pullUpdateScript: ", () => {

                var declDiffer = new PullDeclDiffer();

                // want to name the new script semantic info the same as the old one
                var newScriptSemanticInfo = new SemanticInfo(oldScript.locationInfo.fileName, newScript.locationInfo);
                var oldScriptSemanticInfo = this.semanticInfoChain.getUnit(oldScript.locationInfo.fileName);

                lastBoundPullDeclId = pullDeclID;
                lastBoundPullSymbolID = pullSymbolID;

                var declCollectionContext = new DeclCollectionContext(newScriptSemanticInfo);

                declCollectionContext.scriptName = oldScript.locationInfo.fileName;

                // create decls
                getAstWalkerFactory().walk(newScript, preCollectDecls, postCollectDecls, null, declCollectionContext);

                var oldTopLevelDecl = oldScriptSemanticInfo.getTopLevelDecls()[0];
                var newTopLevelDecl = declCollectionContext.getParent();

                newScriptSemanticInfo.addTopLevelDecl(newTopLevelDecl);

                var diffResults: PullDeclDiff[] = [];

                var diffStartTime = new Date().getTime();
                declDiffer.diffDecls(oldTopLevelDecl, newTopLevelDecl, diffResults);

                var diffEndTime = new Date().getTime();
                this.logger.log("Update Script - Diff time: " + (diffEndTime - diffStartTime));

                // replace the old semantic info
                this.semanticInfoChain.updateUnit(oldScriptSemanticInfo, newScriptSemanticInfo);

                // re-bind
                var innerBindStartTime = new Date().getTime();

                var topLevelDecls = newScriptSemanticInfo.getTopLevelDecls();

                this.semanticInfoChain.update(newScript.locationInfo.fileName);

                var binder = new PullSymbolBinder(this.settings, this.semanticInfoChain);
                binder.setUnit(newScript.locationInfo.fileName);

                var i = 0;

                for (i = 0; i < topLevelDecls.length; i++) {
                    binder.bindDeclToPullSymbol(topLevelDecls[i], true);
                }

                var innerBindEndTime = new Date().getTime();

                this.logger.log("Update Script - Inner bind time: " + (innerBindEndTime - innerBindStartTime));
                if (diffResults.length) {

                    // propagate changes
                    var graphUpdater = new PullSymbolGraphUpdater(this.semanticInfoChain);
                    var diff: PullDeclDiff;

                    var traceStartTime = new Date().getTime();
                    for (i = 0; i < diffResults.length; i++) {
                        diff = diffResults[i];

                        if (diff.kind === PullDeclEdit.DeclRemoved) {
                            graphUpdater.removeDecl(diff.oldDecl);
                        }
                        else if (diff.kind === PullDeclEdit.DeclAdded) {
                            graphUpdater.addDecl(diff.newDecl);
                            graphUpdater.invalidateType(diff.oldDecl.getSymbol());
                        }
                        else {
                            // PULLTODO: Other kinds of edits
                        }
                    }

                    var traceEndTime = new Date().getTime();

                    // Don't re-typecheck or re-report errors just yet
                    this.pullTypeChecker.typeCheckScript(newScript, newScript.locationInfo.fileName, this);

                    this.logger.log("Update Script - Trace time: " + (traceEndTime - traceStartTime));
                    this.logger.log("Update Script - Number of diffs: " + diffResults.length);

                    this.pullErrorReporter.setUnits(this.fileNameToLocationInfo);

                    //this.pullErrorReporter.reportErrors(this.semanticInfoChain.postErrors())

                    return;
                }

                this.pullErrorReporter.setUnits(this.fileNameToLocationInfo);
                this.pullErrorReporter.reportDiagnostics(this.semanticInfoChain.postDiagnostics());
            });
        }

        public getSymbolOfDeclaration(decl: PullDecl) {
            if (!decl) {
                return null;
            }
            var ast = this.pullTypeChecker.resolver.getASTForDecl(decl);
            if (!ast) {
                return null;
            }
            var enlosingDecl = this.pullTypeChecker.resolver.getEnclosingDecl(decl);
            if (ast.nodeType == NodeType.Member) {
                return this.getSymbolOfDeclaration(enlosingDecl);
            }
            var resolutionContext = new PullTypeResolutionContext();
            return this.pullTypeChecker.resolver.resolveDeclaration(ast, resolutionContext, enlosingDecl);
        }

        public resolvePosition(pos: number, script: Script, scriptName?: string): PullTypeInfoAtPositionInfo {

            // find the enclosing decl
            var declStack: PullDecl[] = [];
            var resultASTs: AST[] = [];
            if (!scriptName) {
                scriptName = script.locationInfo.fileName;
            }
            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var lastDeclAST: AST = null;
            var foundAST: AST = null;
            var symbol: PullSymbol = null;
            var candidateSignature: PullSignatureSymbol = null;
            var callSignatures: PullSignatureSymbol[] = null;

            // these are used to track intermediate nodes so that we can properly apply contextual types
            var lambdaAST: FuncDecl = null;
            var declarationInitASTs: VarDecl[] = [];
            var objectLitAST: UnaryExpression = null;
            var asgAST: BinaryExpression = null;
            var typeAssertionASTs: UnaryExpression[] = [];
            var resolutionContext = new PullTypeResolutionContext();
            var inTypeReference = false;
            var enclosingDecl: PullDecl = null;
            var isConstructorCall = false;

            var pre = (cur: AST, parent: AST): AST => {
                if (isValidAstNode(cur)) {
                    if (pos >= cur.minChar && pos <= cur.limChar) {

                        var previous = resultASTs[resultASTs.length - 1];

                        if (previous === undefined || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {

                            var decl = semanticInfo.getDeclForAST(cur);

                            if (decl) {
                                declStack[declStack.length] = decl;
                                lastDeclAST = cur;
                            }

                            if (cur.nodeType === NodeType.FuncDecl && hasFlag((<FuncDecl>cur).fncFlags, FncFlags.IsFunctionExpression)) {
                                lambdaAST = <FuncDecl>cur;
                            }
                            else if (cur.nodeType === NodeType.VarDecl) {
                                declarationInitASTs[declarationInitASTs.length] = <VarDecl>cur;
                            }
                            else if (cur.nodeType === NodeType.ObjectLit) {
                                objectLitAST = <UnaryExpression>cur;
                            }
                            else if (cur.nodeType === NodeType.TypeAssertion) {
                                typeAssertionASTs[typeAssertionASTs.length] = <UnaryExpression>cur;
                            }
                            else if (cur.nodeType === NodeType.Asg) {
                                asgAST = <BinaryExpression>cur;
                            }
                            else if (cur.nodeType === NodeType.TypeRef) {
                                inTypeReference = true;
                            }

                            resultASTs[resultASTs.length] = cur;
                        }
                    }
                }
                return cur;
            }

            getAstWalkerFactory().walk(script, pre);

            if (resultASTs.length) {
                this.pullTypeChecker.setUnit(scriptName);

                foundAST = resultASTs[resultASTs.length - 1];

                // Check if is a name of a container
                if (foundAST.nodeType === NodeType.Name && resultASTs.length > 1) {
                    var previousAST = resultASTs[resultASTs.length - 2];
                    switch (previousAST.nodeType) {
                        case NodeType.InterfaceDeclaration:
                        case NodeType.ClassDeclaration:
                        case NodeType.ModuleDeclaration:
                            if (foundAST === (<NamedDeclaration>previousAST).name) {
                                foundAST = previousAST;
                            }
                            break;

                        case NodeType.VarDecl:
                            if (foundAST === (<VarDecl>previousAST).id) {
                                foundAST = previousAST;
                            }
                            break;

                        case NodeType.FuncDecl:
                            if (foundAST === (<FuncDecl>previousAST).name) {
                                foundAST = previousAST;
                            }
                            break;
                    }
                }

                // are we within a decl?  if so, just grab its symbol
                var funcDecl: FuncDecl = null;
                if (lastDeclAST === foundAST) {
                    symbol = declStack[declStack.length - 1].getSymbol();
                    this.pullTypeChecker.resolver.resolveDeclaredSymbol(symbol, null, resolutionContext);
                    enclosingDecl = declStack[declStack.length - 1].getParentDecl();
                    if (foundAST.nodeType === NodeType.FuncDecl) {
                        funcDecl = <FuncDecl>foundAST;
                    }
                }
                else {
                    // otherwise, it's an expression that needs to be resolved, so we must pull...
                    var i = 0;

                    // first, find the enclosing decl
                    for (i = declStack.length - 1; i >= 0; i--) {
                        if (!(declStack[i].getKind() & (PullElementKind.Variable | PullElementKind.Parameter))) {
                            enclosingDecl = declStack[i];
                            break;
                        }
                    }

                    // next, obtain the assigning AST, if applicable
                    // (this would be the ast for the last decl on the decl stack)

                    // if the found AST is a named, we want to check for previous dotted expressions,
                    // since those will give us the right typing
                    var callExpression: CallExpression = null;
                    if ((foundAST.nodeType == NodeType.Super || foundAST.nodeType == NodeType.This || foundAST.nodeType == NodeType.Name) &&
                        resultASTs.length > 1) {
                        for (i = resultASTs.length - 2; i >= 0; i--) {
                            if (resultASTs[i].nodeType === NodeType.Dot &&
                                (<BinaryExpression>resultASTs[i]).operand2 === resultASTs[i + 1]) {
                                foundAST = resultASTs[i];
                            }
                            else if ((resultASTs[i].nodeType === NodeType.Call || resultASTs[i].nodeType === NodeType.New) &&
                                (<CallExpression>resultASTs[i]).target === resultASTs[i + 1]) {
                                callExpression = <CallExpression>resultASTs[i];
                                break;
                            } else if (resultASTs[i].nodeType === NodeType.FuncDecl && (<FuncDecl>resultASTs[i]).name === resultASTs[i + 1]) {
                                funcDecl = <FuncDecl>resultASTs[i];
                                break;
                            } else {
                                break;
                            }
                        }
                    }

                    // if it's a list, we may not have an exact AST, so find the next nearest one
                    if (foundAST.nodeType === NodeType.List) {
                        for (i = 0; i < (<ASTList>foundAST).members.length; i++) {
                            if ((<ASTList>foundAST).members[i].minChar > pos) {
                                foundAST = (<ASTList>foundAST).members[i];
                                break;
                            }
                        }
                    }

                    resolutionContext.resolveAggressively = true;
                    resolutionContext.searchTypeSpace = inTypeReference;

                    var isTypedAssignment = false;

                    if (declarationInitASTs.length) {
                        var assigningAST: VarDecl;
                        var varSymbol: PullSymbol;

                        for (i = 0; i < declarationInitASTs.length; i++) {

                            assigningAST = declarationInitASTs[i];
                            isTypedAssignment = (assigningAST != null) && (assigningAST.typeExpr != null);

                            this.pullTypeChecker.resolver.resolveDeclaration(assigningAST, resolutionContext);
                            varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST, scriptName);

                            if (varSymbol && isTypedAssignment) {
                                var contextualType = varSymbol.getType();
                                resolutionContext.pushContextualType(contextualType, false, null);
                            }

                            if (assigningAST.init) {
                                this.pullTypeChecker.resolver.resolveAST(assigningAST.init, isTypedAssignment, enclosingDecl, resolutionContext);
                            }
                        }
                    }

                    if (typeAssertionASTs.length) {
                        for (i = 0; i < typeAssertionASTs.length; i++) {
                            this.pullTypeChecker.resolver.resolveAST(typeAssertionASTs[i], isTypedAssignment, enclosingDecl, resolutionContext);
                        }
                    }

                    if (asgAST) {
                        this.pullTypeChecker.resolver.resolveAST(asgAST, isTypedAssignment, enclosingDecl, resolutionContext);
                    }

                    if (objectLitAST) {
                        this.pullTypeChecker.resolver.resolveAST(objectLitAST, isTypedAssignment, enclosingDecl, resolutionContext);
                    }

                    if (lambdaAST) {
                        this.pullTypeChecker.resolver.resolveAST(lambdaAST, true, enclosingDecl, resolutionContext);
                        enclosingDecl = semanticInfo.getDeclForAST(lambdaAST);
                    }

                    symbol = this.pullTypeChecker.resolver.resolveAST(foundAST, isTypedAssignment, enclosingDecl, resolutionContext);
                    if (callExpression) {
                        var isPropertyOrVar = symbol.getKind() == PullElementKind.Property || symbol.getKind() == PullElementKind.Variable;
                        var typeSymbol = symbol.getType();
                        if (isPropertyOrVar) {
                            isPropertyOrVar = (typeSymbol.getKind() != PullElementKind.Interface && typeSymbol.getKind() != PullElementKind.ObjectType) || typeSymbol.getName() == "";
                        }

                        if (!isPropertyOrVar) {
                            isConstructorCall = foundAST.nodeType == NodeType.Super || callExpression.nodeType === NodeType.New;

                            if (foundAST.nodeType == NodeType.Super) {
                                if (symbol.getKind() == PullElementKind.Class) {
                                    callSignatures = (<PullClassTypeSymbol>symbol).getConstructorMethod().getType().getConstructSignatures();
                                }
                            } else {
                                callSignatures = callExpression.nodeType === NodeType.Call ? typeSymbol.getCallSignatures() : typeSymbol.getConstructSignatures();
                            }
                            var callResolutionResults: PullAdditionalCallResolutionData = {
                                targetSymbol: null,
                                resolvedSignatures: null,
                                candidateSignature: null
                            };

                            if (callExpression.nodeType === NodeType.Call) {
                                this.pullTypeChecker.resolver.resolveCallExpression(callExpression, isTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            } else {
                                this.pullTypeChecker.resolver.resolveNewExpression(callExpression, isTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            }

                            if (callResolutionResults.candidateSignature) {
                                candidateSignature = callResolutionResults.candidateSignature;
                            }
                            if (callResolutionResults.targetSymbol && callResolutionResults.targetSymbol.getName() != "") {
                                symbol = callResolutionResults.targetSymbol;
                            }
                            foundAST = callExpression;
                        }
                    }
                }

                if (funcDecl) {
                    if (symbol && symbol.getKind() != PullElementKind.Property) {
                        var signatureInfo = PullHelpers.getSignatureForFuncDecl(funcDecl, this.semanticInfoChain, scriptName);
                        candidateSignature = signatureInfo.signature;
                        callSignatures = signatureInfo.allSignatures;
                    }
                } else if (!callSignatures && symbol &&
                    (symbol.getKind() === PullElementKind.Method || symbol.getKind() == PullElementKind.Function)) {
                    var typeSym = symbol.getType()
                    if (typeSym) {
                        callSignatures = typeSym.getCallSignatures();
                    }
                }
            }

            var enclosingScopeSymbol = this.getSymbolOfDeclaration(enclosingDecl);

            return {
                symbol: symbol,
                ast: foundAST,
                enclosingScopeSymbol: enclosingScopeSymbol,
                candidateSignature: candidateSignature,
                callSignatures: callSignatures,
                isConstructorCall: isConstructorCall
            };
        }

        private extractResolutionContextFromPath(path: AstPath, script: Script, scriptName?: string): { ast: AST; enclosingDecl: PullDecl; resolutionContext: PullTypeResolutionContext; isTypedAssignment: bool; } {
            if (!scriptName) {
                scriptName = script.locationInfo.fileName;
            }

            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var enclosingDecl: PullDecl = null;
            var isTypedAssignment = false;

            var resolutionContext = new PullTypeResolutionContext();
            resolutionContext.resolveAggressively = true;

            if (path.count() === 0) {
                return null;
            }

            var i = 0;
            var n = 0;

            // Extract infromation from path
            for (i = 0, n = path.count(); i < n; i++) {
                var current = path.asts[i];
                var decl = semanticInfo.getDeclForAST(current);

                if (decl && !(decl.getKind() & (PullElementKind.Variable | PullElementKind.Parameter))) {
                    enclosingDecl = decl;
                }

                switch (current.nodeType) {
                    case NodeType.FuncDecl:
                        if (hasFlag((<FuncDecl>current).fncFlags, FncFlags.IsFunctionExpression)) {
                            this.pullTypeChecker.resolver.resolveAST((<FuncDecl>current), true, enclosingDecl, resolutionContext);
                        }

                        break;

                    case NodeType.VarDecl:
                        var assigningAST = <VarDecl> current;
                        isTypedAssignment = (assigningAST.typeExpr != null);

                        this.pullTypeChecker.resolver.resolveDeclaration(assigningAST, resolutionContext);
                        var varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST, scriptName);

                        if (varSymbol && isTypedAssignment) {
                            var contextualType = varSymbol.getType();
                            resolutionContext.pushContextualType(contextualType, false, null);
                        }

                        if (assigningAST.init) {
                            this.pullTypeChecker.resolver.resolveAST(assigningAST.init, isTypedAssignment, enclosingDecl, resolutionContext);
                        }

                        break;

                    case NodeType.ObjectLit:
                        this.pullTypeChecker.resolver.resolveAST((<UnaryExpression>current), isTypedAssignment, enclosingDecl, resolutionContext);
                        break;

                    case NodeType.Asg:
                        this.pullTypeChecker.resolver.resolveAST((<BinaryExpression>current), isTypedAssignment, enclosingDecl, resolutionContext);
                        break;

                    case NodeType.TypeAssertion:
                        this.pullTypeChecker.resolver.resolveAST((<UnaryExpression>current), isTypedAssignment, enclosingDecl, resolutionContext);
                        resolutionContext.searchTypeSpace = true;
                        break;

                    case NodeType.TypeRef:
                    case NodeType.TypeParameter:
                        resolutionContext.searchTypeSpace = true;
                        break;
                }

            }

            // Other possible type space references
            if (path.isNameOfInterface() || path.isInClassImplementsList() || path.isInInterfaceExtendsList()) {
                resolutionContext.searchTypeSpace = true;
            }

            // if the found AST is a named, we want to check for previous dotted expressions,
            // since those will give us the right typing
            if (path.ast().nodeType === NodeType.Name && path.count() > 1) {
                for (i = path.count() - 1; i >= 0; i--) {
                    if (path.asts[path.top - 1].nodeType === NodeType.Dot &&
                        (<BinaryExpression>path.asts[path.top - 1]).operand2 === path.asts[path.top]) {
                        path.pop();
                    }
                    else {
                        break;
                    }
                }
            }

            return {
                ast: path.ast(),
                enclosingDecl: enclosingDecl,
                resolutionContext: resolutionContext,
                isTypedAssignment: isTypedAssignment
            };
        }

        public pullGetSymbolInformationFromPath(path: AstPath, script: Script, scriptName?: string): { symbol: PullSymbol; ast: AST; } {
            var context = this.extractResolutionContextFromPath(path, script, scriptName);
            if (!context) {
                return null;
            }

            var symbol = this.pullTypeChecker.resolver.resolveAST(path.ast(), context.isTypedAssignment, context.enclosingDecl, context.resolutionContext);

            return { symbol: symbol, ast: path.ast() };
        }

        public pullGetCallInformationFromPath(path: AstPath, script: Script, scriptName?: string): { targetSymbol: PullSymbol; resolvedSignatures: PullSignatureSymbol[]; candidateSignature: PullSignatureSymbol; ast: AST; enclosingScopeSymbol: PullSymbol; } {
            // AST has to be a call expression
            if (path.ast().nodeType !== NodeType.Call && path.ast().nodeType !== NodeType.New) {
                return null;
            }

            var isNew = (path.ast().nodeType === NodeType.New);

            var context = this.extractResolutionContextFromPath(path, script, scriptName);
            if (!context) {
                return null;
            }

            var callResolutionResults = {
                targetSymbol: null,
                resolvedSignatures: null,
                candidateSignature: null,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };

            if (isNew) {
                this.pullTypeChecker.resolver.resolveNewExpression(<CallExpression>path.ast(), context.isTypedAssignment, context.enclosingDecl, context.resolutionContext, callResolutionResults);
            }
            else {
                this.pullTypeChecker.resolver.resolveCallExpression(<CallExpression>path.ast(), context.isTypedAssignment, context.enclosingDecl, context.resolutionContext, callResolutionResults);
            }
            return callResolutionResults;
        }

        public pullGetVisibleMemberSymbolsFromPath(path: AstPath, script: Script, scriptName?: string): PullVisibleSymbolsInfo {
            var context = this.extractResolutionContextFromPath(path, script, scriptName);
            if (!context) {
                return null;
            }

            var symbols = this.pullTypeChecker.resolver.getVisibleMembersFromExpresion(path.ast(), context.enclosingDecl, context.resolutionContext);
            if (!symbols) {
                return null;
            }

            return {
                symbols: symbols,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        }

        public pullGetVisibleSymbolsFromPath(path: AstPath, script: Script, scriptName?: string): PullVisibleSymbolsInfo {
            var context = this.extractResolutionContextFromPath(path, script, scriptName);
            if (!context) {
                return null;
            }

            var symbols = this.pullTypeChecker.resolver.getVisibleSymbols(context.enclosingDecl, context.resolutionContext);
            if (!symbols) {
                return null;
            }

            return {
                symbols: symbols,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        }

        public pullGetTypeInfoAtPosition(pos: number, script: Script, scriptName?: string): PullTypeInfoAtPositionInfo {
            return this.timeFunction("pullGetTypeInfoAtPosition for pos " + pos + ":", () => {

                var info = this.resolvePosition(pos, script, scriptName);
                return info;
            });
        }

        private reportDiagnostic(error: IDiagnostic, textWriter: ITextWriter) {
            if (error.fileName()) {
                var lineCol = { line: -1, character: -1 };
                var lineMap = this.fileNameToLocationInfo.lookup(error.fileName()).lineMap;
                lineMap.fillLineAndCharacterFromPosition(error.start(), lineCol);

                textWriter.Write(error.fileName() + "(" + (lineCol.line + 1) + "," + lineCol.character + "): ");
            }

            textWriter.WriteLine(error.message());
        }

        public reportDiagnostics(errors: IDiagnostic[], textWriter: ITextWriter): void {
            for (var i = 0; i < errors.length; i++) {
                this.reportDiagnostic(errors[i], textWriter);
            }
        }
    }
}
declare class Enumerator {
    public atEnd(): bool;
    public moveNext();
    public item(): any;
    constructor (o: any);
}
declare module process {
    export var argv: string[];
    export var platform: string;
    export function on(event: string, handler: (any) => void ): void;
    export module stdout {
        export function write(str: string);
    }
    export module stderr {
        export function write(str: string);
    }
    export module mainModule {
        export var filename: string;
    }
    export function exit(exitCode?: number);
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='Enumerator.ts' />
///<reference path='process.ts' />
///<reference path='Core\References.ts' />

interface IResolvedFile {
    content: string;
    path: string;
}

interface IFileWatcher {
    close(): void;
}

interface IIO {
    readFile(path: string): string;
    writeFile(path: string, contents: string): void;
    createFile(path: string, useUTF8?: bool): ITextWriter;
    deleteFile(path: string): void;
    dir(path: string, re?: RegExp, options?: { recursive?: bool; }): string[];
    fileExists(path: string): bool;
    directoryExists(path: string): bool;
    createDirectory(path: string): void;
    resolvePath(path: string): string;
    dirName(path: string): string;
    findFile(rootPath: string, partialFilePath: string): IResolvedFile;
    print(str: string): void;
    printLine(str: string): void;
    arguments: string[];
    stderr: ITextWriter;
    stdout: ITextWriter;
    watchFile(fileName: string, callback: (string) => void ): IFileWatcher;
    run(source: string, fileName: string): void;
    getExecutingFilePath(): string;
    quit(exitCode?: number);
}

module IOUtils {
    // Creates the directory including its parent if not already present
    function createDirectoryStructure(ioHost: IIO, dirName: string) {
        if (ioHost.directoryExists(dirName)) {
            return;
        }

        var parentDirectory = ioHost.dirName(dirName);
        if (parentDirectory != "") {
            createDirectoryStructure(ioHost, parentDirectory);
        }
        ioHost.createDirectory(dirName);
    }

    // Creates a file including its directory structure if not already present
    export function createFileAndFolderStructure(ioHost: IIO, fileName: string, useUTF8?: bool) {
        var path = ioHost.resolvePath(fileName);
        var dirName = ioHost.dirName(path);
        createDirectoryStructure(ioHost, dirName);
        return ioHost.createFile(path, useUTF8);
    }

    export function throwIOError(message: string, error: Error) {
        var errorMessage = message;
        if (error && error.message) {
            errorMessage += (" " + error.message);
        }
        throw new Error(errorMessage);
    }

    export class BufferedTextWriter implements ITextWriter {
        public buffer = "";
        // Inner writer does not need a WriteLine method, since the BufferedTextWriter wraps it itself
        constructor(public writer: { Write: (str: string) => void; Close: () => void; }, public capacity = 1024) { }
        Write(str) {
            this.buffer += str;
            if (this.buffer.length >= this.capacity) {
                this.writer.Write(this.buffer);
                this.buffer = "";
            }
        }
        WriteLine(str) {
            this.Write(str + '\r\n');
        }
        Close() {
            this.writer.Write(this.buffer);
            this.writer.Close();
            this.buffer = null;
        }
    }
}

// Declare dependencies needed for all supported hosts
declare function setTimeout(callback: () =>void , ms?: number);

var IO = (function() {

    // Create an IO object for use inside WindowsScriptHost hosts
    // Depends on WSCript and FileSystemObject
    function getWindowsScriptHostIO(): IIO {
        var fso = new ActiveXObject("Scripting.FileSystemObject");        
        var streamObjectPool = [];

        function getStreamObject(): any { 
            if (streamObjectPool.length > 0) {
                return streamObjectPool.pop();
            }  else {
                return new ActiveXObject("ADODB.Stream");
            }
        }

        function releaseStreamObject(obj: any) { 
            streamObjectPool.push(obj);
        }

        var args = [];
        for (var i = 0; i < WScript.Arguments.length; i++) {
            args[i] = WScript.Arguments.Item(i);
        }

        return {
            readFile: function(path) {
                try {
                    var streamObj = getStreamObject();
                    streamObj.Open();
                    streamObj.Type = 2; // Text data
                    streamObj.Charset = 'x-ansi'; // Assume we are reading ansi text
                    streamObj.LoadFromFile(path);
                    var bomChar = streamObj.ReadText(2); // Read the BOM char
                    streamObj.Position = 0; // Position has to be at 0 before changing the encoding
                    if ((bomChar.charCodeAt(0) == 0xFE && bomChar.charCodeAt(1) == 0xFF)
                        || (bomChar.charCodeAt(0) == 0xFF && bomChar.charCodeAt(1) == 0xFE)) {
                        streamObj.Charset = 'unicode';
                    } else if (bomChar.charCodeAt(0) == 0xEF && bomChar.charCodeAt(1) == 0xBB) {
                        streamObj.Charset = 'utf-8'; 
                    }

                    // Read the whole file
                    var str = streamObj.ReadText(-1 /* read from the current position to EOS */);
                    streamObj.Close();
                    releaseStreamObject(streamObj);
                    return <string>str;
                }
                catch (err) {
                    IOUtils.throwIOError("Error reading file \"" + path + "\".", err);
                }
            },

            writeFile: function(path, contents) {
                var file = this.createFile(path);
                file.Write(contents);
                file.Close();
            },

            fileExists: function(path: string): bool {
                return fso.FileExists(path);
            },

            resolvePath: function(path: string): string {
                return fso.GetAbsolutePathName(path);
            },

            dirName: function(path: string): string {
                return fso.GetParentFolderName(path);
            },

            findFile: function(rootPath: string, partialFilePath: string): IResolvedFile {
                var path = fso.GetAbsolutePathName(rootPath) + "/" + partialFilePath;

                while (true) {
                    if (fso.FileExists(path)) {
                        try {
                            var content = this.readFile(path);
                            return { content: content, path: path };
                        }
                        catch (err) {
                            //Tools.CompilerDiagnostics.debugPrint("Could not find " + path + ", trying parent");
                        }
                    }
                    else {
                        rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));

                        if (rootPath == "") {
                            return null;
                        }
                        else {
                            path = fso.BuildPath(rootPath, partialFilePath);
                        }
                    }
                }
            },

            deleteFile: function(path: string): void {
                try {
                    if (fso.FileExists(path)) {
                        fso.DeleteFile(path, true); // true: delete read-only files
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't delete file '" + path + "'.", e);
                }
            },

            createFile: function (path, useUTF8?) {
                try {
                    var streamObj = getStreamObject();
                    streamObj.Charset = useUTF8 ? 'utf-8' : 'x-ansi';
                    streamObj.Open();
                    return {
                        Write: function (str) { streamObj.WriteText(str, 0); },
                        WriteLine: function (str) { streamObj.WriteText(str, 1); },
                        Close: function() {
                            try {
                                streamObj.SaveToFile(path, 2);
                            } catch (saveError) {
                                IOUtils.throwIOError("Couldn't write to file '" + path + "'.", saveError);
                            }
                            finally {
                                if (streamObj.State != 0 /*adStateClosed*/) {
                                    streamObj.Close();
                                }
                                releaseStreamObject(streamObj);
                            }
                        }
                    };
                } catch (creationError) {
                    IOUtils.throwIOError("Couldn't write to file '" + path + "'.", creationError);
                }
            },

            directoryExists: function(path) {
                return <bool>fso.FolderExists(path);
            },

            createDirectory: function(path) {
                try {
                    if (!this.directoryExists(path)) {
                        fso.CreateFolder(path);
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't create directory '" + path + "'.", e);
                }
            },

            dir: function(path, spec?, options?) {
                options = options || <{ recursive?: bool; }>{};
                function filesInFolder(folder, root): string[]{
                    var paths = [];
                    var fc: Enumerator;

                    if (options.recursive) {
                        fc = new Enumerator(folder.subfolders);

                        for (; !fc.atEnd() ; fc.moveNext()) {
                            paths = paths.concat(filesInFolder(fc.item(), root + "/" + fc.item().Name));
                        }
                    }

                    fc = new Enumerator(folder.files);

                    for (; !fc.atEnd() ; fc.moveNext()) {
                        if (!spec || fc.item().Name.match(spec)) {
                            paths.push(root + "/" + fc.item().Name);
                        }
                    }

                    return paths;
                }

                var folder = fso.GetFolder(path);
                var paths = [];

                return filesInFolder(folder, path);
            },

            print: function(str) {
                WScript.StdOut.Write(str);
            },

            printLine: function(str) {
                WScript.Echo(str);
            },

            arguments: <string[]>args,
            stderr: WScript.StdErr,
            stdout: WScript.StdOut,
            watchFile: null,
            run: function(source, fileName) {
                try {
                    eval(source);
                } catch (e) {
                    IOUtils.throwIOError("Error while executing file '" + fileName + "'.", e);
                }
            },
            getExecutingFilePath: function () {
                return WScript.ScriptFullName;
            },
            quit: function (exitCode? : number = 0) {
                try {
                    WScript.Quit(exitCode);
                } catch (e) {
                }
            }
        }

    };

    // Create an IO object for use inside Node.js hosts
    // Depends on 'fs' and 'path' modules
    function getNodeIO(): IIO {

        var _fs = require('fs');
        var _path = require('path');
        var _module = require('module');

        return {
            readFile: function(file) {
                try {
                    var buffer = _fs.readFileSync(file);
                    switch (buffer[0]) {
                        case 0xFE:
                            if (buffer[1] == 0xFF) {
                                // utf16-be. Reading the buffer as big endian is not supported, so convert it to 
                                // Little Endian first
                                var i = 0;
                                while ((i + 1) < buffer.length) {
                                    var temp = buffer[i]
                                    buffer[i] = buffer[i + 1];
                                    buffer[i + 1] = temp;
                                    i += 2;
                                }
                                return buffer.toString("ucs2", 2);
                            }
                            break;
                        case 0xFF:
                            if (buffer[1] == 0xFE) {
                                // utf16-le 
                                return buffer.toString("ucs2", 2);
                            }
                            break;
                        case 0xEF:
                            if (buffer[1] == 0xBB) {
                                // utf-8
                                return buffer.toString("utf8", 3);
                            }
                    }
                    // Default behaviour
                    return buffer.toString();
                } catch (e) {
                    IOUtils.throwIOError("Error reading file \"" + file + "\".", e);
                }
            },

            writeFile: <(path: string, contents: string) => void >_fs.writeFileSync,
            deleteFile: function(path) {
                try {
                    _fs.unlinkSync(path);
                } catch (e) {
                    IOUtils.throwIOError("Couldn't delete file '" + path + "'.", e);
                }
            },
            fileExists: function(path): bool {
                return _fs.existsSync(path);
            },
            createFile: function(path, useUTF8?) {
                function mkdirRecursiveSync(path) {
                    var stats = _fs.statSync(path);
                    if (stats.isFile()) {
                        IOUtils.throwIOError("\"" + path + "\" exists but isn't a directory.", null);
                    } else if (stats.isDirectory()) {
                        return;
                    } else {
                        mkdirRecursiveSync(_path.dirname(path));
                        _fs.mkdirSync(path, 0775);
                    }
                }

                mkdirRecursiveSync(_path.dirname(path));

                try {
                    var fd = _fs.openSync(path, 'w');
                } catch (e) {
                    IOUtils.throwIOError("Couldn't write to file '" + path + "'.", e);
                }
                // Writing to a buffer to improve performance
                return new IOUtils.BufferedTextWriter({
                    Write: function (str) { _fs.writeSync(fd, str); },
                    Close: function () { _fs.closeSync(fd); fd = null; }
                });
            },
            dir: function dir(path, spec?, options?) {
                options = options || <{ recursive?: bool; }>{};

                function filesInFolder(folder: string): string[]{
                    var paths = [];

                    try {
                        var files = _fs.readdirSync(folder);
                        for (var i = 0; i < files.length; i++) {
                            var stat = _fs.statSync(folder + "/" + files[i]);
                            if (options.recursive && stat.isDirectory()) {
                                paths = paths.concat(filesInFolder(folder + "/" + files[i]));
                            } else if (stat.isFile() && (!spec || files[i].match(spec))) {
                                paths.push(folder + "/" + files[i]);
                            }
                        }
                    } catch (err) {
                        /*
                        *   Skip folders that are inaccessible
                        */
                    }

                    return paths;
                }

                return filesInFolder(path);
            },
            createDirectory: function(path: string): void {
                try {
                    if (!this.directoryExists(path)) {
                        _fs.mkdirSync(path);
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't create directory '" + path + "'.", e);
                }
            },

            directoryExists: function(path: string): bool {
                return _fs.existsSync(path) && _fs.lstatSync(path).isDirectory();
            },
            resolvePath: function(path: string): string {
                return _path.resolve(path);
            },
            dirName: function(path: string): string {
                return _path.dirname(path);
            },
            findFile: function(rootPath: string, partialFilePath): IResolvedFile {
                var path = rootPath + "/" + partialFilePath;

                while (true) {
                    if (_fs.existsSync(path)) {
                        try {
                            var content = this.readFile(path);
                            return { content: content, path: path };
                        } catch (err) {
                            //Tools.CompilerDiagnostics.debugPrint(("Could not find " + path) + ", trying parent");
                        }
                    }
                    else {
                        var parentPath = _path.resolve(rootPath, "..");

                        // Node will just continue to repeat the root path, rather than return null
                        if (rootPath === parentPath) {
                            return null;
                        }
                        else {
                            rootPath = parentPath;
                            path = _path.resolve(rootPath, partialFilePath);
                        }
                    }
                }
            },
            print: function(str) { process.stdout.write(str) },
            printLine: function(str) { process.stdout.write(str + '\n') },
            arguments: process.argv.slice(2),
            stderr: {
                Write: function(str) { process.stderr.write(str); },
                WriteLine: function(str) { process.stderr.write(str + '\n'); },
                Close: function() { }
            },
            stdout: {
                Write: function(str) { process.stdout.write(str); },
                WriteLine: function(str) { process.stdout.write(str + '\n'); },
                Close: function() { }
            },
            watchFile: function(fileName: string, callback: (string) => void ): IFileWatcher {
                var firstRun = true;
                var processingChange = false;

                var fileChanged: any = function(curr, prev) {
                    if (!firstRun) {
                        if (curr.mtime < prev.mtime) {
                            return;
                        }

                        _fs.unwatchFile(fileName, fileChanged);
                        if (!processingChange) {
                            processingChange = true;
                            callback(fileName);
                            setTimeout(function() { processingChange = false; }, 100);
                        }
                    }
                    firstRun = false;
                    _fs.watchFile(fileName, { persistent: true, interval: 500 }, fileChanged);
                };

                fileChanged();
                return {
                    fileName: fileName,
                    close: function() {
                        _fs.unwatchFile(fileName, fileChanged);
                    }
                };
            },
            run: function(source, fileName) {
                require.main.fileName = fileName;
                require.main.paths = _module._nodeModulePaths(_path.dirname(_fs.realpathSync(fileName)));
                require.main._compile(source, fileName);
            }, 
            getExecutingFilePath: function () {
                return process.mainModule.filename;
            },
            quit: process.exit
        }
    };

    if (typeof ActiveXObject === "function")
        return getWindowsScriptHostIO();
    else if (typeof require === "function")
        return getNodeIO();
    else
        return null; // Unsupported host
})();
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path="io.ts" />

interface IOptions {
    name?: string;
    flag?: bool;
    short?: string;
    usage?: string;
    set?: (s: string) => void;
    type?: string;
    experimental?: bool;
}

class OptionsParser {
    private DEFAULT_SHORT_FLAG = "-";
    private DEFAULT_LONG_FLAG = "--";

    // Find the option record for the given string. Returns null if not found.
    private findOption(arg: string) {

        for (var i = 0; i < this.options.length; i++) {

            if (arg === this.options[i].short || arg === this.options[i].name) {
                return this.options[i];
            }
        }

        return null;
    }

    public unnamed: string[] = [];

    public options: IOptions[] = [];

    constructor (public host: IIO) {
    }

    public printUsage() {
        this.host.printLine("Syntax:   tsc [options] [file ..]");
        this.host.printLine("");
        this.host.printLine("Examples: tsc hello.ts");
        this.host.printLine("          tsc --out foo.js foo.ts");
        this.host.printLine("          tsc @args.txt");
        this.host.printLine("");
        this.host.printLine("Options:");

        var output = [];
        var maxLength = 0;
        var i = 0;

        this.options = this.options.sort(function(a, b) {
            var aName = a.name.toLowerCase();
            var bName = b.name.toLowerCase();

            if (aName > bName) {
                return 1;
            } else if (aName < bName) {
                return -1;
            } else {
                return 0;
            }
        });

        // Build up output array
        for (i = 0; i < this.options.length; i++) {
            var option = this.options[i];

            if (option.experimental) {
                continue;
            }

            if (!option.usage) {
                break;
            }

            var usageString = "  ";
            var type = option.type ? " " + option.type.toUpperCase() : "";

            if (option.short) {
                usageString += this.DEFAULT_SHORT_FLAG + option.short + type + ", ";
            }

            usageString += this.DEFAULT_LONG_FLAG + option.name + type;

            output.push([usageString, option.usage]);

            if (usageString.length > maxLength) {
                maxLength = usageString.length;
            }
        }

        output.push(["  @<file>", "Insert command line options and files from a file."]);

        // Print padded output
        for (i = 0; i < output.length; i++) {
            this.host.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(" ") + output[i][1]);
        }
    }

    public option(name: string, config: IOptions, short?: string) {
        if (!config) {
            config = <any>short;
            short = null;
        }

        config.name = name;
        config.short = short;
        config.flag = false;

        this.options.push(config);
    }

    public flag(name: string, config: IOptions, short?: string) {
        if (!config) {
            config = <any>short;
            short = null;
        }

        config.name = name;
        config.short = short;
        config.flag = true

        this.options.push(config);
    }

    // Parse an arguments string
    public parseString(argString: string) {
        var position = 0;
        var tokens = argString.match(/\s+|"|[^\s"]+/g);

        function peek() {
            return tokens[position];
        }

        function consume() {
            return tokens[position++];
        }

        function consumeQuotedString() {
            var value = '';
            consume(); // skip opening quote.

            var token = peek();

            while (token && token !== '"') {
                consume();

                value += token;

                token = peek();
            }

            consume(); // skip ending quote;

            return value;
        }

        var args: string[] = [];
        var currentArg = '';

        while (position < tokens.length) {
            var token = peek();

            if (token === '"') {
                currentArg += consumeQuotedString();
            } else if (token.match(/\s/)) {
                if (currentArg.length > 0) {
                    args.push(currentArg);
                    currentArg = '';
                }

                consume();
            } else {
                consume();
                currentArg += token;
            }
        }

        if (currentArg.length > 0) {
            args.push(currentArg);
        }

        this.parse(args);
    }

    // Parse arguments as they come from the platform: split into arguments.
    public parse(args: string[]) {
        var position = 0;

        function consume() {
            return args[position++];
        }

        while (position < args.length) {
            var current = consume();
            var match = current.match(/^(--?|@)(.*)/);
            var value = null;

            if (match) {
                if (match[1] === '@') {
                    this.parseString(this.host.readFile(match[2]));
                } else {
                    var arg = match[2];
                    var option = this.findOption(arg);

                    if (option === null) {
                        this.host.printLine("Unknown option '" + arg +"'");
                        this.host.printLine("Use the '--help' flag to see options");
                    } else {
                        if (!option.flag)
                            value = consume();

                        option.set(value);
                    }
                }
            } else {
                this.unnamed.push(current);
            }
        }
    }
}
﻿//﻿
// Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

///<reference path='typescript.ts'/>
///<reference path='io.ts'/>
///<reference path='optionsParser.ts'/>

declare var localizedDiagnosticMessages: TypeScript.TypeScriptDiagnosticMessages;

class DiagnosticsLogger implements TypeScript.ILogger {
    constructor(public ioHost: IIO) {
    }
    public information(): bool { return false; }
    public debug(): bool { return false; }
    public warning(): bool { return false; }
    public error(): bool { return false; }
    public fatal(): bool { return false; }
    public log(s: string): void {
        this.ioHost.stdout.WriteLine(s);
    }
}

class ErrorReporter implements ITextWriter {
    public hasErrors: bool;

    constructor(public ioHost: IIO) {
        this.hasErrors = false;
    }

    public Write(s: string) {
        this.hasErrors = true;
        this.ioHost.stderr.Write(s);
    }

    public WriteLine(s: string) {
        this.hasErrors = true;
        this.ioHost.stderr.WriteLine(s);
    }

    public Close() {
    }

    public reset() {
        this.hasErrors = false;
    }
}

class CommandLineHost implements TypeScript.IResolverHost {

    public pathMap: any = {};
    public resolvedPaths: any = {};

    constructor(public compilationSettings: TypeScript.CompilationSettings, public errorReporter: (err:string)=>void) { 
    }

    public getPathIdentifier(path: string) {
        return this.compilationSettings.useCaseSensitiveFileResolution ? path : path.toLocaleUpperCase();
    }

    public isResolved(path: string) {
        return this.resolvedPaths[this.getPathIdentifier(this.pathMap[path])] != undefined;
    }

    public resolveCompilationEnvironment(preEnv: TypeScript.CompilationEnvironment,
                                         resolver: TypeScript.ICodeResolver,
                                         traceDependencies: bool): TypeScript.CompilationEnvironment {
        var resolvedEnv = new TypeScript.CompilationEnvironment(preEnv.compilationSettings, preEnv.ioHost);

        var nCode = preEnv.code.length;
        var path = "";

        var postResolutionError = 
            (errorFile: string, errorMessage: string) => {
                this.errorReporter(errorFile + (errorMessage === "" ? "" : ": " + errorMessage));
            }

        var resolutionDispatcher: TypeScript.IResolutionDispatcher = {
            postResolutionError: (errorFile, fileReference, errorMessage) => {
                this.errorReporter(errorFile + "(" + (fileReference.line + 1) + "," + (fileReference.character + 1) + ") " + (errorMessage === "" ? "" : ": " + errorMessage));
            },
            postResolution: (path: string, code: TypeScript.IScriptSnapshot) => {
                var pathId = this.getPathIdentifier(path);
                if (!this.resolvedPaths[pathId]) {
                    resolvedEnv.code.push(<TypeScript.SourceUnit>code);
                    this.resolvedPaths[pathId] = true;
                }
            }
        };

        for (var i = 0; i < nCode; i++) {
            path = TypeScript.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.code[i].path));
            this.pathMap[preEnv.code[i].path] = path;
            resolver.resolveCode(path, "", false, resolutionDispatcher);
        }

        return resolvedEnv;
    }
}

class BatchCompiler {
    public compilationSettings: TypeScript.CompilationSettings;
    public compilationEnvironment: TypeScript.CompilationEnvironment;
    public resolvedEnvironment: TypeScript.CompilationEnvironment = null;
    public hasResolveErrors: bool = false;
    public compilerVersion = "0.9.0.0";
    public printedVersion = false;
    public errorReporter: ErrorReporter = null;

    constructor(public ioHost: IIO) {
        this.compilationSettings = new TypeScript.CompilationSettings();
        this.compilationEnvironment = new TypeScript.CompilationEnvironment(this.compilationSettings, this.ioHost);
        this.errorReporter = new ErrorReporter(this.ioHost);
    }

    public resolve() {
        var resolver = new TypeScript.CodeResolver(this.compilationEnvironment);
        var commandLineHost = new CommandLineHost(this.compilationSettings, (err) => this.errorReporter.WriteLine(err));
        var ret = commandLineHost.resolveCompilationEnvironment(this.compilationEnvironment, resolver, true);

        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {
            if (!commandLineHost.isResolved(this.compilationEnvironment.code[i].path)) {
                var path = this.compilationEnvironment.code[i].path;
                if (!TypeScript.isTSFile(path) && !TypeScript.isDTSFile(path)) {
                    this.errorReporter.WriteLine("Unknown extension for file: \"" + path + "\". Only .ts and .d.ts extensions are allowed.");
                }
                else {
                    this.errorReporter.WriteLine("Error reading file \"" + path + "\": File not found");
                }
            }
        }

        return ret;
    }
    
    /// Do the actual compilation reading from input files and
    /// writing to output file(s).
    public compile(): bool {
        if (typeof localizedDiagnosticMessages === "undefined") {
            localizedDiagnosticMessages = null;
        }

        var logger = this.compilationSettings.gatherDiagnostics ? <TypeScript.ILogger>new DiagnosticsLogger(this.ioHost) : new TypeScript.NullLogger();
        var compiler = new TypeScript.TypeScriptCompiler(
            this.errorReporter, logger, this.compilationSettings, localizedDiagnosticMessages);

        for (var iCode = 0 ; iCode < this.resolvedEnvironment.code.length; iCode++) {
            var code = this.resolvedEnvironment.code[iCode];

            // if file resolving is disabled, the file's content will not yet be loaded

            if (!this.compilationSettings.resolve) {
                code.content = this.ioHost.readFile(code.path);
                // If declaration files are going to be emitted, 
                // preprocess the file contents and add in referenced files as well
                if (this.compilationSettings.generateDeclarationFiles) {
                    TypeScript.CompilerDiagnostics.assert(code.referencedFiles === null, "With no resolve option, referenced files need to null");
                    code.referencedFiles = TypeScript.getReferencedFiles(code.path, code);
                }
            }

            if (code.content != null) {
                compiler.addSourceUnit(code.path, TypeScript.ScriptSnapshot.fromString(code.content), code.referencedFiles);

                var syntacticDiagnostics = compiler.getSyntacticDiagnostics(code.path);
                compiler.reportDiagnostics(syntacticDiagnostics, this.errorReporter);

                if (syntacticDiagnostics.length > 0) {
                    return true;
                }
            }
        }

        var emitterIOHost = {
            createFile: (fileName: string, useUTF8?: bool) => IOUtils.createFileAndFolderStructure(this.ioHost, fileName, useUTF8),
            directoryExists: this.ioHost.directoryExists,
            fileExists: this.ioHost.fileExists,
            resolvePath: this.ioHost.resolvePath
        };

        compiler.pullTypeCheck(true, true);
        // Note: we continue even if there were type check warnings.

        var mapInputToOutput = (inputFile: string, outputFile: string): void => {
            this.compilationEnvironment.inputFileNameToOutputFileName.addOrUpdate(inputFile, outputFile);
        };

        // TODO: if there are any emit diagnostics.  Don't proceed.
        var emitDiagnostics = compiler.emit(emitterIOHost, mapInputToOutput);
        compiler.reportDiagnostics(emitDiagnostics, this.errorReporter);
        if (emitDiagnostics.length > 0) {
            return true;
        }

        var emitDeclarationsDiagnostics = compiler.emitDeclarations();
        compiler.reportDiagnostics(emitDeclarationsDiagnostics, this.errorReporter);
        if (emitDeclarationsDiagnostics.length > 0) {
            return true;
        }

        return false;
    }

    // Execute the provided inputs
    private run() {
        for (var i in this.compilationEnvironment.code) {
            var outputFileName: string = this.compilationEnvironment.inputFileNameToOutputFileName.lookup(i);
            if (this.ioHost.fileExists(outputFileName)) {
                var unitRes = this.ioHost.readFile(outputFileName)
                this.ioHost.run(unitRes, outputFileName);
            }
        }
    }

    /// Begin batch compilation
    public batchCompile() {
        TypeScript.CompilerDiagnostics.diagnosticWriter = { Alert: (s: string) => { this.ioHost.printLine(s); } }

        var code: TypeScript.SourceUnit;

        var opts = new OptionsParser(this.ioHost);

        opts.option('out', {
            usage: 'Concatenate and emit output to single file | Redirect output structure to the directory',
            type: 'file|directory',
            set: (str) => {
                this.compilationSettings.outputOption = str;
            }
        });

        opts.option('style', {
            usage: 'Select style checking options (examples --style requireSemi:off or --style "eqeqeq;bitwise:off")',
            experimental: true,
            set: (str) => {
                this.compilationSettings.setStyleOptions(str);
            }
        });

        opts.flag('sourcemap', {
            usage: 'Generates corresponding .map file',
            set: () => {
                this.compilationSettings.mapSourceFiles = true;
            }
        });

        opts.flag('fullSourceMapPath', {
            usage: 'Writes the full path of map file in the generated js file',
            experimental: true,
            set: () => {
                this.compilationSettings.emitFullSourceMapPath = true;
            }
        });

        opts.flag('declaration', {
            usage: 'Generates corresponding .d.ts file',
            set: () => {
                this.compilationSettings.generateDeclarationFiles = true;
            }
        });

        if (this.ioHost.watchFile) {
            opts.flag('watch', {
                usage: 'Watch output files',
                set: () => {
                    this.compilationSettings.watch = true;
                }
            }, 'w');
        }

        opts.flag('exec', {
            usage: 'Execute the script after compilation',
            set: () => {
                this.compilationSettings.exec = true;
            }
        }, 'e');

        opts.flag('minw', {
            usage: 'Minimize whitespace',
            experimental: true,
            set: () => { this.compilationSettings.minWhitespace = true; }
        }, 'mw');

        opts.flag('const', {
            usage: 'Propagate constants to emitted code',
            experimental: true,
            set: () => { this.compilationSettings.propagateConstants = true; }
        });

        opts.flag('comments', {
            usage: 'Emit comments to output',
            set: () => {
                this.compilationSettings.emitComments = true;
            }
        }, 'c');

        opts.flag('cflow', {
            usage: 'Control flow',
            experimental: true,
            set: () => {
                this.compilationSettings.controlFlow = true;
            }
        });

        opts.flag('cflowp', {
            usage: 'Print control flow',
            experimental: true,
            set: () => {
                this.compilationSettings.controlFlow = true;
                this.compilationSettings.printControlFlow = true;
            }
        });

        opts.flag('cflowu', {
            usage: 'Print Use Def control flow',
            experimental: true,
            set: () => {
                this.compilationSettings.controlFlow = true;
                this.compilationSettings.controlFlowUseDef = true;
            }
        });

        opts.flag('noerroronwith', {
            usage: 'Allow with statements',
            experimental: true,
            set: () => {
                this.compilationSettings.errorOnWith = false;
            }
        });

        opts.flag('noresolve', {
            usage: 'Skip resolution and preprocessing',
            experimental: true,
            set: () => {
                this.compilationSettings.resolve = false;
            }
        });

        opts.flag('debug', {
            usage: 'Print debug output',
            experimental: true,
            set: () => {
                TypeScript.CompilerDiagnostics.debug = true;
            }
        });

        opts.flag('canCallDefinitionSignature', {
            usage: 'Allows you to call the definition signature of an overload group',
            experimental: true,
            set: () => {
                this.compilationSettings.canCallDefinitionSignature = true;
            }
        });

        opts.flag('nooptimizemodules', {
            usage: 'Do not optimize module codegen',
            experimental: true,
            set: () => {
                this.compilationSettings.optimizeModuleCodeGen = false;
            }
        });

        opts.flag('nolib', {
            usage: 'Do not include a default lib.d.ts with global declarations',
            set: () => {
                this.compilationSettings.useDefaultLib = false;
            }
        });

        opts.flag('diagnostics', {
            usage: 'gather diagnostic info about the compilation process',
            experimental: true,
            set: () => {
                this.compilationSettings.gatherDiagnostics = true;
            }
        });

        opts.option('target', {
            usage: 'Specify ECMAScript target version: "ES3" (default), or "ES5"',
            type: 'VER',
            set: (type) => {
                type = type.toLowerCase();

                if (type === 'es3') {
                    this.compilationSettings.codeGenTarget = TypeScript.LanguageVersion.EcmaScript3;
                }
                else if (type === 'es5') {
                    this.compilationSettings.codeGenTarget = TypeScript.LanguageVersion.EcmaScript5;
                }
                else {
                    this.errorReporter.WriteLine("ECMAScript target version '" + type + "' not supported.  Using default 'ES3' code generation");
                }
            }
        });

        opts.option('module', {
            usage: 'Specify module code generation: "commonjs" (default) or "amd"',
            type: 'kind',
            set: (type) => {
                type = type.toLowerCase();

                if (type === 'commonjs' || type === 'node') {
                    this.compilationSettings.moduleGenTarget = TypeScript.ModuleGenTarget.Synchronous;
                }
                else if (type === 'amd') {
                    this.compilationSettings.moduleGenTarget = TypeScript.ModuleGenTarget.Asynchronous;
                }
                else {
                    this.errorReporter.WriteLine("Module code generation '" + type + "' not supported.  Using default 'commonjs' code generation");
                }
            }
        });

        var printedUsage = false;

        opts.flag('help', {
            usage: 'Print this message',
            set: () => {
                this.printVersion();
                opts.printUsage();
                printedUsage = true;
            }
        }, 'h');

        opts.flag('useCaseSensitiveFileResolution', {
            usage: 'Force file resolution to be case sensitive',
            experimental: true,
            set: () => {
                this.compilationSettings.useCaseSensitiveFileResolution = true;
            }
        });

        opts.flag('version', {
            usage: 'Print the compiler\'s version: ' + this.compilerVersion,
            set: () => {
                this.printVersion();
            }
        }, 'v');

        opts.parse(this.ioHost.arguments);
        
        if (this.compilationSettings.useDefaultLib) {
            var compilerFilePath = this.ioHost.getExecutingFilePath()
            var binDirPath = this.ioHost.dirName(compilerFilePath);
            var libStrPath = this.ioHost.resolvePath(binDirPath + "/lib.d.ts");
            code = new TypeScript.SourceUnit(libStrPath, null);
            this.compilationEnvironment.code.push(code);
        }

        for (var i = 0; i < opts.unnamed.length; i++) {
            code = new TypeScript.SourceUnit(opts.unnamed[i], null);
            this.compilationEnvironment.code.push(code);
        }

        // If no source files provided to compiler - print usage information
        if (this.compilationEnvironment.code.length === (this.compilationSettings.useDefaultLib ? 1 : 0)) {
            if (!printedUsage && !this.printedVersion) {
                this.printVersion();
                opts.printUsage();
                this.ioHost.quit(1);
            }
            return;
        }

        var sourceFiles: TypeScript.SourceUnit[] = [];
        if (this.compilationSettings.watch) {
            // Capture the state before calling resolve
            sourceFiles = this.compilationEnvironment.code.slice(0);
        }

        // Resolve file dependencies, if requested
        this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;

        this.compile();

        if (!this.errorReporter.hasErrors) {
            if (this.compilationSettings.exec) {
                this.run();
            }
        }

        if (this.compilationSettings.watch) {
            // Watch will cause the program to stick around as long as the files exist
            this.watchFiles(sourceFiles);
        }
        else {  
            // Exit with the appropriate error code
            this.ioHost.quit(this.errorReporter.hasErrors ? 1 : 0);
        }
    }

    public printVersion() {
        if (!this.printedVersion) {
            this.ioHost.printLine("Version " + this.compilerVersion);
            this.printedVersion = true;
        }
    }

    private watchFiles(sourceFiles: TypeScript.SourceUnit[]) {
        if (!this.ioHost.watchFile) {
            this.errorReporter.WriteLine("Error: Current host does not support -w[atch] option");
            return;
        }

        var resolvedFiles: string[] = []
        var watchers: { [x: string]: IFileWatcher; } = {};

        var addWatcher = (fileName: string) => {
            if (!watchers[fileName]) {
                var watcher = this.ioHost.watchFile(fileName, onWatchedFileChange);
                watchers[fileName] = watcher;
            }
            else {
                TypeScript.CompilerDiagnostics.debugPrint("Cannot watch file, it is already watched.");
            }
        };

        var removeWatcher = (fileName: string) => {
            if (watchers[fileName]) {
                watchers[fileName].close();
                delete watchers[fileName];
            }
            else {
                TypeScript.CompilerDiagnostics.debugPrint("Cannot stop watching file, it is not being watched.");
            }
        };

        var onWatchedFileChange = () => {
            // Reset the state
            this.compilationEnvironment.code = sourceFiles;

            // Clean errors for previous compilation
            this.errorReporter.reset();

            // Resolve file dependencies, if requested
            this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;

            // Check if any new files were added to the environment as a result of the file change
            var oldFiles = resolvedFiles;
            var newFiles: string[] = [];
            this.resolvedEnvironment.code.forEach((sf) => newFiles.push(sf.path));
            newFiles = newFiles.sort();

            var i = 0, j = 0;
            while (i < oldFiles.length && j < newFiles.length) {

                var compareResult = oldFiles[i].localeCompare(newFiles[j]);
                if (compareResult === 0) {
                    // No change here
                    i++;
                    j++;
                }
                else if (compareResult < 0) {
                    // Entry in old list does not exist in the new one, it was removed
                    removeWatcher(oldFiles[i]);
                    i++;
                }
                else {
                    // Entry in new list does exist in the new one, it was added
                    addWatcher(newFiles[j]);
                    j++;
                }
            }

            // All remaining unmatched items in the old list have been removed
            for (var k = i; k < oldFiles.length; k++) {
                removeWatcher(oldFiles[k]);
            }

            // All remaing unmatched items in the new list have been added
            for (k = j; k < newFiles.length; k++) {
                addWatcher(newFiles[k]);
            }

            // Update the state
            resolvedFiles = newFiles;

            // Print header
            this.ioHost.printLine("");
            this.ioHost.printLine("Recompiling (" + new Date() + "): ");
            resolvedFiles.forEach((f) => this.ioHost.printLine("    " + f));

            // Trigger a new compilation
            this.compile();

            if (!this.errorReporter.hasErrors) {
                if (this.compilationSettings.exec) {
                    this.run();
                }
            }
        };

        // Switch to using stdout for all error messages
        this.ioHost.stderr = this.ioHost.stdout;

        // Initialize the initial list of resolved files, and add watches to them
        this.resolvedEnvironment.code.forEach((sf) => {
            resolvedFiles.push(sf.path);
            addWatcher(sf.path);
        });
        resolvedFiles.sort();
    }
}

// Start the batch compilation using the current hosts IO
var batch = new BatchCompiler(IO);
batch.batchCompile();
