=== tests/cases/compiler/typeParameterDirectlyConstrainedToItself.ts ===
Line 1 col 6 IdentifierName "C" = C<T>
Line 1 col 8 IdentifierName "T" = T
Line 1 col 18 IdentifierName "T" = T
Line 2 col 6 IdentifierName "C2" = C2<T, U>
Line 2 col 9 IdentifierName "T" = T
Line 2 col 12 IdentifierName "U" = U
Line 2 col 22 IdentifierName "U" = U
Line 4 col 10 IdentifierName "I" = I<T>
Line 4 col 12 IdentifierName "T" = T
Line 4 col 22 IdentifierName "T" = T
Line 5 col 10 IdentifierName "I2" = I2<T, U>
Line 5 col 13 IdentifierName "T" = T
Line 5 col 16 IdentifierName "U" = U
Line 5 col 26 IdentifierName "U" = U
Line 7 col 9 IdentifierName "f" = <T extends T>() => void
Line 7 col 11 IdentifierName "T" = T
Line 7 col 21 IdentifierName "T" = T
Line 8 col 9 IdentifierName "f2" = <T, U extends U>() => void
Line 8 col 12 IdentifierName "T" = T
Line 8 col 15 IdentifierName "U" = U
Line 8 col 25 IdentifierName "U" = U
Line 10 col 4 IdentifierName "a" = { <T extends T>(): void; <T, U extends U>(): void; }
Line 11 col 5 IdentifierName "T" = T
Line 11 col 15 IdentifierName "T" = T
Line 12 col 5 IdentifierName "T" = T
Line 12 col 8 IdentifierName "U" = U
Line 12 col 18 IdentifierName "U" = U
Line 15 col 4 IdentifierName "b" = <T extends T>() => void
Line 15 col 8 ParenthesizedArrowFunctionExpression "<T extends T>() => { }" = <T extends T>() => void
Line 15 col 9 IdentifierName "T" = T
Line 15 col 19 IdentifierName "T" = T
Line 16 col 4 IdentifierName "b2" = <T, U extends U>() => void
Line 16 col 9 ParenthesizedArrowFunctionExpression "<T, U extends U>() => { }" = <T, U extends U>() => void
Line 16 col 10 IdentifierName "T" = T
Line 16 col 13 IdentifierName "U" = U
Line 16 col 23 IdentifierName "U" = U